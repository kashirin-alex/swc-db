#
# Autogenerated by Thrift Compiler (0.17.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:twisted,slots,no_utf8strings
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec


from thrift.transport import TTransport
all_structs = []


class KeySeq(object):
    """
    Column Key Sequences

    """
    UNKNOWN = 0
    LEXIC = 1
    VOLUME = 2
    FC_LEXIC = 3
    FC_VOLUME = 4

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "LEXIC",
        2: "VOLUME",
        3: "FC_LEXIC",
        4: "FC_VOLUME",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "LEXIC": 1,
        "VOLUME": 2,
        "FC_LEXIC": 3,
        "FC_VOLUME": 4,
    }


class ColumnType(object):
    """
    Column Value Types

    """
    UNKNOWN = 0
    PLAIN = 1
    COUNTER_I64 = 2
    COUNTER_I32 = 3
    COUNTER_I16 = 4
    COUNTER_I8 = 5
    SERIAL = 6
    CELL_DEFINED = 15

    _VALUES_TO_NAMES = {
        0: "UNKNOWN",
        1: "PLAIN",
        2: "COUNTER_I64",
        3: "COUNTER_I32",
        4: "COUNTER_I16",
        5: "COUNTER_I8",
        6: "SERIAL",
        15: "CELL_DEFINED",
    }

    _NAMES_TO_VALUES = {
        "UNKNOWN": 0,
        "PLAIN": 1,
        "COUNTER_I64": 2,
        "COUNTER_I32": 3,
        "COUNTER_I16": 4,
        "COUNTER_I8": 5,
        "SERIAL": 6,
        "CELL_DEFINED": 15,
    }


class EncodingType(object):
    """
    Data Encoding Types

    """
    DEFAULT = 0
    PLAIN = 1
    ZLIB = 2
    SNAPPY = 3
    ZSTD = 4
    UNKNOWN = 255

    _VALUES_TO_NAMES = {
        0: "DEFAULT",
        1: "PLAIN",
        2: "ZLIB",
        3: "SNAPPY",
        4: "ZSTD",
        255: "UNKNOWN",
    }

    _NAMES_TO_VALUES = {
        "DEFAULT": 0,
        "PLAIN": 1,
        "ZLIB": 2,
        "SNAPPY": 3,
        "ZSTD": 4,
        "UNKNOWN": 255,
    }


class SchemaFunc(object):
    """
    Manage Columns schema function Flags

    """
    CREATE = 3
    REMOVE = 5
    MODIFY = 7

    _VALUES_TO_NAMES = {
        3: "CREATE",
        5: "REMOVE",
        7: "MODIFY",
    }

    _NAMES_TO_VALUES = {
        "CREATE": 3,
        "REMOVE": 5,
        "MODIFY": 7,
    }


class Comp(object):
    """
    The available logical Comparators, plus extended logic options applied with 'v' for VOLUME

    """
    NONE = 0
    PF = 1
    GT = 2
    GE = 3
    EQ = 4
    LE = 5
    LT = 6
    NE = 7
    RE = 8
    VGT = 9
    VGE = 10
    VLE = 11
    VLT = 12
    SBS = 13
    SPS = 14
    POSBS = 15
    POSPS = 16
    FOSBS = 17
    FOSPS = 18
    FIP = 19
    FI = 20

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "PF",
        2: "GT",
        3: "GE",
        4: "EQ",
        5: "LE",
        6: "LT",
        7: "NE",
        8: "RE",
        9: "VGT",
        10: "VGE",
        11: "VLE",
        12: "VLT",
        13: "SBS",
        14: "SPS",
        15: "POSBS",
        16: "POSPS",
        17: "FOSBS",
        18: "FOSPS",
        19: "FIP",
        20: "FI",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "PF": 1,
        "GT": 2,
        "GE": 3,
        "EQ": 4,
        "LE": 5,
        "LT": 6,
        "NE": 7,
        "RE": 8,
        "VGT": 9,
        "VGE": 10,
        "VLE": 11,
        "VLT": 12,
        "SBS": 13,
        "SPS": 14,
        "POSBS": 15,
        "POSPS": 16,
        "FOSBS": 17,
        "FOSPS": 18,
        "FIP": 19,
        "FI": 20,
    }


class SpecFlagsOpt(object):
    """
    The Scan options Flags Specifications for the SpecFlags 'options' bit

    """
    NONE = 0
    LIMIT_BY_KEYS = 1
    OFFSET_BY_KEYS = 4
    ONLY_KEYS = 8
    ONLY_DELETES = 10

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "LIMIT_BY_KEYS",
        4: "OFFSET_BY_KEYS",
        8: "ONLY_KEYS",
        10: "ONLY_DELETES",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "LIMIT_BY_KEYS": 1,
        "OFFSET_BY_KEYS": 4,
        "ONLY_KEYS": 8,
        "ONLY_DELETES": 10,
    }


class UpdateOP(object):
    REPLACE = 0
    APPEND = 1
    PREPEND = 2
    INSERT = 3
    OVERWRITE = 4
    SERIAL = 5

    _VALUES_TO_NAMES = {
        0: "REPLACE",
        1: "APPEND",
        2: "PREPEND",
        3: "INSERT",
        4: "OVERWRITE",
        5: "SERIAL",
    }

    _NAMES_TO_VALUES = {
        "REPLACE": 0,
        "APPEND": 1,
        "PREPEND": 2,
        "INSERT": 3,
        "OVERWRITE": 4,
        "SERIAL": 5,
    }


class SpecIntervalOptions(object):
    """
    The Scan Interval Specs Options for the SpecIntervalPlain, SpecIntervalCounter and SpecIntervalSerial 'options' bit

    """
    UPDATING = 4
    DELETING = 8

    _VALUES_TO_NAMES = {
        4: "UPDATING",
        8: "DELETING",
    }

    _NAMES_TO_VALUES = {
        "UPDATING": 4,
        "DELETING": 8,
    }


class Flag(object):
    """
    The Cell Flag

    """
    NONE = 0
    INSERT = 1
    DELETE_LE = 2
    DELETE_EQ = 3

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "INSERT",
        2: "DELETE_LE",
        3: "DELETE_EQ",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "INSERT": 1,
        "DELETE_LE": 2,
        "DELETE_EQ": 3,
    }


class FU_MATH_OP(object):
    """
    MATH Operations for Serial Field Update of types INT64 and DOUBLE

    """
    EQUAL = 0
    PLUS = 1
    MULTIPLY = 2
    DIVIDE = 3

    _VALUES_TO_NAMES = {
        0: "EQUAL",
        1: "PLUS",
        2: "MULTIPLY",
        3: "DIVIDE",
    }

    _NAMES_TO_VALUES = {
        "EQUAL": 0,
        "PLUS": 1,
        "MULTIPLY": 2,
        "DIVIDE": 3,
    }


class FU_LIST_OP(object):
    """
    LIST Operations for Serial Field Update of array/list/bytes with LIST-op in the inner SERIAL fields

    """
    REPLACE = 0
    APPEND = 1
    PREPEND = 2
    INSERT = 3
    OVERWRITE = 4
    ERASE = 5
    BY_UNIQUE = 6
    BY_COND = 7
    BY_INDEX = 8

    _VALUES_TO_NAMES = {
        0: "REPLACE",
        1: "APPEND",
        2: "PREPEND",
        3: "INSERT",
        4: "OVERWRITE",
        5: "ERASE",
        6: "BY_UNIQUE",
        7: "BY_COND",
        8: "BY_INDEX",
    }

    _NAMES_TO_VALUES = {
        "REPLACE": 0,
        "APPEND": 1,
        "PREPEND": 2,
        "INSERT": 3,
        "OVERWRITE": 4,
        "ERASE": 5,
        "BY_UNIQUE": 6,
        "BY_COND": 7,
        "BY_INDEX": 8,
    }


class CellsResult(object):
    """
    The Cells Results types for using with CellsGroup requests

    """
    IN_LIST = 0
    ON_COLUMN = 1
    ON_KEY = 2
    ON_FRACTION = 3

    _VALUES_TO_NAMES = {
        0: "IN_LIST",
        1: "ON_COLUMN",
        2: "ON_KEY",
        3: "ON_FRACTION",
    }

    _NAMES_TO_VALUES = {
        "IN_LIST": 0,
        "ON_COLUMN": 1,
        "ON_KEY": 2,
        "ON_FRACTION": 3,
    }


class Exception(TException):
    """
    The SWC::Thrift::Exception a base for any Exceptions
    both for the Thrift-Protocol and SWC-DB Errors.

    Attributes:
     - code: The corresponding Thrift-Procotol or SWC-DB Error Code
     - message: The message describing the error code

    """

    __slots__ = (
        'code',
        'message',
    )


    def __init__(self, code=None, message=None,):
        super(Exception, self).__setattr__('code', code)
        super(Exception, self).__setattr__('message', message)

    def __setattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __delattr__(self, *args):
        raise TypeError("can't modify immutable instance")

    def __hash__(self):
        return hash(self.__class__) ^ hash((self.code, self.message, ))

    @classmethod
    def read(cls, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and cls.thrift_spec is not None:
            return iprot._fast_decode(None, iprot, [cls, cls.thrift_spec])
        iprot.readStructBegin()
        code = None
        message = None
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    code = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    message = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()
        return cls(
            code=code,
            message=message,
        )

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Exception')
        if self.code is not None:
            oprot.writeFieldBegin('code', TType.I32, 1)
            oprot.writeI32(self.code)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Schema(object):
    """
    The Schema Definition

    Attributes:
     - cid: Column ID
     - col_name: Column Name
     - col_tags: Column Tags
     - col_seq: Column Key Sequence
     - col_type: Column Type
     - cell_versions: Cell Versions
     - cell_ttl: Cell Time to Live
     - blk_encoding: Block Encoding
     - blk_size: Block Size in Bytes
     - blk_cells: Number of Cells in Block
     - cs_replication: CellStore file Replication
     - cs_size: CellStore Size in Bytes
     - cs_max: Max CellStores in a Range
     - log_rollout_ratio: Write Fragment File on ratio reached
     - log_compact_cointervaling: Min. Cointervaling Fragments for Compaction
     - log_fragment_preload: Number of Fragment to Preload
     - compact_percent: Compact at percent reach
     - revision: Schema's revision/id

    """

    __slots__ = (
        'cid',
        'col_name',
        'col_tags',
        'col_seq',
        'col_type',
        'cell_versions',
        'cell_ttl',
        'blk_encoding',
        'blk_size',
        'blk_cells',
        'cs_replication',
        'cs_size',
        'cs_max',
        'log_rollout_ratio',
        'log_compact_cointervaling',
        'log_fragment_preload',
        'compact_percent',
        'revision',
    )


    def __init__(self, cid=None, col_name=None, col_tags=None, col_seq=None, col_type=None, cell_versions=None, cell_ttl=None, blk_encoding=None, blk_size=None, blk_cells=None, cs_replication=None, cs_size=None, cs_max=None, log_rollout_ratio=None, log_compact_cointervaling=None, log_fragment_preload=None, compact_percent=None, revision=None,):
        self.cid = cid
        self.col_name = col_name
        self.col_tags = col_tags
        self.col_seq = col_seq
        self.col_type = col_type
        self.cell_versions = cell_versions
        self.cell_ttl = cell_ttl
        self.blk_encoding = blk_encoding
        self.blk_size = blk_size
        self.blk_cells = blk_cells
        self.cs_replication = cs_replication
        self.cs_size = cs_size
        self.cs_max = cs_max
        self.log_rollout_ratio = log_rollout_ratio
        self.log_compact_cointervaling = log_compact_cointervaling
        self.log_fragment_preload = log_fragment_preload
        self.compact_percent = compact_percent
        self.revision = revision

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.col_tags = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString()
                        self.col_tags.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.col_seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.col_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.cell_versions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.cell_ttl = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.blk_encoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.blk_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.blk_cells = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BYTE:
                    self.cs_replication = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.cs_size = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.BYTE:
                    self.cs_max = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BYTE:
                    self.log_rollout_ratio = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BYTE:
                    self.log_compact_cointervaling = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BYTE:
                    self.log_fragment_preload = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.BYTE:
                    self.compact_percent = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.I64:
                    self.revision = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Schema')
        if self.cid is not None:
            oprot.writeFieldBegin('cid', TType.I64, 1)
            oprot.writeI64(self.cid)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 2)
            oprot.writeString(self.col_name)
            oprot.writeFieldEnd()
        if self.col_tags is not None:
            oprot.writeFieldBegin('col_tags', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.col_tags))
            for iter6 in self.col_tags:
                oprot.writeString(iter6)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.col_seq is not None:
            oprot.writeFieldBegin('col_seq', TType.I32, 4)
            oprot.writeI32(self.col_seq)
            oprot.writeFieldEnd()
        if self.col_type is not None:
            oprot.writeFieldBegin('col_type', TType.I32, 5)
            oprot.writeI32(self.col_type)
            oprot.writeFieldEnd()
        if self.cell_versions is not None:
            oprot.writeFieldBegin('cell_versions', TType.I32, 6)
            oprot.writeI32(self.cell_versions)
            oprot.writeFieldEnd()
        if self.cell_ttl is not None:
            oprot.writeFieldBegin('cell_ttl', TType.I32, 7)
            oprot.writeI32(self.cell_ttl)
            oprot.writeFieldEnd()
        if self.blk_encoding is not None:
            oprot.writeFieldBegin('blk_encoding', TType.I32, 8)
            oprot.writeI32(self.blk_encoding)
            oprot.writeFieldEnd()
        if self.blk_size is not None:
            oprot.writeFieldBegin('blk_size', TType.I32, 9)
            oprot.writeI32(self.blk_size)
            oprot.writeFieldEnd()
        if self.blk_cells is not None:
            oprot.writeFieldBegin('blk_cells', TType.I32, 10)
            oprot.writeI32(self.blk_cells)
            oprot.writeFieldEnd()
        if self.cs_replication is not None:
            oprot.writeFieldBegin('cs_replication', TType.BYTE, 11)
            oprot.writeByte(self.cs_replication)
            oprot.writeFieldEnd()
        if self.cs_size is not None:
            oprot.writeFieldBegin('cs_size', TType.I32, 12)
            oprot.writeI32(self.cs_size)
            oprot.writeFieldEnd()
        if self.cs_max is not None:
            oprot.writeFieldBegin('cs_max', TType.BYTE, 13)
            oprot.writeByte(self.cs_max)
            oprot.writeFieldEnd()
        if self.log_rollout_ratio is not None:
            oprot.writeFieldBegin('log_rollout_ratio', TType.BYTE, 14)
            oprot.writeByte(self.log_rollout_ratio)
            oprot.writeFieldEnd()
        if self.log_compact_cointervaling is not None:
            oprot.writeFieldBegin('log_compact_cointervaling', TType.BYTE, 15)
            oprot.writeByte(self.log_compact_cointervaling)
            oprot.writeFieldEnd()
        if self.log_fragment_preload is not None:
            oprot.writeFieldBegin('log_fragment_preload', TType.BYTE, 16)
            oprot.writeByte(self.log_fragment_preload)
            oprot.writeFieldEnd()
        if self.compact_percent is not None:
            oprot.writeFieldBegin('compact_percent', TType.BYTE, 17)
            oprot.writeByte(self.compact_percent)
            oprot.writeFieldEnd()
        if self.revision is not None:
            oprot.writeFieldBegin('revision', TType.I64, 18)
            oprot.writeI64(self.revision)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SchemaPattern(object):
    """
    The Schema matching Pattern

    Attributes:
     - comp: Logical comparator to Apply
     - value: The patern value to match against

    """

    __slots__ = (
        'comp',
        'value',
    )


    def __init__(self, comp=None, value=None,):
        self.comp = comp
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SchemaPattern')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SchemaTagsPatterns(object):
    """
    The Schema Tags patterns for the SchemaPatterns

    Attributes:
     - comp: Logical comparator to Apply, unsupported PF, RE and Vol. kind
     - values: The tags patterns to match against schema's column tags

    """

    __slots__ = (
        'comp',
        'values',
    )


    def __init__(self, comp=None, values=None,):
        self.comp = comp
        self.values = values

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = SchemaPattern()
                        _elem12.read(iprot)
                        self.values.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SchemaTagsPatterns')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter13 in self.values:
                iter13.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SchemaPatterns(object):
    """
    The Schema Patterns for the SpecSchemas

    Attributes:
     - names: The Schema patterns for selecting by Column Name
     - tags: The Schema patterns for selecting by Column Tags

    """

    __slots__ = (
        'names',
        'tags',
    )


    def __init__(self, names=None, tags=None,):
        self.names = names
        self.tags = tags

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = SchemaPattern()
                        _elem19.read(iprot)
                        self.names.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.tags = SchemaTagsPatterns()
                    self.tags.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SchemaPatterns')
        if self.names is not None:
            oprot.writeFieldBegin('names', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.names))
            for iter20 in self.names:
                iter20.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.STRUCT, 2)
            self.tags.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecSchemas(object):
    """
    The Specs for Schemas for using with list_columns or compact_columns

    Attributes:
     - cids: The Column IDs
     - names: The Column Names
     - patterns: The Schema's selector patterns

    """

    __slots__ = (
        'cids',
        'names',
        'patterns',
    )


    def __init__(self, cids=None, names=None, patterns=None,):
        self.cids = cids
        self.names = names
        self.patterns = patterns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.cids = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = iprot.readI64()
                        self.cids.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype30, _size27) = iprot.readListBegin()
                    for _i31 in range(_size27):
                        _elem32 = iprot.readString()
                        self.names.append(_elem32)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.patterns = SchemaPatterns()
                    self.patterns.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecSchemas')
        if self.cids is not None:
            oprot.writeFieldBegin('cids', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.cids))
            for iter33 in self.cids:
                oprot.writeI64(iter33)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.names is not None:
            oprot.writeFieldBegin('names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.names))
            for iter34 in self.names:
                oprot.writeString(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.patterns is not None:
            oprot.writeFieldBegin('patterns', TType.STRUCT, 3)
            self.patterns.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecFlags(object):
    """
    The Scan Specifications Flags

    Attributes:
     - limit: Limit to this number of cells
     - offset: Scan from this number of cells Offset on matching Cell-Interval
     - max_versions: Select only this number of Versions of a given Cell-Key
     - max_buffer: return results with reach of this Buffer size in bytes
     - options: The options bit by SpecFlagsOpt

    """

    __slots__ = (
        'limit',
        'offset',
        'max_versions',
        'max_buffer',
        'options',
    )


    def __init__(self, limit=None, offset=None, max_versions=None, max_buffer=None, options=None,):
        self.limit = limit
        self.offset = offset
        self.max_versions = max_versions
        self.max_buffer = max_buffer
        self.options = options

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.limit = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.offset = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.max_versions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_buffer = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BYTE:
                    self.options = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecFlags')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I64, 1)
            oprot.writeI64(self.limit)
            oprot.writeFieldEnd()
        if self.offset is not None:
            oprot.writeFieldBegin('offset', TType.I64, 2)
            oprot.writeI64(self.offset)
            oprot.writeFieldEnd()
        if self.max_versions is not None:
            oprot.writeFieldBegin('max_versions', TType.I32, 3)
            oprot.writeI32(self.max_versions)
            oprot.writeFieldEnd()
        if self.max_buffer is not None:
            oprot.writeFieldBegin('max_buffer', TType.I32, 4)
            oprot.writeI32(self.max_buffer)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.BYTE, 5)
            oprot.writeByte(self.options)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecUpdateOP(object):
    """
    Attributes:
     - op: The Operation of update
     - pos: The position/index of INSERT and OVERWRITE update operations

    """

    __slots__ = (
        'op',
        'pos',
    )


    def __init__(self, op=None, pos=None,):
        self.op = op
        self.pos = pos

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.pos = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecUpdateOP')
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 1)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.pos is not None:
            oprot.writeFieldBegin('pos', TType.I32, 2)
            oprot.writeI32(self.pos)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecIntervalUpdatePlain(object):
    """
    The Value specs for an Updating Interval of 'updating' in SpecIntervalPlain

    Attributes:
     - v: The bytes value for the updated cell
     - ts: The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
     - encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
     - update_op: Optionally the operaton of value update

    """

    __slots__ = (
        'v',
        'ts',
        'encoder',
        'update_op',
    )


    def __init__(self, v=None, ts=None, encoder=None, update_op=None,):
        self.v = v
        self.ts = ts
        self.encoder = encoder
        self.update_op = update_op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.encoder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.update_op = SpecUpdateOP()
                    self.update_op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecIntervalUpdatePlain')
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 1)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.encoder is not None:
            oprot.writeFieldBegin('encoder', TType.I32, 3)
            oprot.writeI32(self.encoder)
            oprot.writeFieldEnd()
        if self.update_op is not None:
            oprot.writeFieldBegin('update_op', TType.STRUCT, 4)
            self.update_op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecIntervalUpdateCounter(object):
    """
    The Value specs for an Updating Interval of 'updating' in SpecIntervalCounter

    Attributes:
     - v: The int64 value for the updated cell
     - op: The Opration pf Counter, available: COUNTER_OP_EQUAL
     - ts: The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
     - update_op: Optionally the operaton of value update

    """

    __slots__ = (
        'v',
        'op',
        'ts',
        'update_op',
    )


    def __init__(self, v=None, op=0, ts=None, update_op=None,):
        self.v = v
        self.op = op
        self.ts = ts
        self.update_op = update_op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.op = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.update_op = SpecUpdateOP()
                    self.update_op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecIntervalUpdateCounter')
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 1)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I64, 2)
            oprot.writeI64(self.op)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.update_op is not None:
            oprot.writeFieldBegin('update_op', TType.STRUCT, 4)
            self.update_op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecIntervalUpdateSerial(object):
    """
    The Value specs for an Updating Interval of 'updating' in SpecIntervalSerial

    Attributes:
     - ts: The timestamp for the updated cell NULL: MIN_INT64-1, AUTO:MIN_INT64-1
     - v: The values of serial-fields for the updated cell
     - v_op: The values of serial-fields for the the SERIAL operation update
     - encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
     - update_op: Optionally the operaton of value update

    """

    __slots__ = (
        'ts',
        'v',
        'v_op',
        'encoder',
        'update_op',
    )


    def __init__(self, ts=None, v=None, v_op=None, encoder=None, update_op=None,):
        self.ts = ts
        self.v = v
        self.v_op = v_op
        self.encoder = encoder
        self.update_op = update_op

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = CellValueSerial()
                        _elem40.read(iprot)
                        self.v.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.v_op = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = CellValueSerialOp()
                        _elem46.read(iprot)
                        self.v_op.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.encoder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.update_op = SpecUpdateOP()
                    self.update_op.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecIntervalUpdateSerial')
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 1)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter47 in self.v:
                iter47.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v_op is not None:
            oprot.writeFieldBegin('v_op', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.v_op))
            for iter48 in self.v_op:
                iter48.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encoder is not None:
            oprot.writeFieldBegin('encoder', TType.I32, 4)
            oprot.writeI32(self.encoder)
            oprot.writeFieldEnd()
        if self.update_op is not None:
            oprot.writeFieldBegin('update_op', TType.STRUCT, 5)
            self.update_op.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueSerial_INT64(object):
    """
    The Specifications of INT64 Serial Value Field

    Attributes:
     - comp: Logical comparator to Apply
     - v: The int64 to match against the value field

    """

    __slots__ = (
        'comp',
        'v',
    )


    def __init__(self, comp=None, v=None,):
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueSerial_INT64')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 2)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueSerial_DOUBLE(object):
    """
    The Specifications of DOUBLE Serial Value Field

    Attributes:
     - comp: Logical comparator to Apply
     - v: The double to match against the value field

    """

    __slots__ = (
        'comp',
        'v',
    )


    def __init__(self, comp=None, v=None,):
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueSerial_DOUBLE')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 2)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueSerial_BYTES(object):
    """
    The Specifications of BYTES Serial Value Field

    Attributes:
     - comp: Logical comparator to Apply
     - v: The binary(bytes) to match against the value field

    """

    __slots__ = (
        'comp',
        'v',
    )


    def __init__(self, comp=None, v=None,):
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueSerial_BYTES')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 2)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueSerial_KEY(object):
    """
    The Specifications of KEY Serial Value Field

    Attributes:
     - seq: The Key Sequence to use
     - v: The Specification of the Key to match against the value field

    """

    __slots__ = (
        'seq',
        'v',
    )


    def __init__(self, seq=None, v=None,):
        self.seq = seq
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.seq = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = SpecFraction()
                        _elem54.read(iprot)
                        self.v.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueSerial_KEY')
        if self.seq is not None:
            oprot.writeFieldBegin('seq', TType.I32, 1)
            oprot.writeI32(self.seq)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter55 in self.v:
                iter55.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueSerial_LI(object):
    """
    The Specifications of LIST_INT64(LI) Serial Value Field

    Attributes:
     - comp: Logical comparator to Apply
     - v: The List of Int64 to match against the value field

    """

    __slots__ = (
        'comp',
        'v',
    )


    def __init__(self, comp=None, v=None,):
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype59, _size56) = iprot.readListBegin()
                    for _i60 in range(_size56):
                        _elem61 = SpecValueSerial_INT64()
                        _elem61.read(iprot)
                        self.v.append(_elem61)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueSerial_LI')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter62 in self.v:
                iter62.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueSerial_LB(object):
    """
    The Specifications of LIST_BYTES(LB) Serial Value Field

    Attributes:
     - comp: Logical comparator to Apply
     - v: The List of Bytes to match against the value field

    """

    __slots__ = (
        'comp',
        'v',
    )


    def __init__(self, comp=None, v=None,):
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = SpecValueSerial_BYTES()
                        _elem68.read(iprot)
                        self.v.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueSerial_LB')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter69 in self.v:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueSerialField(object):
    """
    Attributes:
     - field_id: The Field Id of the Value Field
     - spec_int64: The specifications of Int64 for the field
     - spec_double: The specifications of Double for the field
     - spec_bytes: The specifications of Bytes for the field
     - spec_key: The specifications of Cell-Key for the field
     - spec_li: The specifications of List Int64 for the field
     - spec_lb: The specifications of List Bytes for the field

    """

    __slots__ = (
        'field_id',
        'spec_int64',
        'spec_double',
        'spec_bytes',
        'spec_key',
        'spec_li',
        'spec_lb',
    )


    def __init__(self, field_id=None, spec_int64=None, spec_double=None, spec_bytes=None, spec_key=None, spec_li=None, spec_lb=None,):
        self.field_id = field_id
        self.spec_int64 = spec_int64
        self.spec_double = spec_double
        self.spec_bytes = spec_bytes
        self.spec_key = spec_key
        self.spec_li = spec_li
        self.spec_lb = spec_lb

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.field_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.spec_int64 = SpecValueSerial_INT64()
                    self.spec_int64.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.spec_double = SpecValueSerial_DOUBLE()
                    self.spec_double.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.spec_bytes = SpecValueSerial_BYTES()
                    self.spec_bytes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.spec_key = SpecValueSerial_KEY()
                    self.spec_key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.spec_li = SpecValueSerial_LI()
                    self.spec_li.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.spec_lb = SpecValueSerial_LB()
                    self.spec_lb.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueSerialField')
        if self.field_id is not None:
            oprot.writeFieldBegin('field_id', TType.I32, 1)
            oprot.writeI32(self.field_id)
            oprot.writeFieldEnd()
        if self.spec_int64 is not None:
            oprot.writeFieldBegin('spec_int64', TType.STRUCT, 2)
            self.spec_int64.write(oprot)
            oprot.writeFieldEnd()
        if self.spec_double is not None:
            oprot.writeFieldBegin('spec_double', TType.STRUCT, 3)
            self.spec_double.write(oprot)
            oprot.writeFieldEnd()
        if self.spec_bytes is not None:
            oprot.writeFieldBegin('spec_bytes', TType.STRUCT, 4)
            self.spec_bytes.write(oprot)
            oprot.writeFieldEnd()
        if self.spec_key is not None:
            oprot.writeFieldBegin('spec_key', TType.STRUCT, 5)
            self.spec_key.write(oprot)
            oprot.writeFieldEnd()
        if self.spec_li is not None:
            oprot.writeFieldBegin('spec_li', TType.STRUCT, 6)
            self.spec_li.write(oprot)
            oprot.writeFieldEnd()
        if self.spec_lb is not None:
            oprot.writeFieldBegin('spec_lb', TType.STRUCT, 7)
            self.spec_lb.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValuePlain(object):
    """
    The Plain Value Specifications, option to use with Extended Logical Comparators

    Attributes:
     - comp: Logical comparator to Apply
     - v: The binary(bytes) to match against the Cell value

    """

    __slots__ = (
        'comp',
        'v',
    )


    def __init__(self, comp=None, v=None,):
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValuePlain')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 2)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueCounter(object):
    """
    The Counter Value Specifications, option to use with Extended Logical Comparators

    Attributes:
     - comp: Logical comparator to Apply
     - v: The int64 to match against the Cell value

    """

    __slots__ = (
        'comp',
        'v',
    )


    def __init__(self, comp=None, v=None,):
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueCounter')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 2)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecValueSerial(object):
    """
    The Serial Value Specifications

    Attributes:
     - comp: Logical comparator to Apply
     - fields: The Serial Value Specifications to match against the SERIAL Cell value fields

    """

    __slots__ = (
        'comp',
        'fields',
    )


    def __init__(self, comp=None, fields=None,):
        self.comp = comp
        self.fields = fields

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.fields = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = SpecValueSerialField()
                        _elem75.read(iprot)
                        self.fields.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecValueSerial')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.fields is not None:
            oprot.writeFieldBegin('fields', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.fields))
            for iter76 in self.fields:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecFraction(object):
    """
    The Fraction Specifications

    Attributes:
     - comp: Logical comparator to Apply
     - f: The binary(bytes) to match against a fraction of a Cell-Key

    """

    __slots__ = (
        'comp',
        'f',
    )


    def __init__(self, comp=None, f=None,):
        self.comp = comp
        self.f = f

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.f = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecFraction')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.STRING, 2)
            oprot.writeBinary(self.f)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecTimestamp(object):
    """
    The Timestamp Specifications

    Attributes:
     - comp: Logical comparator to Apply
     - ts: The timestamp in nanoseconds to match against the Cell timestamp/version (not the revision)

    """

    __slots__ = (
        'comp',
        'ts',
    )


    def __init__(self, comp=None, ts=None,):
        self.comp = comp
        self.ts = ts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecTimestamp')
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 1)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecKeyInterval(object):
    """
    The Key Interval Specifications

    Attributes:
     - start: The Key Start Spec, the start of cells-interval key match
     - finish: The Key Finish Spec, the finish of cells-interval key match

    """

    __slots__ = (
        'start',
        'finish',
    )


    def __init__(self, start=None, finish=None,):
        self.start = start
        self.finish = finish

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.start = []
                    (_etype80, _size77) = iprot.readListBegin()
                    for _i81 in range(_size77):
                        _elem82 = SpecFraction()
                        _elem82.read(iprot)
                        self.start.append(_elem82)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.finish = []
                    (_etype86, _size83) = iprot.readListBegin()
                    for _i87 in range(_size83):
                        _elem88 = SpecFraction()
                        _elem88.read(iprot)
                        self.finish.append(_elem88)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecKeyInterval')
        if self.start is not None:
            oprot.writeFieldBegin('start', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.start))
            for iter89 in self.start:
                iter89.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.finish is not None:
            oprot.writeFieldBegin('finish', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.finish))
            for iter90 in self.finish:
                iter90.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecIntervalPlain(object):
    """
    The Cells Interval Plain type Specifications with interval-scope Flags

    Attributes:
     - range_begin: Begin of Ranges evaluation with this Key inclusive
     - range_end: End of Ranges evaluation with this Key inclusive
     - offset_key: Offset Cell Key of a Scan, select cells from this key inclusive
     - offset_rev: Offset Cell Timestamp of a Scan, select cells after this timestamp
     - key_intervals: The Key Intervals
     - values: The Cell Value Specifications, cell-value match for plain type
     - ts_start: The Timestamp Start Spec, the start of cells-interval timestamp match
     - ts_finish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
     - flags: The Interval Flags Specification
     - options: The Interval Options Specification
     - updating: The Value spec of an Updating Interval

    """

    __slots__ = (
        'range_begin',
        'range_end',
        'offset_key',
        'offset_rev',
        'key_intervals',
        'values',
        'ts_start',
        'ts_finish',
        'flags',
        'options',
        'updating',
    )


    def __init__(self, range_begin=None, range_end=None, offset_key=None, offset_rev=None, key_intervals=None, values=None, ts_start=None, ts_finish=None, flags=None, options=None, updating=None,):
        self.range_begin = range_begin
        self.range_end = range_end
        self.offset_key = offset_key
        self.offset_rev = offset_rev
        self.key_intervals = key_intervals
        self.values = values
        self.ts_start = ts_start
        self.ts_finish = ts_finish
        self.flags = flags
        self.options = options
        self.updating = updating

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.range_begin = []
                    (_etype94, _size91) = iprot.readListBegin()
                    for _i95 in range(_size91):
                        _elem96 = iprot.readBinary()
                        self.range_begin.append(_elem96)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range_end = []
                    (_etype100, _size97) = iprot.readListBegin()
                    for _i101 in range(_size97):
                        _elem102 = iprot.readBinary()
                        self.range_end.append(_elem102)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.offset_key = []
                    (_etype106, _size103) = iprot.readListBegin()
                    for _i107 in range(_size103):
                        _elem108 = iprot.readBinary()
                        self.offset_key.append(_elem108)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset_rev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.key_intervals = []
                    (_etype112, _size109) = iprot.readListBegin()
                    for _i113 in range(_size109):
                        _elem114 = SpecKeyInterval()
                        _elem114.read(iprot)
                        self.key_intervals.append(_elem114)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype118, _size115) = iprot.readListBegin()
                    for _i119 in range(_size115):
                        _elem120 = SpecValuePlain()
                        _elem120.read(iprot)
                        self.values.append(_elem120)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.ts_start = SpecTimestamp()
                    self.ts_start.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.ts_finish = SpecTimestamp()
                    self.ts_finish.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.flags = SpecFlags()
                    self.flags.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.options = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.updating = SpecIntervalUpdatePlain()
                    self.updating.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecIntervalPlain')
        if self.range_begin is not None:
            oprot.writeFieldBegin('range_begin', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.range_begin))
            for iter121 in self.range_begin:
                oprot.writeBinary(iter121)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range_end is not None:
            oprot.writeFieldBegin('range_end', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.range_end))
            for iter122 in self.range_end:
                oprot.writeBinary(iter122)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset_key is not None:
            oprot.writeFieldBegin('offset_key', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.offset_key))
            for iter123 in self.offset_key:
                oprot.writeBinary(iter123)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset_rev is not None:
            oprot.writeFieldBegin('offset_rev', TType.I64, 4)
            oprot.writeI64(self.offset_rev)
            oprot.writeFieldEnd()
        if self.key_intervals is not None:
            oprot.writeFieldBegin('key_intervals', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.key_intervals))
            for iter124 in self.key_intervals:
                iter124.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter125 in self.values:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts_start is not None:
            oprot.writeFieldBegin('ts_start', TType.STRUCT, 7)
            self.ts_start.write(oprot)
            oprot.writeFieldEnd()
        if self.ts_finish is not None:
            oprot.writeFieldBegin('ts_finish', TType.STRUCT, 8)
            self.ts_finish.write(oprot)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.STRUCT, 9)
            self.flags.write(oprot)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.I32, 10)
            oprot.writeI32(self.options)
            oprot.writeFieldEnd()
        if self.updating is not None:
            oprot.writeFieldBegin('updating', TType.STRUCT, 11)
            self.updating.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecIntervalCounter(object):
    """
    The Cells Interval Counter type Specifications with interval-scope Flags

    Attributes:
     - range_begin: Begin of Ranges evaluation with this Key inclusive
     - range_end: End of Ranges evaluation with this Key inclusive
     - offset_key: Offset Cell Key of a Scan, select cells from this key inclusive
     - offset_rev: Offset Cell Timestamp of a Scan, select cells after this timestamp
     - key_intervals: The Key Intervals
     - values: The Cell Value Specifications, cell-value match for counter type
     - ts_start: The Timestamp Start Spec, the start of cells-interval timestamp match
     - ts_finish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
     - flags: The Interval Flags Specification
     - options: The Interval Options Specification
     - updating: The Value spec of an Updating Interval

    """

    __slots__ = (
        'range_begin',
        'range_end',
        'offset_key',
        'offset_rev',
        'key_intervals',
        'values',
        'ts_start',
        'ts_finish',
        'flags',
        'options',
        'updating',
    )


    def __init__(self, range_begin=None, range_end=None, offset_key=None, offset_rev=None, key_intervals=None, values=None, ts_start=None, ts_finish=None, flags=None, options=None, updating=None,):
        self.range_begin = range_begin
        self.range_end = range_end
        self.offset_key = offset_key
        self.offset_rev = offset_rev
        self.key_intervals = key_intervals
        self.values = values
        self.ts_start = ts_start
        self.ts_finish = ts_finish
        self.flags = flags
        self.options = options
        self.updating = updating

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.range_begin = []
                    (_etype129, _size126) = iprot.readListBegin()
                    for _i130 in range(_size126):
                        _elem131 = iprot.readBinary()
                        self.range_begin.append(_elem131)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range_end = []
                    (_etype135, _size132) = iprot.readListBegin()
                    for _i136 in range(_size132):
                        _elem137 = iprot.readBinary()
                        self.range_end.append(_elem137)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.offset_key = []
                    (_etype141, _size138) = iprot.readListBegin()
                    for _i142 in range(_size138):
                        _elem143 = iprot.readBinary()
                        self.offset_key.append(_elem143)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset_rev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.key_intervals = []
                    (_etype147, _size144) = iprot.readListBegin()
                    for _i148 in range(_size144):
                        _elem149 = SpecKeyInterval()
                        _elem149.read(iprot)
                        self.key_intervals.append(_elem149)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype153, _size150) = iprot.readListBegin()
                    for _i154 in range(_size150):
                        _elem155 = SpecValueCounter()
                        _elem155.read(iprot)
                        self.values.append(_elem155)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.ts_start = SpecTimestamp()
                    self.ts_start.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.ts_finish = SpecTimestamp()
                    self.ts_finish.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.flags = SpecFlags()
                    self.flags.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.options = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.updating = SpecIntervalUpdateCounter()
                    self.updating.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecIntervalCounter')
        if self.range_begin is not None:
            oprot.writeFieldBegin('range_begin', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.range_begin))
            for iter156 in self.range_begin:
                oprot.writeBinary(iter156)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range_end is not None:
            oprot.writeFieldBegin('range_end', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.range_end))
            for iter157 in self.range_end:
                oprot.writeBinary(iter157)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset_key is not None:
            oprot.writeFieldBegin('offset_key', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.offset_key))
            for iter158 in self.offset_key:
                oprot.writeBinary(iter158)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset_rev is not None:
            oprot.writeFieldBegin('offset_rev', TType.I64, 4)
            oprot.writeI64(self.offset_rev)
            oprot.writeFieldEnd()
        if self.key_intervals is not None:
            oprot.writeFieldBegin('key_intervals', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.key_intervals))
            for iter159 in self.key_intervals:
                iter159.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter160 in self.values:
                iter160.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts_start is not None:
            oprot.writeFieldBegin('ts_start', TType.STRUCT, 7)
            self.ts_start.write(oprot)
            oprot.writeFieldEnd()
        if self.ts_finish is not None:
            oprot.writeFieldBegin('ts_finish', TType.STRUCT, 8)
            self.ts_finish.write(oprot)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.STRUCT, 9)
            self.flags.write(oprot)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.I32, 10)
            oprot.writeI32(self.options)
            oprot.writeFieldEnd()
        if self.updating is not None:
            oprot.writeFieldBegin('updating', TType.STRUCT, 11)
            self.updating.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecIntervalSerial(object):
    """
    The Cells Interval Serial type Specifications with interval-scope Flags

    Attributes:
     - range_begin: Begin of Ranges evaluation with this Key inclusive
     - range_end: End of Ranges evaluation with this Key inclusive
     - offset_key: Offset Cell Key of a Scan, select cells from this key inclusive
     - offset_rev: Offset Cell Timestamp of a Scan, select cells after this timestamp
     - key_intervals: The Key Intervals
     - values: The Serial Cell Value Specifications, cell-value fields match
     - ts_start: The Timestamp Start Spec, the start of cells-interval timestamp match
     - ts_finish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
     - flags: The Interval Flags Specification
     - options: The Interval Options Specification
     - updating: The Serial-Value spec of an Updating Interval

    """

    __slots__ = (
        'range_begin',
        'range_end',
        'offset_key',
        'offset_rev',
        'key_intervals',
        'values',
        'ts_start',
        'ts_finish',
        'flags',
        'options',
        'updating',
    )


    def __init__(self, range_begin=None, range_end=None, offset_key=None, offset_rev=None, key_intervals=None, values=None, ts_start=None, ts_finish=None, flags=None, options=None, updating=None,):
        self.range_begin = range_begin
        self.range_end = range_end
        self.offset_key = offset_key
        self.offset_rev = offset_rev
        self.key_intervals = key_intervals
        self.values = values
        self.ts_start = ts_start
        self.ts_finish = ts_finish
        self.flags = flags
        self.options = options
        self.updating = updating

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.range_begin = []
                    (_etype164, _size161) = iprot.readListBegin()
                    for _i165 in range(_size161):
                        _elem166 = iprot.readBinary()
                        self.range_begin.append(_elem166)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.range_end = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = iprot.readBinary()
                        self.range_end.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.offset_key = []
                    (_etype176, _size173) = iprot.readListBegin()
                    for _i177 in range(_size173):
                        _elem178 = iprot.readBinary()
                        self.offset_key.append(_elem178)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.offset_rev = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.key_intervals = []
                    (_etype182, _size179) = iprot.readListBegin()
                    for _i183 in range(_size179):
                        _elem184 = SpecKeyInterval()
                        _elem184.read(iprot)
                        self.key_intervals.append(_elem184)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.values = []
                    (_etype188, _size185) = iprot.readListBegin()
                    for _i189 in range(_size185):
                        _elem190 = SpecValueSerial()
                        _elem190.read(iprot)
                        self.values.append(_elem190)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.ts_start = SpecTimestamp()
                    self.ts_start.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.ts_finish = SpecTimestamp()
                    self.ts_finish.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRUCT:
                    self.flags = SpecFlags()
                    self.flags.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.options = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.STRUCT:
                    self.updating = SpecIntervalUpdateSerial()
                    self.updating.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecIntervalSerial')
        if self.range_begin is not None:
            oprot.writeFieldBegin('range_begin', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.range_begin))
            for iter191 in self.range_begin:
                oprot.writeBinary(iter191)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.range_end is not None:
            oprot.writeFieldBegin('range_end', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.range_end))
            for iter192 in self.range_end:
                oprot.writeBinary(iter192)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset_key is not None:
            oprot.writeFieldBegin('offset_key', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.offset_key))
            for iter193 in self.offset_key:
                oprot.writeBinary(iter193)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.offset_rev is not None:
            oprot.writeFieldBegin('offset_rev', TType.I64, 4)
            oprot.writeI64(self.offset_rev)
            oprot.writeFieldEnd()
        if self.key_intervals is not None:
            oprot.writeFieldBegin('key_intervals', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.key_intervals))
            for iter194 in self.key_intervals:
                iter194.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.values is not None:
            oprot.writeFieldBegin('values', TType.LIST, 6)
            oprot.writeListBegin(TType.STRUCT, len(self.values))
            for iter195 in self.values:
                iter195.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts_start is not None:
            oprot.writeFieldBegin('ts_start', TType.STRUCT, 7)
            self.ts_start.write(oprot)
            oprot.writeFieldEnd()
        if self.ts_finish is not None:
            oprot.writeFieldBegin('ts_finish', TType.STRUCT, 8)
            self.ts_finish.write(oprot)
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.STRUCT, 9)
            self.flags.write(oprot)
            oprot.writeFieldEnd()
        if self.options is not None:
            oprot.writeFieldBegin('options', TType.I32, 10)
            oprot.writeI32(self.options)
            oprot.writeFieldEnd()
        if self.updating is not None:
            oprot.writeFieldBegin('updating', TType.STRUCT, 11)
            self.updating.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecColumnPlain(object):
    """
    The Column Specifications, the Cells-Intervals(SpecIntervalPlain/s) specification for a PLAIN Type column

    Attributes:
     - cid: The Column ID
     - intervals: The Cells Interval in a list-container

    """

    __slots__ = (
        'cid',
        'intervals',
    )


    def __init__(self, cid=None, intervals=None,):
        self.cid = cid
        self.intervals = intervals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.intervals = []
                    (_etype199, _size196) = iprot.readListBegin()
                    for _i200 in range(_size196):
                        _elem201 = SpecIntervalPlain()
                        _elem201.read(iprot)
                        self.intervals.append(_elem201)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecColumnPlain')
        if self.cid is not None:
            oprot.writeFieldBegin('cid', TType.I64, 1)
            oprot.writeI64(self.cid)
            oprot.writeFieldEnd()
        if self.intervals is not None:
            oprot.writeFieldBegin('intervals', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.intervals))
            for iter202 in self.intervals:
                iter202.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecColumnCounter(object):
    """
    The Column Specifications, the Cells-Intervals(SpecIntervalCounter/s) specification for a COUNTER Type column

    Attributes:
     - cid: The Column ID
     - intervals: The Cells Interval in a list-container

    """

    __slots__ = (
        'cid',
        'intervals',
    )


    def __init__(self, cid=None, intervals=None,):
        self.cid = cid
        self.intervals = intervals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.intervals = []
                    (_etype206, _size203) = iprot.readListBegin()
                    for _i207 in range(_size203):
                        _elem208 = SpecIntervalCounter()
                        _elem208.read(iprot)
                        self.intervals.append(_elem208)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecColumnCounter')
        if self.cid is not None:
            oprot.writeFieldBegin('cid', TType.I64, 1)
            oprot.writeI64(self.cid)
            oprot.writeFieldEnd()
        if self.intervals is not None:
            oprot.writeFieldBegin('intervals', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.intervals))
            for iter209 in self.intervals:
                iter209.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecColumnSerial(object):
    """
    The Column Specifications, the Cells-Intervals(SpecIntervalSerial/s) specification for a SERIAL Type Column

    Attributes:
     - cid: The Column ID
     - intervals: The Serial Cells Interval in a list-container

    """

    __slots__ = (
        'cid',
        'intervals',
    )


    def __init__(self, cid=None, intervals=None,):
        self.cid = cid
        self.intervals = intervals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.intervals = []
                    (_etype213, _size210) = iprot.readListBegin()
                    for _i214 in range(_size210):
                        _elem215 = SpecIntervalSerial()
                        _elem215.read(iprot)
                        self.intervals.append(_elem215)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecColumnSerial')
        if self.cid is not None:
            oprot.writeFieldBegin('cid', TType.I64, 1)
            oprot.writeI64(self.cid)
            oprot.writeFieldEnd()
        if self.intervals is not None:
            oprot.writeFieldBegin('intervals', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.intervals))
            for iter216 in self.intervals:
                iter216.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class SpecScan(object):
    """
    The Scan Specifications, the Columns-Intervals(SpecColumn/s) with global-scope Flags

    Attributes:
     - columns_plain: The Plain Column Intervals(SpecColumnPlain) in a list-container
     - columns_counter: The Counter Column Intervals(SpecColumnCounter) in a list-container
     - columns_serial: The Serial Column Intervals(SpecColumnSerial) in a list-container
     - flags: The Global Flags Specification

    """

    __slots__ = (
        'columns_plain',
        'columns_counter',
        'columns_serial',
        'flags',
    )


    def __init__(self, columns_plain=None, columns_counter=None, columns_serial=None, flags=None,):
        self.columns_plain = columns_plain
        self.columns_counter = columns_counter
        self.columns_serial = columns_serial
        self.flags = flags

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.columns_plain = []
                    (_etype220, _size217) = iprot.readListBegin()
                    for _i221 in range(_size217):
                        _elem222 = SpecColumnPlain()
                        _elem222.read(iprot)
                        self.columns_plain.append(_elem222)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns_counter = []
                    (_etype226, _size223) = iprot.readListBegin()
                    for _i227 in range(_size223):
                        _elem228 = SpecColumnCounter()
                        _elem228.read(iprot)
                        self.columns_counter.append(_elem228)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columns_serial = []
                    (_etype232, _size229) = iprot.readListBegin()
                    for _i233 in range(_size229):
                        _elem234 = SpecColumnSerial()
                        _elem234.read(iprot)
                        self.columns_serial.append(_elem234)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.flags = SpecFlags()
                    self.flags.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('SpecScan')
        if self.columns_plain is not None:
            oprot.writeFieldBegin('columns_plain', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.columns_plain))
            for iter235 in self.columns_plain:
                iter235.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columns_counter is not None:
            oprot.writeFieldBegin('columns_counter', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns_counter))
            for iter236 in self.columns_counter:
                iter236.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.columns_serial is not None:
            oprot.writeFieldBegin('columns_serial', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.columns_serial))
            for iter237 in self.columns_serial:
                iter237.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.flags is not None:
            oprot.writeFieldBegin('flags', TType.STRUCT, 4)
            self.flags.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class UCellPlain(object):
    """
    The Cell data for using with Update of PLAIN Column Type

    Attributes:
     - f: The Cell Flag
     - k: The Cell Key
     - ts: The Cell Timestamp in nanoseconds
     - ts_desc: The Cell Version is in timestamp descending
     - v: The Cell Value
     - encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD

    """

    __slots__ = (
        'f',
        'k',
        'ts',
        'ts_desc',
        'v',
        'encoder',
    )


    def __init__(self, f=None, k=None, ts=None, ts_desc=None, v=None, encoder=None,):
        self.f = f
        self.k = k
        self.ts = ts
        self.ts_desc = ts_desc
        self.v = v
        self.encoder = encoder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.f = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype241, _size238) = iprot.readListBegin()
                    for _i242 in range(_size238):
                        _elem243 = iprot.readBinary()
                        self.k.append(_elem243)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.ts_desc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.encoder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UCellPlain')
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.I32, 1)
            oprot.writeI32(self.f)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter244 in self.k:
                oprot.writeBinary(iter244)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.ts_desc is not None:
            oprot.writeFieldBegin('ts_desc', TType.BOOL, 4)
            oprot.writeBool(self.ts_desc)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 5)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        if self.encoder is not None:
            oprot.writeFieldBegin('encoder', TType.I32, 6)
            oprot.writeI32(self.encoder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class UCellCounter(object):
    """
    The Cell data for using with Update of COUNTER Column Type

    Attributes:
     - f: The Cell Flag
     - k: The Cell Key
     - ts: The Cell Timestamp in nanoseconds
     - ts_desc: The Cell Version is in timestamp descending
     - op: The Cell Counter Operation
     - v: The Cell Counter Value

    """

    __slots__ = (
        'f',
        'k',
        'ts',
        'ts_desc',
        'op',
        'v',
    )


    def __init__(self, f=None, k=None, ts=None, ts_desc=None, op=0, v=0,):
        self.f = f
        self.k = k
        self.ts = ts
        self.ts_desc = ts_desc
        self.op = op
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.f = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype248, _size245) = iprot.readListBegin()
                    for _i249 in range(_size245):
                        _elem250 = iprot.readBinary()
                        self.k.append(_elem250)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.ts_desc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BYTE:
                    self.op = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UCellCounter')
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.I32, 1)
            oprot.writeI32(self.f)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter251 in self.k:
                oprot.writeBinary(iter251)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.ts_desc is not None:
            oprot.writeFieldBegin('ts_desc', TType.BOOL, 4)
            oprot.writeBool(self.ts_desc)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.BYTE, 5)
            oprot.writeByte(self.op)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 6)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CellValueSerial(object):
    """
    The Serial Value Cell field

    Attributes:
     - field_id: The Field ID, a single ID can have any/all the field types
     - v_int64: The INT64 type field
     - v_double: The DOUBLE type field
     - v_bytes: The BYTES type field
     - v_key: The Cell KEY type field
     - v_li: The LIST INT64 type field
     - v_lb: The LIST BYTES type field

    """

    __slots__ = (
        'field_id',
        'v_int64',
        'v_double',
        'v_bytes',
        'v_key',
        'v_li',
        'v_lb',
    )


    def __init__(self, field_id=None, v_int64=None, v_double=None, v_bytes=None, v_key=None, v_li=None, v_lb=None,):
        self.field_id = field_id
        self.v_int64 = v_int64
        self.v_double = v_double
        self.v_bytes = v_bytes
        self.v_key = v_key
        self.v_li = v_li
        self.v_lb = v_lb

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.field_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.v_int64 = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.DOUBLE:
                    self.v_double = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.v_bytes = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.v_key = []
                    (_etype255, _size252) = iprot.readListBegin()
                    for _i256 in range(_size252):
                        _elem257 = iprot.readBinary()
                        self.v_key.append(_elem257)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.v_li = []
                    (_etype261, _size258) = iprot.readListBegin()
                    for _i262 in range(_size258):
                        _elem263 = iprot.readI64()
                        self.v_li.append(_elem263)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.LIST:
                    self.v_lb = []
                    (_etype267, _size264) = iprot.readListBegin()
                    for _i268 in range(_size264):
                        _elem269 = iprot.readBinary()
                        self.v_lb.append(_elem269)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CellValueSerial')
        if self.field_id is not None:
            oprot.writeFieldBegin('field_id', TType.I32, 1)
            oprot.writeI32(self.field_id)
            oprot.writeFieldEnd()
        if self.v_int64 is not None:
            oprot.writeFieldBegin('v_int64', TType.I64, 2)
            oprot.writeI64(self.v_int64)
            oprot.writeFieldEnd()
        if self.v_double is not None:
            oprot.writeFieldBegin('v_double', TType.DOUBLE, 3)
            oprot.writeDouble(self.v_double)
            oprot.writeFieldEnd()
        if self.v_bytes is not None:
            oprot.writeFieldBegin('v_bytes', TType.STRING, 4)
            oprot.writeBinary(self.v_bytes)
            oprot.writeFieldEnd()
        if self.v_key is not None:
            oprot.writeFieldBegin('v_key', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.v_key))
            for iter270 in self.v_key:
                oprot.writeBinary(iter270)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v_li is not None:
            oprot.writeFieldBegin('v_li', TType.LIST, 6)
            oprot.writeListBegin(TType.I64, len(self.v_li))
            for iter271 in self.v_li:
                oprot.writeI64(iter271)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v_lb is not None:
            oprot.writeFieldBegin('v_lb', TType.LIST, 7)
            oprot.writeListBegin(TType.STRING, len(self.v_lb))
            for iter272 in self.v_lb:
                oprot.writeBinary(iter272)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FU_INT64(object):
    """
    Serial INT64 Field Update

    Attributes:
     - ctrl
     - op
     - pos
     - comp
     - v

    """

    __slots__ = (
        'ctrl',
        'op',
        'pos',
        'comp',
        'v',
    )


    def __init__(self, ctrl=0, op=    0, pos=None, comp=None, v=None,):
        self.ctrl = ctrl
        self.op = op
        self.pos = pos
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.ctrl = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pos = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FU_INT64')
        if self.ctrl is not None:
            oprot.writeFieldBegin('ctrl', TType.BYTE, 1)
            oprot.writeByte(self.ctrl)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 2)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.pos is not None:
            oprot.writeFieldBegin('pos', TType.I32, 3)
            oprot.writeI32(self.pos)
            oprot.writeFieldEnd()
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 4)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 5)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FU_DOUBLE(object):
    """
    Serial DOUBLE Field Update

    Attributes:
     - ctrl
     - op
     - pos
     - comp
     - v

    """

    __slots__ = (
        'ctrl',
        'op',
        'pos',
        'comp',
        'v',
    )


    def __init__(self, ctrl=0, op=    0, pos=None, comp=None, v=None,):
        self.ctrl = ctrl
        self.op = op
        self.pos = pos
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.ctrl = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pos = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.DOUBLE:
                    self.v = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FU_DOUBLE')
        if self.ctrl is not None:
            oprot.writeFieldBegin('ctrl', TType.BYTE, 1)
            oprot.writeByte(self.ctrl)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 2)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.pos is not None:
            oprot.writeFieldBegin('pos', TType.I32, 3)
            oprot.writeI32(self.pos)
            oprot.writeFieldEnd()
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 4)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.DOUBLE, 5)
            oprot.writeDouble(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FU_BYTES(object):
    """
    Serial BYTES Field Update

    Attributes:
     - ctrl
     - op
     - pos
     - comp
     - v

    """

    __slots__ = (
        'ctrl',
        'op',
        'pos',
        'comp',
        'v',
    )


    def __init__(self, ctrl=0, op=    0, pos=None, comp=None, v=None,):
        self.ctrl = ctrl
        self.op = op
        self.pos = pos
        self.comp = comp
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.ctrl = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pos = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.comp = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FU_BYTES')
        if self.ctrl is not None:
            oprot.writeFieldBegin('ctrl', TType.BYTE, 1)
            oprot.writeByte(self.ctrl)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 2)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.pos is not None:
            oprot.writeFieldBegin('pos', TType.I32, 3)
            oprot.writeI32(self.pos)
            oprot.writeFieldEnd()
        if self.comp is not None:
            oprot.writeFieldBegin('comp', TType.I32, 4)
            oprot.writeI32(self.comp)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 5)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FU_LI(object):
    """
    Serial LIST_INT64 Field Update

    Attributes:
     - ctrl
     - op
     - pos
     - v

    """

    __slots__ = (
        'ctrl',
        'op',
        'pos',
        'v',
    )


    def __init__(self, ctrl=0, op=    0, pos=None, v=None,):
        self.ctrl = ctrl
        self.op = op
        self.pos = pos
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.ctrl = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pos = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype276, _size273) = iprot.readListBegin()
                    for _i277 in range(_size273):
                        _elem278 = FU_INT64()
                        _elem278.read(iprot)
                        self.v.append(_elem278)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FU_LI')
        if self.ctrl is not None:
            oprot.writeFieldBegin('ctrl', TType.BYTE, 1)
            oprot.writeByte(self.ctrl)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 2)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.pos is not None:
            oprot.writeFieldBegin('pos', TType.I32, 3)
            oprot.writeI32(self.pos)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter279 in self.v:
                iter279.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FU_LB(object):
    """
    Serial LIST_BYTES Field Update

    Attributes:
     - ctrl
     - op
     - pos
     - v

    """

    __slots__ = (
        'ctrl',
        'op',
        'pos',
        'v',
    )


    def __init__(self, ctrl=0, op=    0, pos=None, v=None,):
        self.ctrl = ctrl
        self.op = op
        self.pos = pos
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.ctrl = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.op = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.pos = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype283, _size280) = iprot.readListBegin()
                    for _i284 in range(_size280):
                        _elem285 = FU_BYTES()
                        _elem285.read(iprot)
                        self.v.append(_elem285)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FU_LB')
        if self.ctrl is not None:
            oprot.writeFieldBegin('ctrl', TType.BYTE, 1)
            oprot.writeByte(self.ctrl)
            oprot.writeFieldEnd()
        if self.op is not None:
            oprot.writeFieldBegin('op', TType.I32, 2)
            oprot.writeI32(self.op)
            oprot.writeFieldEnd()
        if self.pos is not None:
            oprot.writeFieldBegin('pos', TType.I32, 3)
            oprot.writeI32(self.pos)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter286 in self.v:
                iter286.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CellValueSerialOp(object):
    """
    The Serial Values Cell field with Update Operation

    Attributes:
     - field_id: The Field ID, a single ID can have any/all the field types
     - v_int64: The INT64 type update-field
     - v_double: The DOUBLE type update-field
     - v_bytes: The BYTES type update-field
     - v_key: The Cell KEY type update-field
     - v_li: The LIST INT64 type update-field
     - v_lb: The LIST BYTES type update-field

    """

    __slots__ = (
        'field_id',
        'v_int64',
        'v_double',
        'v_bytes',
        'v_key',
        'v_li',
        'v_lb',
    )


    def __init__(self, field_id=None, v_int64=None, v_double=None, v_bytes=None, v_key=None, v_li=None, v_lb=None,):
        self.field_id = field_id
        self.v_int64 = v_int64
        self.v_double = v_double
        self.v_bytes = v_bytes
        self.v_key = v_key
        self.v_li = v_li
        self.v_lb = v_lb

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.field_id = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.v_int64 = FU_INT64()
                    self.v_int64.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.v_double = FU_DOUBLE()
                    self.v_double.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.v_bytes = FU_BYTES()
                    self.v_bytes.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.v_key = []
                    (_etype290, _size287) = iprot.readListBegin()
                    for _i291 in range(_size287):
                        _elem292 = iprot.readBinary()
                        self.v_key.append(_elem292)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.v_li = FU_LI()
                    self.v_li.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.v_lb = FU_LB()
                    self.v_lb.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CellValueSerialOp')
        if self.field_id is not None:
            oprot.writeFieldBegin('field_id', TType.I32, 1)
            oprot.writeI32(self.field_id)
            oprot.writeFieldEnd()
        if self.v_int64 is not None:
            oprot.writeFieldBegin('v_int64', TType.STRUCT, 2)
            self.v_int64.write(oprot)
            oprot.writeFieldEnd()
        if self.v_double is not None:
            oprot.writeFieldBegin('v_double', TType.STRUCT, 3)
            self.v_double.write(oprot)
            oprot.writeFieldEnd()
        if self.v_bytes is not None:
            oprot.writeFieldBegin('v_bytes', TType.STRUCT, 4)
            self.v_bytes.write(oprot)
            oprot.writeFieldEnd()
        if self.v_key is not None:
            oprot.writeFieldBegin('v_key', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.v_key))
            for iter293 in self.v_key:
                oprot.writeBinary(iter293)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.v_li is not None:
            oprot.writeFieldBegin('v_li', TType.STRUCT, 6)
            self.v_li.write(oprot)
            oprot.writeFieldEnd()
        if self.v_lb is not None:
            oprot.writeFieldBegin('v_lb', TType.STRUCT, 7)
            self.v_lb.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class UCellSerial(object):
    """
    The Cell data for using with Update of SERIAL Column Type

    Attributes:
     - f: The Cell Flag
     - k: The Cell Key
     - ts: The Cell Timestamp in nanoseconds
     - ts_desc: The Cell Version is in timestamp descending
     - v: The Serial Cell Value fields
     - encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD

    """

    __slots__ = (
        'f',
        'k',
        'ts',
        'ts_desc',
        'v',
        'encoder',
    )


    def __init__(self, f=None, k=None, ts=None, ts_desc=None, v=None, encoder=None,):
        self.f = f
        self.k = k
        self.ts = ts
        self.ts_desc = ts_desc
        self.v = v
        self.encoder = encoder

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.f = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype297, _size294) = iprot.readListBegin()
                    for _i298 in range(_size294):
                        _elem299 = iprot.readBinary()
                        self.k.append(_elem299)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.ts_desc = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype303, _size300) = iprot.readListBegin()
                    for _i304 in range(_size300):
                        _elem305 = CellValueSerial()
                        _elem305.read(iprot)
                        self.v.append(_elem305)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.encoder = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('UCellSerial')
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.I32, 1)
            oprot.writeI32(self.f)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter306 in self.k:
                oprot.writeBinary(iter306)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.ts_desc is not None:
            oprot.writeFieldBegin('ts_desc', TType.BOOL, 4)
            oprot.writeBool(self.ts_desc)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 5)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter307 in self.v:
                iter307.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.encoder is not None:
            oprot.writeFieldBegin('encoder', TType.I32, 6)
            oprot.writeI32(self.encoder)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CellPlain(object):
    """
    The Cell for results list of scan

    Attributes:
     - c: The Column Name
     - k: The Cell Key
     - ts: The Cell Timestamp
     - v: The Cell Value

    """

    __slots__ = (
        'c',
        'k',
        'ts',
        'v',
    )


    def __init__(self, c=None, k=None, ts=None, v=None,):
        self.c = c
        self.k = k
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype311, _size308) = iprot.readListBegin()
                    for _i312 in range(_size308):
                        _elem313 = iprot.readBinary()
                        self.k.append(_elem313)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CellPlain')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter314 in self.k:
                oprot.writeBinary(iter314)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 4)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CellCounter(object):
    """
    The Counter Cell for results list of scan

    Attributes:
     - c: The Column Name
     - k: The Cell Key
     - ts: The Cell Timestamp
     - v: The Cell Counter Value
     - eq: The Counter EQ since ts

    """

    __slots__ = (
        'c',
        'k',
        'ts',
        'v',
        'eq',
    )


    def __init__(self, c=None, k=None, ts=None, v=None, eq=None,):
        self.c = c
        self.k = k
        self.ts = ts
        self.v = v
        self.eq = eq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype318, _size315) = iprot.readListBegin()
                    for _i319 in range(_size315):
                        _elem320 = iprot.readBinary()
                        self.k.append(_elem320)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.eq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CellCounter')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter321 in self.k:
                oprot.writeBinary(iter321)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 4)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        if self.eq is not None:
            oprot.writeFieldBegin('eq', TType.I64, 5)
            oprot.writeI64(self.eq)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CellSerial(object):
    """
    The Serial Cell for results list of scan

    Attributes:
     - c: The Column Name
     - k: The Cell Key
     - ts: The Cell Timestamp
     - v: The Cell Serial Value

    """

    __slots__ = (
        'c',
        'k',
        'ts',
        'v',
    )


    def __init__(self, c=None, k=None, ts=None, v=None,):
        self.c = c
        self.k = k
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype325, _size322) = iprot.readListBegin()
                    for _i326 in range(_size322):
                        _elem327 = iprot.readBinary()
                        self.k.append(_elem327)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype331, _size328) = iprot.readListBegin()
                    for _i332 in range(_size328):
                        _elem333 = CellValueSerial()
                        _elem333.read(iprot)
                        self.v.append(_elem333)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CellSerial')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter334 in self.k:
                oprot.writeBinary(iter334)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 3)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter335 in self.v:
                iter335.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Cells(object):
    """
    The Cells for results list of scan

    Attributes:
     - plain_cells: The Cells, defined as Cell items in a list-container
     - counter_cells: The Cells, defined as Cell items in a list-container
     - serial_cells: The Serial Cells, defined as CellSerial items in a list-container

    """

    __slots__ = (
        'plain_cells',
        'counter_cells',
        'serial_cells',
    )


    def __init__(self, plain_cells=None, counter_cells=None, serial_cells=None,):
        self.plain_cells = plain_cells
        self.counter_cells = counter_cells
        self.serial_cells = serial_cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.plain_cells = []
                    (_etype339, _size336) = iprot.readListBegin()
                    for _i340 in range(_size336):
                        _elem341 = CellPlain()
                        _elem341.read(iprot)
                        self.plain_cells.append(_elem341)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.counter_cells = []
                    (_etype345, _size342) = iprot.readListBegin()
                    for _i346 in range(_size342):
                        _elem347 = CellCounter()
                        _elem347.read(iprot)
                        self.counter_cells.append(_elem347)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.serial_cells = []
                    (_etype351, _size348) = iprot.readListBegin()
                    for _i352 in range(_size348):
                        _elem353 = CellSerial()
                        _elem353.read(iprot)
                        self.serial_cells.append(_elem353)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Cells')
        if self.plain_cells is not None:
            oprot.writeFieldBegin('plain_cells', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.plain_cells))
            for iter354 in self.plain_cells:
                iter354.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.counter_cells is not None:
            oprot.writeFieldBegin('counter_cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.counter_cells))
            for iter355 in self.counter_cells:
                iter355.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.serial_cells is not None:
            oprot.writeFieldBegin('serial_cells', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.serial_cells))
            for iter356 in self.serial_cells:
                iter356.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CCellPlain(object):
    """
    The Plain column type Cell for results on Columns of scan

    Attributes:
     - k: The Cell Key
     - ts: The Cell Timestamp
     - v: The Cell Value

    """

    __slots__ = (
        'k',
        'ts',
        'v',
    )


    def __init__(self, k=None, ts=None, v=None,):
        self.k = k
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype360, _size357) = iprot.readListBegin()
                    for _i361 in range(_size357):
                        _elem362 = iprot.readBinary()
                        self.k.append(_elem362)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CCellPlain')
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter363 in self.k:
                oprot.writeBinary(iter363)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 3)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CCellCounter(object):
    """
    The Counter column type Cell for results on Columns of scan

    Attributes:
     - k: The Cell Key
     - ts: The Cell Timestamp
     - v: The Cell Counter Value
     - eq: The Counter EQ since ts

    """

    __slots__ = (
        'k',
        'ts',
        'v',
        'eq',
    )


    def __init__(self, k=None, ts=None, v=None, eq=None,):
        self.k = k
        self.ts = ts
        self.v = v
        self.eq = eq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype367, _size364) = iprot.readListBegin()
                    for _i368 in range(_size364):
                        _elem369 = iprot.readBinary()
                        self.k.append(_elem369)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.eq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CCellCounter')
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter370 in self.k:
                oprot.writeBinary(iter370)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 3)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        if self.eq is not None:
            oprot.writeFieldBegin('eq', TType.I64, 4)
            oprot.writeI64(self.eq)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CCellSerial(object):
    """
    The Serial column type Cell for results on Columns of scan

    Attributes:
     - k: The Cell Key
     - ts: The Cell Timestamp
     - v: The Cell Serial Value

    """

    __slots__ = (
        'k',
        'ts',
        'v',
    )


    def __init__(self, k=None, ts=None, v=None,):
        self.k = k
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype374, _size371) = iprot.readListBegin()
                    for _i375 in range(_size371):
                        _elem376 = iprot.readBinary()
                        self.k.append(_elem376)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype380, _size377) = iprot.readListBegin()
                    for _i381 in range(_size377):
                        _elem382 = CellValueSerial()
                        _elem382.read(iprot)
                        self.v.append(_elem382)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CCellSerial')
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter383 in self.k:
                oprot.writeBinary(iter383)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter384 in self.v:
                iter384.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class cCells(object):
    """
    The Column Cells for results on Columns of scan

    Attributes:
     - plain_cells: The Plain type Cells, defined as CCellPlain items in a list-container
     - counter_cells: The Counter type Cells, defined as CCellCounter items in a list-container
     - serial_cells: The Serial type Cells, defined as CCellSerial items in a list-container

    """

    __slots__ = (
        'plain_cells',
        'counter_cells',
        'serial_cells',
    )


    def __init__(self, plain_cells=None, counter_cells=None, serial_cells=None,):
        self.plain_cells = plain_cells
        self.counter_cells = counter_cells
        self.serial_cells = serial_cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.plain_cells = []
                    (_etype388, _size385) = iprot.readListBegin()
                    for _i389 in range(_size385):
                        _elem390 = CCellPlain()
                        _elem390.read(iprot)
                        self.plain_cells.append(_elem390)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.counter_cells = []
                    (_etype394, _size391) = iprot.readListBegin()
                    for _i395 in range(_size391):
                        _elem396 = CCellCounter()
                        _elem396.read(iprot)
                        self.counter_cells.append(_elem396)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.serial_cells = []
                    (_etype400, _size397) = iprot.readListBegin()
                    for _i401 in range(_size397):
                        _elem402 = CCellSerial()
                        _elem402.read(iprot)
                        self.serial_cells.append(_elem402)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('cCells')
        if self.plain_cells is not None:
            oprot.writeFieldBegin('plain_cells', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.plain_cells))
            for iter403 in self.plain_cells:
                iter403.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.counter_cells is not None:
            oprot.writeFieldBegin('counter_cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.counter_cells))
            for iter404 in self.counter_cells:
                iter404.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.serial_cells is not None:
            oprot.writeFieldBegin('serial_cells', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.serial_cells))
            for iter405 in self.serial_cells:
                iter405.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class KCellPlain(object):
    """
    The Plain column type Key Cell for results on Key of scan

    Attributes:
     - c: The Column Name
     - ts: The Cell Timestamp
     - v: The Cell Value

    """

    __slots__ = (
        'c',
        'ts',
        'v',
    )


    def __init__(self, c=None, ts=None, v=None,):
        self.c = c
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KCellPlain')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 3)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class KCellCounter(object):
    """
    The Counter column type Key Cell for results on Key of scan

    Attributes:
     - c: The Column Name
     - ts: The Cell Timestamp
     - v: The Cell Counter Value
     - eq: The Counter EQ since ts

    """

    __slots__ = (
        'c',
        'ts',
        'v',
        'eq',
    )


    def __init__(self, c=None, ts=None, v=None, eq=None,):
        self.c = c
        self.ts = ts
        self.v = v
        self.eq = eq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.eq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KCellCounter')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 3)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        if self.eq is not None:
            oprot.writeFieldBegin('eq', TType.I64, 4)
            oprot.writeI64(self.eq)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class KCellSerial(object):
    """
    The Serial column type Key Cell for results on Key of scan

    Attributes:
     - c: The Column Name
     - ts: The Cell Timestamp
     - v: The Cell Serial Value

    """

    __slots__ = (
        'c',
        'ts',
        'v',
    )


    def __init__(self, c=None, ts=None, v=None,):
        self.c = c
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype409, _size406) = iprot.readListBegin()
                    for _i410 in range(_size406):
                        _elem411 = CellValueSerial()
                        _elem411.read(iprot)
                        self.v.append(_elem411)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('KCellSerial')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter412 in self.v:
                iter412.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class kCells(object):
    """
    The Key Cells for results on Key of scan

    Attributes:
     - k: The Cell Key
     - plain_cells: The Plain type Key Cells, defined as KCellPlain items in a list-container
     - counter_cells: The Counter type Key Cells, defined as KCellCounter items in a list-container
     - serial_cells: The Serial type Key Cells, defined as KCellSerial items in a list-container

    """

    __slots__ = (
        'k',
        'plain_cells',
        'counter_cells',
        'serial_cells',
    )


    def __init__(self, k=None, plain_cells=None, counter_cells=None, serial_cells=None,):
        self.k = k
        self.plain_cells = plain_cells
        self.counter_cells = counter_cells
        self.serial_cells = serial_cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.k = []
                    (_etype416, _size413) = iprot.readListBegin()
                    for _i417 in range(_size413):
                        _elem418 = iprot.readBinary()
                        self.k.append(_elem418)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.plain_cells = []
                    (_etype422, _size419) = iprot.readListBegin()
                    for _i423 in range(_size419):
                        _elem424 = KCellPlain()
                        _elem424.read(iprot)
                        self.plain_cells.append(_elem424)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.counter_cells = []
                    (_etype428, _size425) = iprot.readListBegin()
                    for _i429 in range(_size425):
                        _elem430 = KCellCounter()
                        _elem430.read(iprot)
                        self.counter_cells.append(_elem430)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.serial_cells = []
                    (_etype434, _size431) = iprot.readListBegin()
                    for _i435 in range(_size431):
                        _elem436 = KCellSerial()
                        _elem436.read(iprot)
                        self.serial_cells.append(_elem436)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('kCells')
        if self.k is not None:
            oprot.writeFieldBegin('k', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.k))
            for iter437 in self.k:
                oprot.writeBinary(iter437)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.plain_cells is not None:
            oprot.writeFieldBegin('plain_cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.plain_cells))
            for iter438 in self.plain_cells:
                iter438.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.counter_cells is not None:
            oprot.writeFieldBegin('counter_cells', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.counter_cells))
            for iter439 in self.counter_cells:
                iter439.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.serial_cells is not None:
            oprot.writeFieldBegin('serial_cells', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.serial_cells))
            for iter440 in self.serial_cells:
                iter440.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FCellPlain(object):
    """
    The Plain column type Fraction Cell for results on Fraction of scan

    Attributes:
     - c: The Column Name
     - ts: The Cell Timestamp
     - v: The Cell Value

    """

    __slots__ = (
        'c',
        'ts',
        'v',
    )


    def __init__(self, c=None, ts=None, v=None,):
        self.c = c
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.v = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FCellPlain')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.STRING, 3)
            oprot.writeBinary(self.v)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FCellCounter(object):
    """
    The Counter column type Fraction Cell for results on Fraction of scan

    Attributes:
     - c: The Column Name
     - ts: The Cell Timestamp
     - v: The Cell Counter Value
     - eq: The Counter EQ since ts

    """

    __slots__ = (
        'c',
        'ts',
        'v',
        'eq',
    )


    def __init__(self, c=None, ts=None, v=None, eq=None,):
        self.c = c
        self.ts = ts
        self.v = v
        self.eq = eq

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.v = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.eq = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FCellCounter')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.I64, 3)
            oprot.writeI64(self.v)
            oprot.writeFieldEnd()
        if self.eq is not None:
            oprot.writeFieldBegin('eq', TType.I64, 4)
            oprot.writeI64(self.eq)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FCellSerial(object):
    """
    The Serial column type Fraction Cell for results on Fraction of scan

    Attributes:
     - c: The Column Name
     - ts: The Cell Timestamp
     - v: The Cell Serial Value

    """

    __slots__ = (
        'c',
        'ts',
        'v',
    )


    def __init__(self, c=None, ts=None, v=None,):
        self.c = c
        self.ts = ts
        self.v = v

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.c = iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.ts = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.v = []
                    (_etype444, _size441) = iprot.readListBegin()
                    for _i445 in range(_size441):
                        _elem446 = CellValueSerial()
                        _elem446.read(iprot)
                        self.v.append(_elem446)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FCellSerial')
        if self.c is not None:
            oprot.writeFieldBegin('c', TType.STRING, 1)
            oprot.writeString(self.c)
            oprot.writeFieldEnd()
        if self.ts is not None:
            oprot.writeFieldBegin('ts', TType.I64, 2)
            oprot.writeI64(self.ts)
            oprot.writeFieldEnd()
        if self.v is not None:
            oprot.writeFieldBegin('v', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.v))
            for iter447 in self.v:
                iter447.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class FCells(object):
    """
    The Fraction Cells for results on Fraction of scan

    Attributes:
     - f: The Fraction Container for the Next Fractions Tree,  defined as FCells items in a map-container by current Fraction bytes
     - plain_cells: The current Fraction's Cells, defined as FCellPlain items in a list-container
     - counter_cells: The current Fraction's Cells, defined as FCellCounter items in a list-container
     - serial_cells: The current Fraction's Serial Cells, defined as FCellSerial items in a list-container

    """

    __slots__ = (
        'f',
        'plain_cells',
        'counter_cells',
        'serial_cells',
    )


    def __init__(self, f=None, plain_cells=None, counter_cells=None, serial_cells=None,):
        self.f = f
        self.plain_cells = plain_cells
        self.counter_cells = counter_cells
        self.serial_cells = serial_cells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.f = {}
                    (_ktype449, _vtype450, _size448) = iprot.readMapBegin()
                    for _i452 in range(_size448):
                        _key453 = iprot.readBinary()
                        _val454 = FCells()
                        _val454.read(iprot)
                        self.f[_key453] = _val454
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.plain_cells = []
                    (_etype458, _size455) = iprot.readListBegin()
                    for _i459 in range(_size455):
                        _elem460 = FCellPlain()
                        _elem460.read(iprot)
                        self.plain_cells.append(_elem460)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.counter_cells = []
                    (_etype464, _size461) = iprot.readListBegin()
                    for _i465 in range(_size461):
                        _elem466 = FCellCounter()
                        _elem466.read(iprot)
                        self.counter_cells.append(_elem466)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.serial_cells = []
                    (_etype470, _size467) = iprot.readListBegin()
                    for _i471 in range(_size467):
                        _elem472 = FCellSerial()
                        _elem472.read(iprot)
                        self.serial_cells.append(_elem472)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('FCells')
        if self.f is not None:
            oprot.writeFieldBegin('f', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.f))
            for kiter473, viter474 in self.f.items():
                oprot.writeBinary(kiter473)
                viter474.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.plain_cells is not None:
            oprot.writeFieldBegin('plain_cells', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.plain_cells))
            for iter475 in self.plain_cells:
                iter475.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.counter_cells is not None:
            oprot.writeFieldBegin('counter_cells', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.counter_cells))
            for iter476 in self.counter_cells:
                iter476.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.serial_cells is not None:
            oprot.writeFieldBegin('serial_cells', TType.LIST, 4)
            oprot.writeListBegin(TType.STRUCT, len(self.serial_cells))
            for iter477 in self.serial_cells:
                iter477.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CellsGroup(object):
    """
    A Grouped Cells result for results of scan, determined by the request's CellsResult enum

    Attributes:
     - cells: The Cells in a list, defined as Cell items in a list-container
     - ccells: The Columns Cells in a map-container, defined as cCells items by Column Name
     - kcells: The Keys Cells in a list, defined as kCells items in a list-container
     - fcells: The Fraction Cells in struct FCells

    """

    __slots__ = (
        'cells',
        'ccells',
        'kcells',
        'fcells',
    )


    def __init__(self, cells=None, ccells=None, kcells=None, fcells=None,):
        self.cells = cells
        self.ccells = ccells
        self.kcells = kcells
        self.fcells = fcells

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.cells = Cells()
                    self.cells.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.ccells = {}
                    (_ktype479, _vtype480, _size478) = iprot.readMapBegin()
                    for _i482 in range(_size478):
                        _key483 = iprot.readString()
                        _val484 = cCells()
                        _val484.read(iprot)
                        self.ccells[_key483] = _val484
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.kcells = []
                    (_etype488, _size485) = iprot.readListBegin()
                    for _i489 in range(_size485):
                        _elem490 = kCells()
                        _elem490.read(iprot)
                        self.kcells.append(_elem490)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.fcells = FCells()
                    self.fcells.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CellsGroup')
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.STRUCT, 1)
            self.cells.write(oprot)
            oprot.writeFieldEnd()
        if self.ccells is not None:
            oprot.writeFieldBegin('ccells', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.ccells))
            for kiter491, viter492 in self.ccells.items():
                oprot.writeString(kiter491)
                viter492.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.kcells is not None:
            oprot.writeFieldBegin('kcells', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.kcells))
            for iter493 in self.kcells:
                iter493.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fcells is not None:
            oprot.writeFieldBegin('fcells', TType.STRUCT, 4)
            self.fcells.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class CompactResult(object):
    """
    The Compact Result

    Attributes:
     - cid: Column ID
     - err: Error

    """

    __slots__ = (
        'cid',
        'err',
    )


    def __init__(self, cid=None, err=None,):
        self.cid = cid
        self.err = err

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.cid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.err = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('CompactResult')
        if self.cid is not None:
            oprot.writeFieldBegin('cid', TType.I64, 1)
            oprot.writeI64(self.cid)
            oprot.writeFieldEnd()
        if self.err is not None:
            oprot.writeFieldBegin('err', TType.I32, 2)
            oprot.writeI32(self.err)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)


class Result(object):
    """
    The Result of 'exec_sql'

    Attributes:
     - schemas: Set with result for 'list columns' query
     - cells: Set with result for 'select' query
     - compact: Set with result for 'compact columns' query

    """

    __slots__ = (
        'schemas',
        'cells',
        'compact',
    )


    def __init__(self, schemas=None, cells=None, compact=None,):
        self.schemas = schemas
        self.cells = cells
        self.compact = compact

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.schemas = []
                    (_etype497, _size494) = iprot.readListBegin()
                    for _i498 in range(_size494):
                        _elem499 = Schema()
                        _elem499.read(iprot)
                        self.schemas.append(_elem499)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.cells = Cells()
                    self.cells.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.compact = []
                    (_etype503, _size500) = iprot.readListBegin()
                    for _i504 in range(_size500):
                        _elem505 = CompactResult()
                        _elem505.read(iprot)
                        self.compact.append(_elem505)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('Result')
        if self.schemas is not None:
            oprot.writeFieldBegin('schemas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.schemas))
            for iter506 in self.schemas:
                iter506.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.cells is not None:
            oprot.writeFieldBegin('cells', TType.STRUCT, 2)
            self.cells.write(oprot)
            oprot.writeFieldEnd()
        if self.compact is not None:
            oprot.writeFieldBegin('compact', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.compact))
            for iter507 in self.compact:
                iter507.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, getattr(self, key))
             for key in self.__slots__]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        for attr in self.__slots__:
            my_val = getattr(self, attr)
            other_val = getattr(other, attr)
            if my_val != other_val:
                return False
        return True

    def __ne__(self, other):
        return not (self == other)
all_structs.append(Exception)
Exception.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'code', None, None, ),  # 1
    (2, TType.STRING, 'message', None, None, ),  # 2
)
all_structs.append(Schema)
Schema.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cid', None, None, ),  # 1
    (2, TType.STRING, 'col_name', None, None, ),  # 2
    (3, TType.LIST, 'col_tags', (TType.STRING, None, False), None, ),  # 3
    (4, TType.I32, 'col_seq', None, None, ),  # 4
    (5, TType.I32, 'col_type', None, None, ),  # 5
    (6, TType.I32, 'cell_versions', None, None, ),  # 6
    (7, TType.I32, 'cell_ttl', None, None, ),  # 7
    (8, TType.I32, 'blk_encoding', None, None, ),  # 8
    (9, TType.I32, 'blk_size', None, None, ),  # 9
    (10, TType.I32, 'blk_cells', None, None, ),  # 10
    (11, TType.BYTE, 'cs_replication', None, None, ),  # 11
    (12, TType.I32, 'cs_size', None, None, ),  # 12
    (13, TType.BYTE, 'cs_max', None, None, ),  # 13
    (14, TType.BYTE, 'log_rollout_ratio', None, None, ),  # 14
    (15, TType.BYTE, 'log_compact_cointervaling', None, None, ),  # 15
    (16, TType.BYTE, 'log_fragment_preload', None, None, ),  # 16
    (17, TType.BYTE, 'compact_percent', None, None, ),  # 17
    (18, TType.I64, 'revision', None, None, ),  # 18
)
all_structs.append(SchemaPattern)
SchemaPattern.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.STRING, 'value', None, None, ),  # 2
)
all_structs.append(SchemaTagsPatterns)
SchemaTagsPatterns.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.LIST, 'values', (TType.STRUCT, [SchemaPattern, None], False), None, ),  # 2
)
all_structs.append(SchemaPatterns)
SchemaPatterns.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'names', (TType.STRUCT, [SchemaPattern, None], False), None, ),  # 1
    (2, TType.STRUCT, 'tags', [SchemaTagsPatterns, None], None, ),  # 2
)
all_structs.append(SpecSchemas)
SpecSchemas.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'cids', (TType.I64, None, False), None, ),  # 1
    (2, TType.LIST, 'names', (TType.STRING, None, False), None, ),  # 2
    (3, TType.STRUCT, 'patterns', [SchemaPatterns, None], None, ),  # 3
)
all_structs.append(SpecFlags)
SpecFlags.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'limit', None, None, ),  # 1
    (2, TType.I64, 'offset', None, None, ),  # 2
    (3, TType.I32, 'max_versions', None, None, ),  # 3
    (4, TType.I32, 'max_buffer', None, None, ),  # 4
    (5, TType.BYTE, 'options', None, None, ),  # 5
)
all_structs.append(SpecUpdateOP)
SpecUpdateOP.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'op', None, None, ),  # 1
    (2, TType.I32, 'pos', None, None, ),  # 2
)
all_structs.append(SpecIntervalUpdatePlain)
SpecIntervalUpdatePlain.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'v', 'BINARY', None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.I32, 'encoder', None, None, ),  # 3
    (4, TType.STRUCT, 'update_op', [SpecUpdateOP, None], None, ),  # 4
)
all_structs.append(SpecIntervalUpdateCounter)
SpecIntervalUpdateCounter.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'v', None, None, ),  # 1
    (2, TType.I64, 'op', None, 0, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.STRUCT, 'update_op', [SpecUpdateOP, None], None, ),  # 4
)
all_structs.append(SpecIntervalUpdateSerial)
SpecIntervalUpdateSerial.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'ts', None, None, ),  # 1
    (2, TType.LIST, 'v', (TType.STRUCT, [CellValueSerial, None], False), None, ),  # 2
    (3, TType.LIST, 'v_op', (TType.STRUCT, [CellValueSerialOp, None], False), None, ),  # 3
    (4, TType.I32, 'encoder', None, None, ),  # 4
    (5, TType.STRUCT, 'update_op', [SpecUpdateOP, None], None, ),  # 5
)
all_structs.append(SpecValueSerial_INT64)
SpecValueSerial_INT64.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.I64, 'v', None, None, ),  # 2
)
all_structs.append(SpecValueSerial_DOUBLE)
SpecValueSerial_DOUBLE.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.DOUBLE, 'v', None, None, ),  # 2
)
all_structs.append(SpecValueSerial_BYTES)
SpecValueSerial_BYTES.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.STRING, 'v', 'BINARY', None, ),  # 2
)
all_structs.append(SpecValueSerial_KEY)
SpecValueSerial_KEY.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'seq', None, None, ),  # 1
    (2, TType.LIST, 'v', (TType.STRUCT, [SpecFraction, None], False), None, ),  # 2
)
all_structs.append(SpecValueSerial_LI)
SpecValueSerial_LI.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.LIST, 'v', (TType.STRUCT, [SpecValueSerial_INT64, None], False), None, ),  # 2
)
all_structs.append(SpecValueSerial_LB)
SpecValueSerial_LB.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.LIST, 'v', (TType.STRUCT, [SpecValueSerial_BYTES, None], False), None, ),  # 2
)
all_structs.append(SpecValueSerialField)
SpecValueSerialField.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'field_id', None, None, ),  # 1
    (2, TType.STRUCT, 'spec_int64', [SpecValueSerial_INT64, None], None, ),  # 2
    (3, TType.STRUCT, 'spec_double', [SpecValueSerial_DOUBLE, None], None, ),  # 3
    (4, TType.STRUCT, 'spec_bytes', [SpecValueSerial_BYTES, None], None, ),  # 4
    (5, TType.STRUCT, 'spec_key', [SpecValueSerial_KEY, None], None, ),  # 5
    (6, TType.STRUCT, 'spec_li', [SpecValueSerial_LI, None], None, ),  # 6
    (7, TType.STRUCT, 'spec_lb', [SpecValueSerial_LB, None], None, ),  # 7
)
all_structs.append(SpecValuePlain)
SpecValuePlain.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.STRING, 'v', 'BINARY', None, ),  # 2
)
all_structs.append(SpecValueCounter)
SpecValueCounter.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.I64, 'v', None, None, ),  # 2
)
all_structs.append(SpecValueSerial)
SpecValueSerial.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.LIST, 'fields', (TType.STRUCT, [SpecValueSerialField, None], False), None, ),  # 2
)
all_structs.append(SpecFraction)
SpecFraction.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.STRING, 'f', 'BINARY', None, ),  # 2
)
all_structs.append(SpecTimestamp)
SpecTimestamp.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'comp', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
)
all_structs.append(SpecKeyInterval)
SpecKeyInterval.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'start', (TType.STRUCT, [SpecFraction, None], False), None, ),  # 1
    (2, TType.LIST, 'finish', (TType.STRUCT, [SpecFraction, None], False), None, ),  # 2
)
all_structs.append(SpecIntervalPlain)
SpecIntervalPlain.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'range_begin', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'range_end', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'offset_key', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.I64, 'offset_rev', None, None, ),  # 4
    (5, TType.LIST, 'key_intervals', (TType.STRUCT, [SpecKeyInterval, None], False), None, ),  # 5
    (6, TType.LIST, 'values', (TType.STRUCT, [SpecValuePlain, None], False), None, ),  # 6
    (7, TType.STRUCT, 'ts_start', [SpecTimestamp, None], None, ),  # 7
    (8, TType.STRUCT, 'ts_finish', [SpecTimestamp, None], None, ),  # 8
    (9, TType.STRUCT, 'flags', [SpecFlags, None], None, ),  # 9
    (10, TType.I32, 'options', None, None, ),  # 10
    (11, TType.STRUCT, 'updating', [SpecIntervalUpdatePlain, None], None, ),  # 11
)
all_structs.append(SpecIntervalCounter)
SpecIntervalCounter.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'range_begin', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'range_end', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'offset_key', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.I64, 'offset_rev', None, None, ),  # 4
    (5, TType.LIST, 'key_intervals', (TType.STRUCT, [SpecKeyInterval, None], False), None, ),  # 5
    (6, TType.LIST, 'values', (TType.STRUCT, [SpecValueCounter, None], False), None, ),  # 6
    (7, TType.STRUCT, 'ts_start', [SpecTimestamp, None], None, ),  # 7
    (8, TType.STRUCT, 'ts_finish', [SpecTimestamp, None], None, ),  # 8
    (9, TType.STRUCT, 'flags', [SpecFlags, None], None, ),  # 9
    (10, TType.I32, 'options', None, None, ),  # 10
    (11, TType.STRUCT, 'updating', [SpecIntervalUpdateCounter, None], None, ),  # 11
)
all_structs.append(SpecIntervalSerial)
SpecIntervalSerial.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'range_begin', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'range_end', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.LIST, 'offset_key', (TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.I64, 'offset_rev', None, None, ),  # 4
    (5, TType.LIST, 'key_intervals', (TType.STRUCT, [SpecKeyInterval, None], False), None, ),  # 5
    (6, TType.LIST, 'values', (TType.STRUCT, [SpecValueSerial, None], False), None, ),  # 6
    (7, TType.STRUCT, 'ts_start', [SpecTimestamp, None], None, ),  # 7
    (8, TType.STRUCT, 'ts_finish', [SpecTimestamp, None], None, ),  # 8
    (9, TType.STRUCT, 'flags', [SpecFlags, None], None, ),  # 9
    (10, TType.I32, 'options', None, None, ),  # 10
    (11, TType.STRUCT, 'updating', [SpecIntervalUpdateSerial, None], None, ),  # 11
)
all_structs.append(SpecColumnPlain)
SpecColumnPlain.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cid', None, None, ),  # 1
    (2, TType.LIST, 'intervals', (TType.STRUCT, [SpecIntervalPlain, None], False), None, ),  # 2
)
all_structs.append(SpecColumnCounter)
SpecColumnCounter.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cid', None, None, ),  # 1
    (2, TType.LIST, 'intervals', (TType.STRUCT, [SpecIntervalCounter, None], False), None, ),  # 2
)
all_structs.append(SpecColumnSerial)
SpecColumnSerial.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cid', None, None, ),  # 1
    (2, TType.LIST, 'intervals', (TType.STRUCT, [SpecIntervalSerial, None], False), None, ),  # 2
)
all_structs.append(SpecScan)
SpecScan.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'columns_plain', (TType.STRUCT, [SpecColumnPlain, None], False), None, ),  # 1
    (2, TType.LIST, 'columns_counter', (TType.STRUCT, [SpecColumnCounter, None], False), None, ),  # 2
    (3, TType.LIST, 'columns_serial', (TType.STRUCT, [SpecColumnSerial, None], False), None, ),  # 3
    (4, TType.STRUCT, 'flags', [SpecFlags, None], None, ),  # 4
)
all_structs.append(UCellPlain)
UCellPlain.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'f', None, None, ),  # 1
    (2, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.BOOL, 'ts_desc', None, None, ),  # 4
    (5, TType.STRING, 'v', 'BINARY', None, ),  # 5
    (6, TType.I32, 'encoder', None, None, ),  # 6
)
all_structs.append(UCellCounter)
UCellCounter.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'f', None, None, ),  # 1
    (2, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.BOOL, 'ts_desc', None, None, ),  # 4
    (5, TType.BYTE, 'op', None, 0, ),  # 5
    (6, TType.I64, 'v', None, 0, ),  # 6
)
all_structs.append(CellValueSerial)
CellValueSerial.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'field_id', None, None, ),  # 1
    (2, TType.I64, 'v_int64', None, None, ),  # 2
    (3, TType.DOUBLE, 'v_double', None, None, ),  # 3
    (4, TType.STRING, 'v_bytes', 'BINARY', None, ),  # 4
    (5, TType.LIST, 'v_key', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.LIST, 'v_li', (TType.I64, None, False), None, ),  # 6
    (7, TType.LIST, 'v_lb', (TType.STRING, 'BINARY', False), None, ),  # 7
)
all_structs.append(FU_INT64)
FU_INT64.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'ctrl', None, 0, ),  # 1
    (2, TType.I32, 'op', None,     0, ),  # 2
    (3, TType.I32, 'pos', None, None, ),  # 3
    (4, TType.I32, 'comp', None, None, ),  # 4
    (5, TType.I64, 'v', None, None, ),  # 5
)
all_structs.append(FU_DOUBLE)
FU_DOUBLE.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'ctrl', None, 0, ),  # 1
    (2, TType.I32, 'op', None,     0, ),  # 2
    (3, TType.I32, 'pos', None, None, ),  # 3
    (4, TType.I32, 'comp', None, None, ),  # 4
    (5, TType.DOUBLE, 'v', None, None, ),  # 5
)
all_structs.append(FU_BYTES)
FU_BYTES.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'ctrl', None, 0, ),  # 1
    (2, TType.I32, 'op', None,     0, ),  # 2
    (3, TType.I32, 'pos', None, None, ),  # 3
    (4, TType.I32, 'comp', None, None, ),  # 4
    (5, TType.STRING, 'v', 'BINARY', None, ),  # 5
)
all_structs.append(FU_LI)
FU_LI.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'ctrl', None, 0, ),  # 1
    (2, TType.I32, 'op', None,     0, ),  # 2
    (3, TType.I32, 'pos', None, None, ),  # 3
    (4, TType.LIST, 'v', (TType.STRUCT, [FU_INT64, None], False), None, ),  # 4
)
all_structs.append(FU_LB)
FU_LB.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'ctrl', None, 0, ),  # 1
    (2, TType.I32, 'op', None,     0, ),  # 2
    (3, TType.I32, 'pos', None, None, ),  # 3
    (4, TType.LIST, 'v', (TType.STRUCT, [FU_BYTES, None], False), None, ),  # 4
)
all_structs.append(CellValueSerialOp)
CellValueSerialOp.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'field_id', None, None, ),  # 1
    (2, TType.STRUCT, 'v_int64', [FU_INT64, None], None, ),  # 2
    (3, TType.STRUCT, 'v_double', [FU_DOUBLE, None], None, ),  # 3
    (4, TType.STRUCT, 'v_bytes', [FU_BYTES, None], None, ),  # 4
    (5, TType.LIST, 'v_key', (TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.STRUCT, 'v_li', [FU_LI, None], None, ),  # 6
    (7, TType.STRUCT, 'v_lb', [FU_LB, None], None, ),  # 7
)
all_structs.append(UCellSerial)
UCellSerial.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'f', None, None, ),  # 1
    (2, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.BOOL, 'ts_desc', None, None, ),  # 4
    (5, TType.LIST, 'v', (TType.STRUCT, [CellValueSerial, None], False), None, ),  # 5
    (6, TType.I32, 'encoder', None, None, ),  # 6
)
all_structs.append(CellPlain)
CellPlain.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.STRING, 'v', 'BINARY', None, ),  # 4
)
all_structs.append(CellCounter)
CellCounter.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.I64, 'v', None, None, ),  # 4
    (5, TType.I64, 'eq', None, None, ),  # 5
)
all_structs.append(CellSerial)
CellSerial.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.I64, 'ts', None, None, ),  # 3
    (4, TType.LIST, 'v', (TType.STRUCT, [CellValueSerial, None], False), None, ),  # 4
)
all_structs.append(Cells)
Cells.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'plain_cells', (TType.STRUCT, [CellPlain, None], False), None, ),  # 1
    (2, TType.LIST, 'counter_cells', (TType.STRUCT, [CellCounter, None], False), None, ),  # 2
    (3, TType.LIST, 'serial_cells', (TType.STRUCT, [CellSerial, None], False), None, ),  # 3
)
all_structs.append(CCellPlain)
CCellPlain.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.STRING, 'v', 'BINARY', None, ),  # 3
)
all_structs.append(CCellCounter)
CCellCounter.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.I64, 'v', None, None, ),  # 3
    (4, TType.I64, 'eq', None, None, ),  # 4
)
all_structs.append(CCellSerial)
CCellSerial.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.LIST, 'v', (TType.STRUCT, [CellValueSerial, None], False), None, ),  # 3
)
all_structs.append(cCells)
cCells.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'plain_cells', (TType.STRUCT, [CCellPlain, None], False), None, ),  # 1
    (2, TType.LIST, 'counter_cells', (TType.STRUCT, [CCellCounter, None], False), None, ),  # 2
    (3, TType.LIST, 'serial_cells', (TType.STRUCT, [CCellSerial, None], False), None, ),  # 3
)
all_structs.append(KCellPlain)
KCellPlain.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.STRING, 'v', 'BINARY', None, ),  # 3
)
all_structs.append(KCellCounter)
KCellCounter.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.I64, 'v', None, None, ),  # 3
    (4, TType.I64, 'eq', None, None, ),  # 4
)
all_structs.append(KCellSerial)
KCellSerial.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.LIST, 'v', (TType.STRUCT, [CellValueSerial, None], False), None, ),  # 3
)
all_structs.append(kCells)
kCells.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'k', (TType.STRING, 'BINARY', False), None, ),  # 1
    (2, TType.LIST, 'plain_cells', (TType.STRUCT, [KCellPlain, None], False), None, ),  # 2
    (3, TType.LIST, 'counter_cells', (TType.STRUCT, [KCellCounter, None], False), None, ),  # 3
    (4, TType.LIST, 'serial_cells', (TType.STRUCT, [KCellSerial, None], False), None, ),  # 4
)
all_structs.append(FCellPlain)
FCellPlain.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.STRING, 'v', 'BINARY', None, ),  # 3
)
all_structs.append(FCellCounter)
FCellCounter.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.I64, 'v', None, None, ),  # 3
    (4, TType.I64, 'eq', None, None, ),  # 4
)
all_structs.append(FCellSerial)
FCellSerial.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'c', None, None, ),  # 1
    (2, TType.I64, 'ts', None, None, ),  # 2
    (3, TType.LIST, 'v', (TType.STRUCT, [CellValueSerial, None], False), None, ),  # 3
)
all_structs.append(FCells)
FCells.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'f', (TType.STRING, 'BINARY', TType.STRUCT, [FCells, None], False), None, ),  # 1
    (2, TType.LIST, 'plain_cells', (TType.STRUCT, [FCellPlain, None], False), None, ),  # 2
    (3, TType.LIST, 'counter_cells', (TType.STRUCT, [FCellCounter, None], False), None, ),  # 3
    (4, TType.LIST, 'serial_cells', (TType.STRUCT, [FCellSerial, None], False), None, ),  # 4
)
all_structs.append(CellsGroup)
CellsGroup.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'cells', [Cells, None], None, ),  # 1
    (2, TType.MAP, 'ccells', (TType.STRING, None, TType.STRUCT, [cCells, None], False), None, ),  # 2
    (3, TType.LIST, 'kcells', (TType.STRUCT, [kCells, None], False), None, ),  # 3
    (4, TType.STRUCT, 'fcells', [FCells, None], None, ),  # 4
)
all_structs.append(CompactResult)
CompactResult.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'cid', None, None, ),  # 1
    (2, TType.I32, 'err', None, None, ),  # 2
)
all_structs.append(Result)
Result.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'schemas', (TType.STRUCT, [Schema, None], False), None, ),  # 1
    (2, TType.STRUCT, 'cells', [Cells, None], None, ),  # 2
    (3, TType.LIST, 'compact', (TType.STRUCT, [CompactResult, None], False), None, ),  # 3
)
fix_spec(all_structs)
del all_structs
