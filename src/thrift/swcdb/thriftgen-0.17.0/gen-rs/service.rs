// Autogenerated by Thrift Compiler (0.17.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]

use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;

use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

/// Column Key Sequences
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KeySeq(pub i32);

impl KeySeq {
  /// Unknown/Unrecognized Type
  pub const UNKNOWN: KeySeq = KeySeq(0);
  /// The Lexical Key Order Sequence
  pub const LEXIC: KeySeq = KeySeq(1);
  /// The Volumetric Key Order Sequence
  pub const VOLUME: KeySeq = KeySeq(2);
  /// The by Fractions Count on Lexical Key Order Sequence
  pub const FC_LEXIC: KeySeq = KeySeq(3);
  /// The by Fractions Count on Volumetric Key Order Sequence
  pub const FC_VOLUME: KeySeq = KeySeq(4);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::LEXIC,
    Self::VOLUME,
    Self::FC_LEXIC,
    Self::FC_VOLUME,
  ];
}

impl TSerializable for KeySeq {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KeySeq> {
    let enum_value = i_prot.read_i32()?;
    Ok(KeySeq::from(enum_value))
  }
}

impl From<i32> for KeySeq {
  fn from(i: i32) -> Self {
    match i {
      0 => KeySeq::UNKNOWN,
      1 => KeySeq::LEXIC,
      2 => KeySeq::VOLUME,
      3 => KeySeq::FC_LEXIC,
      4 => KeySeq::FC_VOLUME,
      _ => KeySeq(i)
    }
  }
}

impl From<&i32> for KeySeq {
  fn from(i: &i32) -> Self {
    KeySeq::from(*i)
  }
}

impl From<KeySeq> for i32 {
  fn from(e: KeySeq) -> i32 {
    e.0
  }
}

impl From<&KeySeq> for i32 {
  fn from(e: &KeySeq) -> i32 {
    e.0
  }
}

/// Column Value Types
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ColumnType(pub i32);

impl ColumnType {
  /// Unknown/Unrecognized Type
  pub const UNKNOWN: ColumnType = ColumnType(0);
  /// A Plain Column Value
  pub const PLAIN: ColumnType = ColumnType(1);
  /// A Counter Column Value with integrity of signed-64bit
  pub const COUNTER_I64: ColumnType = ColumnType(2);
  /// A Counter Column Value with integrity of signed-32bit
  pub const COUNTER_I32: ColumnType = ColumnType(3);
  /// A Counter Column Value with integrity of signed-16bit
  pub const COUNTER_I16: ColumnType = ColumnType(4);
  /// A Counter Column Value with integrity of signed-8bit
  pub const COUNTER_I8: ColumnType = ColumnType(5);
  /// A Serial Column Value
  pub const SERIAL: ColumnType = ColumnType(6);
  /// Not used - experimental
  pub const CELL_DEFINED: ColumnType = ColumnType(15);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UNKNOWN,
    Self::PLAIN,
    Self::COUNTER_I64,
    Self::COUNTER_I32,
    Self::COUNTER_I16,
    Self::COUNTER_I8,
    Self::SERIAL,
    Self::CELL_DEFINED,
  ];
}

impl TSerializable for ColumnType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ColumnType> {
    let enum_value = i_prot.read_i32()?;
    Ok(ColumnType::from(enum_value))
  }
}

impl From<i32> for ColumnType {
  fn from(i: i32) -> Self {
    match i {
      0 => ColumnType::UNKNOWN,
      1 => ColumnType::PLAIN,
      2 => ColumnType::COUNTER_I64,
      3 => ColumnType::COUNTER_I32,
      4 => ColumnType::COUNTER_I16,
      5 => ColumnType::COUNTER_I8,
      6 => ColumnType::SERIAL,
      15 => ColumnType::CELL_DEFINED,
      _ => ColumnType(i)
    }
  }
}

impl From<&i32> for ColumnType {
  fn from(i: &i32) -> Self {
    ColumnType::from(*i)
  }
}

impl From<ColumnType> for i32 {
  fn from(e: ColumnType) -> i32 {
    e.0
  }
}

impl From<&ColumnType> for i32 {
  fn from(e: &ColumnType) -> i32 {
    e.0
  }
}

/// Data Encoding Types
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EncodingType(pub i32);

impl EncodingType {
  /// Encoding by Ranger DEFAULT configurations
  pub const DEFAULT: EncodingType = EncodingType(0);
  /// No Encoding
  pub const PLAIN: EncodingType = EncodingType(1);
  /// Encode with zlib
  pub const ZLIB: EncodingType = EncodingType(2);
  /// Encode with snappy
  pub const SNAPPY: EncodingType = EncodingType(3);
  /// Encode with zstandard
  pub const ZSTD: EncodingType = EncodingType(4);
  /// Unrecognized Type
  pub const UNKNOWN: EncodingType = EncodingType(255);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::DEFAULT,
    Self::PLAIN,
    Self::ZLIB,
    Self::SNAPPY,
    Self::ZSTD,
    Self::UNKNOWN,
  ];
}

impl TSerializable for EncodingType {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<EncodingType> {
    let enum_value = i_prot.read_i32()?;
    Ok(EncodingType::from(enum_value))
  }
}

impl From<i32> for EncodingType {
  fn from(i: i32) -> Self {
    match i {
      0 => EncodingType::DEFAULT,
      1 => EncodingType::PLAIN,
      2 => EncodingType::ZLIB,
      3 => EncodingType::SNAPPY,
      4 => EncodingType::ZSTD,
      255 => EncodingType::UNKNOWN,
      _ => EncodingType(i)
    }
  }
}

impl From<&i32> for EncodingType {
  fn from(i: &i32) -> Self {
    EncodingType::from(*i)
  }
}

impl From<EncodingType> for i32 {
  fn from(e: EncodingType) -> i32 {
    e.0
  }
}

impl From<&EncodingType> for i32 {
  fn from(e: &EncodingType) -> i32 {
    e.0
  }
}

/// Manage Columns schema function Flags
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaFunc(pub i32);

impl SchemaFunc {
  /// Create Column Function
  pub const CREATE: SchemaFunc = SchemaFunc(3);
  /// Delete Column Function
  pub const REMOVE: SchemaFunc = SchemaFunc(5);
  /// Modify Column Function
  pub const MODIFY: SchemaFunc = SchemaFunc(7);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::CREATE,
    Self::REMOVE,
    Self::MODIFY,
  ];
}

impl TSerializable for SchemaFunc {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaFunc> {
    let enum_value = i_prot.read_i32()?;
    Ok(SchemaFunc::from(enum_value))
  }
}

impl From<i32> for SchemaFunc {
  fn from(i: i32) -> Self {
    match i {
      3 => SchemaFunc::CREATE,
      5 => SchemaFunc::REMOVE,
      7 => SchemaFunc::MODIFY,
      _ => SchemaFunc(i)
    }
  }
}

impl From<&i32> for SchemaFunc {
  fn from(i: &i32) -> Self {
    SchemaFunc::from(*i)
  }
}

impl From<SchemaFunc> for i32 {
  fn from(e: SchemaFunc) -> i32 {
    e.0
  }
}

impl From<&SchemaFunc> for i32 {
  fn from(e: &SchemaFunc) -> i32 {
    e.0
  }
}

/// The available logical Comparators, plus extended logic options applied with 'v' for VOLUME
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Comp(pub i32);

impl Comp {
  /// [         ]  :   none               (no comparison applied)
  pub const NONE: Comp = Comp(0);
  /// [  =^     ]  :   -pf [prefix]       (starts-with)
  pub const PF: Comp = Comp(1);
  /// [ &gt;    ]  :   -gt                (greater-than)
  pub const GT: Comp = Comp(2);
  /// [ &gt;=   ]  :   -ge                (greater-equal)
  pub const GE: Comp = Comp(3);
  /// [  =      ]  :   -eq                (equal)
  pub const EQ: Comp = Comp(4);
  /// [ &lt;=   ]  :   -le                (lower-equal)
  pub const LE: Comp = Comp(5);
  /// [ &lt;    ]  :   -lt                (lower-than)
  pub const LT: Comp = Comp(6);
  /// [  !=     ]  :   -ne                (not-equal)
  pub const NE: Comp = Comp(7);
  /// [  re     ]  :   -re [r,regexp]     (regular-expression)
  pub const RE: Comp = Comp(8);
  /// [ v&gt;   ]  :   -vgt               (vol greater-than)
  pub const VGT: Comp = Comp(9);
  /// [ v&gt;=  ]  :   -vge               (vol greater-equal)
  pub const VGE: Comp = Comp(10);
  /// [ v&lt;=  ]  :   -vle               (vol lower-equal)
  pub const VLE: Comp = Comp(11);
  /// [ v&lt;   ]  :   -vlt               (vol lower-than)
  pub const VLT: Comp = Comp(12);
  /// [ %&gt;   ]  :   -subset [sbs]      (subset)
  pub const SBS: Comp = Comp(13);
  /// [ &lt;%   ]  :   -supset [sps]      (superset)
  pub const SPS: Comp = Comp(14);
  /// [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
  pub const POSBS: Comp = Comp(15);
  /// [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
  pub const POSPS: Comp = Comp(16);
  /// [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
  pub const FOSBS: Comp = Comp(17);
  /// [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
  pub const FOSPS: Comp = Comp(18);
  /// [ :&lt;   ]  :   -fip  (fraction include prior)
  pub const FIP: Comp = Comp(19);
  /// [ :       ]  :   -fi   (fraction include)
  pub const FI: Comp = Comp(20);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::PF,
    Self::GT,
    Self::GE,
    Self::EQ,
    Self::LE,
    Self::LT,
    Self::NE,
    Self::RE,
    Self::VGT,
    Self::VGE,
    Self::VLE,
    Self::VLT,
    Self::SBS,
    Self::SPS,
    Self::POSBS,
    Self::POSPS,
    Self::FOSBS,
    Self::FOSPS,
    Self::FIP,
    Self::FI,
  ];
}

impl TSerializable for Comp {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Comp> {
    let enum_value = i_prot.read_i32()?;
    Ok(Comp::from(enum_value))
  }
}

impl From<i32> for Comp {
  fn from(i: i32) -> Self {
    match i {
      0 => Comp::NONE,
      1 => Comp::PF,
      2 => Comp::GT,
      3 => Comp::GE,
      4 => Comp::EQ,
      5 => Comp::LE,
      6 => Comp::LT,
      7 => Comp::NE,
      8 => Comp::RE,
      9 => Comp::VGT,
      10 => Comp::VGE,
      11 => Comp::VLE,
      12 => Comp::VLT,
      13 => Comp::SBS,
      14 => Comp::SPS,
      15 => Comp::POSBS,
      16 => Comp::POSPS,
      17 => Comp::FOSBS,
      18 => Comp::FOSPS,
      19 => Comp::FIP,
      20 => Comp::FI,
      _ => Comp(i)
    }
  }
}

impl From<&i32> for Comp {
  fn from(i: &i32) -> Self {
    Comp::from(*i)
  }
}

impl From<Comp> for i32 {
  fn from(e: Comp) -> i32 {
    e.0
  }
}

impl From<&Comp> for i32 {
  fn from(e: &Comp) -> i32 {
    e.0
  }
}

/// The Scan options Flags Specifications for the SpecFlags 'options' bit
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecFlagsOpt(pub i32);

impl SpecFlagsOpt {
  /// No Flag Applied
  pub const NONE: SpecFlagsOpt = SpecFlagsOpt(0);
  /// Cells Limit by Keys
  pub const LIMIT_BY_KEYS: SpecFlagsOpt = SpecFlagsOpt(1);
  /// Cells Offset by Keys
  pub const OFFSET_BY_KEYS: SpecFlagsOpt = SpecFlagsOpt(4);
  /// Select Cells Only Keys without Value data
  pub const ONLY_KEYS: SpecFlagsOpt = SpecFlagsOpt(8);
  /// Select Cells Only with DELETE(cell-flag)
  pub const ONLY_DELETES: SpecFlagsOpt = SpecFlagsOpt(10);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::LIMIT_BY_KEYS,
    Self::OFFSET_BY_KEYS,
    Self::ONLY_KEYS,
    Self::ONLY_DELETES,
  ];
}

impl TSerializable for SpecFlagsOpt {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecFlagsOpt> {
    let enum_value = i_prot.read_i32()?;
    Ok(SpecFlagsOpt::from(enum_value))
  }
}

impl From<i32> for SpecFlagsOpt {
  fn from(i: i32) -> Self {
    match i {
      0 => SpecFlagsOpt::NONE,
      1 => SpecFlagsOpt::LIMIT_BY_KEYS,
      4 => SpecFlagsOpt::OFFSET_BY_KEYS,
      8 => SpecFlagsOpt::ONLY_KEYS,
      10 => SpecFlagsOpt::ONLY_DELETES,
      _ => SpecFlagsOpt(i)
    }
  }
}

impl From<&i32> for SpecFlagsOpt {
  fn from(i: &i32) -> Self {
    SpecFlagsOpt::from(*i)
  }
}

impl From<SpecFlagsOpt> for i32 {
  fn from(e: SpecFlagsOpt) -> i32 {
    e.0
  }
}

impl From<&SpecFlagsOpt> for i32 {
  fn from(e: &SpecFlagsOpt) -> i32 {
    e.0
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UpdateOP(pub i32);

impl UpdateOP {
  /// The OP supported by column-types: PLAIN, SERIAL, COUNTER. Replaces with the update value (_default as well if other OP not supported by the col-type_)
  pub const REPLACE: UpdateOP = UpdateOP(0);
  /// The OP supported by column-types: PLAIN, SERIAL. Appends the update value to the cell's current
  pub const APPEND: UpdateOP = UpdateOP(1);
  /// The OP supported by column-types: PLAIN, SERIAL. Prepends the update value to the cell's current
  pub const PREPEND: UpdateOP = UpdateOP(2);
  /// The OP supported by column-type PLAIN. Inserts the update value at position in current value (appends if pos above value)
  pub const INSERT: UpdateOP = UpdateOP(3);
  /// The OP supported by column-type PLAIN. Overwrites the current value at position with new value (appends if pos above value)
  pub const OVERWRITE: UpdateOP = UpdateOP(4);
  /// The OP supported by column-type SERIAL. update is done by the inner serial-fields defintions
  pub const SERIAL: UpdateOP = UpdateOP(5);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REPLACE,
    Self::APPEND,
    Self::PREPEND,
    Self::INSERT,
    Self::OVERWRITE,
    Self::SERIAL,
  ];
}

impl TSerializable for UpdateOP {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UpdateOP> {
    let enum_value = i_prot.read_i32()?;
    Ok(UpdateOP::from(enum_value))
  }
}

impl From<i32> for UpdateOP {
  fn from(i: i32) -> Self {
    match i {
      0 => UpdateOP::REPLACE,
      1 => UpdateOP::APPEND,
      2 => UpdateOP::PREPEND,
      3 => UpdateOP::INSERT,
      4 => UpdateOP::OVERWRITE,
      5 => UpdateOP::SERIAL,
      _ => UpdateOP(i)
    }
  }
}

impl From<&i32> for UpdateOP {
  fn from(i: &i32) -> Self {
    UpdateOP::from(*i)
  }
}

impl From<UpdateOP> for i32 {
  fn from(e: UpdateOP) -> i32 {
    e.0
  }
}

impl From<&UpdateOP> for i32 {
  fn from(e: &UpdateOP) -> i32 {
    e.0
  }
}

/// The Scan Interval Specs Options for the SpecIntervalPlain, SpecIntervalCounter and SpecIntervalSerial 'options' bit
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecIntervalOptions(pub i32);

impl SpecIntervalOptions {
  /// Update Bit Option
  pub const UPDATING: SpecIntervalOptions = SpecIntervalOptions(4);
  /// Delete Bit Option
  pub const DELETING: SpecIntervalOptions = SpecIntervalOptions(8);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::UPDATING,
    Self::DELETING,
  ];
}

impl TSerializable for SpecIntervalOptions {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecIntervalOptions> {
    let enum_value = i_prot.read_i32()?;
    Ok(SpecIntervalOptions::from(enum_value))
  }
}

impl From<i32> for SpecIntervalOptions {
  fn from(i: i32) -> Self {
    match i {
      4 => SpecIntervalOptions::UPDATING,
      8 => SpecIntervalOptions::DELETING,
      _ => SpecIntervalOptions(i)
    }
  }
}

impl From<&i32> for SpecIntervalOptions {
  fn from(i: &i32) -> Self {
    SpecIntervalOptions::from(*i)
  }
}

impl From<SpecIntervalOptions> for i32 {
  fn from(e: SpecIntervalOptions) -> i32 {
    e.0
  }
}

impl From<&SpecIntervalOptions> for i32 {
  fn from(e: &SpecIntervalOptions) -> i32 {
    e.0
  }
}

/// The Cell Flag
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Flag(pub i32);

impl Flag {
  /// Unknown/Undefined
  pub const NONE: Flag = Flag(0);
  /// The Cell is an insert
  pub const INSERT: Flag = Flag(1);
  /// The Cell is a delete versions lower-equal
  pub const DELETE_LE: Flag = Flag(2);
  /// The Cell is a  delete version equal
  pub const DELETE_EQ: Flag = Flag(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::INSERT,
    Self::DELETE_LE,
    Self::DELETE_EQ,
  ];
}

impl TSerializable for Flag {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Flag> {
    let enum_value = i_prot.read_i32()?;
    Ok(Flag::from(enum_value))
  }
}

impl From<i32> for Flag {
  fn from(i: i32) -> Self {
    match i {
      0 => Flag::NONE,
      1 => Flag::INSERT,
      2 => Flag::DELETE_LE,
      3 => Flag::DELETE_EQ,
      _ => Flag(i)
    }
  }
}

impl From<&i32> for Flag {
  fn from(i: &i32) -> Self {
    Flag::from(*i)
  }
}

impl From<Flag> for i32 {
  fn from(e: Flag) -> i32 {
    e.0
  }
}

impl From<&Flag> for i32 {
  fn from(e: &Flag) -> i32 {
    e.0
  }
}

/// MATH Operations for Serial Field Update of types INT64 and DOUBLE
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FUMATHOP(pub i32);

impl FUMATHOP {
  /// set field value to the new value
  pub const EQUAL: FUMATHOP = FUMATHOP(0);
  /// plus new value to field's value (negative number allowed)
  pub const PLUS: FUMATHOP = FUMATHOP(1);
  /// multiply current value by update value
  pub const MULTIPLY: FUMATHOP = FUMATHOP(2);
  /// divide current value by the new value (ignored at zero)
  pub const DIVIDE: FUMATHOP = FUMATHOP(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::EQUAL,
    Self::PLUS,
    Self::MULTIPLY,
    Self::DIVIDE,
  ];
}

impl TSerializable for FUMATHOP {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FUMATHOP> {
    let enum_value = i_prot.read_i32()?;
    Ok(FUMATHOP::from(enum_value))
  }
}

impl From<i32> for FUMATHOP {
  fn from(i: i32) -> Self {
    match i {
      0 => FUMATHOP::EQUAL,
      1 => FUMATHOP::PLUS,
      2 => FUMATHOP::MULTIPLY,
      3 => FUMATHOP::DIVIDE,
      _ => FUMATHOP(i)
    }
  }
}

impl From<&i32> for FUMATHOP {
  fn from(i: &i32) -> Self {
    FUMATHOP::from(*i)
  }
}

impl From<FUMATHOP> for i32 {
  fn from(e: FUMATHOP) -> i32 {
    e.0
  }
}

impl From<&FUMATHOP> for i32 {
  fn from(e: &FUMATHOP) -> i32 {
    e.0
  }
}

/// LIST Operations for Serial Field Update of array/list/bytes with LIST-op in the inner SERIAL fields
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FULISTOP(pub i32);

impl FULISTOP {
  /// Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Replaces with the update value
  pub const REPLACE: FULISTOP = FULISTOP(0);
  /// Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Appends the update value to a field value
  pub const APPEND: FULISTOP = FULISTOP(1);
  /// Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Prepends the update value to a field value
  pub const PREPEND: FULISTOP = FULISTOP(2);
  /// Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Insert the update value at position in a field value (appends if pos above value)
  pub const INSERT: FULISTOP = FULISTOP(3);
  /// Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Overwrites a field value at position with new value (appends if pos above value)
  pub const OVERWRITE: FULISTOP = FULISTOP(4);
  /// Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Erases the position in a field value
  pub const ERASE: FULISTOP = FULISTOP(5);
  /// Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP
  pub const BY_UNIQUE: FULISTOP = FULISTOP(6);
  /// Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP and Comparator
  pub const BY_COND: FULISTOP = FULISTOP(7);
  /// Supported by field-types: LIST_BYTES, LIST_INT64. The field value is with Postion and OP in items
  pub const BY_INDEX: FULISTOP = FULISTOP(8);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::REPLACE,
    Self::APPEND,
    Self::PREPEND,
    Self::INSERT,
    Self::OVERWRITE,
    Self::ERASE,
    Self::BY_UNIQUE,
    Self::BY_COND,
    Self::BY_INDEX,
  ];
}

impl TSerializable for FULISTOP {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FULISTOP> {
    let enum_value = i_prot.read_i32()?;
    Ok(FULISTOP::from(enum_value))
  }
}

impl From<i32> for FULISTOP {
  fn from(i: i32) -> Self {
    match i {
      0 => FULISTOP::REPLACE,
      1 => FULISTOP::APPEND,
      2 => FULISTOP::PREPEND,
      3 => FULISTOP::INSERT,
      4 => FULISTOP::OVERWRITE,
      5 => FULISTOP::ERASE,
      6 => FULISTOP::BY_UNIQUE,
      7 => FULISTOP::BY_COND,
      8 => FULISTOP::BY_INDEX,
      _ => FULISTOP(i)
    }
  }
}

impl From<&i32> for FULISTOP {
  fn from(i: &i32) -> Self {
    FULISTOP::from(*i)
  }
}

impl From<FULISTOP> for i32 {
  fn from(e: FULISTOP) -> i32 {
    e.0
  }
}

impl From<&FULISTOP> for i32 {
  fn from(e: &FULISTOP) -> i32 {
    e.0
  }
}

/// The Cells Results types for using with CellsGroup requests
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellsResult(pub i32);

impl CellsResult {
  /// Correspond to result on Cells (Cells in list)
  pub const IN_LIST: CellsResult = CellsResult(0);
  /// Correspond to result on CCells (Columns Cells)
  pub const ON_COLUMN: CellsResult = CellsResult(1);
  /// Correspond to result on KCells (Keys Cells)
  pub const ON_KEY: CellsResult = CellsResult(2);
  /// Correspond to result on FCells (Fraction Cells)
  pub const ON_FRACTION: CellsResult = CellsResult(3);
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::IN_LIST,
    Self::ON_COLUMN,
    Self::ON_KEY,
    Self::ON_FRACTION,
  ];
}

impl TSerializable for CellsResult {
  #[allow(clippy::trivially_copy_pass_by_ref)]
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(self.0)
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellsResult> {
    let enum_value = i_prot.read_i32()?;
    Ok(CellsResult::from(enum_value))
  }
}

impl From<i32> for CellsResult {
  fn from(i: i32) -> Self {
    match i {
      0 => CellsResult::IN_LIST,
      1 => CellsResult::ON_COLUMN,
      2 => CellsResult::ON_KEY,
      3 => CellsResult::ON_FRACTION,
      _ => CellsResult(i)
    }
  }
}

impl From<&i32> for CellsResult {
  fn from(i: &i32) -> Self {
    CellsResult::from(*i)
  }
}

impl From<CellsResult> for i32 {
  fn from(e: CellsResult) -> i32 {
    e.0
  }
}

impl From<&CellsResult> for i32 {
  fn from(e: &CellsResult) -> i32 {
    e.0
  }
}

pub type Schemas = Vec<Schema>;

pub type Key = Vec<Vec<u8>>;

pub type SpecValueSerialFields = Vec<SpecValueSerialField>;

pub type SpecValuesPlain = Vec<SpecValuePlain>;

pub type SpecValuesCounter = Vec<SpecValueCounter>;

pub type SpecValuesSerial = Vec<SpecValueSerial>;

pub type SpecKey = Vec<SpecFraction>;

pub type SpecKeyIntervals = Vec<SpecKeyInterval>;

pub type UCellsPlain = Vec<UCellPlain>;

pub type UCCellsPlain = BTreeMap<i64, UCellsPlain>;

pub type UCellsCounter = Vec<UCellCounter>;

pub type UCCellsCounter = BTreeMap<i64, UCellsCounter>;

pub type CellValuesSerial = Vec<CellValueSerial>;

pub type CellValuesSerialOp = Vec<CellValueSerialOp>;

pub type UCellsSerial = Vec<UCellSerial>;

pub type UCCellsSerial = BTreeMap<i64, UCellsSerial>;

pub type CellsPlain = Vec<CellPlain>;

pub type CellsCounter = Vec<CellCounter>;

pub type CellsSerial = Vec<CellSerial>;

pub type CCells = BTreeMap<String, CCells>;

pub type KCells = Vec<KCells>;

pub type CompactResults = Vec<CompactResult>;

//
// Exception
//

/// The SWC::Thrift::Exception a base for any Exceptions
/// both for the Thrift-Protocol and SWC-DB Errors.
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Exception {
  /// The corresponding Thrift-Procotol or SWC-DB Error Code
  pub code: Option<i32>,
  /// The message describing the error code
  pub message: Option<String>,
}

impl Exception {
  pub fn new<F1, F2>(code: F1, message: F2) -> Exception where F1: Into<Option<i32>>, F2: Into<Option<String>> {
    Exception {
      code: code.into(),
      message: message.into(),
    }
  }
}

impl TSerializable for Exception {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Exception> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Exception {
      code: f_1,
      message: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Exception");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.code {
      o_prot.write_field_begin(&TFieldIdentifier::new("code", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.message {
      o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Exception {
  fn default() -> Self {
    Exception{
      code: Some(0),
      message: Some("".to_owned()),
    }
  }
}

impl Error for Exception {}

impl From<Exception> for thrift::Error {
  fn from(e: Exception) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for Exception {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    write!(f, "remote service threw Exception")
  }
}

//
// Schema
//

/// The Schema Definition
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Schema {
  /// Column ID
  pub cid: Option<i64>,
  /// Column Name
  pub col_name: Option<String>,
  /// Column Tags
  pub col_tags: Option<Vec<String>>,
  /// Column Key Sequence
  pub col_seq: Option<KeySeq>,
  /// Column Type
  pub col_type: Option<ColumnType>,
  /// Cell Versions
  pub cell_versions: Option<i32>,
  /// Cell Time to Live
  pub cell_ttl: Option<i32>,
  /// Block Encoding
  pub blk_encoding: Option<EncodingType>,
  /// Block Size in Bytes
  pub blk_size: Option<i32>,
  /// Number of Cells in Block
  pub blk_cells: Option<i32>,
  /// CellStore file Replication
  pub cs_replication: Option<i8>,
  /// CellStore Size in Bytes
  pub cs_size: Option<i32>,
  /// Max CellStores in a Range
  pub cs_max: Option<i8>,
  /// Write Fragment File on ratio reached
  pub log_rollout_ratio: Option<i8>,
  /// Min. Cointervaling Fragments for Compaction
  pub log_compact_cointervaling: Option<i8>,
  /// Number of Fragment to Preload
  pub log_fragment_preload: Option<i8>,
  /// Compact at percent reach
  pub compact_percent: Option<i8>,
  /// Schema's revision/id
  pub revision: Option<i64>,
}

impl Schema {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18>(cid: F1, col_name: F2, col_tags: F3, col_seq: F4, col_type: F5, cell_versions: F6, cell_ttl: F7, blk_encoding: F8, blk_size: F9, blk_cells: F10, cs_replication: F11, cs_size: F12, cs_max: F13, log_rollout_ratio: F14, log_compact_cointervaling: F15, log_fragment_preload: F16, compact_percent: F17, revision: F18) -> Schema where F1: Into<Option<i64>>, F2: Into<Option<String>>, F3: Into<Option<Vec<String>>>, F4: Into<Option<KeySeq>>, F5: Into<Option<ColumnType>>, F6: Into<Option<i32>>, F7: Into<Option<i32>>, F8: Into<Option<EncodingType>>, F9: Into<Option<i32>>, F10: Into<Option<i32>>, F11: Into<Option<i8>>, F12: Into<Option<i32>>, F13: Into<Option<i8>>, F14: Into<Option<i8>>, F15: Into<Option<i8>>, F16: Into<Option<i8>>, F17: Into<Option<i8>>, F18: Into<Option<i64>> {
    Schema {
      cid: cid.into(),
      col_name: col_name.into(),
      col_tags: col_tags.into(),
      col_seq: col_seq.into(),
      col_type: col_type.into(),
      cell_versions: cell_versions.into(),
      cell_ttl: cell_ttl.into(),
      blk_encoding: blk_encoding.into(),
      blk_size: blk_size.into(),
      blk_cells: blk_cells.into(),
      cs_replication: cs_replication.into(),
      cs_size: cs_size.into(),
      cs_max: cs_max.into(),
      log_rollout_ratio: log_rollout_ratio.into(),
      log_compact_cointervaling: log_compact_cointervaling.into(),
      log_fragment_preload: log_fragment_preload.into(),
      compact_percent: compact_percent.into(),
      revision: revision.into(),
    }
  }
}

impl TSerializable for Schema {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Schema> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = Some(Vec::new());
    let mut f_4: Option<KeySeq> = None;
    let mut f_5: Option<ColumnType> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<EncodingType> = None;
    let mut f_9: Option<i32> = None;
    let mut f_10: Option<i32> = None;
    let mut f_11: Option<i8> = None;
    let mut f_12: Option<i32> = None;
    let mut f_13: Option<i8> = None;
    let mut f_14: Option<i8> = None;
    let mut f_15: Option<i8> = None;
    let mut f_16: Option<i8> = None;
    let mut f_17: Option<i8> = None;
    let mut f_18: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_string()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = KeySeq::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = ColumnType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_i32()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_i8()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_i32()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_i8()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_i8()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_i8()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_i8()?;
          f_16 = Some(val);
        },
        17 => {
          let val = i_prot.read_i8()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_i64()?;
          f_18 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Schema {
      cid: f_1,
      col_name: f_2,
      col_tags: f_3,
      col_seq: f_4,
      col_type: f_5,
      cell_versions: f_6,
      cell_ttl: f_7,
      blk_encoding: f_8,
      blk_size: f_9,
      blk_cells: f_10,
      cs_replication: f_11,
      cs_size: f_12,
      cs_max: f_13,
      log_rollout_ratio: f_14,
      log_compact_cointervaling: f_15,
      log_fragment_preload: f_16,
      compact_percent: f_17,
      revision: f_18,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Schema");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_tags", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_seq", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.col_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("col_type", TType::I32, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cell_versions {
      o_prot.write_field_begin(&TFieldIdentifier::new("cell_versions", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cell_ttl {
      o_prot.write_field_begin(&TFieldIdentifier::new("cell_ttl", TType::I32, 7))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.blk_encoding {
      o_prot.write_field_begin(&TFieldIdentifier::new("blk_encoding", TType::I32, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.blk_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("blk_size", TType::I32, 9))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.blk_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("blk_cells", TType::I32, 10))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cs_replication {
      o_prot.write_field_begin(&TFieldIdentifier::new("cs_replication", TType::I08, 11))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cs_size {
      o_prot.write_field_begin(&TFieldIdentifier::new("cs_size", TType::I32, 12))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.cs_max {
      o_prot.write_field_begin(&TFieldIdentifier::new("cs_max", TType::I08, 13))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.log_rollout_ratio {
      o_prot.write_field_begin(&TFieldIdentifier::new("log_rollout_ratio", TType::I08, 14))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.log_compact_cointervaling {
      o_prot.write_field_begin(&TFieldIdentifier::new("log_compact_cointervaling", TType::I08, 15))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.log_fragment_preload {
      o_prot.write_field_begin(&TFieldIdentifier::new("log_fragment_preload", TType::I08, 16))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.compact_percent {
      o_prot.write_field_begin(&TFieldIdentifier::new("compact_percent", TType::I08, 17))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.revision {
      o_prot.write_field_begin(&TFieldIdentifier::new("revision", TType::I64, 18))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Schema {
  fn default() -> Self {
    Schema{
      cid: Some(0),
      col_name: Some("".to_owned()),
      col_tags: Some(Vec::new()),
      col_seq: None,
      col_type: None,
      cell_versions: Some(0),
      cell_ttl: Some(0),
      blk_encoding: None,
      blk_size: Some(0),
      blk_cells: Some(0),
      cs_replication: Some(0),
      cs_size: Some(0),
      cs_max: Some(0),
      log_rollout_ratio: Some(0),
      log_compact_cointervaling: Some(0),
      log_fragment_preload: Some(0),
      compact_percent: Some(0),
      revision: Some(0),
    }
  }
}

//
// SchemaPattern
//

/// The Schema matching Pattern
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaPattern {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The patern value to match against
  pub value: Option<String>,
}

impl SchemaPattern {
  pub fn new<F1, F2>(comp: F1, value: F2) -> SchemaPattern where F1: Into<Option<Comp>>, F2: Into<Option<String>> {
    SchemaPattern {
      comp: comp.into(),
      value: value.into(),
    }
  }
}

impl TSerializable for SchemaPattern {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaPattern> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SchemaPattern {
      comp: f_1,
      value: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SchemaPattern");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SchemaPattern {
  fn default() -> Self {
    SchemaPattern{
      comp: None,
      value: Some("".to_owned()),
    }
  }
}

//
// SchemaTagsPatterns
//

/// The Schema Tags patterns for the SchemaPatterns
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaTagsPatterns {
  /// Logical comparator to Apply, unsupported PF, RE and Vol. kind
  pub comp: Option<Comp>,
  /// The tags patterns to match against schema's column tags
  pub values: Option<Vec<SchemaPattern>>,
}

impl SchemaTagsPatterns {
  pub fn new<F1, F2>(comp: F1, values: F2) -> SchemaTagsPatterns where F1: Into<Option<Comp>>, F2: Into<Option<Vec<SchemaPattern>>> {
    SchemaTagsPatterns {
      comp: comp.into(),
      values: values.into(),
    }
  }
}

impl TSerializable for SchemaTagsPatterns {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaTagsPatterns> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<SchemaPattern>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SchemaPattern> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = SchemaPattern::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SchemaTagsPatterns {
      comp: f_1,
      values: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SchemaTagsPatterns");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SchemaTagsPatterns {
  fn default() -> Self {
    SchemaTagsPatterns{
      comp: None,
      values: Some(Vec::new()),
    }
  }
}

//
// SchemaPatterns
//

/// The Schema Patterns for the SpecSchemas
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SchemaPatterns {
  /// The Schema patterns for selecting by Column Name
  pub names: Option<Vec<SchemaPattern>>,
  /// The Schema patterns for selecting by Column Tags
  pub tags: Option<SchemaTagsPatterns>,
}

impl SchemaPatterns {
  pub fn new<F1, F2>(names: F1, tags: F2) -> SchemaPatterns where F1: Into<Option<Vec<SchemaPattern>>>, F2: Into<Option<SchemaTagsPatterns>> {
    SchemaPatterns {
      names: names.into(),
      tags: tags.into(),
    }
  }
}

impl TSerializable for SchemaPatterns {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SchemaPatterns> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SchemaPattern>> = Some(Vec::new());
    let mut f_2: Option<SchemaTagsPatterns> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SchemaPattern> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = SchemaPattern::read_from_in_protocol(i_prot)?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = SchemaTagsPatterns::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SchemaPatterns {
      names: f_1,
      tags: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SchemaPatterns");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.names {
      o_prot.write_field_begin(&TFieldIdentifier::new("names", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SchemaPatterns {
  fn default() -> Self {
    SchemaPatterns{
      names: Some(Vec::new()),
      tags: None,
    }
  }
}

//
// SpecSchemas
//

/// The Specs for Schemas for using with list_columns or compact_columns
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecSchemas {
  /// The Column IDs
  pub cids: Option<Vec<i64>>,
  /// The Column Names
  pub names: Option<Vec<String>>,
  /// The Schema's selector patterns
  pub patterns: Option<SchemaPatterns>,
}

impl SpecSchemas {
  pub fn new<F1, F2, F3>(cids: F1, names: F2, patterns: F3) -> SpecSchemas where F1: Into<Option<Vec<i64>>>, F2: Into<Option<Vec<String>>>, F3: Into<Option<SchemaPatterns>> {
    SpecSchemas {
      cids: cids.into(),
      names: names.into(),
      patterns: patterns.into(),
    }
  }
}

impl TSerializable for SpecSchemas {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecSchemas> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i64>> = Some(Vec::new());
    let mut f_2: Option<Vec<String>> = Some(Vec::new());
    let mut f_3: Option<SchemaPatterns> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_i64()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_string()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = SchemaPatterns::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecSchemas {
      cids: f_1,
      names: f_2,
      patterns: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecSchemas");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cids {
      o_prot.write_field_begin(&TFieldIdentifier::new("cids", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.names {
      o_prot.write_field_begin(&TFieldIdentifier::new("names", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.patterns {
      o_prot.write_field_begin(&TFieldIdentifier::new("patterns", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecSchemas {
  fn default() -> Self {
    SpecSchemas{
      cids: Some(Vec::new()),
      names: Some(Vec::new()),
      patterns: None,
    }
  }
}

//
// SpecFlags
//

/// The Scan Specifications Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecFlags {
  /// Limit to this number of cells
  pub limit: Option<i64>,
  /// Scan from this number of cells Offset on matching Cell-Interval
  pub offset: Option<i64>,
  /// Select only this number of Versions of a given Cell-Key
  pub max_versions: Option<i32>,
  /// return results with reach of this Buffer size in bytes
  pub max_buffer: Option<i32>,
  /// The options bit by SpecFlagsOpt
  pub options: Option<i8>,
}

impl SpecFlags {
  pub fn new<F1, F2, F3, F4, F5>(limit: F1, offset: F2, max_versions: F3, max_buffer: F4, options: F5) -> SpecFlags where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i8>> {
    SpecFlags {
      limit: limit.into(),
      offset: offset.into(),
      max_versions: max_versions.into(),
      max_buffer: max_buffer.into(),
      options: options.into(),
    }
  }
}

impl TSerializable for SpecFlags {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecFlags> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i8> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i8()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecFlags {
      limit: f_1,
      offset: f_2,
      max_versions: f_3,
      max_buffer: f_4,
      options: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecFlags");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.limit {
      o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_versions {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_versions", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.max_buffer {
      o_prot.write_field_begin(&TFieldIdentifier::new("max_buffer", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.options {
      o_prot.write_field_begin(&TFieldIdentifier::new("options", TType::I08, 5))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecFlags {
  fn default() -> Self {
    SpecFlags{
      limit: Some(0),
      offset: Some(0),
      max_versions: Some(0),
      max_buffer: Some(0),
      options: Some(0),
    }
  }
}

//
// SpecUpdateOP
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecUpdateOP {
  /// The Operation of update
  pub op: Option<UpdateOP>,
  /// The position/index of INSERT and OVERWRITE update operations
  pub pos: Option<i32>,
}

impl SpecUpdateOP {
  pub fn new<F1, F2>(op: F1, pos: F2) -> SpecUpdateOP where F1: Into<Option<UpdateOP>>, F2: Into<Option<i32>> {
    SpecUpdateOP {
      op: op.into(),
      pos: pos.into(),
    }
  }
}

impl TSerializable for SpecUpdateOP {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecUpdateOP> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UpdateOP> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = UpdateOP::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecUpdateOP {
      op: f_1,
      pos: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecUpdateOP");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pos {
      o_prot.write_field_begin(&TFieldIdentifier::new("pos", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecUpdateOP {
  fn default() -> Self {
    SpecUpdateOP{
      op: None,
      pos: Some(0),
    }
  }
}

//
// SpecIntervalUpdatePlain
//

/// The Value specs for an Updating Interval of 'updating' in SpecIntervalPlain
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecIntervalUpdatePlain {
  /// The bytes value for the updated cell
  pub v: Option<Vec<u8>>,
  /// The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
  pub ts: Option<i64>,
  /// Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
  pub encoder: Option<EncodingType>,
  /// Optionally the operaton of value update
  pub update_op: Option<SpecUpdateOP>,
}

impl SpecIntervalUpdatePlain {
  pub fn new<F1, F2, F3, F4>(v: F1, ts: F2, encoder: F3, update_op: F4) -> SpecIntervalUpdatePlain where F1: Into<Option<Vec<u8>>>, F2: Into<Option<i64>>, F3: Into<Option<EncodingType>>, F4: Into<Option<SpecUpdateOP>> {
    SpecIntervalUpdatePlain {
      v: v.into(),
      ts: ts.into(),
      encoder: encoder.into(),
      update_op: update_op.into(),
    }
  }
}

impl TSerializable for SpecIntervalUpdatePlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecIntervalUpdatePlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<u8>> = Some(Vec::new());
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<EncodingType> = None;
    let mut f_4: Option<SpecUpdateOP> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bytes()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = SpecUpdateOP::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecIntervalUpdatePlain {
      v: f_1,
      ts: f_2,
      encoder: f_3,
      update_op: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecIntervalUpdatePlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 1))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.encoder {
      o_prot.write_field_begin(&TFieldIdentifier::new("encoder", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.update_op {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_op", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecIntervalUpdatePlain {
  fn default() -> Self {
    SpecIntervalUpdatePlain{
      v: Some(Vec::new()),
      ts: Some(0),
      encoder: None,
      update_op: None,
    }
  }
}

//
// SpecIntervalUpdateCounter
//

/// The Value specs for an Updating Interval of 'updating' in SpecIntervalCounter
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecIntervalUpdateCounter {
  /// The int64 value for the updated cell
  pub v: Option<i64>,
  /// The Opration pf Counter, available: COUNTER_OP_EQUAL
  pub op: Option<i64>,
  /// The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
  pub ts: Option<i64>,
  /// Optionally the operaton of value update
  pub update_op: Option<SpecUpdateOP>,
}

impl SpecIntervalUpdateCounter {
  pub fn new<F1, F2, F3, F4>(v: F1, op: F2, ts: F3, update_op: F4) -> SpecIntervalUpdateCounter where F1: Into<Option<i64>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<SpecUpdateOP>> {
    SpecIntervalUpdateCounter {
      v: v.into(),
      op: op.into(),
      ts: ts.into(),
      update_op: update_op.into(),
    }
  }
}

impl TSerializable for SpecIntervalUpdateCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecIntervalUpdateCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<SpecUpdateOP> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = SpecUpdateOP::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecIntervalUpdateCounter {
      v: f_1,
      op: f_2,
      ts: f_3,
      update_op: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecIntervalUpdateCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.update_op {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_op", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecIntervalUpdateCounter {
  fn default() -> Self {
    SpecIntervalUpdateCounter{
      v: Some(0),
      op: Some(0),
      ts: Some(0),
      update_op: None,
    }
  }
}

//
// SpecIntervalUpdateSerial
//

/// The Value specs for an Updating Interval of 'updating' in SpecIntervalSerial
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecIntervalUpdateSerial {
  /// The timestamp for the updated cell NULL: MIN_INT64-1, AUTO:MIN_INT64-1
  pub ts: Option<i64>,
  /// The values of serial-fields for the updated cell
  pub v: Option<Box<CellValuesSerial>>,
  /// The values of serial-fields for the the SERIAL operation update
  pub v_op: Option<Box<CellValuesSerialOp>>,
  /// Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
  pub encoder: Option<EncodingType>,
  /// Optionally the operaton of value update
  pub update_op: Option<SpecUpdateOP>,
}

impl SpecIntervalUpdateSerial {
  pub fn new<F1, F2, F3, F4, F5>(ts: F1, v: F2, v_op: F3, encoder: F4, update_op: F5) -> SpecIntervalUpdateSerial where F1: Into<Option<i64>>, F2: Into<Option<Box<CellValuesSerial>>>, F3: Into<Option<Box<CellValuesSerialOp>>>, F4: Into<Option<EncodingType>>, F5: Into<Option<SpecUpdateOP>> {
    SpecIntervalUpdateSerial {
      ts: ts.into(),
      v: v.into(),
      v_op: v_op.into(),
      encoder: encoder.into(),
      update_op: update_op.into(),
    }
  }
}

impl TSerializable for SpecIntervalUpdateSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecIntervalUpdateSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<Box<CellValuesSerial>> = Some(Vec::new());
    let mut f_3: Option<Box<CellValuesSerialOp>> = Some(Vec::new());
    let mut f_4: Option<EncodingType> = None;
    let mut f_5: Option<SpecUpdateOP> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerialOp> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = CellValueSerialOp::read_from_in_protocol(i_prot)?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = SpecUpdateOP::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecIntervalUpdateSerial {
      ts: f_1,
      v: f_2,
      v_op: f_3,
      encoder: f_4,
      update_op: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecIntervalUpdateSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_op {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_op", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.encoder {
      o_prot.write_field_begin(&TFieldIdentifier::new("encoder", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.update_op {
      o_prot.write_field_begin(&TFieldIdentifier::new("update_op", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecIntervalUpdateSerial {
  fn default() -> Self {
    SpecIntervalUpdateSerial{
      ts: Some(0),
      v: Some(Vec::new()),
      v_op: Some(Vec::new()),
      encoder: None,
      update_op: None,
    }
  }
}

//
// SpecValueSerialINT64
//

/// The Specifications of INT64 Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialINT64 {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The int64 to match against the value field
  pub v: Option<i64>,
}

impl SpecValueSerialINT64 {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialINT64 where F1: Into<Option<Comp>>, F2: Into<Option<i64>> {
    SpecValueSerialINT64 {
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SpecValueSerialINT64 {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialINT64> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialINT64 {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_INT64");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialINT64 {
  fn default() -> Self {
    SpecValueSerialINT64{
      comp: None,
      v: Some(0),
    }
  }
}

//
// SpecValueSerialDOUBLE
//

/// The Specifications of DOUBLE Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialDOUBLE {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The double to match against the value field
  pub v: Option<OrderedFloat<f64>>,
}

impl SpecValueSerialDOUBLE {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialDOUBLE where F1: Into<Option<Comp>>, F2: Into<Option<OrderedFloat<f64>>> {
    SpecValueSerialDOUBLE {
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SpecValueSerialDOUBLE {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialDOUBLE> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialDOUBLE {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_DOUBLE");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialDOUBLE {
  fn default() -> Self {
    SpecValueSerialDOUBLE{
      comp: None,
      v: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// SpecValueSerialBYTES
//

/// The Specifications of BYTES Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialBYTES {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The binary(bytes) to match against the value field
  pub v: Option<Vec<u8>>,
}

impl SpecValueSerialBYTES {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialBYTES where F1: Into<Option<Comp>>, F2: Into<Option<Vec<u8>>> {
    SpecValueSerialBYTES {
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SpecValueSerialBYTES {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialBYTES> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialBYTES {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_BYTES");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialBYTES {
  fn default() -> Self {
    SpecValueSerialBYTES{
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialKEY
//

/// The Specifications of KEY Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialKEY {
  /// The Key Sequence to use
  pub seq: Option<KeySeq>,
  /// The Specification of the Key to match against the value field
  pub v: Option<Box<SpecKey>>,
}

impl SpecValueSerialKEY {
  pub fn new<F1, F2>(seq: F1, v: F2) -> SpecValueSerialKEY where F1: Into<Option<KeySeq>>, F2: Into<Option<Box<SpecKey>>> {
    SpecValueSerialKEY {
      seq: seq.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SpecValueSerialKEY {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialKEY> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<KeySeq> = None;
    let mut f_2: Option<Box<SpecKey>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = KeySeq::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecFraction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = SpecFraction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialKEY {
      seq: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_KEY");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.seq {
      o_prot.write_field_begin(&TFieldIdentifier::new("seq", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialKEY {
  fn default() -> Self {
    SpecValueSerialKEY{
      seq: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialLI
//

/// The Specifications of LIST_INT64(LI) Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialLI {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The List of Int64 to match against the value field
  pub v: Option<Vec<SpecValueSerialINT64>>,
}

impl SpecValueSerialLI {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialLI where F1: Into<Option<Comp>>, F2: Into<Option<Vec<SpecValueSerialINT64>>> {
    SpecValueSerialLI {
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SpecValueSerialLI {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialLI> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<SpecValueSerialINT64>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueSerialINT64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = SpecValueSerialINT64::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialLI {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_LI");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialLI {
  fn default() -> Self {
    SpecValueSerialLI{
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialLB
//

/// The Specifications of LIST_BYTES(LB) Serial Value Field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialLB {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The List of Bytes to match against the value field
  pub v: Option<Vec<SpecValueSerialBYTES>>,
}

impl SpecValueSerialLB {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueSerialLB where F1: Into<Option<Comp>>, F2: Into<Option<Vec<SpecValueSerialBYTES>>> {
    SpecValueSerialLB {
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SpecValueSerialLB {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialLB> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<SpecValueSerialBYTES>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueSerialBYTES> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = SpecValueSerialBYTES::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialLB {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial_LB");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialLB {
  fn default() -> Self {
    SpecValueSerialLB{
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueSerialField
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerialField {
  /// The Field Id of the Value Field
  pub field_id: Option<i32>,
  /// The specifications of Int64 for the field
  pub spec_int64: Option<SpecValueSerialINT64>,
  /// The specifications of Double for the field
  pub spec_double: Option<SpecValueSerialDOUBLE>,
  /// The specifications of Bytes for the field
  pub spec_bytes: Option<SpecValueSerialBYTES>,
  /// The specifications of Cell-Key for the field
  pub spec_key: Option<SpecValueSerialKEY>,
  /// The specifications of List Int64 for the field
  pub spec_li: Option<SpecValueSerialLI>,
  /// The specifications of List Bytes for the field
  pub spec_lb: Option<SpecValueSerialLB>,
}

impl SpecValueSerialField {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(field_id: F1, spec_int64: F2, spec_double: F3, spec_bytes: F4, spec_key: F5, spec_li: F6, spec_lb: F7) -> SpecValueSerialField where F1: Into<Option<i32>>, F2: Into<Option<SpecValueSerialINT64>>, F3: Into<Option<SpecValueSerialDOUBLE>>, F4: Into<Option<SpecValueSerialBYTES>>, F5: Into<Option<SpecValueSerialKEY>>, F6: Into<Option<SpecValueSerialLI>>, F7: Into<Option<SpecValueSerialLB>> {
    SpecValueSerialField {
      field_id: field_id.into(),
      spec_int64: spec_int64.into(),
      spec_double: spec_double.into(),
      spec_bytes: spec_bytes.into(),
      spec_key: spec_key.into(),
      spec_li: spec_li.into(),
      spec_lb: spec_lb.into(),
    }
  }
}

impl TSerializable for SpecValueSerialField {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerialField> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<SpecValueSerialINT64> = None;
    let mut f_3: Option<SpecValueSerialDOUBLE> = None;
    let mut f_4: Option<SpecValueSerialBYTES> = None;
    let mut f_5: Option<SpecValueSerialKEY> = None;
    let mut f_6: Option<SpecValueSerialLI> = None;
    let mut f_7: Option<SpecValueSerialLB> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = SpecValueSerialINT64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = SpecValueSerialDOUBLE::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = SpecValueSerialBYTES::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = SpecValueSerialKEY::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = SpecValueSerialLI::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = SpecValueSerialLB::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerialField {
      field_id: f_1,
      spec_int64: f_2,
      spec_double: f_3,
      spec_bytes: f_4,
      spec_key: f_5,
      spec_li: f_6,
      spec_lb: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerialField");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.field_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.spec_int64 {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_int64", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.spec_double {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_double", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.spec_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_bytes", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.spec_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_key", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.spec_li {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_li", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.spec_lb {
      o_prot.write_field_begin(&TFieldIdentifier::new("spec_lb", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerialField {
  fn default() -> Self {
    SpecValueSerialField{
      field_id: Some(0),
      spec_int64: None,
      spec_double: None,
      spec_bytes: None,
      spec_key: None,
      spec_li: None,
      spec_lb: None,
    }
  }
}

//
// SpecValuePlain
//

/// The Plain Value Specifications, option to use with Extended Logical Comparators
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValuePlain {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The binary(bytes) to match against the Cell value
  pub v: Option<Vec<u8>>,
}

impl SpecValuePlain {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValuePlain where F1: Into<Option<Comp>>, F2: Into<Option<Vec<u8>>> {
    SpecValuePlain {
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SpecValuePlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValuePlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValuePlain {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValuePlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValuePlain {
  fn default() -> Self {
    SpecValuePlain{
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// SpecValueCounter
//

/// The Counter Value Specifications, option to use with Extended Logical Comparators
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueCounter {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The int64 to match against the Cell value
  pub v: Option<i64>,
}

impl SpecValueCounter {
  pub fn new<F1, F2>(comp: F1, v: F2) -> SpecValueCounter where F1: Into<Option<Comp>>, F2: Into<Option<i64>> {
    SpecValueCounter {
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for SpecValueCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueCounter {
      comp: f_1,
      v: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueCounter {
  fn default() -> Self {
    SpecValueCounter{
      comp: None,
      v: Some(0),
    }
  }
}

//
// SpecValueSerial
//

/// The Serial Value Specifications
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecValueSerial {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The Serial Value Specifications to match against the SERIAL Cell value fields
  pub fields: Option<SpecValueSerialFields>,
}

impl SpecValueSerial {
  pub fn new<F1, F2>(comp: F1, fields: F2) -> SpecValueSerial where F1: Into<Option<Comp>>, F2: Into<Option<SpecValueSerialFields>> {
    SpecValueSerial {
      comp: comp.into(),
      fields: fields.into(),
    }
  }
}

impl TSerializable for SpecValueSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecValueSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<SpecValueSerialFields> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueSerialField> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = SpecValueSerialField::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecValueSerial {
      comp: f_1,
      fields: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecValueSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fields {
      o_prot.write_field_begin(&TFieldIdentifier::new("fields", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecValueSerial {
  fn default() -> Self {
    SpecValueSerial{
      comp: None,
      fields: Some(Vec::new()),
    }
  }
}

//
// SpecFraction
//

/// The Fraction Specifications
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecFraction {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The binary(bytes) to match against a fraction of a Cell-Key
  pub f: Option<Vec<u8>>,
}

impl SpecFraction {
  pub fn new<F1, F2>(comp: F1, f: F2) -> SpecFraction where F1: Into<Option<Comp>>, F2: Into<Option<Vec<u8>>> {
    SpecFraction {
      comp: comp.into(),
      f: f.into(),
    }
  }
}

impl TSerializable for SpecFraction {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecFraction> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bytes()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecFraction {
      comp: f_1,
      f: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecFraction");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::String, 2))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecFraction {
  fn default() -> Self {
    SpecFraction{
      comp: None,
      f: Some(Vec::new()),
    }
  }
}

//
// SpecTimestamp
//

/// The Timestamp Specifications
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecTimestamp {
  /// Logical comparator to Apply
  pub comp: Option<Comp>,
  /// The timestamp in nanoseconds to match against the Cell timestamp/version (not the revision)
  pub ts: Option<i64>,
}

impl SpecTimestamp {
  pub fn new<F1, F2>(comp: F1, ts: F2) -> SpecTimestamp where F1: Into<Option<Comp>>, F2: Into<Option<i64>> {
    SpecTimestamp {
      comp: comp.into(),
      ts: ts.into(),
    }
  }
}

impl TSerializable for SpecTimestamp {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecTimestamp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Comp> = None;
    let mut f_2: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecTimestamp {
      comp: f_1,
      ts: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecTimestamp");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecTimestamp {
  fn default() -> Self {
    SpecTimestamp{
      comp: None,
      ts: Some(0),
    }
  }
}

//
// SpecKeyInterval
//

/// The Key Interval Specifications
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecKeyInterval {
  /// The Key Start Spec, the start of cells-interval key match
  pub start: Option<SpecKey>,
  /// The Key Finish Spec, the finish of cells-interval key match
  pub finish: Option<SpecKey>,
}

impl SpecKeyInterval {
  pub fn new<F1, F2>(start: F1, finish: F2) -> SpecKeyInterval where F1: Into<Option<SpecKey>>, F2: Into<Option<SpecKey>> {
    SpecKeyInterval {
      start: start.into(),
      finish: finish.into(),
    }
  }
}

impl TSerializable for SpecKeyInterval {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecKeyInterval> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecKey> = Some(Vec::new());
    let mut f_2: Option<SpecKey> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecFraction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = SpecFraction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecFraction> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = SpecFraction::read_from_in_protocol(i_prot)?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecKeyInterval {
      start: f_1,
      finish: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecKeyInterval");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.start {
      o_prot.write_field_begin(&TFieldIdentifier::new("start", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.finish {
      o_prot.write_field_begin(&TFieldIdentifier::new("finish", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecKeyInterval {
  fn default() -> Self {
    SpecKeyInterval{
      start: Some(Vec::new()),
      finish: Some(Vec::new()),
    }
  }
}

//
// SpecIntervalPlain
//

/// The Cells Interval Plain type Specifications with interval-scope Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecIntervalPlain {
  /// Begin of Ranges evaluation with this Key inclusive
  pub range_begin: Option<Key>,
  /// End of Ranges evaluation with this Key inclusive
  pub range_end: Option<Key>,
  /// Offset Cell Key of a Scan, select cells from this key inclusive
  pub offset_key: Option<Key>,
  /// Offset Cell Timestamp of a Scan, select cells after this timestamp
  pub offset_rev: Option<i64>,
  /// The Key Intervals
  pub key_intervals: Option<SpecKeyIntervals>,
  /// The Cell Value Specifications, cell-value match for plain type
  pub values: Option<SpecValuesPlain>,
  /// The Timestamp Start Spec, the start of cells-interval timestamp match
  pub ts_start: Option<SpecTimestamp>,
  /// The Timestamp Finish Spec, the finish of cells-interval timestamp match
  pub ts_finish: Option<SpecTimestamp>,
  /// The Interval Flags Specification
  pub flags: Option<SpecFlags>,
  /// The Interval Options Specification
  pub options: Option<SpecIntervalOptions>,
  /// The Value spec of an Updating Interval
  pub updating: Option<SpecIntervalUpdatePlain>,
}

impl SpecIntervalPlain {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(range_begin: F1, range_end: F2, offset_key: F3, offset_rev: F4, key_intervals: F5, values: F6, ts_start: F7, ts_finish: F8, flags: F9, options: F10, updating: F11) -> SpecIntervalPlain where F1: Into<Option<Key>>, F2: Into<Option<Key>>, F3: Into<Option<Key>>, F4: Into<Option<i64>>, F5: Into<Option<SpecKeyIntervals>>, F6: Into<Option<SpecValuesPlain>>, F7: Into<Option<SpecTimestamp>>, F8: Into<Option<SpecTimestamp>>, F9: Into<Option<SpecFlags>>, F10: Into<Option<SpecIntervalOptions>>, F11: Into<Option<SpecIntervalUpdatePlain>> {
    SpecIntervalPlain {
      range_begin: range_begin.into(),
      range_end: range_end.into(),
      offset_key: offset_key.into(),
      offset_rev: offset_rev.into(),
      key_intervals: key_intervals.into(),
      values: values.into(),
      ts_start: ts_start.into(),
      ts_finish: ts_finish.into(),
      flags: flags.into(),
      options: options.into(),
      updating: updating.into(),
    }
  }
}

impl TSerializable for SpecIntervalPlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecIntervalPlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<Key> = Some(Vec::new());
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<SpecKeyIntervals> = Some(Vec::new());
    let mut f_6: Option<SpecValuesPlain> = Some(Vec::new());
    let mut f_7: Option<SpecTimestamp> = None;
    let mut f_8: Option<SpecTimestamp> = None;
    let mut f_9: Option<SpecFlags> = None;
    let mut f_10: Option<SpecIntervalOptions> = None;
    let mut f_11: Option<SpecIntervalUpdatePlain> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = i_prot.read_bytes()?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = i_prot.read_bytes()?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = i_prot.read_bytes()?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecKeyInterval> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_16 = SpecKeyInterval::read_from_in_protocol(i_prot)?;
            val.push(list_elem_16);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValuePlain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = SpecValuePlain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = SpecFlags::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = SpecIntervalOptions::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = SpecIntervalUpdatePlain::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecIntervalPlain {
      range_begin: f_1,
      range_end: f_2,
      offset_key: f_3,
      offset_rev: f_4,
      key_intervals: f_5,
      values: f_6,
      ts_start: f_7,
      ts_finish: f_8,
      flags: f_9,
      options: f_10,
      updating: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecIntervalPlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.range_begin {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_begin", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.range_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_end", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.offset_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_key", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.offset_rev {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_rev", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.key_intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_intervals", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ts_start {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_start", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ts_finish {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_finish", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("flags", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.options {
      o_prot.write_field_begin(&TFieldIdentifier::new("options", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.updating {
      o_prot.write_field_begin(&TFieldIdentifier::new("updating", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecIntervalPlain {
  fn default() -> Self {
    SpecIntervalPlain{
      range_begin: Some(Vec::new()),
      range_end: Some(Vec::new()),
      offset_key: Some(Vec::new()),
      offset_rev: Some(0),
      key_intervals: Some(Vec::new()),
      values: Some(Vec::new()),
      ts_start: None,
      ts_finish: None,
      flags: None,
      options: None,
      updating: None,
    }
  }
}

//
// SpecIntervalCounter
//

/// The Cells Interval Counter type Specifications with interval-scope Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecIntervalCounter {
  /// Begin of Ranges evaluation with this Key inclusive
  pub range_begin: Option<Key>,
  /// End of Ranges evaluation with this Key inclusive
  pub range_end: Option<Key>,
  /// Offset Cell Key of a Scan, select cells from this key inclusive
  pub offset_key: Option<Key>,
  /// Offset Cell Timestamp of a Scan, select cells after this timestamp
  pub offset_rev: Option<i64>,
  /// The Key Intervals
  pub key_intervals: Option<SpecKeyIntervals>,
  /// The Cell Value Specifications, cell-value match for counter type
  pub values: Option<SpecValuesCounter>,
  /// The Timestamp Start Spec, the start of cells-interval timestamp match
  pub ts_start: Option<SpecTimestamp>,
  /// The Timestamp Finish Spec, the finish of cells-interval timestamp match
  pub ts_finish: Option<SpecTimestamp>,
  /// The Interval Flags Specification
  pub flags: Option<SpecFlags>,
  /// The Interval Options Specification
  pub options: Option<SpecIntervalOptions>,
  /// The Value spec of an Updating Interval
  pub updating: Option<SpecIntervalUpdateCounter>,
}

impl SpecIntervalCounter {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(range_begin: F1, range_end: F2, offset_key: F3, offset_rev: F4, key_intervals: F5, values: F6, ts_start: F7, ts_finish: F8, flags: F9, options: F10, updating: F11) -> SpecIntervalCounter where F1: Into<Option<Key>>, F2: Into<Option<Key>>, F3: Into<Option<Key>>, F4: Into<Option<i64>>, F5: Into<Option<SpecKeyIntervals>>, F6: Into<Option<SpecValuesCounter>>, F7: Into<Option<SpecTimestamp>>, F8: Into<Option<SpecTimestamp>>, F9: Into<Option<SpecFlags>>, F10: Into<Option<SpecIntervalOptions>>, F11: Into<Option<SpecIntervalUpdateCounter>> {
    SpecIntervalCounter {
      range_begin: range_begin.into(),
      range_end: range_end.into(),
      offset_key: offset_key.into(),
      offset_rev: offset_rev.into(),
      key_intervals: key_intervals.into(),
      values: values.into(),
      ts_start: ts_start.into(),
      ts_finish: ts_finish.into(),
      flags: flags.into(),
      options: options.into(),
      updating: updating.into(),
    }
  }
}

impl TSerializable for SpecIntervalCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecIntervalCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<Key> = Some(Vec::new());
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<SpecKeyIntervals> = Some(Vec::new());
    let mut f_6: Option<SpecValuesCounter> = Some(Vec::new());
    let mut f_7: Option<SpecTimestamp> = None;
    let mut f_8: Option<SpecTimestamp> = None;
    let mut f_9: Option<SpecFlags> = None;
    let mut f_10: Option<SpecIntervalOptions> = None;
    let mut f_11: Option<SpecIntervalUpdateCounter> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = i_prot.read_bytes()?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_bytes()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = i_prot.read_bytes()?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecKeyInterval> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = SpecKeyInterval::read_from_in_protocol(i_prot)?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueCounter> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = SpecValueCounter::read_from_in_protocol(i_prot)?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = SpecFlags::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = SpecIntervalOptions::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = SpecIntervalUpdateCounter::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecIntervalCounter {
      range_begin: f_1,
      range_end: f_2,
      offset_key: f_3,
      offset_rev: f_4,
      key_intervals: f_5,
      values: f_6,
      ts_start: f_7,
      ts_finish: f_8,
      flags: f_9,
      options: f_10,
      updating: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecIntervalCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.range_begin {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_begin", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.range_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_end", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.offset_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_key", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.offset_rev {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_rev", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.key_intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_intervals", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ts_start {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_start", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ts_finish {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_finish", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("flags", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.options {
      o_prot.write_field_begin(&TFieldIdentifier::new("options", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.updating {
      o_prot.write_field_begin(&TFieldIdentifier::new("updating", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecIntervalCounter {
  fn default() -> Self {
    SpecIntervalCounter{
      range_begin: Some(Vec::new()),
      range_end: Some(Vec::new()),
      offset_key: Some(Vec::new()),
      offset_rev: Some(0),
      key_intervals: Some(Vec::new()),
      values: Some(Vec::new()),
      ts_start: None,
      ts_finish: None,
      flags: None,
      options: None,
      updating: None,
    }
  }
}

//
// SpecIntervalSerial
//

/// The Cells Interval Serial type Specifications with interval-scope Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecIntervalSerial {
  /// Begin of Ranges evaluation with this Key inclusive
  pub range_begin: Option<Key>,
  /// End of Ranges evaluation with this Key inclusive
  pub range_end: Option<Key>,
  /// Offset Cell Key of a Scan, select cells from this key inclusive
  pub offset_key: Option<Key>,
  /// Offset Cell Timestamp of a Scan, select cells after this timestamp
  pub offset_rev: Option<i64>,
  /// The Key Intervals
  pub key_intervals: Option<SpecKeyIntervals>,
  /// The Serial Cell Value Specifications, cell-value fields match
  pub values: Option<SpecValuesSerial>,
  /// The Timestamp Start Spec, the start of cells-interval timestamp match
  pub ts_start: Option<SpecTimestamp>,
  /// The Timestamp Finish Spec, the finish of cells-interval timestamp match
  pub ts_finish: Option<SpecTimestamp>,
  /// The Interval Flags Specification
  pub flags: Option<SpecFlags>,
  /// The Interval Options Specification
  pub options: Option<SpecIntervalOptions>,
  /// The Serial-Value spec of an Updating Interval
  pub updating: Option<SpecIntervalUpdateSerial>,
}

impl SpecIntervalSerial {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(range_begin: F1, range_end: F2, offset_key: F3, offset_rev: F4, key_intervals: F5, values: F6, ts_start: F7, ts_finish: F8, flags: F9, options: F10, updating: F11) -> SpecIntervalSerial where F1: Into<Option<Key>>, F2: Into<Option<Key>>, F3: Into<Option<Key>>, F4: Into<Option<i64>>, F5: Into<Option<SpecKeyIntervals>>, F6: Into<Option<SpecValuesSerial>>, F7: Into<Option<SpecTimestamp>>, F8: Into<Option<SpecTimestamp>>, F9: Into<Option<SpecFlags>>, F10: Into<Option<SpecIntervalOptions>>, F11: Into<Option<SpecIntervalUpdateSerial>> {
    SpecIntervalSerial {
      range_begin: range_begin.into(),
      range_end: range_end.into(),
      offset_key: offset_key.into(),
      offset_rev: offset_rev.into(),
      key_intervals: key_intervals.into(),
      values: values.into(),
      ts_start: ts_start.into(),
      ts_finish: ts_finish.into(),
      flags: flags.into(),
      options: options.into(),
      updating: updating.into(),
    }
  }
}

impl TSerializable for SpecIntervalSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecIntervalSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<Key> = Some(Vec::new());
    let mut f_4: Option<i64> = None;
    let mut f_5: Option<SpecKeyIntervals> = Some(Vec::new());
    let mut f_6: Option<SpecValuesSerial> = Some(Vec::new());
    let mut f_7: Option<SpecTimestamp> = None;
    let mut f_8: Option<SpecTimestamp> = None;
    let mut f_9: Option<SpecFlags> = None;
    let mut f_10: Option<SpecIntervalOptions> = None;
    let mut f_11: Option<SpecIntervalUpdateSerial> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = i_prot.read_bytes()?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = i_prot.read_bytes()?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = i_prot.read_bytes()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecKeyInterval> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = SpecKeyInterval::read_from_in_protocol(i_prot)?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = SpecValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = SpecTimestamp::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = SpecFlags::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = SpecIntervalOptions::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = SpecIntervalUpdateSerial::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecIntervalSerial {
      range_begin: f_1,
      range_end: f_2,
      offset_key: f_3,
      offset_rev: f_4,
      key_intervals: f_5,
      values: f_6,
      ts_start: f_7,
      ts_finish: f_8,
      flags: f_9,
      options: f_10,
      updating: f_11,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecIntervalSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.range_begin {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_begin", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.range_end {
      o_prot.write_field_begin(&TFieldIdentifier::new("range_end", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.offset_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_key", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.offset_rev {
      o_prot.write_field_begin(&TFieldIdentifier::new("offset_rev", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.key_intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("key_intervals", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ts_start {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_start", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ts_finish {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_finish", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("flags", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.options {
      o_prot.write_field_begin(&TFieldIdentifier::new("options", TType::I32, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.updating {
      o_prot.write_field_begin(&TFieldIdentifier::new("updating", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecIntervalSerial {
  fn default() -> Self {
    SpecIntervalSerial{
      range_begin: Some(Vec::new()),
      range_end: Some(Vec::new()),
      offset_key: Some(Vec::new()),
      offset_rev: Some(0),
      key_intervals: Some(Vec::new()),
      values: Some(Vec::new()),
      ts_start: None,
      ts_finish: None,
      flags: None,
      options: None,
      updating: None,
    }
  }
}

//
// SpecColumnPlain
//

/// The Column Specifications, the Cells-Intervals(SpecIntervalPlain/s) specification for a PLAIN Type column
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecColumnPlain {
  /// The Column ID
  pub cid: Option<i64>,
  /// The Cells Interval in a list-container
  pub intervals: Option<Vec<SpecIntervalPlain>>,
}

impl SpecColumnPlain {
  pub fn new<F1, F2>(cid: F1, intervals: F2) -> SpecColumnPlain where F1: Into<Option<i64>>, F2: Into<Option<Vec<SpecIntervalPlain>>> {
    SpecColumnPlain {
      cid: cid.into(),
      intervals: intervals.into(),
    }
  }
}

impl TSerializable for SpecColumnPlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecColumnPlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<Vec<SpecIntervalPlain>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecIntervalPlain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = SpecIntervalPlain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecColumnPlain {
      cid: f_1,
      intervals: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecColumnPlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("intervals", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecColumnPlain {
  fn default() -> Self {
    SpecColumnPlain{
      cid: Some(0),
      intervals: Some(Vec::new()),
    }
  }
}

//
// SpecColumnCounter
//

/// The Column Specifications, the Cells-Intervals(SpecIntervalCounter/s) specification for a COUNTER Type column
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecColumnCounter {
  /// The Column ID
  pub cid: Option<i64>,
  /// The Cells Interval in a list-container
  pub intervals: Option<Vec<SpecIntervalCounter>>,
}

impl SpecColumnCounter {
  pub fn new<F1, F2>(cid: F1, intervals: F2) -> SpecColumnCounter where F1: Into<Option<i64>>, F2: Into<Option<Vec<SpecIntervalCounter>>> {
    SpecColumnCounter {
      cid: cid.into(),
      intervals: intervals.into(),
    }
  }
}

impl TSerializable for SpecColumnCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecColumnCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<Vec<SpecIntervalCounter>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecIntervalCounter> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_29 = SpecIntervalCounter::read_from_in_protocol(i_prot)?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecColumnCounter {
      cid: f_1,
      intervals: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecColumnCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("intervals", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecColumnCounter {
  fn default() -> Self {
    SpecColumnCounter{
      cid: Some(0),
      intervals: Some(Vec::new()),
    }
  }
}

//
// SpecColumnSerial
//

/// The Column Specifications, the Cells-Intervals(SpecIntervalSerial/s) specification for a SERIAL Type Column
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecColumnSerial {
  /// The Column ID
  pub cid: Option<i64>,
  /// The Serial Cells Interval in a list-container
  pub intervals: Option<Vec<SpecIntervalSerial>>,
}

impl SpecColumnSerial {
  pub fn new<F1, F2>(cid: F1, intervals: F2) -> SpecColumnSerial where F1: Into<Option<i64>>, F2: Into<Option<Vec<SpecIntervalSerial>>> {
    SpecColumnSerial {
      cid: cid.into(),
      intervals: intervals.into(),
    }
  }
}

impl TSerializable for SpecColumnSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecColumnSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<Vec<SpecIntervalSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecIntervalSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_30 = SpecIntervalSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_30);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecColumnSerial {
      cid: f_1,
      intervals: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecColumnSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.intervals {
      o_prot.write_field_begin(&TFieldIdentifier::new("intervals", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecColumnSerial {
  fn default() -> Self {
    SpecColumnSerial{
      cid: Some(0),
      intervals: Some(Vec::new()),
    }
  }
}

//
// SpecScan
//

/// The Scan Specifications, the Columns-Intervals(SpecColumn/s) with global-scope Flags
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SpecScan {
  /// The Plain Column Intervals(SpecColumnPlain) in a list-container
  pub columns_plain: Option<Vec<SpecColumnPlain>>,
  /// The Counter Column Intervals(SpecColumnCounter) in a list-container
  pub columns_counter: Option<Vec<SpecColumnCounter>>,
  /// The Serial Column Intervals(SpecColumnSerial) in a list-container
  pub columns_serial: Option<Vec<SpecColumnSerial>>,
  /// The Global Flags Specification
  pub flags: Option<SpecFlags>,
}

impl SpecScan {
  pub fn new<F1, F2, F3, F4>(columns_plain: F1, columns_counter: F2, columns_serial: F3, flags: F4) -> SpecScan where F1: Into<Option<Vec<SpecColumnPlain>>>, F2: Into<Option<Vec<SpecColumnCounter>>>, F3: Into<Option<Vec<SpecColumnSerial>>>, F4: Into<Option<SpecFlags>> {
    SpecScan {
      columns_plain: columns_plain.into(),
      columns_counter: columns_counter.into(),
      columns_serial: columns_serial.into(),
      flags: flags.into(),
    }
  }
}

impl TSerializable for SpecScan {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<SpecScan> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<SpecColumnPlain>> = Some(Vec::new());
    let mut f_2: Option<Vec<SpecColumnCounter>> = Some(Vec::new());
    let mut f_3: Option<Vec<SpecColumnSerial>> = Some(Vec::new());
    let mut f_4: Option<SpecFlags> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecColumnPlain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_31 = SpecColumnPlain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_31);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecColumnCounter> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_32 = SpecColumnCounter::read_from_in_protocol(i_prot)?;
            val.push(list_elem_32);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SpecColumnSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_33 = SpecColumnSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_33);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = SpecFlags::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SpecScan {
      columns_plain: f_1,
      columns_counter: f_2,
      columns_serial: f_3,
      flags: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SpecScan");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.columns_plain {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_plain", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_counter {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_counter", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.columns_serial {
      o_prot.write_field_begin(&TFieldIdentifier::new("columns_serial", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("flags", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SpecScan {
  fn default() -> Self {
    SpecScan{
      columns_plain: Some(Vec::new()),
      columns_counter: Some(Vec::new()),
      columns_serial: Some(Vec::new()),
      flags: None,
    }
  }
}

//
// UCellPlain
//

/// The Cell data for using with Update of PLAIN Column Type
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UCellPlain {
  /// The Cell Flag
  pub f: Option<Flag>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp in nanoseconds
  pub ts: Option<i64>,
  /// The Cell Version is in timestamp descending
  pub ts_desc: Option<bool>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
  /// Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
  pub encoder: Option<EncodingType>,
}

impl UCellPlain {
  pub fn new<F1, F2, F3, F4, F5, F6>(f: F1, k: F2, ts: F3, ts_desc: F4, v: F5, encoder: F6) -> UCellPlain where F1: Into<Option<Flag>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<Vec<u8>>>, F6: Into<Option<EncodingType>> {
    UCellPlain {
      f: f.into(),
      k: k.into(),
      ts: ts.into(),
      ts_desc: ts_desc.into(),
      v: v.into(),
      encoder: encoder.into(),
    }
  }
}

impl TSerializable for UCellPlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UCellPlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Flag> = None;
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    let mut f_6: Option<EncodingType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Flag::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_34 = i_prot.read_bytes()?;
            val.push(list_elem_34);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        6 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UCellPlain {
      f: f_1,
      k: f_2,
      ts: f_3,
      ts_desc: f_4,
      v: f_5,
      encoder: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UCellPlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_desc", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.encoder {
      o_prot.write_field_begin(&TFieldIdentifier::new("encoder", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UCellPlain {
  fn default() -> Self {
    UCellPlain{
      f: None,
      k: Some(Vec::new()),
      ts: Some(0),
      ts_desc: Some(false),
      v: Some(Vec::new()),
      encoder: None,
    }
  }
}

//
// UCellCounter
//

/// The Cell data for using with Update of COUNTER Column Type
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UCellCounter {
  /// The Cell Flag
  pub f: Option<Flag>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp in nanoseconds
  pub ts: Option<i64>,
  /// The Cell Version is in timestamp descending
  pub ts_desc: Option<bool>,
  /// The Cell Counter Operation
  pub op: Option<i8>,
  /// The Cell Counter Value
  pub v: Option<i64>,
}

impl UCellCounter {
  pub fn new<F1, F2, F3, F4, F5, F6>(f: F1, k: F2, ts: F3, ts_desc: F4, op: F5, v: F6) -> UCellCounter where F1: Into<Option<Flag>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<i8>>, F6: Into<Option<i64>> {
    UCellCounter {
      f: f.into(),
      k: k.into(),
      ts: ts.into(),
      ts_desc: ts_desc.into(),
      op: op.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for UCellCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UCellCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Flag> = None;
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<i8> = Some(0);
    let mut f_6: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Flag::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_35 = i_prot.read_bytes()?;
            val.push(list_elem_35);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i8()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UCellCounter {
      f: f_1,
      k: f_2,
      ts: f_3,
      ts_desc: f_4,
      op: f_5,
      v: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UCellCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_desc", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I08, 5))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 6))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UCellCounter {
  fn default() -> Self {
    UCellCounter{
      f: None,
      k: Some(Vec::new()),
      ts: Some(0),
      ts_desc: Some(false),
      op: Some(0),
      v: Some(0),
    }
  }
}

//
// CellValueSerial
//

/// The Serial Value Cell field
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellValueSerial {
  /// The Field ID, a single ID can have any/all the field types
  pub field_id: Option<i32>,
  /// The INT64 type field
  pub v_int64: Option<i64>,
  /// The DOUBLE type field
  pub v_double: Option<OrderedFloat<f64>>,
  /// The BYTES type field
  pub v_bytes: Option<Vec<u8>>,
  /// The Cell KEY type field
  pub v_key: Option<Key>,
  /// The LIST INT64 type field
  pub v_li: Option<Vec<i64>>,
  /// The LIST BYTES type field
  pub v_lb: Option<Vec<Vec<u8>>>,
}

impl CellValueSerial {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(field_id: F1, v_int64: F2, v_double: F3, v_bytes: F4, v_key: F5, v_li: F6, v_lb: F7) -> CellValueSerial where F1: Into<Option<i32>>, F2: Into<Option<i64>>, F3: Into<Option<OrderedFloat<f64>>>, F4: Into<Option<Vec<u8>>>, F5: Into<Option<Key>>, F6: Into<Option<Vec<i64>>>, F7: Into<Option<Vec<Vec<u8>>>> {
    CellValueSerial {
      field_id: field_id.into(),
      v_int64: v_int64.into(),
      v_double: v_double.into(),
      v_bytes: v_bytes.into(),
      v_key: v_key.into(),
      v_li: v_li.into(),
      v_lb: v_lb.into(),
    }
  }
}

impl TSerializable for CellValueSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellValueSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<OrderedFloat<f64>> = None;
    let mut f_4: Option<Vec<u8>> = None;
    let mut f_5: Option<Key> = None;
    let mut f_6: Option<Vec<i64>> = None;
    let mut f_7: Option<Vec<Vec<u8>>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_36 = i_prot.read_bytes()?;
            val.push(list_elem_36);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_37 = i_prot.read_i64()?;
            val.push(list_elem_37);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = i_prot.read_bytes()?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellValueSerial {
      field_id: f_1,
      v_int64: f_2,
      v_double: f_3,
      v_bytes: f_4,
      v_key: f_5,
      v_li: f_6,
      v_lb: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellValueSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.field_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v_int64 {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_int64", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v_double {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_double", TType::Double, 3))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_bytes", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_key", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_li {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_li", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i64(*e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_lb {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_lb", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellValueSerial {
  fn default() -> Self {
    CellValueSerial{
      field_id: Some(0),
      v_int64: Some(0),
      v_double: Some(OrderedFloat::from(0.0)),
      v_bytes: Some(Vec::new()),
      v_key: Some(Vec::new()),
      v_li: Some(Vec::new()),
      v_lb: Some(Vec::new()),
    }
  }
}

//
// FUINT64
//

/// Serial INT64 Field Update
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FUINT64 {
  pub ctrl: Option<i8>,
  pub op: Option<FUMATHOP>,
  pub pos: Option<i32>,
  pub comp: Option<Comp>,
  pub v: Option<i64>,
}

impl FUINT64 {
  pub fn new<F1, F2, F3, F4, F5>(ctrl: F1, op: F2, pos: F3, comp: F4, v: F5) -> FUINT64 where F1: Into<Option<i8>>, F2: Into<Option<FUMATHOP>>, F3: Into<Option<i32>>, F4: Into<Option<Comp>>, F5: Into<Option<i64>> {
    FUINT64 {
      ctrl: ctrl.into(),
      op: op.into(),
      pos: pos.into(),
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for FUINT64 {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FUINT64> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = Some(0);
    let mut f_2: Option<FUMATHOP> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Comp> = None;
    let mut f_5: Option<i64> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = FUMATHOP::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FUINT64 {
      ctrl: f_1,
      op: f_2,
      pos: f_3,
      comp: f_4,
      v: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FU_INT64");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.ctrl {
      o_prot.write_field_begin(&TFieldIdentifier::new("ctrl", TType::I08, 1))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pos {
      o_prot.write_field_begin(&TFieldIdentifier::new("pos", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FUINT64 {
  fn default() -> Self {
    FUINT64{
      ctrl: Some(0),
      op: None,
      pos: Some(0),
      comp: None,
      v: Some(0),
    }
  }
}

//
// FUDOUBLE
//

/// Serial DOUBLE Field Update
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FUDOUBLE {
  pub ctrl: Option<i8>,
  pub op: Option<FUMATHOP>,
  pub pos: Option<i32>,
  pub comp: Option<Comp>,
  pub v: Option<OrderedFloat<f64>>,
}

impl FUDOUBLE {
  pub fn new<F1, F2, F3, F4, F5>(ctrl: F1, op: F2, pos: F3, comp: F4, v: F5) -> FUDOUBLE where F1: Into<Option<i8>>, F2: Into<Option<FUMATHOP>>, F3: Into<Option<i32>>, F4: Into<Option<Comp>>, F5: Into<Option<OrderedFloat<f64>>> {
    FUDOUBLE {
      ctrl: ctrl.into(),
      op: op.into(),
      pos: pos.into(),
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for FUDOUBLE {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FUDOUBLE> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = Some(0);
    let mut f_2: Option<FUMATHOP> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Comp> = None;
    let mut f_5: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = FUMATHOP::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FUDOUBLE {
      ctrl: f_1,
      op: f_2,
      pos: f_3,
      comp: f_4,
      v: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FU_DOUBLE");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.ctrl {
      o_prot.write_field_begin(&TFieldIdentifier::new("ctrl", TType::I08, 1))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pos {
      o_prot.write_field_begin(&TFieldIdentifier::new("pos", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::Double, 5))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FUDOUBLE {
  fn default() -> Self {
    FUDOUBLE{
      ctrl: Some(0),
      op: None,
      pos: Some(0),
      comp: None,
      v: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// FUBYTES
//

/// Serial BYTES Field Update
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FUBYTES {
  pub ctrl: Option<i8>,
  pub op: Option<FULISTOP>,
  pub pos: Option<i32>,
  pub comp: Option<Comp>,
  pub v: Option<Vec<u8>>,
}

impl FUBYTES {
  pub fn new<F1, F2, F3, F4, F5>(ctrl: F1, op: F2, pos: F3, comp: F4, v: F5) -> FUBYTES where F1: Into<Option<i8>>, F2: Into<Option<FULISTOP>>, F3: Into<Option<i32>>, F4: Into<Option<Comp>>, F5: Into<Option<Vec<u8>>> {
    FUBYTES {
      ctrl: ctrl.into(),
      op: op.into(),
      pos: pos.into(),
      comp: comp.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for FUBYTES {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FUBYTES> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = Some(0);
    let mut f_2: Option<FULISTOP> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Comp> = None;
    let mut f_5: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = FULISTOP::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = Comp::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bytes()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FUBYTES {
      ctrl: f_1,
      op: f_2,
      pos: f_3,
      comp: f_4,
      v: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FU_BYTES");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.ctrl {
      o_prot.write_field_begin(&TFieldIdentifier::new("ctrl", TType::I08, 1))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pos {
      o_prot.write_field_begin(&TFieldIdentifier::new("pos", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.comp {
      o_prot.write_field_begin(&TFieldIdentifier::new("comp", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 5))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FUBYTES {
  fn default() -> Self {
    FUBYTES{
      ctrl: Some(0),
      op: None,
      pos: Some(0),
      comp: None,
      v: Some(Vec::new()),
    }
  }
}

//
// FULI
//

/// Serial LIST_INT64 Field Update
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FULI {
  pub ctrl: Option<i8>,
  pub op: Option<FULISTOP>,
  pub pos: Option<i32>,
  pub v: Option<Vec<FUINT64>>,
}

impl FULI {
  pub fn new<F1, F2, F3, F4>(ctrl: F1, op: F2, pos: F3, v: F4) -> FULI where F1: Into<Option<i8>>, F2: Into<Option<FULISTOP>>, F3: Into<Option<i32>>, F4: Into<Option<Vec<FUINT64>>> {
    FULI {
      ctrl: ctrl.into(),
      op: op.into(),
      pos: pos.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for FULI {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FULI> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = Some(0);
    let mut f_2: Option<FULISTOP> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Vec<FUINT64>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = FULISTOP::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FUINT64> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = FUINT64::read_from_in_protocol(i_prot)?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FULI {
      ctrl: f_1,
      op: f_2,
      pos: f_3,
      v: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FU_LI");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.ctrl {
      o_prot.write_field_begin(&TFieldIdentifier::new("ctrl", TType::I08, 1))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pos {
      o_prot.write_field_begin(&TFieldIdentifier::new("pos", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FULI {
  fn default() -> Self {
    FULI{
      ctrl: Some(0),
      op: None,
      pos: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// FULB
//

/// Serial LIST_BYTES Field Update
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FULB {
  pub ctrl: Option<i8>,
  pub op: Option<FULISTOP>,
  pub pos: Option<i32>,
  pub v: Option<Vec<FUBYTES>>,
}

impl FULB {
  pub fn new<F1, F2, F3, F4>(ctrl: F1, op: F2, pos: F3, v: F4) -> FULB where F1: Into<Option<i8>>, F2: Into<Option<FULISTOP>>, F3: Into<Option<i32>>, F4: Into<Option<Vec<FUBYTES>>> {
    FULB {
      ctrl: ctrl.into(),
      op: op.into(),
      pos: pos.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for FULB {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FULB> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = Some(0);
    let mut f_2: Option<FULISTOP> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<Vec<FUBYTES>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = FULISTOP::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FUBYTES> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = FUBYTES::read_from_in_protocol(i_prot)?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FULB {
      ctrl: f_1,
      op: f_2,
      pos: f_3,
      v: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FU_LB");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.ctrl {
      o_prot.write_field_begin(&TFieldIdentifier::new("ctrl", TType::I08, 1))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.op {
      o_prot.write_field_begin(&TFieldIdentifier::new("op", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.pos {
      o_prot.write_field_begin(&TFieldIdentifier::new("pos", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FULB {
  fn default() -> Self {
    FULB{
      ctrl: Some(0),
      op: None,
      pos: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// CellValueSerialOp
//

/// The Serial Values Cell field with Update Operation
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellValueSerialOp {
  /// The Field ID, a single ID can have any/all the field types
  pub field_id: Option<i32>,
  /// The INT64 type update-field
  pub v_int64: Option<FUINT64>,
  /// The DOUBLE type update-field
  pub v_double: Option<FUDOUBLE>,
  /// The BYTES type update-field
  pub v_bytes: Option<FUBYTES>,
  /// The Cell KEY type update-field
  pub v_key: Option<Key>,
  /// The LIST INT64 type update-field
  pub v_li: Option<FULI>,
  /// The LIST BYTES type update-field
  pub v_lb: Option<FULB>,
}

impl CellValueSerialOp {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(field_id: F1, v_int64: F2, v_double: F3, v_bytes: F4, v_key: F5, v_li: F6, v_lb: F7) -> CellValueSerialOp where F1: Into<Option<i32>>, F2: Into<Option<FUINT64>>, F3: Into<Option<FUDOUBLE>>, F4: Into<Option<FUBYTES>>, F5: Into<Option<Key>>, F6: Into<Option<FULI>>, F7: Into<Option<FULB>> {
    CellValueSerialOp {
      field_id: field_id.into(),
      v_int64: v_int64.into(),
      v_double: v_double.into(),
      v_bytes: v_bytes.into(),
      v_key: v_key.into(),
      v_li: v_li.into(),
      v_lb: v_lb.into(),
    }
  }
}

impl TSerializable for CellValueSerialOp {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellValueSerialOp> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<FUINT64> = None;
    let mut f_3: Option<FUDOUBLE> = None;
    let mut f_4: Option<FUBYTES> = None;
    let mut f_5: Option<Key> = None;
    let mut f_6: Option<FULI> = None;
    let mut f_7: Option<FULB> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = FUINT64::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = FUDOUBLE::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = FUBYTES::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = i_prot.read_bytes()?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = FULI::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = FULB::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellValueSerialOp {
      field_id: f_1,
      v_int64: f_2,
      v_double: f_3,
      v_bytes: f_4,
      v_key: f_5,
      v_li: f_6,
      v_lb: f_7,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellValueSerialOp");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.field_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("field_id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_int64 {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_int64", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_double {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_double", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_bytes {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_bytes", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_key {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_key", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_li {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_li", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v_lb {
      o_prot.write_field_begin(&TFieldIdentifier::new("v_lb", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellValueSerialOp {
  fn default() -> Self {
    CellValueSerialOp{
      field_id: Some(0),
      v_int64: None,
      v_double: None,
      v_bytes: None,
      v_key: Some(Vec::new()),
      v_li: None,
      v_lb: None,
    }
  }
}

//
// UCellSerial
//

/// The Cell data for using with Update of SERIAL Column Type
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UCellSerial {
  /// The Cell Flag
  pub f: Option<Flag>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp in nanoseconds
  pub ts: Option<i64>,
  /// The Cell Version is in timestamp descending
  pub ts_desc: Option<bool>,
  /// The Serial Cell Value fields
  pub v: Option<CellValuesSerial>,
  /// Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
  pub encoder: Option<EncodingType>,
}

impl UCellSerial {
  pub fn new<F1, F2, F3, F4, F5, F6>(f: F1, k: F2, ts: F3, ts_desc: F4, v: F5, encoder: F6) -> UCellSerial where F1: Into<Option<Flag>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<bool>>, F5: Into<Option<CellValuesSerial>>, F6: Into<Option<EncodingType>> {
    UCellSerial {
      f: f.into(),
      k: k.into(),
      ts: ts.into(),
      ts_desc: ts_desc.into(),
      v: v.into(),
      encoder: encoder.into(),
    }
  }
}

impl TSerializable for UCellSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<UCellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Flag> = None;
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<CellValuesSerial> = Some(Vec::new());
    let mut f_6: Option<EncodingType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Flag::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = i_prot.read_bytes()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = EncodingType::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UCellSerial {
      f: f_1,
      k: f_2,
      ts: f_3,
      ts_desc: f_4,
      v: f_5,
      encoder: f_6,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UCellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::I32, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts_desc {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts_desc", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 5))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.encoder {
      o_prot.write_field_begin(&TFieldIdentifier::new("encoder", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UCellSerial {
  fn default() -> Self {
    UCellSerial{
      f: None,
      k: Some(Vec::new()),
      ts: Some(0),
      ts_desc: Some(false),
      v: Some(Vec::new()),
      encoder: None,
    }
  }
}

//
// CellPlain
//

/// The Cell for results list of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellPlain {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
}

impl CellPlain {
  pub fn new<F1, F2, F3, F4>(c: F1, k: F2, ts: F3, v: F4) -> CellPlain where F1: Into<Option<String>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<Vec<u8>>> {
    CellPlain {
      c: c.into(),
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for CellPlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellPlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = i_prot.read_bytes()?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bytes()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellPlain {
      c: f_1,
      k: f_2,
      ts: f_3,
      v: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellPlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 4))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellPlain {
  fn default() -> Self {
    CellPlain{
      c: Some("".to_owned()),
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// CellCounter
//

/// The Counter Cell for results list of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellCounter {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Counter Value
  pub v: Option<i64>,
  /// The Counter EQ since ts
  pub eq: Option<i64>,
}

impl CellCounter {
  pub fn new<F1, F2, F3, F4, F5>(c: F1, k: F2, ts: F3, v: F4, eq: F5) -> CellCounter where F1: Into<Option<String>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<i64>>, F5: Into<Option<i64>> {
    CellCounter {
      c: c.into(),
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
      eq: eq.into(),
    }
  }
}

impl TSerializable for CellCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = i_prot.read_bytes()?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellCounter {
      c: f_1,
      k: f_2,
      ts: f_3,
      v: f_4,
      eq: f_5,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.eq {
      o_prot.write_field_begin(&TFieldIdentifier::new("eq", TType::I64, 5))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellCounter {
  fn default() -> Self {
    CellCounter{
      c: Some("".to_owned()),
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(0),
      eq: Some(0),
    }
  }
}

//
// CellSerial
//

/// The Serial Cell for results list of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellSerial {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Serial Value
  pub v: Option<CellValuesSerial>,
}

impl CellSerial {
  pub fn new<F1, F2, F3, F4>(c: F1, k: F2, ts: F3, v: F4) -> CellSerial where F1: Into<Option<String>>, F2: Into<Option<Key>>, F3: Into<Option<i64>>, F4: Into<Option<CellValuesSerial>> {
    CellSerial {
      c: c.into(),
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for CellSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Key> = Some(Vec::new());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<CellValuesSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = i_prot.read_bytes()?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellSerial {
      c: f_1,
      k: f_2,
      ts: f_3,
      v: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellSerial {
  fn default() -> Self {
    CellSerial{
      c: Some("".to_owned()),
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// Cells
//

/// The Cells for results list of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Cells {
  /// The Cells, defined as Cell items in a list-container
  pub plain_cells: Option<CellsPlain>,
  /// The Cells, defined as Cell items in a list-container
  pub counter_cells: Option<CellsCounter>,
  /// The Serial Cells, defined as CellSerial items in a list-container
  pub serial_cells: Option<CellsSerial>,
}

impl Cells {
  pub fn new<F1, F2, F3>(plain_cells: F1, counter_cells: F2, serial_cells: F3) -> Cells where F1: Into<Option<CellsPlain>>, F2: Into<Option<CellsCounter>>, F3: Into<Option<CellsSerial>> {
    Cells {
      plain_cells: plain_cells.into(),
      counter_cells: counter_cells.into(),
      serial_cells: serial_cells.into(),
    }
  }
}

impl TSerializable for Cells {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Cells> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CellsPlain> = Some(Vec::new());
    let mut f_2: Option<CellsCounter> = Some(Vec::new());
    let mut f_3: Option<CellsSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellPlain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_48 = CellPlain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_48);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellCounter> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_49 = CellCounter::read_from_in_protocol(i_prot)?;
            val.push(list_elem_49);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_50 = CellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_50);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Cells {
      plain_cells: f_1,
      counter_cells: f_2,
      serial_cells: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Cells");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.plain_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("plain_cells", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.counter_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("counter_cells", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serial_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("serial_cells", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Cells {
  fn default() -> Self {
    Cells{
      plain_cells: Some(Vec::new()),
      counter_cells: Some(Vec::new()),
      serial_cells: Some(Vec::new()),
    }
  }
}

//
// CCellPlain
//

/// The Plain column type Cell for results on Columns of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CCellPlain {
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
}

impl CCellPlain {
  pub fn new<F1, F2, F3>(k: F1, ts: F2, v: F3) -> CCellPlain where F1: Into<Option<Key>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>> {
    CCellPlain {
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for CCellPlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CCellPlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_51 = i_prot.read_bytes()?;
            val.push(list_elem_51);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CCellPlain {
      k: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CCellPlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CCellPlain {
  fn default() -> Self {
    CCellPlain{
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// CCellCounter
//

/// The Counter column type Cell for results on Columns of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CCellCounter {
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Counter Value
  pub v: Option<i64>,
  /// The Counter EQ since ts
  pub eq: Option<i64>,
}

impl CCellCounter {
  pub fn new<F1, F2, F3, F4>(k: F1, ts: F2, v: F3, eq: F4) -> CCellCounter where F1: Into<Option<Key>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    CCellCounter {
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
      eq: eq.into(),
    }
  }
}

impl TSerializable for CCellCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CCellCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_52 = i_prot.read_bytes()?;
            val.push(list_elem_52);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CCellCounter {
      k: f_1,
      ts: f_2,
      v: f_3,
      eq: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CCellCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.eq {
      o_prot.write_field_begin(&TFieldIdentifier::new("eq", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CCellCounter {
  fn default() -> Self {
    CCellCounter{
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(0),
      eq: Some(0),
    }
  }
}

//
// CCellSerial
//

/// The Serial column type Cell for results on Columns of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CCellSerial {
  /// The Cell Key
  pub k: Option<Key>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Serial Value
  pub v: Option<CellValuesSerial>,
}

impl CCellSerial {
  pub fn new<F1, F2, F3>(k: F1, ts: F2, v: F3) -> CCellSerial where F1: Into<Option<Key>>, F2: Into<Option<i64>>, F3: Into<Option<CellValuesSerial>> {
    CCellSerial {
      k: k.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for CCellSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CCellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<CellValuesSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_53 = i_prot.read_bytes()?;
            val.push(list_elem_53);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_54 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_54);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CCellSerial {
      k: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CCellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CCellSerial {
  fn default() -> Self {
    CCellSerial{
      k: Some(Vec::new()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// CCells
//

/// The Column Cells for results on Columns of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CCells {
  /// The Plain type Cells, defined as CCellPlain items in a list-container
  pub plain_cells: Option<Vec<CCellPlain>>,
  /// The Counter type Cells, defined as CCellCounter items in a list-container
  pub counter_cells: Option<Vec<CCellCounter>>,
  /// The Serial type Cells, defined as CCellSerial items in a list-container
  pub serial_cells: Option<Vec<CCellSerial>>,
}

impl CCells {
  pub fn new<F1, F2, F3>(plain_cells: F1, counter_cells: F2, serial_cells: F3) -> CCells where F1: Into<Option<Vec<CCellPlain>>>, F2: Into<Option<Vec<CCellCounter>>>, F3: Into<Option<Vec<CCellSerial>>> {
    CCells {
      plain_cells: plain_cells.into(),
      counter_cells: counter_cells.into(),
      serial_cells: serial_cells.into(),
    }
  }
}

impl TSerializable for CCells {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CCells> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<CCellPlain>> = Some(Vec::new());
    let mut f_2: Option<Vec<CCellCounter>> = Some(Vec::new());
    let mut f_3: Option<Vec<CCellSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CCellPlain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_55 = CCellPlain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_55);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CCellCounter> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_56 = CCellCounter::read_from_in_protocol(i_prot)?;
            val.push(list_elem_56);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CCellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_57 = CCellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_57);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CCells {
      plain_cells: f_1,
      counter_cells: f_2,
      serial_cells: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("cCells");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.plain_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("plain_cells", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.counter_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("counter_cells", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serial_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("serial_cells", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CCells {
  fn default() -> Self {
    CCells{
      plain_cells: Some(Vec::new()),
      counter_cells: Some(Vec::new()),
      serial_cells: Some(Vec::new()),
    }
  }
}

//
// KCellPlain
//

/// The Plain column type Key Cell for results on Key of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KCellPlain {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
}

impl KCellPlain {
  pub fn new<F1, F2, F3>(c: F1, ts: F2, v: F3) -> KCellPlain where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>> {
    KCellPlain {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for KCellPlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KCellPlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = KCellPlain {
      c: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("KCellPlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for KCellPlain {
  fn default() -> Self {
    KCellPlain{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// KCellCounter
//

/// The Counter column type Key Cell for results on Key of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KCellCounter {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Counter Value
  pub v: Option<i64>,
  /// The Counter EQ since ts
  pub eq: Option<i64>,
}

impl KCellCounter {
  pub fn new<F1, F2, F3, F4>(c: F1, ts: F2, v: F3, eq: F4) -> KCellCounter where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    KCellCounter {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
      eq: eq.into(),
    }
  }
}

impl TSerializable for KCellCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KCellCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = KCellCounter {
      c: f_1,
      ts: f_2,
      v: f_3,
      eq: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("KCellCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.eq {
      o_prot.write_field_begin(&TFieldIdentifier::new("eq", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for KCellCounter {
  fn default() -> Self {
    KCellCounter{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(0),
      eq: Some(0),
    }
  }
}

//
// KCellSerial
//

/// The Serial column type Key Cell for results on Key of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KCellSerial {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Serial Value
  pub v: Option<CellValuesSerial>,
}

impl KCellSerial {
  pub fn new<F1, F2, F3>(c: F1, ts: F2, v: F3) -> KCellSerial where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<CellValuesSerial>> {
    KCellSerial {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for KCellSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KCellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<CellValuesSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_58 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_58);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = KCellSerial {
      c: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("KCellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for KCellSerial {
  fn default() -> Self {
    KCellSerial{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// KCells
//

/// The Key Cells for results on Key of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct KCells {
  /// The Cell Key
  pub k: Option<Key>,
  /// The Plain type Key Cells, defined as KCellPlain items in a list-container
  pub plain_cells: Option<Vec<KCellPlain>>,
  /// The Counter type Key Cells, defined as KCellCounter items in a list-container
  pub counter_cells: Option<Vec<KCellCounter>>,
  /// The Serial type Key Cells, defined as KCellSerial items in a list-container
  pub serial_cells: Option<Vec<KCellSerial>>,
}

impl KCells {
  pub fn new<F1, F2, F3, F4>(k: F1, plain_cells: F2, counter_cells: F3, serial_cells: F4) -> KCells where F1: Into<Option<Key>>, F2: Into<Option<Vec<KCellPlain>>>, F3: Into<Option<Vec<KCellCounter>>>, F4: Into<Option<Vec<KCellSerial>>> {
    KCells {
      k: k.into(),
      plain_cells: plain_cells.into(),
      counter_cells: counter_cells.into(),
      serial_cells: serial_cells.into(),
    }
  }
}

impl TSerializable for KCells {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<KCells> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Key> = Some(Vec::new());
    let mut f_2: Option<Vec<KCellPlain>> = Some(Vec::new());
    let mut f_3: Option<Vec<KCellCounter>> = Some(Vec::new());
    let mut f_4: Option<Vec<KCellSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Vec<u8>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_59 = i_prot.read_bytes()?;
            val.push(list_elem_59);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCellPlain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_60 = KCellPlain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_60);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCellCounter> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_61 = KCellCounter::read_from_in_protocol(i_prot)?;
            val.push(list_elem_61);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_62 = KCellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_62);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = KCells {
      k: f_1,
      plain_cells: f_2,
      counter_cells: f_3,
      serial_cells: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("kCells");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.k {
      o_prot.write_field_begin(&TFieldIdentifier::new("k", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_bytes(e)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.plain_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("plain_cells", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.counter_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("counter_cells", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serial_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("serial_cells", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for KCells {
  fn default() -> Self {
    KCells{
      k: Some(Vec::new()),
      plain_cells: Some(Vec::new()),
      counter_cells: Some(Vec::new()),
      serial_cells: Some(Vec::new()),
    }
  }
}

//
// FCellPlain
//

/// The Plain column type Fraction Cell for results on Fraction of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FCellPlain {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Value
  pub v: Option<Vec<u8>>,
}

impl FCellPlain {
  pub fn new<F1, F2, F3>(c: F1, ts: F2, v: F3) -> FCellPlain where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<Vec<u8>>> {
    FCellPlain {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for FCellPlain {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FCellPlain> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<Vec<u8>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bytes()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FCellPlain {
      c: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FCellPlain");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::String, 3))?;
      o_prot.write_bytes(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FCellPlain {
  fn default() -> Self {
    FCellPlain{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// FCellCounter
//

/// The Counter column type Fraction Cell for results on Fraction of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FCellCounter {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Counter Value
  pub v: Option<i64>,
  /// The Counter EQ since ts
  pub eq: Option<i64>,
}

impl FCellCounter {
  pub fn new<F1, F2, F3, F4>(c: F1, ts: F2, v: F3, eq: F4) -> FCellCounter where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<i64>>, F4: Into<Option<i64>> {
    FCellCounter {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
      eq: eq.into(),
    }
  }
}

impl TSerializable for FCellCounter {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FCellCounter> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FCellCounter {
      c: f_1,
      ts: f_2,
      v: f_3,
      eq: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FCellCounter");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.eq {
      o_prot.write_field_begin(&TFieldIdentifier::new("eq", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FCellCounter {
  fn default() -> Self {
    FCellCounter{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(0),
      eq: Some(0),
    }
  }
}

//
// FCellSerial
//

/// The Serial column type Fraction Cell for results on Fraction of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FCellSerial {
  /// The Column Name
  pub c: Option<String>,
  /// The Cell Timestamp
  pub ts: Option<i64>,
  /// The Cell Serial Value
  pub v: Option<CellValuesSerial>,
}

impl FCellSerial {
  pub fn new<F1, F2, F3>(c: F1, ts: F2, v: F3) -> FCellSerial where F1: Into<Option<String>>, F2: Into<Option<i64>>, F3: Into<Option<CellValuesSerial>> {
    FCellSerial {
      c: c.into(),
      ts: ts.into(),
      v: v.into(),
    }
  }
}

impl TSerializable for FCellSerial {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FCellSerial> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i64> = Some(0);
    let mut f_3: Option<CellValuesSerial> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellValueSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_63 = CellValueSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_63);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FCellSerial {
      c: f_1,
      ts: f_2,
      v: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FCellSerial");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.c {
      o_prot.write_field_begin(&TFieldIdentifier::new("c", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.ts {
      o_prot.write_field_begin(&TFieldIdentifier::new("ts", TType::I64, 2))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.v {
      o_prot.write_field_begin(&TFieldIdentifier::new("v", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FCellSerial {
  fn default() -> Self {
    FCellSerial{
      c: Some("".to_owned()),
      ts: Some(0),
      v: Some(Vec::new()),
    }
  }
}

//
// FCells
//

/// The Fraction Cells for results on Fraction of scan
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FCells {
  /// The Fraction Container for the Next Fractions Tree,  defined as FCells items in a map-container by current Fraction bytes
  pub f: Option<BTreeMap<Vec<u8>, Box<FCells>>>,
  /// The current Fraction's Cells, defined as FCellPlain items in a list-container
  pub plain_cells: Option<Vec<FCellPlain>>,
  /// The current Fraction's Cells, defined as FCellCounter items in a list-container
  pub counter_cells: Option<Vec<FCellCounter>>,
  /// The current Fraction's Serial Cells, defined as FCellSerial items in a list-container
  pub serial_cells: Option<Vec<FCellSerial>>,
}

impl FCells {
  pub fn new<F1, F2, F3, F4>(f: F1, plain_cells: F2, counter_cells: F3, serial_cells: F4) -> FCells where F1: Into<Option<BTreeMap<Vec<u8>, Box<FCells>>>>, F2: Into<Option<Vec<FCellPlain>>>, F3: Into<Option<Vec<FCellCounter>>>, F4: Into<Option<Vec<FCellSerial>>> {
    FCells {
      f: f.into(),
      plain_cells: plain_cells.into(),
      counter_cells: counter_cells.into(),
      serial_cells: serial_cells.into(),
    }
  }
}

impl TSerializable for FCells {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<FCells> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<Vec<u8>, Box<FCells>>> = Some(BTreeMap::new());
    let mut f_2: Option<Vec<FCellPlain>> = Some(Vec::new());
    let mut f_3: Option<Vec<FCellCounter>> = Some(Vec::new());
    let mut f_4: Option<Vec<FCellSerial>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<Vec<u8>, Box<FCells>> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_64 = i_prot.read_bytes()?;
            let map_val_65 = Box::new(FCells::read_from_in_protocol(i_prot)?);
            val.insert(map_key_64, map_val_65);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FCellPlain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_66 = FCellPlain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_66);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FCellCounter> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_67 = FCellCounter::read_from_in_protocol(i_prot)?;
            val.push(list_elem_67);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<FCellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_68 = FCellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_68);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FCells {
      f: f_1,
      plain_cells: f_2,
      counter_cells: f_3,
      serial_cells: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FCells");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.f {
      o_prot.write_field_begin(&TFieldIdentifier::new("f", TType::Map, 1))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_bytes(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.plain_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("plain_cells", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.counter_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("counter_cells", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.serial_cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("serial_cells", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FCells {
  fn default() -> Self {
    FCells{
      f: Some(BTreeMap::new()),
      plain_cells: Some(Vec::new()),
      counter_cells: Some(Vec::new()),
      serial_cells: Some(Vec::new()),
    }
  }
}

//
// CellsGroup
//

/// A Grouped Cells result for results of scan, determined by the request's CellsResult enum
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CellsGroup {
  /// The Cells in a list, defined as Cell items in a list-container
  pub cells: Option<Cells>,
  /// The Columns Cells in a map-container, defined as cCells items by Column Name
  pub ccells: Option<CCells>,
  /// The Keys Cells in a list, defined as kCells items in a list-container
  pub kcells: Option<KCells>,
  /// The Fraction Cells in struct FCells
  pub fcells: Option<FCells>,
}

impl CellsGroup {
  pub fn new<F1, F2, F3, F4>(cells: F1, ccells: F2, kcells: F3, fcells: F4) -> CellsGroup where F1: Into<Option<Cells>>, F2: Into<Option<CCells>>, F3: Into<Option<KCells>>, F4: Into<Option<FCells>> {
    CellsGroup {
      cells: cells.into(),
      ccells: ccells.into(),
      kcells: kcells.into(),
      fcells: fcells.into(),
    }
  }
}

impl TSerializable for CellsGroup {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CellsGroup> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Cells> = None;
    let mut f_2: Option<CCells> = Some(BTreeMap::new());
    let mut f_3: Option<KCells> = Some(Vec::new());
    let mut f_4: Option<FCells> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Cells::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, CCells> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_69 = i_prot.read_string()?;
            let map_val_70 = CCells::read_from_in_protocol(i_prot)?;
            val.insert(map_key_69, map_val_70);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCells> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_71 = KCells::read_from_in_protocol(i_prot)?;
            val.push(list_elem_71);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = FCells::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CellsGroup {
      cells: f_1,
      ccells: f_2,
      kcells: f_3,
      fcells: f_4,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CellsGroup");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.ccells {
      o_prot.write_field_begin(&TFieldIdentifier::new("ccells", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.kcells {
      o_prot.write_field_begin(&TFieldIdentifier::new("kcells", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.fcells {
      o_prot.write_field_begin(&TFieldIdentifier::new("fcells", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CellsGroup {
  fn default() -> Self {
    CellsGroup{
      cells: None,
      ccells: Some(BTreeMap::new()),
      kcells: Some(Vec::new()),
      fcells: None,
    }
  }
}

//
// CompactResult
//

/// The Compact Result
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompactResult {
  /// Column ID
  pub cid: Option<i64>,
  /// Error
  pub err: Option<i32>,
}

impl CompactResult {
  pub fn new<F1, F2>(cid: F1, err: F2) -> CompactResult where F1: Into<Option<i64>>, F2: Into<Option<i32>> {
    CompactResult {
      cid: cid.into(),
      err: err.into(),
    }
  }
}

impl TSerializable for CompactResult {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<CompactResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CompactResult {
      cid: f_1,
      err: f_2,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CompactResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.cid {
      o_prot.write_field_begin(&TFieldIdentifier::new("cid", TType::I64, 1))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(fld_var) = self.err {
      o_prot.write_field_begin(&TFieldIdentifier::new("err", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CompactResult {
  fn default() -> Self {
    CompactResult{
      cid: Some(0),
      err: Some(0),
    }
  }
}

//
// Result
//

/// The Result of 'exec_sql'
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Result {
  /// Set with result for 'list columns' query
  pub schemas: Option<Schemas>,
  /// Set with result for 'select' query
  pub cells: Option<Cells>,
  /// Set with result for 'compact columns' query
  pub compact: Option<CompactResults>,
}

impl Result {
  pub fn new<F1, F2, F3>(schemas: F1, cells: F2, compact: F3) -> Result where F1: Into<Option<Schemas>>, F2: Into<Option<Cells>>, F3: Into<Option<CompactResults>> {
    Result {
      schemas: schemas.into(),
      cells: cells.into(),
      compact: compact.into(),
    }
  }
}

impl TSerializable for Result {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Result> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Schemas> = Some(Vec::new());
    let mut f_2: Option<Cells> = None;
    let mut f_3: Option<CompactResults> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Schema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_72 = Schema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_72);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = Cells::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CompactResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_73 = CompactResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_73);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Result {
      schemas: f_1,
      cells: f_2,
      compact: f_3,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Result");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.schemas {
      o_prot.write_field_begin(&TFieldIdentifier::new("schemas", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.cells {
      o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.compact {
      o_prot.write_field_begin(&TFieldIdentifier::new("compact", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Result {
  fn default() -> Self {
    Result{
      schemas: Some(Vec::new()),
      cells: None,
      compact: Some(Vec::new()),
    }
  }
}

pub const TIMESTAMP_NULL: i64 = -9223372036854775807;

pub const TIMESTAMP_AUTO: i64 = -9223372036854775806;

pub const COUNTER_OP_EQUAL: i8 = 1;

pub const FU_CTRL_DEFAULT: i8 = 0;

pub const FU_CTRL_NO_ADD_FIELD: i8 = 1;

pub const FU_CTRL_DELETE_FIELD: i8 = 2;

pub const FU_CTRL_VALUE_SET: i8 = 4;

pub const FU_CTRL_VALUE_DEL: i8 = 8;

//
// Service service client
//

/// The SWC-DB Thrift Service
pub trait TServiceSyncClient {
  /// The direct SQL method to Manage Column.
  fn sql_mng_column(&mut self, sql: String) -> thrift::Result<()>;
  /// The direct SQL method to List Columns
  fn sql_list_columns(&mut self, sql: String) -> thrift::Result<Schemas>;
  /// The direct SQL method to Compact Columns
  fn sql_compact_columns(&mut self, sql: String) -> thrift::Result<CompactResults>;
  /// The direct SQL method to select cells with result in CellsPlain.
  fn sql_select_plain(&mut self, sql: String) -> thrift::Result<CellsPlain>;
  /// The direct SQL method to select cells with result in CellsCounter.
  fn sql_select_counter(&mut self, sql: String) -> thrift::Result<CellsCounter>;
  /// The direct SQL method to select cells with result in CellsSerial.
  fn sql_select_serial(&mut self, sql: String) -> thrift::Result<CellsSerial>;
  /// The direct SQL method to select cells with result in Cells List.
  fn sql_select(&mut self, sql: String) -> thrift::Result<Cells>;
  /// The direct SQL method to select cells with result in Columns Cells map.
  fn sql_select_rslt_on_column(&mut self, sql: String) -> thrift::Result<CCells>;
  /// The direct SQL method to select cells with result in Key Cells list.
  fn sql_select_rslt_on_key(&mut self, sql: String) -> thrift::Result<KCells>;
  /// The direct SQL method to select cells with result in Fractons Cells.
  fn sql_select_rslt_on_fraction(&mut self, sql: String) -> thrift::Result<FCells>;
  /// The SQL method to select cells with result set by the request's type of CellsResult.
  fn sql_query(&mut self, sql: String, rslt: CellsResult) -> thrift::Result<CellsGroup>;
  /// The direct SQL method to update cells optionally to work with updater-id.
  fn sql_update(&mut self, sql: String, updater_id: i64) -> thrift::Result<()>;
  /// The SQL method to execute any query.
  fn exec_sql(&mut self, sql: String) -> thrift::Result<Result>;
  /// The method to Create an Updater ID with buffering size in bytes.
  fn updater_create(&mut self, buffer_size: i32) -> thrift::Result<i64>;
  /// The method to Close an Updater ID.
  fn updater_close(&mut self, id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells-Plain,
  /// optionally to work with updater-id.
  fn update_plain(&mut self, cells: UCCellsPlain, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells-Counter,
  /// optionally to work with updater-id.
  fn update_counter(&mut self, cells: UCCellsCounter, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells-Serial,
  /// optionally to work with updater-id.
  fn update_serial(&mut self, cells: UCCellsSerial, updater_id: i64) -> thrift::Result<()>;
  /// The method is to update cells by several Column-Types,
  /// optionally to work with updater-id.
  fn update_by_types(&mut self, plain: UCCellsPlain, counter: UCCellsCounter, serial: UCCellsSerial, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to Manage Column
  fn mng_column(&mut self, func: SchemaFunc, schema: Schema) -> thrift::Result<()>;
  /// The direct method to List Columns
  fn list_columns(&mut self, spec: SpecSchemas) -> thrift::Result<Schemas>;
  /// The direct method to Compact Columns
  fn compact_columns(&mut self, spec: SpecSchemas) -> thrift::Result<CompactResults>;
  /// The direct method to select cells with result in Cells List.
  fn scan(&mut self, spec: SpecScan) -> thrift::Result<Cells>;
  /// The direct method to select cells with result in Columns Cells map.
  fn scan_rslt_on_column(&mut self, spec: SpecScan) -> thrift::Result<CCells>;
  /// The direct method to select cells with result in Key Cells list.
  fn scan_rslt_on_key(&mut self, spec: SpecScan) -> thrift::Result<KCells>;
  /// The direct method to select cells with result in Fractons Cells.
  fn scan_rslt_on_fraction(&mut self, spec: SpecScan) -> thrift::Result<FCells>;
  /// The method to select cells with result set by the request's type of CellsResult.
  fn scan_rslt_on(&mut self, spec: SpecScan, rslt: CellsResult) -> thrift::Result<CellsGroup>;
}

pub trait TServiceSyncClientMarker {}

pub struct ServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> ServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> ServiceSyncClient<IP, OP> {
    ServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for ServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut dyn TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut dyn TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TServiceSyncClientMarker for ServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TServiceSyncClientMarker> TServiceSyncClient for C {
  fn sql_mng_column(&mut self, sql: String) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlMngColumnArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_mng_column", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlMngColumnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_list_columns(&mut self, sql: String) -> thrift::Result<Schemas> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlListColumnsArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_list_columns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlListColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_compact_columns(&mut self, sql: String) -> thrift::Result<CompactResults> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlCompactColumnsArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_compact_columns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlCompactColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_plain(&mut self, sql: String) -> thrift::Result<CellsPlain> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_plain", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectPlainArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_plain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectPlainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_counter(&mut self, sql: String) -> thrift::Result<CellsCounter> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_counter", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectCounterArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_counter", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectCounterResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_serial(&mut self, sql: String) -> thrift::Result<CellsSerial> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_serial", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectSerialArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_serial", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectSerialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select(&mut self, sql: String) -> thrift::Result<Cells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_rslt_on_column(&mut self, sql: String) -> thrift::Result<CCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectRsltOnColumnArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_rslt_on_column", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectRsltOnColumnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_rslt_on_key(&mut self, sql: String) -> thrift::Result<KCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectRsltOnKeyArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_rslt_on_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectRsltOnKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_select_rslt_on_fraction(&mut self, sql: String) -> thrift::Result<FCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlSelectRsltOnFractionArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_select_rslt_on_fraction", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlSelectRsltOnFractionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_query(&mut self, sql: String, rslt: CellsResult) -> thrift::Result<CellsGroup> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlQueryArgs { sql, rslt };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_query", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlQueryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn sql_update(&mut self, sql: String, updater_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Call, self.sequence_number());
        let call_args = ServiceSqlUpdateArgs { sql, updater_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("sql_update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceSqlUpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn exec_sql(&mut self, sql: String) -> thrift::Result<Result> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Call, self.sequence_number());
        let call_args = ServiceExecSqlArgs { sql };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("exec_sql", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceExecSqlResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn updater_create(&mut self, buffer_size: i32) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdaterCreateArgs { buffer_size };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updater_create", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdaterCreateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn updater_close(&mut self, id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdaterCloseArgs { id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("updater_close", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdaterCloseResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_plain(&mut self, cells: UCCellsPlain, updater_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_plain", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdatePlainArgs { cells, updater_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_plain", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdatePlainResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_counter(&mut self, cells: UCCellsCounter, updater_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_counter", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdateCounterArgs { cells, updater_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_counter", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdateCounterResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_serial(&mut self, cells: UCCellsSerial, updater_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdateSerialArgs { cells, updater_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_serial", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdateSerialResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_by_types(&mut self, plain: UCCellsPlain, counter: UCCellsCounter, serial: UCCellsSerial, updater_id: i64) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("update_by_types", TMessageType::Call, self.sequence_number());
        let call_args = ServiceUpdateByTypesArgs { plain, counter, serial, updater_id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("update_by_types", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceUpdateByTypesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn mng_column(&mut self, func: SchemaFunc, schema: Schema) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Call, self.sequence_number());
        let call_args = ServiceMngColumnArgs { func, schema };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("mng_column", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceMngColumnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn list_columns(&mut self, spec: SpecSchemas) -> thrift::Result<Schemas> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Call, self.sequence_number());
        let call_args = ServiceListColumnsArgs { spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("list_columns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceListColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn compact_columns(&mut self, spec: SpecSchemas) -> thrift::Result<CompactResults> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Call, self.sequence_number());
        let call_args = ServiceCompactColumnsArgs { spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("compact_columns", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceCompactColumnsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan(&mut self, spec: SpecScan) -> thrift::Result<Cells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanArgs { spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_rslt_on_column(&mut self, spec: SpecScan) -> thrift::Result<CCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanRsltOnColumnArgs { spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan_rslt_on_column", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanRsltOnColumnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_rslt_on_key(&mut self, spec: SpecScan) -> thrift::Result<KCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanRsltOnKeyArgs { spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan_rslt_on_key", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanRsltOnKeyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_rslt_on_fraction(&mut self, spec: SpecScan) -> thrift::Result<FCells> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanRsltOnFractionArgs { spec };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan_rslt_on_fraction", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanRsltOnFractionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn scan_rslt_on(&mut self, spec: SpecScan, rslt: CellsResult) -> thrift::Result<CellsGroup> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Call, self.sequence_number());
        let call_args = ServiceScanRsltOnArgs { spec, rslt };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("scan_rslt_on", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ServiceScanRsltOnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// Service service processor
//

/// The SWC-DB Thrift Service
pub trait ServiceSyncHandler {
  /// The direct SQL method to Manage Column.
  fn handle_sql_mng_column(&self, sql: String) -> thrift::Result<()>;
  /// The direct SQL method to List Columns
  fn handle_sql_list_columns(&self, sql: String) -> thrift::Result<Schemas>;
  /// The direct SQL method to Compact Columns
  fn handle_sql_compact_columns(&self, sql: String) -> thrift::Result<CompactResults>;
  /// The direct SQL method to select cells with result in CellsPlain.
  fn handle_sql_select_plain(&self, sql: String) -> thrift::Result<CellsPlain>;
  /// The direct SQL method to select cells with result in CellsCounter.
  fn handle_sql_select_counter(&self, sql: String) -> thrift::Result<CellsCounter>;
  /// The direct SQL method to select cells with result in CellsSerial.
  fn handle_sql_select_serial(&self, sql: String) -> thrift::Result<CellsSerial>;
  /// The direct SQL method to select cells with result in Cells List.
  fn handle_sql_select(&self, sql: String) -> thrift::Result<Cells>;
  /// The direct SQL method to select cells with result in Columns Cells map.
  fn handle_sql_select_rslt_on_column(&self, sql: String) -> thrift::Result<CCells>;
  /// The direct SQL method to select cells with result in Key Cells list.
  fn handle_sql_select_rslt_on_key(&self, sql: String) -> thrift::Result<KCells>;
  /// The direct SQL method to select cells with result in Fractons Cells.
  fn handle_sql_select_rslt_on_fraction(&self, sql: String) -> thrift::Result<FCells>;
  /// The SQL method to select cells with result set by the request's type of CellsResult.
  fn handle_sql_query(&self, sql: String, rslt: CellsResult) -> thrift::Result<CellsGroup>;
  /// The direct SQL method to update cells optionally to work with updater-id.
  fn handle_sql_update(&self, sql: String, updater_id: i64) -> thrift::Result<()>;
  /// The SQL method to execute any query.
  fn handle_exec_sql(&self, sql: String) -> thrift::Result<Result>;
  /// The method to Create an Updater ID with buffering size in bytes.
  fn handle_updater_create(&self, buffer_size: i32) -> thrift::Result<i64>;
  /// The method to Close an Updater ID.
  fn handle_updater_close(&self, id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells-Plain,
  /// optionally to work with updater-id.
  fn handle_update_plain(&self, cells: UCCellsPlain, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells-Counter,
  /// optionally to work with updater-id.
  fn handle_update_counter(&self, cells: UCCellsCounter, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to update cells with cell in Update-Columns-Cells-Serial,
  /// optionally to work with updater-id.
  fn handle_update_serial(&self, cells: UCCellsSerial, updater_id: i64) -> thrift::Result<()>;
  /// The method is to update cells by several Column-Types,
  /// optionally to work with updater-id.
  fn handle_update_by_types(&self, plain: UCCellsPlain, counter: UCCellsCounter, serial: UCCellsSerial, updater_id: i64) -> thrift::Result<()>;
  /// The direct method to Manage Column
  fn handle_mng_column(&self, func: SchemaFunc, schema: Schema) -> thrift::Result<()>;
  /// The direct method to List Columns
  fn handle_list_columns(&self, spec: SpecSchemas) -> thrift::Result<Schemas>;
  /// The direct method to Compact Columns
  fn handle_compact_columns(&self, spec: SpecSchemas) -> thrift::Result<CompactResults>;
  /// The direct method to select cells with result in Cells List.
  fn handle_scan(&self, spec: SpecScan) -> thrift::Result<Cells>;
  /// The direct method to select cells with result in Columns Cells map.
  fn handle_scan_rslt_on_column(&self, spec: SpecScan) -> thrift::Result<CCells>;
  /// The direct method to select cells with result in Key Cells list.
  fn handle_scan_rslt_on_key(&self, spec: SpecScan) -> thrift::Result<KCells>;
  /// The direct method to select cells with result in Fractons Cells.
  fn handle_scan_rslt_on_fraction(&self, spec: SpecScan) -> thrift::Result<FCells>;
  /// The method to select cells with result set by the request's type of CellsResult.
  fn handle_scan_rslt_on(&self, spec: SpecScan, rslt: CellsResult) -> thrift::Result<CellsGroup>;
}

pub struct ServiceSyncProcessor<H: ServiceSyncHandler> {
  handler: H,
}

impl <H: ServiceSyncHandler> ServiceSyncProcessor<H> {
  pub fn new(handler: H) -> ServiceSyncProcessor<H> {
    ServiceSyncProcessor {
      handler,
    }
  }
  fn process_sql_mng_column(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_mng_column(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_list_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_list_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_compact_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_compact_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_plain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_plain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_counter(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_counter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_serial(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_serial(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_rslt_on_column(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_rslt_on_column(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_rslt_on_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_rslt_on_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_select_rslt_on_fraction(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_select_rslt_on_fraction(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_query(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_query(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_sql_update(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_sql_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_exec_sql(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_exec_sql(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_updater_create(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_updater_create(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_updater_close(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_updater_close(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_plain(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_update_plain(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_counter(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_update_counter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_serial(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_update_serial(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_by_types(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_update_by_types(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_mng_column(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_mng_column(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_list_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_list_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_compact_columns(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_compact_columns(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_rslt_on_column(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan_rslt_on_column(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_rslt_on_key(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan_rslt_on_key(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_rslt_on_fraction(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan_rslt_on_fraction(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_scan_rslt_on(&self, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    TServiceProcessFunctions::process_scan_rslt_on(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TServiceProcessFunctions;

impl TServiceProcessFunctions {
  pub fn process_sql_mng_column<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlMngColumnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_mng_column(args.sql) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlMngColumnResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlMngColumnResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_mng_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_list_columns<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlListColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_list_columns(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlListColumnsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlListColumnsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_list_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_compact_columns<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlCompactColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_compact_columns(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlCompactColumnsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlCompactColumnsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_compact_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_plain<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectPlainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_plain(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_plain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectPlainResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectPlainResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_plain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_plain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_plain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_plain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_counter<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectCounterArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_counter(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_counter", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectCounterResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectCounterResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_counter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_counter", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_counter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_counter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_serial<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectSerialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_serial(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_serial", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectSerialResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectSerialResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_serial", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_serial", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_serial", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_serial", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_rslt_on_column<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectRsltOnColumnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_rslt_on_column(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectRsltOnColumnResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectRsltOnColumnResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_rslt_on_key<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectRsltOnKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_rslt_on_key(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectRsltOnKeyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectRsltOnKeyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_select_rslt_on_fraction<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlSelectRsltOnFractionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_select_rslt_on_fraction(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlSelectRsltOnFractionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlSelectRsltOnFractionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_select_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_query<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlQueryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_query(args.sql, args.rslt) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlQueryResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlQueryResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_query", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_sql_update<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceSqlUpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_sql_update(args.sql, args.updater_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceSqlUpdateResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceSqlUpdateResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("sql_update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_exec_sql<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceExecSqlArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_exec_sql(args.sql) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceExecSqlResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceExecSqlResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("exec_sql", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_updater_create<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdaterCreateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_updater_create(args.buffer_size) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdaterCreateResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdaterCreateResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updater_create", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_updater_close<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdaterCloseArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_updater_close(args.id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdaterCloseResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdaterCloseResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("updater_close", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_plain<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdatePlainArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_plain(args.cells, args.updater_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update_plain", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdatePlainResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdatePlainResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_plain", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_plain", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_plain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_plain", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_counter<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdateCounterArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_counter(args.cells, args.updater_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update_counter", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdateCounterResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdateCounterResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_counter", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_counter", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_counter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_counter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_serial<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdateSerialArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_serial(args.cells, args.updater_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdateSerialResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdateSerialResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_serial", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_by_types<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceUpdateByTypesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_by_types(args.plain, args.counter, args.serial, args.updater_id) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("update_by_types", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceUpdateByTypesResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceUpdateByTypesResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("update_by_types", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("update_by_types", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("update_by_types", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("update_by_types", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_mng_column<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceMngColumnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_mng_column(args.func, args.schema) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceMngColumnResult { e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceMngColumnResult{ e: Some(*err) };
              let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("mng_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_list_columns<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceListColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_list_columns(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceListColumnsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceListColumnsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("list_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_compact_columns<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceCompactColumnsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_compact_columns(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceCompactColumnsResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceCompactColumnsResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("compact_columns", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("scan", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("scan", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_rslt_on_column<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanRsltOnColumnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_rslt_on_column(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanRsltOnColumnResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanRsltOnColumnResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("scan_rslt_on_column", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_rslt_on_key<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanRsltOnKeyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_rslt_on_key(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanRsltOnKeyResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanRsltOnKeyResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("scan_rslt_on_key", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_rslt_on_fraction<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanRsltOnFractionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_rslt_on_fraction(args.spec) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanRsltOnFractionResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanRsltOnFractionResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("scan_rslt_on_fraction", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_scan_rslt_on<H: ServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let args = ServiceScanRsltOnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_scan_rslt_on(args.spec, args.rslt) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ServiceScanRsltOnResult { result_value: Some(handler_return), e: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<Exception>().is_some() {
              let err = usr_err.downcast::<Exception>().expect("downcast already checked");
              let ret_err = ServiceScanRsltOnResult{ result_value: None, e: Some(*err) };
              let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.to_string()
                )
              };
              let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.to_string()
              )
            };
            let message_ident = TMessageIdentifier::new("scan_rslt_on", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: ServiceSyncHandler> TProcessor for ServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut dyn TInputProtocol, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "sql_mng_column" => {
        self.process_sql_mng_column(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_list_columns" => {
        self.process_sql_list_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_compact_columns" => {
        self.process_sql_compact_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_plain" => {
        self.process_sql_select_plain(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_counter" => {
        self.process_sql_select_counter(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_serial" => {
        self.process_sql_select_serial(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select" => {
        self.process_sql_select(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_rslt_on_column" => {
        self.process_sql_select_rslt_on_column(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_rslt_on_key" => {
        self.process_sql_select_rslt_on_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_select_rslt_on_fraction" => {
        self.process_sql_select_rslt_on_fraction(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_query" => {
        self.process_sql_query(message_ident.sequence_number, i_prot, o_prot)
      },
      "sql_update" => {
        self.process_sql_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "exec_sql" => {
        self.process_exec_sql(message_ident.sequence_number, i_prot, o_prot)
      },
      "updater_create" => {
        self.process_updater_create(message_ident.sequence_number, i_prot, o_prot)
      },
      "updater_close" => {
        self.process_updater_close(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_plain" => {
        self.process_update_plain(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_counter" => {
        self.process_update_counter(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_serial" => {
        self.process_update_serial(message_ident.sequence_number, i_prot, o_prot)
      },
      "update_by_types" => {
        self.process_update_by_types(message_ident.sequence_number, i_prot, o_prot)
      },
      "mng_column" => {
        self.process_mng_column(message_ident.sequence_number, i_prot, o_prot)
      },
      "list_columns" => {
        self.process_list_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "compact_columns" => {
        self.process_compact_columns(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan" => {
        self.process_scan(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan_rslt_on_column" => {
        self.process_scan_rslt_on_column(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan_rslt_on_key" => {
        self.process_scan_rslt_on_key(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan_rslt_on_fraction" => {
        self.process_scan_rslt_on_fraction(message_ident.sequence_number, i_prot, o_prot)
      },
      "scan_rslt_on" => {
        self.process_scan_rslt_on(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// ServiceSqlMngColumnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlMngColumnArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlMngColumnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlMngColumnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlMngColumnArgs.sql", &f_1)?;
    let ret = ServiceSqlMngColumnArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_mng_column_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlMngColumnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlMngColumnResult {
  e: Option<Exception>,
}

impl ServiceSqlMngColumnResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlMngColumnResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlMngColumnResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlMngColumnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlListColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlListColumnsArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlListColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlListColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlListColumnsArgs.sql", &f_1)?;
    let ret = ServiceSqlListColumnsArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_list_columns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlListColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlListColumnsResult {
  result_value: Option<Schemas>,
  e: Option<Exception>,
}

impl ServiceSqlListColumnsResult {
  fn ok_or(self) -> thrift::Result<Schemas> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlListColumns"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlListColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Schemas> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Schema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_74 = Schema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_74);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlListColumnsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlListColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlCompactColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlCompactColumnsArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlCompactColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlCompactColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlCompactColumnsArgs.sql", &f_1)?;
    let ret = ServiceSqlCompactColumnsArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_compact_columns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlCompactColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlCompactColumnsResult {
  result_value: Option<CompactResults>,
  e: Option<Exception>,
}

impl ServiceSqlCompactColumnsResult {
  fn ok_or(self) -> thrift::Result<CompactResults> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlCompactColumns"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlCompactColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CompactResults> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CompactResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_75 = CompactResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_75);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlCompactColumnsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlCompactColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectPlainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectPlainArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectPlainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectPlainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectPlainArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectPlainArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_plain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectPlainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectPlainResult {
  result_value: Option<CellsPlain>,
  e: Option<Exception>,
}

impl ServiceSqlSelectPlainResult {
  fn ok_or(self) -> thrift::Result<CellsPlain> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectPlain"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectPlainResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CellsPlain> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellPlain> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_76 = CellPlain::read_from_in_protocol(i_prot)?;
            val.push(list_elem_76);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectPlainResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectPlainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectCounterArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectCounterArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectCounterArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectCounterArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectCounterArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectCounterArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_counter_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectCounterResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectCounterResult {
  result_value: Option<CellsCounter>,
  e: Option<Exception>,
}

impl ServiceSqlSelectCounterResult {
  fn ok_or(self) -> thrift::Result<CellsCounter> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectCounter"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectCounterResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CellsCounter> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellCounter> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_77 = CellCounter::read_from_in_protocol(i_prot)?;
            val.push(list_elem_77);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectCounterResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectCounterResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectSerialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectSerialArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectSerialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectSerialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectSerialArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectSerialArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_serial_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectSerialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectSerialResult {
  result_value: Option<CellsSerial>,
  e: Option<Exception>,
}

impl ServiceSqlSelectSerialResult {
  fn ok_or(self) -> thrift::Result<CellsSerial> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectSerial"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectSerialResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CellsSerial> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CellSerial> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_78 = CellSerial::read_from_in_protocol(i_prot)?;
            val.push(list_elem_78);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectSerialResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectSerialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectResult {
  result_value: Option<Cells>,
  e: Option<Exception>,
}

impl ServiceSqlSelectResult {
  fn ok_or(self) -> thrift::Result<Cells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelect"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Cells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Cells::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnColumnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnColumnArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectRsltOnColumnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnColumnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectRsltOnColumnArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectRsltOnColumnArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_rslt_on_column_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnColumnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnColumnResult {
  result_value: Option<CCells>,
  e: Option<Exception>,
}

impl ServiceSqlSelectRsltOnColumnResult {
  fn ok_or(self) -> thrift::Result<CCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectRsltOnColumn"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnColumnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, CCells> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_79 = i_prot.read_string()?;
            let map_val_80 = CCells::read_from_in_protocol(i_prot)?;
            val.insert(map_key_79, map_val_80);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectRsltOnColumnResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectRsltOnColumnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnKeyArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectRsltOnKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectRsltOnKeyArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectRsltOnKeyArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_rslt_on_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnKeyResult {
  result_value: Option<KCells>,
  e: Option<Exception>,
}

impl ServiceSqlSelectRsltOnKeyResult {
  fn ok_or(self) -> thrift::Result<KCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectRsltOnKey"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<KCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCells> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_81 = KCells::read_from_in_protocol(i_prot)?;
            val.push(list_elem_81);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectRsltOnKeyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectRsltOnKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnFractionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnFractionArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceSqlSelectRsltOnFractionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnFractionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlSelectRsltOnFractionArgs.sql", &f_1)?;
    let ret = ServiceSqlSelectRsltOnFractionArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_select_rslt_on_fraction_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlSelectRsltOnFractionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlSelectRsltOnFractionResult {
  result_value: Option<FCells>,
  e: Option<Exception>,
}

impl ServiceSqlSelectRsltOnFractionResult {
  fn ok_or(self) -> thrift::Result<FCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlSelectRsltOnFraction"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlSelectRsltOnFractionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FCells::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlSelectRsltOnFractionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlSelectRsltOnFractionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlQueryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlQueryArgs {
  /// The SQL string to Execute
  sql: String,
  /// The Type of Cells Result for the response
  rslt: CellsResult,
}

impl ServiceSqlQueryArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlQueryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<CellsResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = CellsResult::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlQueryArgs.sql", &f_1)?;
    verify_required_field_exists("ServiceSqlQueryArgs.rslt", &f_2)?;
    let ret = ServiceSqlQueryArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
      rslt: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_query_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rslt", TType::I32, 2))?;
    self.rslt.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlQueryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlQueryResult {
  result_value: Option<CellsGroup>,
  e: Option<Exception>,
}

impl ServiceSqlQueryResult {
  fn ok_or(self) -> thrift::Result<CellsGroup> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceSqlQuery"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlQueryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CellsGroup> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CellsGroup::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlQueryResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlQueryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlUpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlUpdateArgs {
  /// The SQL string to Execute
  sql: String,
  /// The Updater ID to work with
  updater_id: i64,
}

impl ServiceSqlUpdateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlUpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceSqlUpdateArgs.sql", &f_1)?;
    verify_required_field_exists("ServiceSqlUpdateArgs.updater_id", &f_2)?;
    let ret = ServiceSqlUpdateArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
      updater_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("sql_update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updater_id", TType::I64, 2))?;
    o_prot.write_i64(self.updater_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceSqlUpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceSqlUpdateResult {
  e: Option<Exception>,
}

impl ServiceSqlUpdateResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceSqlUpdateResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceSqlUpdateResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceSqlUpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceExecSqlArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceExecSqlArgs {
  /// The SQL string to Execute
  sql: String,
}

impl ServiceExecSqlArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceExecSqlArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceExecSqlArgs.sql", &f_1)?;
    let ret = ServiceExecSqlArgs {
      sql: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("exec_sql_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sql", TType::String, 1))?;
    o_prot.write_string(&self.sql)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceExecSqlResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceExecSqlResult {
  result_value: Option<Result>,
  e: Option<Exception>,
}

impl ServiceExecSqlResult {
  fn ok_or(self) -> thrift::Result<Result> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceExecSql"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceExecSqlResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Result> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Result::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceExecSqlResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceExecSqlResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdaterCreateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdaterCreateArgs {
  /// The buffer size of the Updater
  buffer_size: i32,
}

impl ServiceUpdaterCreateArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdaterCreateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdaterCreateArgs.buffer_size", &f_1)?;
    let ret = ServiceUpdaterCreateArgs {
      buffer_size: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updater_create_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("buffer_size", TType::I32, 1))?;
    o_prot.write_i32(self.buffer_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdaterCreateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdaterCreateResult {
  result_value: Option<i64>,
  e: Option<Exception>,
}

impl ServiceUpdaterCreateResult {
  fn ok_or(self) -> thrift::Result<i64> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceUpdaterCreate"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdaterCreateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdaterCreateResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdaterCreateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdaterCloseArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdaterCloseArgs {
  /// The Updater ID to close
  id: i64,
}

impl ServiceUpdaterCloseArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdaterCloseArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdaterCloseArgs.id", &f_1)?;
    let ret = ServiceUpdaterCloseArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("updater_close_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::I64, 1))?;
    o_prot.write_i64(self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdaterCloseResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdaterCloseResult {
  e: Option<Exception>,
}

impl ServiceUpdaterCloseResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdaterCloseResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdaterCloseResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdaterCloseResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdatePlainArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdatePlainArgs {
  /// The Cells to update
  cells: UCCellsPlain,
  /// The Updater ID to use for write
  updater_id: i64,
}

impl ServiceUpdatePlainArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdatePlainArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UCCellsPlain> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, UCellsPlain> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_82 = i_prot.read_i64()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_83: Vec<UCellPlain> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_84 = UCellPlain::read_from_in_protocol(i_prot)?;
              map_val_83.push(list_elem_84);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_82, map_val_83);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdatePlainArgs.cells", &f_1)?;
    verify_required_field_exists("ServiceUpdatePlainArgs.updater_id", &f_2)?;
    let ret = ServiceUpdatePlainArgs {
      cells: f_1.expect("auto-generated code should have checked for presence of required fields"),
      updater_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_plain_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::List, self.cells.len() as i32))?;
    for (k, v) in &self.cells {
      o_prot.write_i64(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updater_id", TType::I64, 2))?;
    o_prot.write_i64(self.updater_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdatePlainResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdatePlainResult {
  e: Option<Exception>,
}

impl ServiceUpdatePlainResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdatePlainResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdatePlainResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdatePlainResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdateCounterArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateCounterArgs {
  /// The Counter Cells to update
  cells: UCCellsCounter,
  /// The Updater ID to use for write
  updater_id: i64,
}

impl ServiceUpdateCounterArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateCounterArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UCCellsCounter> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, UCellsCounter> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_85 = i_prot.read_i64()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_86: Vec<UCellCounter> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_87 = UCellCounter::read_from_in_protocol(i_prot)?;
              map_val_86.push(list_elem_87);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_85, map_val_86);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdateCounterArgs.cells", &f_1)?;
    verify_required_field_exists("ServiceUpdateCounterArgs.updater_id", &f_2)?;
    let ret = ServiceUpdateCounterArgs {
      cells: f_1.expect("auto-generated code should have checked for presence of required fields"),
      updater_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_counter_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::List, self.cells.len() as i32))?;
    for (k, v) in &self.cells {
      o_prot.write_i64(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updater_id", TType::I64, 2))?;
    o_prot.write_i64(self.updater_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdateCounterResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateCounterResult {
  e: Option<Exception>,
}

impl ServiceUpdateCounterResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateCounterResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdateCounterResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdateCounterResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdateSerialArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateSerialArgs {
  /// The Serial Cells to update
  cells: UCCellsSerial,
  /// The Updater ID to use for write
  updater_id: i64,
}

impl ServiceUpdateSerialArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateSerialArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UCCellsSerial> = None;
    let mut f_2: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, UCellsSerial> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_88 = i_prot.read_i64()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_89: Vec<UCellSerial> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_90 = UCellSerial::read_from_in_protocol(i_prot)?;
              map_val_89.push(list_elem_90);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_88, map_val_89);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdateSerialArgs.cells", &f_1)?;
    verify_required_field_exists("ServiceUpdateSerialArgs.updater_id", &f_2)?;
    let ret = ServiceUpdateSerialArgs {
      cells: f_1.expect("auto-generated code should have checked for presence of required fields"),
      updater_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_serial_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cells", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::List, self.cells.len() as i32))?;
    for (k, v) in &self.cells {
      o_prot.write_i64(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updater_id", TType::I64, 2))?;
    o_prot.write_i64(self.updater_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdateSerialResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateSerialResult {
  e: Option<Exception>,
}

impl ServiceUpdateSerialResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateSerialResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdateSerialResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdateSerialResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdateByTypesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateByTypesArgs {
  /// The PLAIN Cells to update
  plain: UCCellsPlain,
  /// The COUNTER Cells to update
  counter: UCCellsCounter,
  /// The SERIAL Cells to update
  serial: UCCellsSerial,
  /// The Updater ID to use for write
  updater_id: i64,
}

impl ServiceUpdateByTypesArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateByTypesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<UCCellsPlain> = None;
    let mut f_2: Option<UCCellsCounter> = None;
    let mut f_3: Option<UCCellsSerial> = None;
    let mut f_4: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, UCellsPlain> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_91 = i_prot.read_i64()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_92: Vec<UCellPlain> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_93 = UCellPlain::read_from_in_protocol(i_prot)?;
              map_val_92.push(list_elem_93);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_91, map_val_92);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, UCellsCounter> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_94 = i_prot.read_i64()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_95: Vec<UCellCounter> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_96 = UCellCounter::read_from_in_protocol(i_prot)?;
              map_val_95.push(list_elem_96);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_94, map_val_95);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<i64, UCellsSerial> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_97 = i_prot.read_i64()?;
            let list_ident = i_prot.read_list_begin()?;
            let mut map_val_98: Vec<UCellSerial> = Vec::with_capacity(list_ident.size as usize);
            for _ in 0..list_ident.size {
              let list_elem_99 = UCellSerial::read_from_in_protocol(i_prot)?;
              map_val_98.push(list_elem_99);
            }
            i_prot.read_list_end()?;
            val.insert(map_key_97, map_val_98);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceUpdateByTypesArgs.plain", &f_1)?;
    verify_required_field_exists("ServiceUpdateByTypesArgs.counter", &f_2)?;
    verify_required_field_exists("ServiceUpdateByTypesArgs.serial", &f_3)?;
    verify_required_field_exists("ServiceUpdateByTypesArgs.updater_id", &f_4)?;
    let ret = ServiceUpdateByTypesArgs {
      plain: f_1.expect("auto-generated code should have checked for presence of required fields"),
      counter: f_2.expect("auto-generated code should have checked for presence of required fields"),
      serial: f_3.expect("auto-generated code should have checked for presence of required fields"),
      updater_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("update_by_types_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("plain", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::List, self.plain.len() as i32))?;
    for (k, v) in &self.plain {
      o_prot.write_i64(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("counter", TType::Map, 2))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::List, self.counter.len() as i32))?;
    for (k, v) in &self.counter {
      o_prot.write_i64(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serial", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::I64, TType::List, self.serial.len() as i32))?;
    for (k, v) in &self.serial {
      o_prot.write_i64(*k)?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, v.len() as i32))?;
      for e in v {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
    }
    o_prot.write_map_end()?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updater_id", TType::I64, 4))?;
    o_prot.write_i64(self.updater_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceUpdateByTypesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceUpdateByTypesResult {
  e: Option<Exception>,
}

impl ServiceUpdateByTypesResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceUpdateByTypesResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceUpdateByTypesResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceUpdateByTypesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceMngColumnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceMngColumnArgs {
  /// The Action Function to use
  func: SchemaFunc,
  /// The Schema for the Action
  schema: Schema,
}

impl ServiceMngColumnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceMngColumnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SchemaFunc> = None;
    let mut f_2: Option<Schema> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SchemaFunc::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = Schema::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceMngColumnArgs.func", &f_1)?;
    verify_required_field_exists("ServiceMngColumnArgs.schema", &f_2)?;
    let ret = ServiceMngColumnArgs {
      func: f_1.expect("auto-generated code should have checked for presence of required fields"),
      schema: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("mng_column_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("func", TType::I32, 1))?;
    self.func.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("schema", TType::Struct, 2))?;
    self.schema.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceMngColumnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceMngColumnResult {
  e: Option<Exception>,
}

impl ServiceMngColumnResult {
  fn ok_or(self) -> thrift::Result<()> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else {
      Ok(())
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceMngColumnResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceMngColumnResult {
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceMngColumnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceListColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceListColumnsArgs {
  /// The Schemas Specifications to match Schema for response
  spec: SpecSchemas,
}

impl ServiceListColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceListColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecSchemas> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecSchemas::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceListColumnsArgs.spec", &f_1)?;
    let ret = ServiceListColumnsArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("list_columns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceListColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceListColumnsResult {
  result_value: Option<Schemas>,
  e: Option<Exception>,
}

impl ServiceListColumnsResult {
  fn ok_or(self) -> thrift::Result<Schemas> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceListColumns"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceListColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Schemas> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Schema> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_100 = Schema::read_from_in_protocol(i_prot)?;
            val.push(list_elem_100);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceListColumnsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceListColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceCompactColumnsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceCompactColumnsArgs {
  /// The Schemas Specifications to match columns to Compact
  spec: SpecSchemas,
}

impl ServiceCompactColumnsArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceCompactColumnsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecSchemas> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecSchemas::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceCompactColumnsArgs.spec", &f_1)?;
    let ret = ServiceCompactColumnsArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("compact_columns_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceCompactColumnsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceCompactColumnsResult {
  result_value: Option<CompactResults>,
  e: Option<Exception>,
}

impl ServiceCompactColumnsResult {
  fn ok_or(self) -> thrift::Result<CompactResults> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceCompactColumns"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceCompactColumnsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CompactResults> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<CompactResult> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_101 = CompactResult::read_from_in_protocol(i_prot)?;
            val.push(list_elem_101);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceCompactColumnsResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceCompactColumnsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
}

impl ServiceScanArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanArgs.spec", &f_1)?;
    let ret = ServiceScanArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanResult {
  result_value: Option<Cells>,
  e: Option<Exception>,
}

impl ServiceScanResult {
  fn ok_or(self) -> thrift::Result<Cells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScan"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Cells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = Cells::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnColumnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnColumnArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
}

impl ServiceScanRsltOnColumnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnColumnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanRsltOnColumnArgs.spec", &f_1)?;
    let ret = ServiceScanRsltOnColumnArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_rslt_on_column_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnColumnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnColumnResult {
  result_value: Option<CCells>,
  e: Option<Exception>,
}

impl ServiceScanRsltOnColumnResult {
  fn ok_or(self) -> thrift::Result<CCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScanRsltOnColumn"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnColumnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, CCells> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_102 = i_prot.read_string()?;
            let map_val_103 = CCells::read_from_in_protocol(i_prot)?;
            val.insert(map_key_102, map_val_103);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanRsltOnColumnResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanRsltOnColumnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_map_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnKeyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnKeyArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
}

impl ServiceScanRsltOnKeyArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnKeyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanRsltOnKeyArgs.spec", &f_1)?;
    let ret = ServiceScanRsltOnKeyArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_rslt_on_key_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnKeyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnKeyResult {
  result_value: Option<KCells>,
  e: Option<Exception>,
}

impl ServiceScanRsltOnKeyResult {
  fn ok_or(self) -> thrift::Result<KCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScanRsltOnKey"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnKeyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<KCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<KCells> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_104 = KCells::read_from_in_protocol(i_prot)?;
            val.push(list_elem_104);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanRsltOnKeyResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanRsltOnKeyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
      }
      o_prot.write_list_end()?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnFractionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnFractionArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
}

impl ServiceScanRsltOnFractionArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnFractionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanRsltOnFractionArgs.spec", &f_1)?;
    let ret = ServiceScanRsltOnFractionArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_rslt_on_fraction_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnFractionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnFractionResult {
  result_value: Option<FCells>,
  e: Option<Exception>,
}

impl ServiceScanRsltOnFractionResult {
  fn ok_or(self) -> thrift::Result<FCells> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScanRsltOnFraction"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnFractionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<FCells> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = FCells::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanRsltOnFractionResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanRsltOnFractionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnArgs {
  /// The Scan Specifications for the scan
  spec: SpecScan,
  /// The Type of Cells Result for the response
  rslt: CellsResult,
}

impl ServiceScanRsltOnArgs {
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<SpecScan> = None;
    let mut f_2: Option<CellsResult> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = SpecScan::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = CellsResult::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ServiceScanRsltOnArgs.spec", &f_1)?;
    verify_required_field_exists("ServiceScanRsltOnArgs.rslt", &f_2)?;
    let ret = ServiceScanRsltOnArgs {
      spec: f_1.expect("auto-generated code should have checked for presence of required fields"),
      rslt: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("scan_rslt_on_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("spec", TType::Struct, 1))?;
    self.spec.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rslt", TType::I32, 2))?;
    self.rslt.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ServiceScanRsltOnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ServiceScanRsltOnResult {
  result_value: Option<CellsGroup>,
  /// The Base Exception
  e: Option<Exception>,
}

impl ServiceScanRsltOnResult {
  fn ok_or(self) -> thrift::Result<CellsGroup> {
    if self.e.is_some() {
      Err(thrift::Error::User(Box::new(self.e.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ServiceScanRsltOn"
          )
        )
      )
    }
  }
  fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<ServiceScanRsltOnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<CellsGroup> = None;
    let mut f_1: Option<Exception> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = CellsGroup::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = Exception::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ServiceScanRsltOnResult {
      result_value: f_0,
      e: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ServiceScanRsltOnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    if let Some(ref fld_var) = self.e {
      o_prot.write_field_begin(&TFieldIdentifier::new("e", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

