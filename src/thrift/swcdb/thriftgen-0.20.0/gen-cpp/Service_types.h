/**
 * Autogenerated by Thrift Compiler (0.20.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Service_TYPES_H
#define Service_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <functional>
#include <memory>


namespace SWC { namespace Thrift {

/**
 * Column Key Sequences
 */
struct KeySeq {
  enum type {
    /**
     * Unknown/Unrecognized Type
     */
    UNKNOWN = 0,
    /**
     * The Lexical Key Order Sequence
     */
    LEXIC = 1,
    /**
     * The Volumetric Key Order Sequence
     */
    VOLUME = 2,
    /**
     * The by Fractions Count on Lexical Key Order Sequence
     */
    FC_LEXIC = 3,
    /**
     * The by Fractions Count on Volumetric Key Order Sequence
     */
    FC_VOLUME = 4
  };
};

extern const std::map<int, const char*> _KeySeq_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const KeySeq::type& val);

std::string to_string(const KeySeq::type& val);

/**
 * Column Value Types
 */
struct ColumnType {
  enum type {
    /**
     * Unknown/Unrecognized Type
     */
    UNKNOWN = 0,
    /**
     * A Plain Column Value
     */
    PLAIN = 1,
    /**
     * A Counter Column Value with integrity of signed-64bit
     */
    COUNTER_I64 = 2,
    /**
     * A Counter Column Value with integrity of signed-32bit
     */
    COUNTER_I32 = 3,
    /**
     * A Counter Column Value with integrity of signed-16bit
     */
    COUNTER_I16 = 4,
    /**
     * A Counter Column Value with integrity of signed-8bit
     */
    COUNTER_I8 = 5,
    /**
     * A Serial Column Value
     */
    SERIAL = 6,
    /**
     * Not used - experimental
     */
    CELL_DEFINED = 15
  };
};

extern const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val);

std::string to_string(const ColumnType::type& val);

/**
 * Data Encoding Types
 */
struct EncodingType {
  enum type {
    /**
     * Encoding by Ranger DEFAULT configurations
     */
    DEFAULT = 0,
    /**
     * No Encoding
     */
    PLAIN = 1,
    /**
     * Encode with zlib
     */
    ZLIB = 2,
    /**
     * Encode with snappy
     */
    SNAPPY = 3,
    /**
     * Encode with zstandard
     */
    ZSTD = 4,
    /**
     * Unrecognized Type
     */
    UNKNOWN = 255
  };
};

extern const std::map<int, const char*> _EncodingType_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const EncodingType::type& val);

std::string to_string(const EncodingType::type& val);

/**
 * Manage Columns schema function Flags
 */
struct SchemaFunc {
  enum type {
    /**
     * Create Column Function
     */
    CREATE = 3,
    /**
     * Delete Column Function
     */
    REMOVE = 5,
    /**
     * Modify Column Function
     */
    MODIFY = 7
  };
};

extern const std::map<int, const char*> _SchemaFunc_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SchemaFunc::type& val);

std::string to_string(const SchemaFunc::type& val);

/**
 * The available logical Comparators, plus extended logic options applied with 'v' for VOLUME
 */
struct Comp {
  enum type {
    /**
     * [         ]  :   none               (no comparison applied)
     */
    NONE = 0,
    /**
     * [  =^     ]  :   -pf [prefix]       (starts-with)
     */
    PF = 1,
    /**
     * [ &gt;    ]  :   -gt                (greater-than)
     */
    GT = 2,
    /**
     * [ &gt;=   ]  :   -ge                (greater-equal)
     */
    GE = 3,
    /**
     * [  =      ]  :   -eq                (equal)
     */
    EQ = 4,
    /**
     * [ &lt;=   ]  :   -le                (lower-equal)
     */
    LE = 5,
    /**
     * [ &lt;    ]  :   -lt                (lower-than)
     */
    LT = 6,
    /**
     * [  !=     ]  :   -ne                (not-equal)
     */
    NE = 7,
    /**
     * [  re     ]  :   -re [r,regexp]     (regular-expression)
     */
    RE = 8,
    /**
     * [ v&gt;   ]  :   -vgt               (vol greater-than)
     */
    VGT = 9,
    /**
     * [ v&gt;=  ]  :   -vge               (vol greater-equal)
     */
    VGE = 10,
    /**
     * [ v&lt;=  ]  :   -vle               (vol lower-equal)
     */
    VLE = 11,
    /**
     * [ v&lt;   ]  :   -vlt               (vol lower-than)
     */
    VLT = 12,
    /**
     * [ %&gt;   ]  :   -subset [sbs]      (subset)
     */
    SBS = 13,
    /**
     * [ &lt;%   ]  :   -supset [sps]      (superset)
     */
    SPS = 14,
    /**
     * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
     */
    POSBS = 15,
    /**
     * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
     */
    POSPS = 16,
    /**
     * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
     */
    FOSBS = 17,
    /**
     * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
     */
    FOSPS = 18,
    /**
     * [ :&lt;   ]  :   -fip  (fraction include prior)
     */
    FIP = 19,
    /**
     * [ :       ]  :   -fi   (fraction include)
     */
    FI = 20,
    /**
     * [ ||      ]  :   -or   (match any)
     */
    OR = 21
  };
};

extern const std::map<int, const char*> _Comp_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Comp::type& val);

std::string to_string(const Comp::type& val);

/**
 * The Scan options Flags Specifications for the SpecFlags 'options' bit
 */
struct SpecFlagsOpt {
  enum type {
    /**
     * No Flag Applied
     */
    NONE = 0,
    /**
     * Cells Limit by Keys
     */
    LIMIT_BY_KEYS = 1,
    /**
     * Cells Offset by Keys
     */
    OFFSET_BY_KEYS = 4,
    /**
     * Select Cells Only Keys without Value data
     */
    ONLY_KEYS = 8,
    /**
     * Select Cells Only with DELETE(cell-flag)
     */
    ONLY_DELETES = 10
  };
};

extern const std::map<int, const char*> _SpecFlagsOpt_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SpecFlagsOpt::type& val);

std::string to_string(const SpecFlagsOpt::type& val);

struct UpdateOP {
  enum type {
    /**
     * The OP supported by column-types: PLAIN, SERIAL, COUNTER. Replaces with the update value (_default as well if other OP not supported by the col-type_)
     */
    REPLACE = 0,
    /**
     * The OP supported by column-types: PLAIN, SERIAL. Appends the update value to the cell's current
     */
    APPEND = 1,
    /**
     * The OP supported by column-types: PLAIN, SERIAL. Prepends the update value to the cell's current
     */
    PREPEND = 2,
    /**
     * The OP supported by column-type PLAIN. Inserts the update value at position in current value (appends if pos above value)
     */
    INSERT = 3,
    /**
     * The OP supported by column-type PLAIN. Overwrites the current value at position with new value (appends if pos above value)
     */
    OVERWRITE = 4,
    /**
     * The OP supported by column-type SERIAL. update is done by the inner serial-fields defintions
     */
    SERIAL = 5
  };
};

extern const std::map<int, const char*> _UpdateOP_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const UpdateOP::type& val);

std::string to_string(const UpdateOP::type& val);

/**
 * The Scan Interval Specs Options for the SpecIntervalPlain, SpecIntervalCounter and SpecIntervalSerial 'options' bit
 */
struct SpecIntervalOptions {
  enum type {
    /**
     * Update Bit Option
     */
    UPDATING = 4,
    /**
     * Delete Bit Option
     */
    DELETING = 8
  };
};

extern const std::map<int, const char*> _SpecIntervalOptions_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const SpecIntervalOptions::type& val);

std::string to_string(const SpecIntervalOptions::type& val);

/**
 * The Cell Flag
 */
struct Flag {
  enum type {
    /**
     * Unknown/Undefined
     */
    NONE = 0,
    /**
     * The Cell is an insert
     */
    INSERT = 1,
    /**
     * The Cell is a delete versions lower-equal
     */
    DELETE_LE = 2,
    /**
     * The Cell is a  delete version equal
     */
    DELETE_EQ = 3
  };
};

extern const std::map<int, const char*> _Flag_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const Flag::type& val);

std::string to_string(const Flag::type& val);

/**
 * MATH Operations for Serial Field Update of types INT64 and DOUBLE
 */
struct FU_MATH_OP {
  enum type {
    /**
     * set field value to the new value
     */
    EQUAL = 0,
    /**
     * plus new value to field's value (negative number allowed)
     */
    PLUS = 1,
    /**
     * multiply current value by update value
     */
    MULTIPLY = 2,
    /**
     * divide current value by the new value (ignored at zero)
     */
    DIVIDE = 3
  };
};

extern const std::map<int, const char*> _FU_MATH_OP_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FU_MATH_OP::type& val);

std::string to_string(const FU_MATH_OP::type& val);

/**
 * LIST Operations for Serial Field Update of array/list/bytes with LIST-op in the inner SERIAL fields
 */
struct FU_LIST_OP {
  enum type {
    /**
     * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Replaces with the update value
     */
    REPLACE = 0,
    /**
     * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Appends the update value to a field value
     */
    APPEND = 1,
    /**
     * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Prepends the update value to a field value
     */
    PREPEND = 2,
    /**
     * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Insert the update value at position in a field value (appends if pos above value)
     */
    INSERT = 3,
    /**
     * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Overwrites a field value at position with new value (appends if pos above value)
     */
    OVERWRITE = 4,
    /**
     * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Erases the position in a field value
     */
    ERASE = 5,
    /**
     * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP
     */
    BY_UNIQUE = 6,
    /**
     * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP and Comparator
     */
    BY_COND = 7,
    /**
     * Supported by field-types: LIST_BYTES, LIST_INT64. The field value is with Postion and OP in items
     */
    BY_INDEX = 8
  };
};

extern const std::map<int, const char*> _FU_LIST_OP_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const FU_LIST_OP::type& val);

std::string to_string(const FU_LIST_OP::type& val);

/**
 * The Cells Results types for using with CellsGroup requests
 */
struct CellsResult {
  enum type {
    /**
     * Correspond to result on Cells (Cells in list)
     */
    IN_LIST = 0,
    /**
     * Correspond to result on CCells (Columns Cells)
     */
    ON_COLUMN = 1,
    /**
     * Correspond to result on KCells (Keys Cells)
     */
    ON_KEY = 2,
    /**
     * Correspond to result on FCells (Fraction Cells)
     */
    ON_FRACTION = 3
  };
};

extern const std::map<int, const char*> _CellsResult_VALUES_TO_NAMES;

std::ostream& operator<<(std::ostream& out, const CellsResult::type& val);

std::string to_string(const CellsResult::type& val);

/**
 * A list-container of Schemas
 */
typedef std::vector<class Schema>  Schemas;

/**
 * A Cell Key defined as binary(bytes) items in a list-container
 */
typedef std::vector<std::string>  Key;

/**
 * The Serial Cell Value Specifications defined as SpecValueSerialField items in a list-container
 */
typedef std::vector<class SpecValueSerialField>  SpecValueSerialFields;

/**
 * The Cell Value Specifications defined as SpecValuePlain items in a list-container
 */
typedef std::vector<class SpecValuePlain>  SpecValuesPlain;

/**
 * The Cell Value Specifications defined as SpecValueCounter items in a list-container
 */
typedef std::vector<class SpecValueCounter>  SpecValuesCounter;

/**
 * The Cell Value Specifications defined as SpecValueSerial items in a list-container
 */
typedef std::vector<class SpecValueSerial>  SpecValuesSerial;

/**
 * The Key Specifications defined as SpecFraction items in a list-container
 */
typedef std::vector<class SpecFraction>  SpecKey;

/**
 * The Key Intervals Specifications defined as SpecKeyInterval items in a list-container
 */
typedef std::vector<class SpecKeyInterval>  SpecKeyIntervals;

/**
 * The Cells for Update defined as UCellPlain items in a list-container
 */
typedef std::vector<class UCellPlain>  UCellsPlain;

/**
 * The Cells for Update for a Column Id defined as UCellsPlain items in a map-container by CID
 */
typedef std::map<int64_t, UCellsPlain>  UCCellsPlain;

/**
 * The Cells for Update defined as UCellCounter items in a list-container
 */
typedef std::vector<class UCellCounter>  UCellsCounter;

/**
 * The Cells for Update for a Column Id defined as UCellsCounter items in a map-container by CID
 */
typedef std::map<int64_t, UCellsCounter>  UCCellsCounter;

/**
 * The Serial Cell Value Fields defined as CellValueSerial items in a list-container
 */
typedef std::vector<class CellValueSerial>  CellValuesSerial;

/**
 * The Serial Cell Value Fields defined as CellValueSerialOp items in a list-container
 */
typedef std::vector<class CellValueSerialOp>  CellValuesSerialOp;

/**
 * The Cells for Update defined as UCellSerial items in a list-container
 */
typedef std::vector<class UCellSerial>  UCellsSerial;

/**
 * The Cells for Update for a Column Id defined as UCellsSerial items in a map-container by CID
 */
typedef std::map<int64_t, UCellsSerial>  UCCellsSerial;

/**
 * A list-container of Plain Cells
 */
typedef std::vector<class CellPlain>  CellsPlain;

/**
 * A list-container of Counter Cells
 */
typedef std::vector<class CellCounter>  CellsCounter;

/**
 * A list-container of Serial Cells
 */
typedef std::vector<class CellSerial>  CellsSerial;

/**
 * The Columns Cells for results on Columns of scan, defined as cCells items in a map-container by Column Name
 */
typedef std::map<std::string, class cCells>  CCells;

/**
 * The Keys Cells for results on Key of scan, defined as kCells items in a list-container
 */
typedef std::vector<class kCells>  KCells;

/**
 * The Compact Results, defined as CompactResult items in a list-container
 */
typedef std::vector<class CompactResult>  CompactResults;

class Exception;

class Schema;

class SchemaPattern;

class SchemaTagsPatterns;

class SchemaPatterns;

class SpecSchemas;

class SpecFlags;

class SpecUpdateOP;

class SpecIntervalUpdatePlain;

class SpecIntervalUpdateCounter;

class SpecIntervalUpdateSerial;

class SpecValueSerial_INT64;

class SpecValueSerial_DOUBLE;

class SpecValueSerial_BYTES;

class SpecValueSerial_KEY;

class SpecValueSerial_LI;

class SpecValueSerial_LB;

class SpecValueSerialField;

class SpecValuePlain;

class SpecValueCounter;

class SpecValueSerial;

class SpecFraction;

class SpecTimestamp;

class SpecKeyInterval;

class SpecIntervalPlain;

class SpecIntervalCounter;

class SpecIntervalSerial;

class SpecColumnPlain;

class SpecColumnCounter;

class SpecColumnSerial;

class SpecScan;

class UCellPlain;

class UCellCounter;

class CellValueSerial;

class FU_INT64;

class FU_DOUBLE;

class FU_BYTES;

class FU_LI;

class FU_LB;

class CellValueSerialOp;

class UCellSerial;

class CellPlain;

class CellCounter;

class CellSerial;

class Cells;

class CCellPlain;

class CCellCounter;

class CCellSerial;

class cCells;

class KCellPlain;

class KCellCounter;

class KCellSerial;

class kCells;

class FCellPlain;

class FCellCounter;

class FCellSerial;

class FCells;

class CellsGroup;

class CompactResult;

class Result;

typedef struct _Exception__isset {
  _Exception__isset() : code(false), message(false) {}
  bool code :1;
  bool message :1;
} _Exception__isset;

/**
 * The SWC::Thrift::Exception a base for any Exceptions
 * both for the Thrift-Protocol and SWC-DB Errors.
 */
class Exception : public ::apache::thrift::TException {
 public:

  Exception(const Exception&);
  Exception(Exception&&) noexcept;
  Exception& operator=(const Exception&);
  Exception& operator=(Exception&&) noexcept;
  Exception() noexcept
            : code(0),
              message() {
  }

  virtual ~Exception() noexcept;
  /**
   * The corresponding Thrift-Procotol or SWC-DB Error Code
   */
  int32_t code;
  /**
   * The message describing the error code
   */
  std::string message;

  _Exception__isset __isset;

  void __set_code(const int32_t val);

  void __set_message(const std::string& val);

  bool operator == (const Exception & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const Exception &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Exception & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const noexcept override;
};

void swap(Exception &a, Exception &b);

std::ostream& operator<<(std::ostream& out, const Exception& obj);

typedef struct _Schema__isset {
  _Schema__isset() : cid(false), col_name(false), col_tags(false), col_seq(false), col_type(false), cell_versions(false), cell_ttl(false), blk_encoding(false), blk_size(false), blk_cells(false), cs_replication(false), cs_size(false), cs_max(false), log_rollout_ratio(false), log_compact_cointervaling(false), log_fragment_preload(false), compact_percent(false), revision(false) {}
  bool cid :1;
  bool col_name :1;
  bool col_tags :1;
  bool col_seq :1;
  bool col_type :1;
  bool cell_versions :1;
  bool cell_ttl :1;
  bool blk_encoding :1;
  bool blk_size :1;
  bool blk_cells :1;
  bool cs_replication :1;
  bool cs_size :1;
  bool cs_max :1;
  bool log_rollout_ratio :1;
  bool log_compact_cointervaling :1;
  bool log_fragment_preload :1;
  bool compact_percent :1;
  bool revision :1;
} _Schema__isset;

/**
 * The Schema Definition
 */
class Schema : public virtual ::apache::thrift::TBase {
 public:

  Schema(const Schema&);
  Schema(Schema&&) noexcept;
  Schema& operator=(const Schema&);
  Schema& operator=(Schema&&) noexcept;
  Schema() noexcept
         : cid(0),
           col_name(),
           col_seq(static_cast<KeySeq::type>(0)),
           col_type(static_cast<ColumnType::type>(0)),
           cell_versions(0),
           cell_ttl(0),
           blk_encoding(static_cast<EncodingType::type>(0)),
           blk_size(0),
           blk_cells(0),
           cs_replication(0),
           cs_size(0),
           cs_max(0),
           log_rollout_ratio(0),
           log_compact_cointervaling(0),
           log_fragment_preload(0),
           compact_percent(0),
           revision(0) {
  }

  virtual ~Schema() noexcept;
  /**
   * Column ID
   */
  int64_t cid;
  /**
   * Column Name
   */
  std::string col_name;
  /**
   * Column Tags
   */
  std::vector<std::string>  col_tags;
  /**
   * Column Key Sequence
   * 
   * @see KeySeq
   */
  KeySeq::type col_seq;
  /**
   * Column Type
   * 
   * @see ColumnType
   */
  ColumnType::type col_type;
  /**
   * Cell Versions
   */
  int32_t cell_versions;
  /**
   * Cell Time to Live
   */
  int32_t cell_ttl;
  /**
   * Block Encoding
   * 
   * @see EncodingType
   */
  EncodingType::type blk_encoding;
  /**
   * Block Size in Bytes
   */
  int32_t blk_size;
  /**
   * Number of Cells in Block
   */
  int32_t blk_cells;
  /**
   * CellStore file Replication
   */
  int8_t cs_replication;
  /**
   * CellStore Size in Bytes
   */
  int32_t cs_size;
  /**
   * Max CellStores in a Range
   */
  int8_t cs_max;
  /**
   * Write Fragment File on ratio reached
   */
  int8_t log_rollout_ratio;
  /**
   * Min. Cointervaling Fragments for Compaction
   */
  int8_t log_compact_cointervaling;
  /**
   * Number of Fragment to Preload
   */
  int8_t log_fragment_preload;
  /**
   * Compact at percent reach
   */
  int8_t compact_percent;
  /**
   * Schema's revision/id
   */
  int64_t revision;

  _Schema__isset __isset;

  void __set_cid(const int64_t val);

  void __set_col_name(const std::string& val);

  void __set_col_tags(const std::vector<std::string> & val);

  void __set_col_seq(const KeySeq::type val);

  void __set_col_type(const ColumnType::type val);

  void __set_cell_versions(const int32_t val);

  void __set_cell_ttl(const int32_t val);

  void __set_blk_encoding(const EncodingType::type val);

  void __set_blk_size(const int32_t val);

  void __set_blk_cells(const int32_t val);

  void __set_cs_replication(const int8_t val);

  void __set_cs_size(const int32_t val);

  void __set_cs_max(const int8_t val);

  void __set_log_rollout_ratio(const int8_t val);

  void __set_log_compact_cointervaling(const int8_t val);

  void __set_log_fragment_preload(const int8_t val);

  void __set_compact_percent(const int8_t val);

  void __set_revision(const int64_t val);

  bool operator == (const Schema & rhs) const
  {
    if (__isset.cid != rhs.__isset.cid)
      return false;
    else if (__isset.cid && !(cid == rhs.cid))
      return false;
    if (__isset.col_name != rhs.__isset.col_name)
      return false;
    else if (__isset.col_name && !(col_name == rhs.col_name))
      return false;
    if (!(col_tags == rhs.col_tags))
      return false;
    if (__isset.col_seq != rhs.__isset.col_seq)
      return false;
    else if (__isset.col_seq && !(col_seq == rhs.col_seq))
      return false;
    if (__isset.col_type != rhs.__isset.col_type)
      return false;
    else if (__isset.col_type && !(col_type == rhs.col_type))
      return false;
    if (__isset.cell_versions != rhs.__isset.cell_versions)
      return false;
    else if (__isset.cell_versions && !(cell_versions == rhs.cell_versions))
      return false;
    if (__isset.cell_ttl != rhs.__isset.cell_ttl)
      return false;
    else if (__isset.cell_ttl && !(cell_ttl == rhs.cell_ttl))
      return false;
    if (__isset.blk_encoding != rhs.__isset.blk_encoding)
      return false;
    else if (__isset.blk_encoding && !(blk_encoding == rhs.blk_encoding))
      return false;
    if (__isset.blk_size != rhs.__isset.blk_size)
      return false;
    else if (__isset.blk_size && !(blk_size == rhs.blk_size))
      return false;
    if (__isset.blk_cells != rhs.__isset.blk_cells)
      return false;
    else if (__isset.blk_cells && !(blk_cells == rhs.blk_cells))
      return false;
    if (__isset.cs_replication != rhs.__isset.cs_replication)
      return false;
    else if (__isset.cs_replication && !(cs_replication == rhs.cs_replication))
      return false;
    if (__isset.cs_size != rhs.__isset.cs_size)
      return false;
    else if (__isset.cs_size && !(cs_size == rhs.cs_size))
      return false;
    if (__isset.cs_max != rhs.__isset.cs_max)
      return false;
    else if (__isset.cs_max && !(cs_max == rhs.cs_max))
      return false;
    if (__isset.log_rollout_ratio != rhs.__isset.log_rollout_ratio)
      return false;
    else if (__isset.log_rollout_ratio && !(log_rollout_ratio == rhs.log_rollout_ratio))
      return false;
    if (__isset.log_compact_cointervaling != rhs.__isset.log_compact_cointervaling)
      return false;
    else if (__isset.log_compact_cointervaling && !(log_compact_cointervaling == rhs.log_compact_cointervaling))
      return false;
    if (__isset.log_fragment_preload != rhs.__isset.log_fragment_preload)
      return false;
    else if (__isset.log_fragment_preload && !(log_fragment_preload == rhs.log_fragment_preload))
      return false;
    if (__isset.compact_percent != rhs.__isset.compact_percent)
      return false;
    else if (__isset.compact_percent && !(compact_percent == rhs.compact_percent))
      return false;
    if (__isset.revision != rhs.__isset.revision)
      return false;
    else if (__isset.revision && !(revision == rhs.revision))
      return false;
    return true;
  }
  bool operator != (const Schema &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Schema & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Schema &a, Schema &b);

std::ostream& operator<<(std::ostream& out, const Schema& obj);

typedef struct _SchemaPattern__isset {
  _SchemaPattern__isset() : comp(false), value(false) {}
  bool comp :1;
  bool value :1;
} _SchemaPattern__isset;

/**
 * The Schema matching Pattern
 */
class SchemaPattern : public virtual ::apache::thrift::TBase {
 public:

  SchemaPattern(const SchemaPattern&);
  SchemaPattern(SchemaPattern&&) noexcept;
  SchemaPattern& operator=(const SchemaPattern&);
  SchemaPattern& operator=(SchemaPattern&&) noexcept;
  SchemaPattern() noexcept
                : comp(static_cast<Comp::type>(0)),
                  value() {
  }

  virtual ~SchemaPattern() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The patern value to match against
   */
  std::string value;

  _SchemaPattern__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_value(const std::string& val);

  bool operator == (const SchemaPattern & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const SchemaPattern &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaPattern & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaPattern &a, SchemaPattern &b);

std::ostream& operator<<(std::ostream& out, const SchemaPattern& obj);

typedef struct _SchemaTagsPatterns__isset {
  _SchemaTagsPatterns__isset() : comp(false), values(false) {}
  bool comp :1;
  bool values :1;
} _SchemaTagsPatterns__isset;

/**
 * The Schema Tags patterns for the SchemaPatterns
 */
class SchemaTagsPatterns : public virtual ::apache::thrift::TBase {
 public:

  SchemaTagsPatterns(const SchemaTagsPatterns&);
  SchemaTagsPatterns(SchemaTagsPatterns&&) noexcept;
  SchemaTagsPatterns& operator=(const SchemaTagsPatterns&);
  SchemaTagsPatterns& operator=(SchemaTagsPatterns&&) noexcept;
  SchemaTagsPatterns() noexcept
                     : comp(static_cast<Comp::type>(0)) {
  }

  virtual ~SchemaTagsPatterns() noexcept;
  /**
   * Logical comparator to Apply, unsupported PF, RE and Vol. kind
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The tags patterns to match against schema's column tags
   */
  std::vector<SchemaPattern>  values;

  _SchemaTagsPatterns__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_values(const std::vector<SchemaPattern> & val);

  bool operator == (const SchemaTagsPatterns & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(values == rhs.values))
      return false;
    return true;
  }
  bool operator != (const SchemaTagsPatterns &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaTagsPatterns & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaTagsPatterns &a, SchemaTagsPatterns &b);

std::ostream& operator<<(std::ostream& out, const SchemaTagsPatterns& obj);

typedef struct _SchemaPatterns__isset {
  _SchemaPatterns__isset() : names(false), tags(false) {}
  bool names :1;
  bool tags :1;
} _SchemaPatterns__isset;

/**
 * The Schema Patterns for the SpecSchemas
 */
class SchemaPatterns : public virtual ::apache::thrift::TBase {
 public:

  SchemaPatterns(const SchemaPatterns&);
  SchemaPatterns(SchemaPatterns&&) noexcept;
  SchemaPatterns& operator=(const SchemaPatterns&);
  SchemaPatterns& operator=(SchemaPatterns&&) noexcept;
  SchemaPatterns() noexcept {
  }

  virtual ~SchemaPatterns() noexcept;
  /**
   * The Schema patterns for selecting by Column Name
   */
  std::vector<SchemaPattern>  names;
  /**
   * The Schema patterns for selecting by Column Tags
   */
  SchemaTagsPatterns tags;

  _SchemaPatterns__isset __isset;

  void __set_names(const std::vector<SchemaPattern> & val);

  void __set_tags(const SchemaTagsPatterns& val);

  bool operator == (const SchemaPatterns & rhs) const
  {
    if (!(names == rhs.names))
      return false;
    if (!(tags == rhs.tags))
      return false;
    return true;
  }
  bool operator != (const SchemaPatterns &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SchemaPatterns & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SchemaPatterns &a, SchemaPatterns &b);

std::ostream& operator<<(std::ostream& out, const SchemaPatterns& obj);

typedef struct _SpecSchemas__isset {
  _SpecSchemas__isset() : cids(false), names(false), patterns(false) {}
  bool cids :1;
  bool names :1;
  bool patterns :1;
} _SpecSchemas__isset;

/**
 * The Specs for Schemas for using with list_columns or compact_columns
 */
class SpecSchemas : public virtual ::apache::thrift::TBase {
 public:

  SpecSchemas(const SpecSchemas&);
  SpecSchemas(SpecSchemas&&) noexcept;
  SpecSchemas& operator=(const SpecSchemas&);
  SpecSchemas& operator=(SpecSchemas&&) noexcept;
  SpecSchemas() noexcept {
  }

  virtual ~SpecSchemas() noexcept;
  /**
   * The Column IDs
   */
  std::vector<int64_t>  cids;
  /**
   * The Column Names
   */
  std::vector<std::string>  names;
  /**
   * The Schema's selector patterns
   */
  SchemaPatterns patterns;

  _SpecSchemas__isset __isset;

  void __set_cids(const std::vector<int64_t> & val);

  void __set_names(const std::vector<std::string> & val);

  void __set_patterns(const SchemaPatterns& val);

  bool operator == (const SpecSchemas & rhs) const
  {
    if (!(cids == rhs.cids))
      return false;
    if (!(names == rhs.names))
      return false;
    if (!(patterns == rhs.patterns))
      return false;
    return true;
  }
  bool operator != (const SpecSchemas &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecSchemas & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecSchemas &a, SpecSchemas &b);

std::ostream& operator<<(std::ostream& out, const SpecSchemas& obj);

typedef struct _SpecFlags__isset {
  _SpecFlags__isset() : limit(false), offset(false), max_versions(false), max_buffer(false), options(false) {}
  bool limit :1;
  bool offset :1;
  bool max_versions :1;
  bool max_buffer :1;
  bool options :1;
} _SpecFlags__isset;

/**
 * The Scan Specifications Flags
 */
class SpecFlags : public virtual ::apache::thrift::TBase {
 public:

  SpecFlags(const SpecFlags&) noexcept;
  SpecFlags(SpecFlags&&) noexcept;
  SpecFlags& operator=(const SpecFlags&) noexcept;
  SpecFlags& operator=(SpecFlags&&) noexcept;
  SpecFlags() noexcept
            : limit(0),
              offset(0),
              max_versions(0),
              max_buffer(0),
              options(0) {
  }

  virtual ~SpecFlags() noexcept;
  /**
   * Limit to this number of cells
   */
  int64_t limit;
  /**
   * Scan from this number of cells Offset on matching Cell-Interval
   */
  int64_t offset;
  /**
   * Select only this number of Versions of a given Cell-Key
   */
  int32_t max_versions;
  /**
   * return results with reach of this Buffer size in bytes
   */
  int32_t max_buffer;
  /**
   * The options bit by SpecFlagsOpt
   */
  int8_t options;

  _SpecFlags__isset __isset;

  void __set_limit(const int64_t val);

  void __set_offset(const int64_t val);

  void __set_max_versions(const int32_t val);

  void __set_max_buffer(const int32_t val);

  void __set_options(const int8_t val);

  bool operator == (const SpecFlags & rhs) const
  {
    if (__isset.limit != rhs.__isset.limit)
      return false;
    else if (__isset.limit && !(limit == rhs.limit))
      return false;
    if (__isset.offset != rhs.__isset.offset)
      return false;
    else if (__isset.offset && !(offset == rhs.offset))
      return false;
    if (__isset.max_versions != rhs.__isset.max_versions)
      return false;
    else if (__isset.max_versions && !(max_versions == rhs.max_versions))
      return false;
    if (__isset.max_buffer != rhs.__isset.max_buffer)
      return false;
    else if (__isset.max_buffer && !(max_buffer == rhs.max_buffer))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const SpecFlags &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecFlags & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecFlags &a, SpecFlags &b);

std::ostream& operator<<(std::ostream& out, const SpecFlags& obj);

typedef struct _SpecUpdateOP__isset {
  _SpecUpdateOP__isset() : op(false), pos(false) {}
  bool op :1;
  bool pos :1;
} _SpecUpdateOP__isset;

class SpecUpdateOP : public virtual ::apache::thrift::TBase {
 public:

  SpecUpdateOP(const SpecUpdateOP&) noexcept;
  SpecUpdateOP(SpecUpdateOP&&) noexcept;
  SpecUpdateOP& operator=(const SpecUpdateOP&) noexcept;
  SpecUpdateOP& operator=(SpecUpdateOP&&) noexcept;
  SpecUpdateOP() noexcept
               : op(static_cast<UpdateOP::type>(0)),
                 pos(0) {
  }

  virtual ~SpecUpdateOP() noexcept;
  /**
   * The Operation of update
   * 
   * @see UpdateOP
   */
  UpdateOP::type op;
  /**
   * The position/index of INSERT and OVERWRITE update operations
   */
  int32_t pos;

  _SpecUpdateOP__isset __isset;

  void __set_op(const UpdateOP::type val);

  void __set_pos(const int32_t val);

  bool operator == (const SpecUpdateOP & rhs) const
  {
    if (!(op == rhs.op))
      return false;
    if (__isset.pos != rhs.__isset.pos)
      return false;
    else if (__isset.pos && !(pos == rhs.pos))
      return false;
    return true;
  }
  bool operator != (const SpecUpdateOP &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecUpdateOP & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecUpdateOP &a, SpecUpdateOP &b);

std::ostream& operator<<(std::ostream& out, const SpecUpdateOP& obj);

typedef struct _SpecIntervalUpdatePlain__isset {
  _SpecIntervalUpdatePlain__isset() : v(false), ts(false), encoder(false), update_op(false) {}
  bool v :1;
  bool ts :1;
  bool encoder :1;
  bool update_op :1;
} _SpecIntervalUpdatePlain__isset;

/**
 * The Value specs for an Updating Interval of 'updating' in SpecIntervalPlain
 */
class SpecIntervalUpdatePlain : public virtual ::apache::thrift::TBase {
 public:

  SpecIntervalUpdatePlain(const SpecIntervalUpdatePlain&);
  SpecIntervalUpdatePlain(SpecIntervalUpdatePlain&&) noexcept;
  SpecIntervalUpdatePlain& operator=(const SpecIntervalUpdatePlain&);
  SpecIntervalUpdatePlain& operator=(SpecIntervalUpdatePlain&&) noexcept;
  SpecIntervalUpdatePlain() noexcept
                          : v(),
                            ts(0),
                            encoder(static_cast<EncodingType::type>(0)) {
  }

  virtual ~SpecIntervalUpdatePlain() noexcept;
  /**
   * The bytes value for the updated cell
   */
  std::string v;
  /**
   * The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
   */
  int64_t ts;
  /**
   * Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
   * 
   * @see EncodingType
   */
  EncodingType::type encoder;
  /**
   * Optionally the operaton of value update
   */
  SpecUpdateOP update_op;

  _SpecIntervalUpdatePlain__isset __isset;

  void __set_v(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_encoder(const EncodingType::type val);

  void __set_update_op(const SpecUpdateOP& val);

  bool operator == (const SpecIntervalUpdatePlain & rhs) const
  {
    if (!(v == rhs.v))
      return false;
    if (__isset.ts != rhs.__isset.ts)
      return false;
    else if (__isset.ts && !(ts == rhs.ts))
      return false;
    if (__isset.encoder != rhs.__isset.encoder)
      return false;
    else if (__isset.encoder && !(encoder == rhs.encoder))
      return false;
    if (__isset.update_op != rhs.__isset.update_op)
      return false;
    else if (__isset.update_op && !(update_op == rhs.update_op))
      return false;
    return true;
  }
  bool operator != (const SpecIntervalUpdatePlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecIntervalUpdatePlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecIntervalUpdatePlain &a, SpecIntervalUpdatePlain &b);

std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdatePlain& obj);

typedef struct _SpecIntervalUpdateCounter__isset {
  _SpecIntervalUpdateCounter__isset() : v(false), op(true), ts(false), update_op(false) {}
  bool v :1;
  bool op :1;
  bool ts :1;
  bool update_op :1;
} _SpecIntervalUpdateCounter__isset;

/**
 * The Value specs for an Updating Interval of 'updating' in SpecIntervalCounter
 */
class SpecIntervalUpdateCounter : public virtual ::apache::thrift::TBase {
 public:

  SpecIntervalUpdateCounter(const SpecIntervalUpdateCounter&) noexcept;
  SpecIntervalUpdateCounter(SpecIntervalUpdateCounter&&) noexcept;
  SpecIntervalUpdateCounter& operator=(const SpecIntervalUpdateCounter&) noexcept;
  SpecIntervalUpdateCounter& operator=(SpecIntervalUpdateCounter&&) noexcept;
  SpecIntervalUpdateCounter() noexcept
                            : v(0),
                              op(0LL),
                              ts(0) {
  }

  virtual ~SpecIntervalUpdateCounter() noexcept;
  /**
   * The int64 value for the updated cell
   */
  int64_t v;
  /**
   * The Opration pf Counter, available: COUNTER_OP_EQUAL
   */
  int64_t op;
  /**
   * The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
   */
  int64_t ts;
  /**
   * Optionally the operaton of value update
   */
  SpecUpdateOP update_op;

  _SpecIntervalUpdateCounter__isset __isset;

  void __set_v(const int64_t val);

  void __set_op(const int64_t val);

  void __set_ts(const int64_t val);

  void __set_update_op(const SpecUpdateOP& val);

  bool operator == (const SpecIntervalUpdateCounter & rhs) const
  {
    if (!(v == rhs.v))
      return false;
    if (!(op == rhs.op))
      return false;
    if (__isset.ts != rhs.__isset.ts)
      return false;
    else if (__isset.ts && !(ts == rhs.ts))
      return false;
    if (__isset.update_op != rhs.__isset.update_op)
      return false;
    else if (__isset.update_op && !(update_op == rhs.update_op))
      return false;
    return true;
  }
  bool operator != (const SpecIntervalUpdateCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecIntervalUpdateCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecIntervalUpdateCounter &a, SpecIntervalUpdateCounter &b);

std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdateCounter& obj);

typedef struct _SpecIntervalUpdateSerial__isset {
  _SpecIntervalUpdateSerial__isset() : ts(false), v(false), v_op(false), encoder(false), update_op(false) {}
  bool ts :1;
  bool v :1;
  bool v_op :1;
  bool encoder :1;
  bool update_op :1;
} _SpecIntervalUpdateSerial__isset;

/**
 * The Value specs for an Updating Interval of 'updating' in SpecIntervalSerial
 */
class SpecIntervalUpdateSerial : public virtual ::apache::thrift::TBase {
 public:

  SpecIntervalUpdateSerial(const SpecIntervalUpdateSerial&);
  SpecIntervalUpdateSerial(SpecIntervalUpdateSerial&&) noexcept;
  SpecIntervalUpdateSerial& operator=(const SpecIntervalUpdateSerial&);
  SpecIntervalUpdateSerial& operator=(SpecIntervalUpdateSerial&&) noexcept;
  SpecIntervalUpdateSerial() noexcept
                           : ts(0),
                             encoder(static_cast<EncodingType::type>(0)) {
  }

  virtual ~SpecIntervalUpdateSerial() noexcept;
  /**
   * The timestamp for the updated cell NULL: MIN_INT64-1, AUTO:MIN_INT64-1
   */
  int64_t ts;
  /**
   * The values of serial-fields for the updated cell
   */
  CellValuesSerial v;
  /**
   * The values of serial-fields for the the SERIAL operation update
   */
  CellValuesSerialOp v_op;
  /**
   * Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
   * 
   * @see EncodingType
   */
  EncodingType::type encoder;
  /**
   * Optionally the operaton of value update
   */
  SpecUpdateOP update_op;

  _SpecIntervalUpdateSerial__isset __isset;

  void __set_ts(const int64_t val);

  void __set_v(const CellValuesSerial& val);

  void __set_v_op(const CellValuesSerialOp& val);

  void __set_encoder(const EncodingType::type val);

  void __set_update_op(const SpecUpdateOP& val);

  bool operator == (const SpecIntervalUpdateSerial & rhs) const
  {
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    if (!(v_op == rhs.v_op))
      return false;
    if (__isset.encoder != rhs.__isset.encoder)
      return false;
    else if (__isset.encoder && !(encoder == rhs.encoder))
      return false;
    if (__isset.update_op != rhs.__isset.update_op)
      return false;
    else if (__isset.update_op && !(update_op == rhs.update_op))
      return false;
    return true;
  }
  bool operator != (const SpecIntervalUpdateSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecIntervalUpdateSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecIntervalUpdateSerial &a, SpecIntervalUpdateSerial &b);

std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdateSerial& obj);

typedef struct _SpecValueSerial_INT64__isset {
  _SpecValueSerial_INT64__isset() : comp(false), v(false) {}
  bool comp :1;
  bool v :1;
} _SpecValueSerial_INT64__isset;

/**
 * The Specifications of INT64 Serial Value Field
 */
class SpecValueSerial_INT64 : public virtual ::apache::thrift::TBase {
 public:

  SpecValueSerial_INT64(const SpecValueSerial_INT64&) noexcept;
  SpecValueSerial_INT64(SpecValueSerial_INT64&&) noexcept;
  SpecValueSerial_INT64& operator=(const SpecValueSerial_INT64&) noexcept;
  SpecValueSerial_INT64& operator=(SpecValueSerial_INT64&&) noexcept;
  SpecValueSerial_INT64() noexcept
                        : comp(static_cast<Comp::type>(0)),
                          v(0) {
  }

  virtual ~SpecValueSerial_INT64() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The int64 to match against the value field
   */
  int64_t v;

  _SpecValueSerial_INT64__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_v(const int64_t val);

  bool operator == (const SpecValueSerial_INT64 & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValueSerial_INT64 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueSerial_INT64 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueSerial_INT64 &a, SpecValueSerial_INT64 &b);

std::ostream& operator<<(std::ostream& out, const SpecValueSerial_INT64& obj);

typedef struct _SpecValueSerial_DOUBLE__isset {
  _SpecValueSerial_DOUBLE__isset() : comp(false), v(false) {}
  bool comp :1;
  bool v :1;
} _SpecValueSerial_DOUBLE__isset;

/**
 * The Specifications of DOUBLE Serial Value Field
 */
class SpecValueSerial_DOUBLE : public virtual ::apache::thrift::TBase {
 public:

  SpecValueSerial_DOUBLE(const SpecValueSerial_DOUBLE&) noexcept;
  SpecValueSerial_DOUBLE(SpecValueSerial_DOUBLE&&) noexcept;
  SpecValueSerial_DOUBLE& operator=(const SpecValueSerial_DOUBLE&) noexcept;
  SpecValueSerial_DOUBLE& operator=(SpecValueSerial_DOUBLE&&) noexcept;
  SpecValueSerial_DOUBLE() noexcept
                         : comp(static_cast<Comp::type>(0)),
                           v(0) {
  }

  virtual ~SpecValueSerial_DOUBLE() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The double to match against the value field
   */
  double v;

  _SpecValueSerial_DOUBLE__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_v(const double val);

  bool operator == (const SpecValueSerial_DOUBLE & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValueSerial_DOUBLE &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueSerial_DOUBLE & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueSerial_DOUBLE &a, SpecValueSerial_DOUBLE &b);

std::ostream& operator<<(std::ostream& out, const SpecValueSerial_DOUBLE& obj);

typedef struct _SpecValueSerial_BYTES__isset {
  _SpecValueSerial_BYTES__isset() : comp(false), v(false) {}
  bool comp :1;
  bool v :1;
} _SpecValueSerial_BYTES__isset;

/**
 * The Specifications of BYTES Serial Value Field
 */
class SpecValueSerial_BYTES : public virtual ::apache::thrift::TBase {
 public:

  SpecValueSerial_BYTES(const SpecValueSerial_BYTES&);
  SpecValueSerial_BYTES(SpecValueSerial_BYTES&&) noexcept;
  SpecValueSerial_BYTES& operator=(const SpecValueSerial_BYTES&);
  SpecValueSerial_BYTES& operator=(SpecValueSerial_BYTES&&) noexcept;
  SpecValueSerial_BYTES() noexcept
                        : comp(static_cast<Comp::type>(0)),
                          v() {
  }

  virtual ~SpecValueSerial_BYTES() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The binary(bytes) to match against the value field
   */
  std::string v;

  _SpecValueSerial_BYTES__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_v(const std::string& val);

  bool operator == (const SpecValueSerial_BYTES & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValueSerial_BYTES &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueSerial_BYTES & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueSerial_BYTES &a, SpecValueSerial_BYTES &b);

std::ostream& operator<<(std::ostream& out, const SpecValueSerial_BYTES& obj);

typedef struct _SpecValueSerial_KEY__isset {
  _SpecValueSerial_KEY__isset() : seq(false), v(false) {}
  bool seq :1;
  bool v :1;
} _SpecValueSerial_KEY__isset;

/**
 * The Specifications of KEY Serial Value Field
 */
class SpecValueSerial_KEY : public virtual ::apache::thrift::TBase {
 public:

  SpecValueSerial_KEY(const SpecValueSerial_KEY&);
  SpecValueSerial_KEY(SpecValueSerial_KEY&&) noexcept;
  SpecValueSerial_KEY& operator=(const SpecValueSerial_KEY&);
  SpecValueSerial_KEY& operator=(SpecValueSerial_KEY&&) noexcept;
  SpecValueSerial_KEY() noexcept
                      : seq(static_cast<KeySeq::type>(0)) {
  }

  virtual ~SpecValueSerial_KEY() noexcept;
  /**
   * The Key Sequence to use
   * 
   * @see KeySeq
   */
  KeySeq::type seq;
  /**
   * The Specification of the Key to match against the value field
   */
  SpecKey v;

  _SpecValueSerial_KEY__isset __isset;

  void __set_seq(const KeySeq::type val);

  void __set_v(const SpecKey& val);

  bool operator == (const SpecValueSerial_KEY & rhs) const
  {
    if (!(seq == rhs.seq))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValueSerial_KEY &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueSerial_KEY & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueSerial_KEY &a, SpecValueSerial_KEY &b);

std::ostream& operator<<(std::ostream& out, const SpecValueSerial_KEY& obj);

typedef struct _SpecValueSerial_LI__isset {
  _SpecValueSerial_LI__isset() : comp(false), v(false) {}
  bool comp :1;
  bool v :1;
} _SpecValueSerial_LI__isset;

/**
 * The Specifications of LIST_INT64(LI) Serial Value Field
 */
class SpecValueSerial_LI : public virtual ::apache::thrift::TBase {
 public:

  SpecValueSerial_LI(const SpecValueSerial_LI&);
  SpecValueSerial_LI(SpecValueSerial_LI&&) noexcept;
  SpecValueSerial_LI& operator=(const SpecValueSerial_LI&);
  SpecValueSerial_LI& operator=(SpecValueSerial_LI&&) noexcept;
  SpecValueSerial_LI() noexcept
                     : comp(static_cast<Comp::type>(0)) {
  }

  virtual ~SpecValueSerial_LI() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The List of Int64 to match against the value field
   */
  std::vector<SpecValueSerial_INT64>  v;

  _SpecValueSerial_LI__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_v(const std::vector<SpecValueSerial_INT64> & val);

  bool operator == (const SpecValueSerial_LI & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValueSerial_LI &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueSerial_LI & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueSerial_LI &a, SpecValueSerial_LI &b);

std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LI& obj);

typedef struct _SpecValueSerial_LB__isset {
  _SpecValueSerial_LB__isset() : comp(false), v(false) {}
  bool comp :1;
  bool v :1;
} _SpecValueSerial_LB__isset;

/**
 * The Specifications of LIST_BYTES(LB) Serial Value Field
 */
class SpecValueSerial_LB : public virtual ::apache::thrift::TBase {
 public:

  SpecValueSerial_LB(const SpecValueSerial_LB&);
  SpecValueSerial_LB(SpecValueSerial_LB&&) noexcept;
  SpecValueSerial_LB& operator=(const SpecValueSerial_LB&);
  SpecValueSerial_LB& operator=(SpecValueSerial_LB&&) noexcept;
  SpecValueSerial_LB() noexcept
                     : comp(static_cast<Comp::type>(0)) {
  }

  virtual ~SpecValueSerial_LB() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The List of Bytes to match against the value field
   */
  std::vector<SpecValueSerial_BYTES>  v;

  _SpecValueSerial_LB__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_v(const std::vector<SpecValueSerial_BYTES> & val);

  bool operator == (const SpecValueSerial_LB & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValueSerial_LB &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueSerial_LB & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueSerial_LB &a, SpecValueSerial_LB &b);

std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LB& obj);

typedef struct _SpecValueSerialField__isset {
  _SpecValueSerialField__isset() : field_id(false), spec_int64(false), spec_double(false), spec_bytes(false), spec_key(false), spec_li(false), spec_lb(false) {}
  bool field_id :1;
  bool spec_int64 :1;
  bool spec_double :1;
  bool spec_bytes :1;
  bool spec_key :1;
  bool spec_li :1;
  bool spec_lb :1;
} _SpecValueSerialField__isset;

class SpecValueSerialField : public virtual ::apache::thrift::TBase {
 public:

  SpecValueSerialField(const SpecValueSerialField&);
  SpecValueSerialField(SpecValueSerialField&&) noexcept;
  SpecValueSerialField& operator=(const SpecValueSerialField&);
  SpecValueSerialField& operator=(SpecValueSerialField&&) noexcept;
  SpecValueSerialField() noexcept
                       : field_id(0) {
  }

  virtual ~SpecValueSerialField() noexcept;
  /**
   * The Field Id of the Value Field
   */
  int32_t field_id;
  /**
   * The specifications of Int64 for the field
   */
  SpecValueSerial_INT64 spec_int64;
  /**
   * The specifications of Double for the field
   */
  SpecValueSerial_DOUBLE spec_double;
  /**
   * The specifications of Bytes for the field
   */
  SpecValueSerial_BYTES spec_bytes;
  /**
   * The specifications of Cell-Key for the field
   */
  SpecValueSerial_KEY spec_key;
  /**
   * The specifications of List Int64 for the field
   */
  SpecValueSerial_LI spec_li;
  /**
   * The specifications of List Bytes for the field
   */
  SpecValueSerial_LB spec_lb;

  _SpecValueSerialField__isset __isset;

  void __set_field_id(const int32_t val);

  void __set_spec_int64(const SpecValueSerial_INT64& val);

  void __set_spec_double(const SpecValueSerial_DOUBLE& val);

  void __set_spec_bytes(const SpecValueSerial_BYTES& val);

  void __set_spec_key(const SpecValueSerial_KEY& val);

  void __set_spec_li(const SpecValueSerial_LI& val);

  void __set_spec_lb(const SpecValueSerial_LB& val);

  bool operator == (const SpecValueSerialField & rhs) const
  {
    if (!(field_id == rhs.field_id))
      return false;
    if (__isset.spec_int64 != rhs.__isset.spec_int64)
      return false;
    else if (__isset.spec_int64 && !(spec_int64 == rhs.spec_int64))
      return false;
    if (__isset.spec_double != rhs.__isset.spec_double)
      return false;
    else if (__isset.spec_double && !(spec_double == rhs.spec_double))
      return false;
    if (!(spec_bytes == rhs.spec_bytes))
      return false;
    if (!(spec_key == rhs.spec_key))
      return false;
    if (!(spec_li == rhs.spec_li))
      return false;
    if (!(spec_lb == rhs.spec_lb))
      return false;
    return true;
  }
  bool operator != (const SpecValueSerialField &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueSerialField & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueSerialField &a, SpecValueSerialField &b);

std::ostream& operator<<(std::ostream& out, const SpecValueSerialField& obj);

typedef struct _SpecValuePlain__isset {
  _SpecValuePlain__isset() : comp(false), v(false) {}
  bool comp :1;
  bool v :1;
} _SpecValuePlain__isset;

/**
 * The Plain Value Specifications, option to use with Extended Logical Comparators
 */
class SpecValuePlain : public virtual ::apache::thrift::TBase {
 public:

  SpecValuePlain(const SpecValuePlain&);
  SpecValuePlain(SpecValuePlain&&) noexcept;
  SpecValuePlain& operator=(const SpecValuePlain&);
  SpecValuePlain& operator=(SpecValuePlain&&) noexcept;
  SpecValuePlain() noexcept
                 : comp(static_cast<Comp::type>(0)),
                   v() {
  }

  virtual ~SpecValuePlain() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The binary(bytes) to match against the Cell value
   */
  std::string v;

  _SpecValuePlain__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_v(const std::string& val);

  bool operator == (const SpecValuePlain & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValuePlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValuePlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValuePlain &a, SpecValuePlain &b);

std::ostream& operator<<(std::ostream& out, const SpecValuePlain& obj);

typedef struct _SpecValueCounter__isset {
  _SpecValueCounter__isset() : comp(false), v(false) {}
  bool comp :1;
  bool v :1;
} _SpecValueCounter__isset;

/**
 * The Counter Value Specifications, option to use with Extended Logical Comparators
 */
class SpecValueCounter : public virtual ::apache::thrift::TBase {
 public:

  SpecValueCounter(const SpecValueCounter&) noexcept;
  SpecValueCounter(SpecValueCounter&&) noexcept;
  SpecValueCounter& operator=(const SpecValueCounter&) noexcept;
  SpecValueCounter& operator=(SpecValueCounter&&) noexcept;
  SpecValueCounter() noexcept
                   : comp(static_cast<Comp::type>(0)),
                     v(0) {
  }

  virtual ~SpecValueCounter() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The int64 to match against the Cell value
   */
  int64_t v;

  _SpecValueCounter__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_v(const int64_t val);

  bool operator == (const SpecValueCounter & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const SpecValueCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueCounter &a, SpecValueCounter &b);

std::ostream& operator<<(std::ostream& out, const SpecValueCounter& obj);

typedef struct _SpecValueSerial__isset {
  _SpecValueSerial__isset() : comp(false), fields(false) {}
  bool comp :1;
  bool fields :1;
} _SpecValueSerial__isset;

/**
 * The Serial Value Specifications
 */
class SpecValueSerial : public virtual ::apache::thrift::TBase {
 public:

  SpecValueSerial(const SpecValueSerial&);
  SpecValueSerial(SpecValueSerial&&) noexcept;
  SpecValueSerial& operator=(const SpecValueSerial&);
  SpecValueSerial& operator=(SpecValueSerial&&) noexcept;
  SpecValueSerial() noexcept
                  : comp(static_cast<Comp::type>(0)) {
  }

  virtual ~SpecValueSerial() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The Serial Value Specifications to match against the SERIAL Cell value fields
   */
  SpecValueSerialFields fields;

  _SpecValueSerial__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_fields(const SpecValueSerialFields& val);

  bool operator == (const SpecValueSerial & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(fields == rhs.fields))
      return false;
    return true;
  }
  bool operator != (const SpecValueSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecValueSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecValueSerial &a, SpecValueSerial &b);

std::ostream& operator<<(std::ostream& out, const SpecValueSerial& obj);

typedef struct _SpecFraction__isset {
  _SpecFraction__isset() : comp(false), f(false) {}
  bool comp :1;
  bool f :1;
} _SpecFraction__isset;

/**
 * The Fraction Specifications
 */
class SpecFraction : public virtual ::apache::thrift::TBase {
 public:

  SpecFraction(const SpecFraction&);
  SpecFraction(SpecFraction&&) noexcept;
  SpecFraction& operator=(const SpecFraction&);
  SpecFraction& operator=(SpecFraction&&) noexcept;
  SpecFraction() noexcept
               : comp(static_cast<Comp::type>(0)),
                 f() {
  }

  virtual ~SpecFraction() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The binary(bytes) to match against a fraction of a Cell-Key
   */
  std::string f;

  _SpecFraction__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_f(const std::string& val);

  bool operator == (const SpecFraction & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(f == rhs.f))
      return false;
    return true;
  }
  bool operator != (const SpecFraction &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecFraction & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecFraction &a, SpecFraction &b);

std::ostream& operator<<(std::ostream& out, const SpecFraction& obj);

typedef struct _SpecTimestamp__isset {
  _SpecTimestamp__isset() : comp(false), ts(false) {}
  bool comp :1;
  bool ts :1;
} _SpecTimestamp__isset;

/**
 * The Timestamp Specifications
 */
class SpecTimestamp : public virtual ::apache::thrift::TBase {
 public:

  SpecTimestamp(const SpecTimestamp&) noexcept;
  SpecTimestamp(SpecTimestamp&&) noexcept;
  SpecTimestamp& operator=(const SpecTimestamp&) noexcept;
  SpecTimestamp& operator=(SpecTimestamp&&) noexcept;
  SpecTimestamp() noexcept
                : comp(static_cast<Comp::type>(0)),
                  ts(0) {
  }

  virtual ~SpecTimestamp() noexcept;
  /**
   * Logical comparator to Apply
   * 
   * @see Comp
   */
  Comp::type comp;
  /**
   * The timestamp in nanoseconds to match against the Cell timestamp/version (not the revision)
   */
  int64_t ts;

  _SpecTimestamp__isset __isset;

  void __set_comp(const Comp::type val);

  void __set_ts(const int64_t val);

  bool operator == (const SpecTimestamp & rhs) const
  {
    if (!(comp == rhs.comp))
      return false;
    if (!(ts == rhs.ts))
      return false;
    return true;
  }
  bool operator != (const SpecTimestamp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecTimestamp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecTimestamp &a, SpecTimestamp &b);

std::ostream& operator<<(std::ostream& out, const SpecTimestamp& obj);

typedef struct _SpecKeyInterval__isset {
  _SpecKeyInterval__isset() : start(false), finish(false) {}
  bool start :1;
  bool finish :1;
} _SpecKeyInterval__isset;

/**
 * The Key Interval Specifications
 */
class SpecKeyInterval : public virtual ::apache::thrift::TBase {
 public:

  SpecKeyInterval(const SpecKeyInterval&);
  SpecKeyInterval(SpecKeyInterval&&) noexcept;
  SpecKeyInterval& operator=(const SpecKeyInterval&);
  SpecKeyInterval& operator=(SpecKeyInterval&&) noexcept;
  SpecKeyInterval() noexcept {
  }

  virtual ~SpecKeyInterval() noexcept;
  /**
   * The Key Start Spec, the start of cells-interval key match
   */
  SpecKey start;
  /**
   * The Key Finish Spec, the finish of cells-interval key match
   */
  SpecKey finish;

  _SpecKeyInterval__isset __isset;

  void __set_start(const SpecKey& val);

  void __set_finish(const SpecKey& val);

  bool operator == (const SpecKeyInterval & rhs) const
  {
    if (!(start == rhs.start))
      return false;
    if (!(finish == rhs.finish))
      return false;
    return true;
  }
  bool operator != (const SpecKeyInterval &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecKeyInterval & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecKeyInterval &a, SpecKeyInterval &b);

std::ostream& operator<<(std::ostream& out, const SpecKeyInterval& obj);

typedef struct _SpecIntervalPlain__isset {
  _SpecIntervalPlain__isset() : range_begin(false), range_end(false), offset_key(false), offset_rev(false), key_intervals(false), values(false), ts_start(false), ts_finish(false), flags(false), options(false), updating(false) {}
  bool range_begin :1;
  bool range_end :1;
  bool offset_key :1;
  bool offset_rev :1;
  bool key_intervals :1;
  bool values :1;
  bool ts_start :1;
  bool ts_finish :1;
  bool flags :1;
  bool options :1;
  bool updating :1;
} _SpecIntervalPlain__isset;

/**
 * The Cells Interval Plain type Specifications with interval-scope Flags
 */
class SpecIntervalPlain : public virtual ::apache::thrift::TBase {
 public:

  SpecIntervalPlain(const SpecIntervalPlain&);
  SpecIntervalPlain(SpecIntervalPlain&&) noexcept;
  SpecIntervalPlain& operator=(const SpecIntervalPlain&);
  SpecIntervalPlain& operator=(SpecIntervalPlain&&) noexcept;
  SpecIntervalPlain() noexcept
                    : offset_rev(0),
                      options(static_cast<SpecIntervalOptions::type>(0)) {
  }

  virtual ~SpecIntervalPlain() noexcept;
  /**
   * Begin of Ranges evaluation with this Key inclusive
   */
  Key range_begin;
  /**
   * End of Ranges evaluation with this Key inclusive
   */
  Key range_end;
  /**
   * Offset Cell Key of a Scan, select cells from this key inclusive
   */
  Key offset_key;
  /**
   * Offset Cell Timestamp of a Scan, select cells after this timestamp
   */
  int64_t offset_rev;
  /**
   * The Key Intervals
   */
  SpecKeyIntervals key_intervals;
  /**
   * The Cell Value Specifications, cell-value match for plain type
   */
  SpecValuesPlain values;
  /**
   * The Timestamp Start Spec, the start of cells-interval timestamp match
   */
  SpecTimestamp ts_start;
  /**
   * The Timestamp Finish Spec, the finish of cells-interval timestamp match
   */
  SpecTimestamp ts_finish;
  /**
   * The Interval Flags Specification
   */
  SpecFlags flags;
  /**
   * The Interval Options Specification
   * 
   * @see SpecIntervalOptions
   */
  SpecIntervalOptions::type options;
  /**
   * The Value spec of an Updating Interval
   */
  SpecIntervalUpdatePlain updating;

  _SpecIntervalPlain__isset __isset;

  void __set_range_begin(const Key& val);

  void __set_range_end(const Key& val);

  void __set_offset_key(const Key& val);

  void __set_offset_rev(const int64_t val);

  void __set_key_intervals(const SpecKeyIntervals& val);

  void __set_values(const SpecValuesPlain& val);

  void __set_ts_start(const SpecTimestamp& val);

  void __set_ts_finish(const SpecTimestamp& val);

  void __set_flags(const SpecFlags& val);

  void __set_options(const SpecIntervalOptions::type val);

  void __set_updating(const SpecIntervalUpdatePlain& val);

  bool operator == (const SpecIntervalPlain & rhs) const
  {
    if (!(range_begin == rhs.range_begin))
      return false;
    if (!(range_end == rhs.range_end))
      return false;
    if (!(offset_key == rhs.offset_key))
      return false;
    if (__isset.offset_rev != rhs.__isset.offset_rev)
      return false;
    else if (__isset.offset_rev && !(offset_rev == rhs.offset_rev))
      return false;
    if (!(key_intervals == rhs.key_intervals))
      return false;
    if (!(values == rhs.values))
      return false;
    if (__isset.ts_start != rhs.__isset.ts_start)
      return false;
    else if (__isset.ts_start && !(ts_start == rhs.ts_start))
      return false;
    if (__isset.ts_finish != rhs.__isset.ts_finish)
      return false;
    else if (__isset.ts_finish && !(ts_finish == rhs.ts_finish))
      return false;
    if (__isset.flags != rhs.__isset.flags)
      return false;
    else if (__isset.flags && !(flags == rhs.flags))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    if (__isset.updating != rhs.__isset.updating)
      return false;
    else if (__isset.updating && !(updating == rhs.updating))
      return false;
    return true;
  }
  bool operator != (const SpecIntervalPlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecIntervalPlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecIntervalPlain &a, SpecIntervalPlain &b);

std::ostream& operator<<(std::ostream& out, const SpecIntervalPlain& obj);

typedef struct _SpecIntervalCounter__isset {
  _SpecIntervalCounter__isset() : range_begin(false), range_end(false), offset_key(false), offset_rev(false), key_intervals(false), values(false), ts_start(false), ts_finish(false), flags(false), options(false), updating(false) {}
  bool range_begin :1;
  bool range_end :1;
  bool offset_key :1;
  bool offset_rev :1;
  bool key_intervals :1;
  bool values :1;
  bool ts_start :1;
  bool ts_finish :1;
  bool flags :1;
  bool options :1;
  bool updating :1;
} _SpecIntervalCounter__isset;

/**
 * The Cells Interval Counter type Specifications with interval-scope Flags
 */
class SpecIntervalCounter : public virtual ::apache::thrift::TBase {
 public:

  SpecIntervalCounter(const SpecIntervalCounter&);
  SpecIntervalCounter(SpecIntervalCounter&&) noexcept;
  SpecIntervalCounter& operator=(const SpecIntervalCounter&);
  SpecIntervalCounter& operator=(SpecIntervalCounter&&) noexcept;
  SpecIntervalCounter() noexcept
                      : offset_rev(0),
                        options(static_cast<SpecIntervalOptions::type>(0)) {
  }

  virtual ~SpecIntervalCounter() noexcept;
  /**
   * Begin of Ranges evaluation with this Key inclusive
   */
  Key range_begin;
  /**
   * End of Ranges evaluation with this Key inclusive
   */
  Key range_end;
  /**
   * Offset Cell Key of a Scan, select cells from this key inclusive
   */
  Key offset_key;
  /**
   * Offset Cell Timestamp of a Scan, select cells after this timestamp
   */
  int64_t offset_rev;
  /**
   * The Key Intervals
   */
  SpecKeyIntervals key_intervals;
  /**
   * The Cell Value Specifications, cell-value match for counter type
   */
  SpecValuesCounter values;
  /**
   * The Timestamp Start Spec, the start of cells-interval timestamp match
   */
  SpecTimestamp ts_start;
  /**
   * The Timestamp Finish Spec, the finish of cells-interval timestamp match
   */
  SpecTimestamp ts_finish;
  /**
   * The Interval Flags Specification
   */
  SpecFlags flags;
  /**
   * The Interval Options Specification
   * 
   * @see SpecIntervalOptions
   */
  SpecIntervalOptions::type options;
  /**
   * The Value spec of an Updating Interval
   */
  SpecIntervalUpdateCounter updating;

  _SpecIntervalCounter__isset __isset;

  void __set_range_begin(const Key& val);

  void __set_range_end(const Key& val);

  void __set_offset_key(const Key& val);

  void __set_offset_rev(const int64_t val);

  void __set_key_intervals(const SpecKeyIntervals& val);

  void __set_values(const SpecValuesCounter& val);

  void __set_ts_start(const SpecTimestamp& val);

  void __set_ts_finish(const SpecTimestamp& val);

  void __set_flags(const SpecFlags& val);

  void __set_options(const SpecIntervalOptions::type val);

  void __set_updating(const SpecIntervalUpdateCounter& val);

  bool operator == (const SpecIntervalCounter & rhs) const
  {
    if (!(range_begin == rhs.range_begin))
      return false;
    if (!(range_end == rhs.range_end))
      return false;
    if (!(offset_key == rhs.offset_key))
      return false;
    if (__isset.offset_rev != rhs.__isset.offset_rev)
      return false;
    else if (__isset.offset_rev && !(offset_rev == rhs.offset_rev))
      return false;
    if (!(key_intervals == rhs.key_intervals))
      return false;
    if (!(values == rhs.values))
      return false;
    if (__isset.ts_start != rhs.__isset.ts_start)
      return false;
    else if (__isset.ts_start && !(ts_start == rhs.ts_start))
      return false;
    if (__isset.ts_finish != rhs.__isset.ts_finish)
      return false;
    else if (__isset.ts_finish && !(ts_finish == rhs.ts_finish))
      return false;
    if (__isset.flags != rhs.__isset.flags)
      return false;
    else if (__isset.flags && !(flags == rhs.flags))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    if (__isset.updating != rhs.__isset.updating)
      return false;
    else if (__isset.updating && !(updating == rhs.updating))
      return false;
    return true;
  }
  bool operator != (const SpecIntervalCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecIntervalCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecIntervalCounter &a, SpecIntervalCounter &b);

std::ostream& operator<<(std::ostream& out, const SpecIntervalCounter& obj);

typedef struct _SpecIntervalSerial__isset {
  _SpecIntervalSerial__isset() : range_begin(false), range_end(false), offset_key(false), offset_rev(false), key_intervals(false), values(false), ts_start(false), ts_finish(false), flags(false), options(false), updating(false) {}
  bool range_begin :1;
  bool range_end :1;
  bool offset_key :1;
  bool offset_rev :1;
  bool key_intervals :1;
  bool values :1;
  bool ts_start :1;
  bool ts_finish :1;
  bool flags :1;
  bool options :1;
  bool updating :1;
} _SpecIntervalSerial__isset;

/**
 * The Cells Interval Serial type Specifications with interval-scope Flags
 */
class SpecIntervalSerial : public virtual ::apache::thrift::TBase {
 public:

  SpecIntervalSerial(const SpecIntervalSerial&);
  SpecIntervalSerial(SpecIntervalSerial&&) noexcept;
  SpecIntervalSerial& operator=(const SpecIntervalSerial&);
  SpecIntervalSerial& operator=(SpecIntervalSerial&&) noexcept;
  SpecIntervalSerial() noexcept
                     : offset_rev(0),
                       options(static_cast<SpecIntervalOptions::type>(0)) {
  }

  virtual ~SpecIntervalSerial() noexcept;
  /**
   * Begin of Ranges evaluation with this Key inclusive
   */
  Key range_begin;
  /**
   * End of Ranges evaluation with this Key inclusive
   */
  Key range_end;
  /**
   * Offset Cell Key of a Scan, select cells from this key inclusive
   */
  Key offset_key;
  /**
   * Offset Cell Timestamp of a Scan, select cells after this timestamp
   */
  int64_t offset_rev;
  /**
   * The Key Intervals
   */
  SpecKeyIntervals key_intervals;
  /**
   * The Serial Cell Value Specifications, cell-value fields match
   */
  SpecValuesSerial values;
  /**
   * The Timestamp Start Spec, the start of cells-interval timestamp match
   */
  SpecTimestamp ts_start;
  /**
   * The Timestamp Finish Spec, the finish of cells-interval timestamp match
   */
  SpecTimestamp ts_finish;
  /**
   * The Interval Flags Specification
   */
  SpecFlags flags;
  /**
   * The Interval Options Specification
   * 
   * @see SpecIntervalOptions
   */
  SpecIntervalOptions::type options;
  /**
   * The Serial-Value spec of an Updating Interval
   */
  SpecIntervalUpdateSerial updating;

  _SpecIntervalSerial__isset __isset;

  void __set_range_begin(const Key& val);

  void __set_range_end(const Key& val);

  void __set_offset_key(const Key& val);

  void __set_offset_rev(const int64_t val);

  void __set_key_intervals(const SpecKeyIntervals& val);

  void __set_values(const SpecValuesSerial& val);

  void __set_ts_start(const SpecTimestamp& val);

  void __set_ts_finish(const SpecTimestamp& val);

  void __set_flags(const SpecFlags& val);

  void __set_options(const SpecIntervalOptions::type val);

  void __set_updating(const SpecIntervalUpdateSerial& val);

  bool operator == (const SpecIntervalSerial & rhs) const
  {
    if (!(range_begin == rhs.range_begin))
      return false;
    if (!(range_end == rhs.range_end))
      return false;
    if (!(offset_key == rhs.offset_key))
      return false;
    if (__isset.offset_rev != rhs.__isset.offset_rev)
      return false;
    else if (__isset.offset_rev && !(offset_rev == rhs.offset_rev))
      return false;
    if (!(key_intervals == rhs.key_intervals))
      return false;
    if (!(values == rhs.values))
      return false;
    if (__isset.ts_start != rhs.__isset.ts_start)
      return false;
    else if (__isset.ts_start && !(ts_start == rhs.ts_start))
      return false;
    if (__isset.ts_finish != rhs.__isset.ts_finish)
      return false;
    else if (__isset.ts_finish && !(ts_finish == rhs.ts_finish))
      return false;
    if (__isset.flags != rhs.__isset.flags)
      return false;
    else if (__isset.flags && !(flags == rhs.flags))
      return false;
    if (__isset.options != rhs.__isset.options)
      return false;
    else if (__isset.options && !(options == rhs.options))
      return false;
    if (__isset.updating != rhs.__isset.updating)
      return false;
    else if (__isset.updating && !(updating == rhs.updating))
      return false;
    return true;
  }
  bool operator != (const SpecIntervalSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecIntervalSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecIntervalSerial &a, SpecIntervalSerial &b);

std::ostream& operator<<(std::ostream& out, const SpecIntervalSerial& obj);

typedef struct _SpecColumnPlain__isset {
  _SpecColumnPlain__isset() : cid(false), intervals(false) {}
  bool cid :1;
  bool intervals :1;
} _SpecColumnPlain__isset;

/**
 * The Column Specifications, the Cells-Intervals(SpecIntervalPlain/s) specification for a PLAIN Type column
 */
class SpecColumnPlain : public virtual ::apache::thrift::TBase {
 public:

  SpecColumnPlain(const SpecColumnPlain&);
  SpecColumnPlain(SpecColumnPlain&&) noexcept;
  SpecColumnPlain& operator=(const SpecColumnPlain&);
  SpecColumnPlain& operator=(SpecColumnPlain&&) noexcept;
  SpecColumnPlain() noexcept
                  : cid(0) {
  }

  virtual ~SpecColumnPlain() noexcept;
  /**
   * The Column ID
   */
  int64_t cid;
  /**
   * The Cells Interval in a list-container
   */
  std::vector<SpecIntervalPlain>  intervals;

  _SpecColumnPlain__isset __isset;

  void __set_cid(const int64_t val);

  void __set_intervals(const std::vector<SpecIntervalPlain> & val);

  bool operator == (const SpecColumnPlain & rhs) const
  {
    if (!(cid == rhs.cid))
      return false;
    if (!(intervals == rhs.intervals))
      return false;
    return true;
  }
  bool operator != (const SpecColumnPlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecColumnPlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecColumnPlain &a, SpecColumnPlain &b);

std::ostream& operator<<(std::ostream& out, const SpecColumnPlain& obj);

typedef struct _SpecColumnCounter__isset {
  _SpecColumnCounter__isset() : cid(false), intervals(false) {}
  bool cid :1;
  bool intervals :1;
} _SpecColumnCounter__isset;

/**
 * The Column Specifications, the Cells-Intervals(SpecIntervalCounter/s) specification for a COUNTER Type column
 */
class SpecColumnCounter : public virtual ::apache::thrift::TBase {
 public:

  SpecColumnCounter(const SpecColumnCounter&);
  SpecColumnCounter(SpecColumnCounter&&) noexcept;
  SpecColumnCounter& operator=(const SpecColumnCounter&);
  SpecColumnCounter& operator=(SpecColumnCounter&&) noexcept;
  SpecColumnCounter() noexcept
                    : cid(0) {
  }

  virtual ~SpecColumnCounter() noexcept;
  /**
   * The Column ID
   */
  int64_t cid;
  /**
   * The Cells Interval in a list-container
   */
  std::vector<SpecIntervalCounter>  intervals;

  _SpecColumnCounter__isset __isset;

  void __set_cid(const int64_t val);

  void __set_intervals(const std::vector<SpecIntervalCounter> & val);

  bool operator == (const SpecColumnCounter & rhs) const
  {
    if (!(cid == rhs.cid))
      return false;
    if (!(intervals == rhs.intervals))
      return false;
    return true;
  }
  bool operator != (const SpecColumnCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecColumnCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecColumnCounter &a, SpecColumnCounter &b);

std::ostream& operator<<(std::ostream& out, const SpecColumnCounter& obj);

typedef struct _SpecColumnSerial__isset {
  _SpecColumnSerial__isset() : cid(false), intervals(false) {}
  bool cid :1;
  bool intervals :1;
} _SpecColumnSerial__isset;

/**
 * The Column Specifications, the Cells-Intervals(SpecIntervalSerial/s) specification for a SERIAL Type Column
 */
class SpecColumnSerial : public virtual ::apache::thrift::TBase {
 public:

  SpecColumnSerial(const SpecColumnSerial&);
  SpecColumnSerial(SpecColumnSerial&&) noexcept;
  SpecColumnSerial& operator=(const SpecColumnSerial&);
  SpecColumnSerial& operator=(SpecColumnSerial&&) noexcept;
  SpecColumnSerial() noexcept
                   : cid(0) {
  }

  virtual ~SpecColumnSerial() noexcept;
  /**
   * The Column ID
   */
  int64_t cid;
  /**
   * The Serial Cells Interval in a list-container
   */
  std::vector<SpecIntervalSerial>  intervals;

  _SpecColumnSerial__isset __isset;

  void __set_cid(const int64_t val);

  void __set_intervals(const std::vector<SpecIntervalSerial> & val);

  bool operator == (const SpecColumnSerial & rhs) const
  {
    if (!(cid == rhs.cid))
      return false;
    if (!(intervals == rhs.intervals))
      return false;
    return true;
  }
  bool operator != (const SpecColumnSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecColumnSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecColumnSerial &a, SpecColumnSerial &b);

std::ostream& operator<<(std::ostream& out, const SpecColumnSerial& obj);

typedef struct _SpecScan__isset {
  _SpecScan__isset() : columns_plain(false), columns_counter(false), columns_serial(false), flags(false) {}
  bool columns_plain :1;
  bool columns_counter :1;
  bool columns_serial :1;
  bool flags :1;
} _SpecScan__isset;

/**
 * The Scan Specifications, the Columns-Intervals(SpecColumn/s) with global-scope Flags
 */
class SpecScan : public virtual ::apache::thrift::TBase {
 public:

  SpecScan(const SpecScan&);
  SpecScan(SpecScan&&) noexcept;
  SpecScan& operator=(const SpecScan&);
  SpecScan& operator=(SpecScan&&) noexcept;
  SpecScan() noexcept {
  }

  virtual ~SpecScan() noexcept;
  /**
   * The Plain Column Intervals(SpecColumnPlain) in a list-container
   */
  std::vector<SpecColumnPlain>  columns_plain;
  /**
   * The Counter Column Intervals(SpecColumnCounter) in a list-container
   */
  std::vector<SpecColumnCounter>  columns_counter;
  /**
   * The Serial Column Intervals(SpecColumnSerial) in a list-container
   */
  std::vector<SpecColumnSerial>  columns_serial;
  /**
   * The Global Flags Specification
   */
  SpecFlags flags;

  _SpecScan__isset __isset;

  void __set_columns_plain(const std::vector<SpecColumnPlain> & val);

  void __set_columns_counter(const std::vector<SpecColumnCounter> & val);

  void __set_columns_serial(const std::vector<SpecColumnSerial> & val);

  void __set_flags(const SpecFlags& val);

  bool operator == (const SpecScan & rhs) const
  {
    if (!(columns_plain == rhs.columns_plain))
      return false;
    if (!(columns_counter == rhs.columns_counter))
      return false;
    if (!(columns_serial == rhs.columns_serial))
      return false;
    if (__isset.flags != rhs.__isset.flags)
      return false;
    else if (__isset.flags && !(flags == rhs.flags))
      return false;
    return true;
  }
  bool operator != (const SpecScan &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SpecScan & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(SpecScan &a, SpecScan &b);

std::ostream& operator<<(std::ostream& out, const SpecScan& obj);

typedef struct _UCellPlain__isset {
  _UCellPlain__isset() : f(false), k(false), ts(false), ts_desc(false), v(false), encoder(false) {}
  bool f :1;
  bool k :1;
  bool ts :1;
  bool ts_desc :1;
  bool v :1;
  bool encoder :1;
} _UCellPlain__isset;

/**
 * The Cell data for using with Update of PLAIN Column Type
 */
class UCellPlain : public virtual ::apache::thrift::TBase {
 public:

  UCellPlain(const UCellPlain&);
  UCellPlain(UCellPlain&&) noexcept;
  UCellPlain& operator=(const UCellPlain&);
  UCellPlain& operator=(UCellPlain&&) noexcept;
  UCellPlain() noexcept
             : f(static_cast<Flag::type>(0)),
               ts(0),
               ts_desc(0),
               v(),
               encoder(static_cast<EncodingType::type>(0)) {
  }

  virtual ~UCellPlain() noexcept;
  /**
   * The Cell Flag
   * 
   * @see Flag
   */
  Flag::type f;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp in nanoseconds
   */
  int64_t ts;
  /**
   * The Cell Version is in timestamp descending
   */
  bool ts_desc;
  /**
   * The Cell Value
   */
  std::string v;
  /**
   * Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
   * 
   * @see EncodingType
   */
  EncodingType::type encoder;

  _UCellPlain__isset __isset;

  void __set_f(const Flag::type val);

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_ts_desc(const bool val);

  void __set_v(const std::string& val);

  void __set_encoder(const EncodingType::type val);

  bool operator == (const UCellPlain & rhs) const
  {
    if (!(f == rhs.f))
      return false;
    if (!(k == rhs.k))
      return false;
    if (__isset.ts != rhs.__isset.ts)
      return false;
    else if (__isset.ts && !(ts == rhs.ts))
      return false;
    if (__isset.ts_desc != rhs.__isset.ts_desc)
      return false;
    else if (__isset.ts_desc && !(ts_desc == rhs.ts_desc))
      return false;
    if (!(v == rhs.v))
      return false;
    if (__isset.encoder != rhs.__isset.encoder)
      return false;
    else if (__isset.encoder && !(encoder == rhs.encoder))
      return false;
    return true;
  }
  bool operator != (const UCellPlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UCellPlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UCellPlain &a, UCellPlain &b);

std::ostream& operator<<(std::ostream& out, const UCellPlain& obj);

typedef struct _UCellCounter__isset {
  _UCellCounter__isset() : f(false), k(false), ts(false), ts_desc(false), op(true), v(true) {}
  bool f :1;
  bool k :1;
  bool ts :1;
  bool ts_desc :1;
  bool op :1;
  bool v :1;
} _UCellCounter__isset;

/**
 * The Cell data for using with Update of COUNTER Column Type
 */
class UCellCounter : public virtual ::apache::thrift::TBase {
 public:

  UCellCounter(const UCellCounter&);
  UCellCounter(UCellCounter&&) noexcept;
  UCellCounter& operator=(const UCellCounter&);
  UCellCounter& operator=(UCellCounter&&) noexcept;
  UCellCounter() noexcept
               : f(static_cast<Flag::type>(0)),
                 ts(0),
                 ts_desc(0),
                 op(0),
                 v(0LL) {
  }

  virtual ~UCellCounter() noexcept;
  /**
   * The Cell Flag
   * 
   * @see Flag
   */
  Flag::type f;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp in nanoseconds
   */
  int64_t ts;
  /**
   * The Cell Version is in timestamp descending
   */
  bool ts_desc;
  /**
   * The Cell Counter Operation
   */
  int8_t op;
  /**
   * The Cell Counter Value
   */
  int64_t v;

  _UCellCounter__isset __isset;

  void __set_f(const Flag::type val);

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_ts_desc(const bool val);

  void __set_op(const int8_t val);

  void __set_v(const int64_t val);

  bool operator == (const UCellCounter & rhs) const
  {
    if (!(f == rhs.f))
      return false;
    if (!(k == rhs.k))
      return false;
    if (__isset.ts != rhs.__isset.ts)
      return false;
    else if (__isset.ts && !(ts == rhs.ts))
      return false;
    if (__isset.ts_desc != rhs.__isset.ts_desc)
      return false;
    else if (__isset.ts_desc && !(ts_desc == rhs.ts_desc))
      return false;
    if (!(op == rhs.op))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const UCellCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UCellCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UCellCounter &a, UCellCounter &b);

std::ostream& operator<<(std::ostream& out, const UCellCounter& obj);

typedef struct _CellValueSerial__isset {
  _CellValueSerial__isset() : field_id(false), v_int64(false), v_double(false), v_bytes(false), v_key(false), v_li(false), v_lb(false) {}
  bool field_id :1;
  bool v_int64 :1;
  bool v_double :1;
  bool v_bytes :1;
  bool v_key :1;
  bool v_li :1;
  bool v_lb :1;
} _CellValueSerial__isset;

/**
 * The Serial Value Cell field
 */
class CellValueSerial : public virtual ::apache::thrift::TBase {
 public:

  CellValueSerial(const CellValueSerial&);
  CellValueSerial(CellValueSerial&&) noexcept;
  CellValueSerial& operator=(const CellValueSerial&);
  CellValueSerial& operator=(CellValueSerial&&) noexcept;
  CellValueSerial() noexcept
                  : field_id(0),
                    v_int64(0),
                    v_double(0),
                    v_bytes() {
  }

  virtual ~CellValueSerial() noexcept;
  /**
   * The Field ID, a single ID can have any/all the field types
   */
  int32_t field_id;
  /**
   * The INT64 type field
   */
  int64_t v_int64;
  /**
   * The DOUBLE type field
   */
  double v_double;
  /**
   * The BYTES type field
   */
  std::string v_bytes;
  /**
   * The Cell KEY type field
   */
  Key v_key;
  /**
   * The LIST INT64 type field
   */
  std::vector<int64_t>  v_li;
  /**
   * The LIST BYTES type field
   */
  std::vector<std::string>  v_lb;

  _CellValueSerial__isset __isset;

  void __set_field_id(const int32_t val);

  void __set_v_int64(const int64_t val);

  void __set_v_double(const double val);

  void __set_v_bytes(const std::string& val);

  void __set_v_key(const Key& val);

  void __set_v_li(const std::vector<int64_t> & val);

  void __set_v_lb(const std::vector<std::string> & val);

  bool operator == (const CellValueSerial & rhs) const
  {
    if (!(field_id == rhs.field_id))
      return false;
    if (__isset.v_int64 != rhs.__isset.v_int64)
      return false;
    else if (__isset.v_int64 && !(v_int64 == rhs.v_int64))
      return false;
    if (__isset.v_double != rhs.__isset.v_double)
      return false;
    else if (__isset.v_double && !(v_double == rhs.v_double))
      return false;
    if (__isset.v_bytes != rhs.__isset.v_bytes)
      return false;
    else if (__isset.v_bytes && !(v_bytes == rhs.v_bytes))
      return false;
    if (__isset.v_key != rhs.__isset.v_key)
      return false;
    else if (__isset.v_key && !(v_key == rhs.v_key))
      return false;
    if (__isset.v_li != rhs.__isset.v_li)
      return false;
    else if (__isset.v_li && !(v_li == rhs.v_li))
      return false;
    if (__isset.v_lb != rhs.__isset.v_lb)
      return false;
    else if (__isset.v_lb && !(v_lb == rhs.v_lb))
      return false;
    return true;
  }
  bool operator != (const CellValueSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellValueSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CellValueSerial &a, CellValueSerial &b);

std::ostream& operator<<(std::ostream& out, const CellValueSerial& obj);

typedef struct _FU_INT64__isset {
  _FU_INT64__isset() : ctrl(true), op(true), pos(false), comp(false), v(false) {}
  bool ctrl :1;
  bool op :1;
  bool pos :1;
  bool comp :1;
  bool v :1;
} _FU_INT64__isset;

/**
 * Serial INT64 Field Update
 */
class FU_INT64 : public virtual ::apache::thrift::TBase {
 public:

  FU_INT64(const FU_INT64&) noexcept;
  FU_INT64(FU_INT64&&) noexcept;
  FU_INT64& operator=(const FU_INT64&) noexcept;
  FU_INT64& operator=(FU_INT64&&) noexcept;
  FU_INT64() noexcept
           : ctrl(0),
             op(static_cast<FU_MATH_OP::type>(0)),
             pos(0),
             comp(static_cast<Comp::type>(0)),
             v(0) {
  }

  virtual ~FU_INT64() noexcept;
  int8_t ctrl;
  /**
   * 
   * @see FU_MATH_OP
   */
  FU_MATH_OP::type op;
  int32_t pos;
  /**
   * 
   * @see Comp
   */
  Comp::type comp;
  int64_t v;

  _FU_INT64__isset __isset;

  void __set_ctrl(const int8_t val);

  void __set_op(const FU_MATH_OP::type val);

  void __set_pos(const int32_t val);

  void __set_comp(const Comp::type val);

  void __set_v(const int64_t val);

  bool operator == (const FU_INT64 & rhs) const
  {
    if (!(ctrl == rhs.ctrl))
      return false;
    if (!(op == rhs.op))
      return false;
    if (__isset.pos != rhs.__isset.pos)
      return false;
    else if (__isset.pos && !(pos == rhs.pos))
      return false;
    if (__isset.comp != rhs.__isset.comp)
      return false;
    else if (__isset.comp && !(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const FU_INT64 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FU_INT64 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FU_INT64 &a, FU_INT64 &b);

std::ostream& operator<<(std::ostream& out, const FU_INT64& obj);

typedef struct _FU_DOUBLE__isset {
  _FU_DOUBLE__isset() : ctrl(true), op(true), pos(false), comp(false), v(false) {}
  bool ctrl :1;
  bool op :1;
  bool pos :1;
  bool comp :1;
  bool v :1;
} _FU_DOUBLE__isset;

/**
 * Serial DOUBLE Field Update
 */
class FU_DOUBLE : public virtual ::apache::thrift::TBase {
 public:

  FU_DOUBLE(const FU_DOUBLE&) noexcept;
  FU_DOUBLE(FU_DOUBLE&&) noexcept;
  FU_DOUBLE& operator=(const FU_DOUBLE&) noexcept;
  FU_DOUBLE& operator=(FU_DOUBLE&&) noexcept;
  FU_DOUBLE() noexcept
            : ctrl(0),
              op(static_cast<FU_MATH_OP::type>(0)),
              pos(0),
              comp(static_cast<Comp::type>(0)),
              v(0) {
  }

  virtual ~FU_DOUBLE() noexcept;
  int8_t ctrl;
  /**
   * 
   * @see FU_MATH_OP
   */
  FU_MATH_OP::type op;
  int32_t pos;
  /**
   * 
   * @see Comp
   */
  Comp::type comp;
  double v;

  _FU_DOUBLE__isset __isset;

  void __set_ctrl(const int8_t val);

  void __set_op(const FU_MATH_OP::type val);

  void __set_pos(const int32_t val);

  void __set_comp(const Comp::type val);

  void __set_v(const double val);

  bool operator == (const FU_DOUBLE & rhs) const
  {
    if (!(ctrl == rhs.ctrl))
      return false;
    if (!(op == rhs.op))
      return false;
    if (__isset.pos != rhs.__isset.pos)
      return false;
    else if (__isset.pos && !(pos == rhs.pos))
      return false;
    if (__isset.comp != rhs.__isset.comp)
      return false;
    else if (__isset.comp && !(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const FU_DOUBLE &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FU_DOUBLE & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FU_DOUBLE &a, FU_DOUBLE &b);

std::ostream& operator<<(std::ostream& out, const FU_DOUBLE& obj);

typedef struct _FU_BYTES__isset {
  _FU_BYTES__isset() : ctrl(true), op(true), pos(false), comp(false), v(false) {}
  bool ctrl :1;
  bool op :1;
  bool pos :1;
  bool comp :1;
  bool v :1;
} _FU_BYTES__isset;

/**
 * Serial BYTES Field Update
 */
class FU_BYTES : public virtual ::apache::thrift::TBase {
 public:

  FU_BYTES(const FU_BYTES&);
  FU_BYTES(FU_BYTES&&) noexcept;
  FU_BYTES& operator=(const FU_BYTES&);
  FU_BYTES& operator=(FU_BYTES&&) noexcept;
  FU_BYTES() noexcept
           : ctrl(0),
             op(static_cast<FU_LIST_OP::type>(0)),
             pos(0),
             comp(static_cast<Comp::type>(0)),
             v() {
  }

  virtual ~FU_BYTES() noexcept;
  int8_t ctrl;
  /**
   * 
   * @see FU_LIST_OP
   */
  FU_LIST_OP::type op;
  int32_t pos;
  /**
   * 
   * @see Comp
   */
  Comp::type comp;
  std::string v;

  _FU_BYTES__isset __isset;

  void __set_ctrl(const int8_t val);

  void __set_op(const FU_LIST_OP::type val);

  void __set_pos(const int32_t val);

  void __set_comp(const Comp::type val);

  void __set_v(const std::string& val);

  bool operator == (const FU_BYTES & rhs) const
  {
    if (!(ctrl == rhs.ctrl))
      return false;
    if (!(op == rhs.op))
      return false;
    if (__isset.pos != rhs.__isset.pos)
      return false;
    else if (__isset.pos && !(pos == rhs.pos))
      return false;
    if (__isset.comp != rhs.__isset.comp)
      return false;
    else if (__isset.comp && !(comp == rhs.comp))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const FU_BYTES &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FU_BYTES & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FU_BYTES &a, FU_BYTES &b);

std::ostream& operator<<(std::ostream& out, const FU_BYTES& obj);

typedef struct _FU_LI__isset {
  _FU_LI__isset() : ctrl(true), op(true), pos(false), v(false) {}
  bool ctrl :1;
  bool op :1;
  bool pos :1;
  bool v :1;
} _FU_LI__isset;

/**
 * Serial LIST_INT64 Field Update
 */
class FU_LI : public virtual ::apache::thrift::TBase {
 public:

  FU_LI(const FU_LI&);
  FU_LI(FU_LI&&) noexcept;
  FU_LI& operator=(const FU_LI&);
  FU_LI& operator=(FU_LI&&) noexcept;
  FU_LI() noexcept
        : ctrl(0),
          op(static_cast<FU_LIST_OP::type>(0)),
          pos(0) {
  }

  virtual ~FU_LI() noexcept;
  int8_t ctrl;
  /**
   * 
   * @see FU_LIST_OP
   */
  FU_LIST_OP::type op;
  int32_t pos;
  std::vector<FU_INT64>  v;

  _FU_LI__isset __isset;

  void __set_ctrl(const int8_t val);

  void __set_op(const FU_LIST_OP::type val);

  void __set_pos(const int32_t val);

  void __set_v(const std::vector<FU_INT64> & val);

  bool operator == (const FU_LI & rhs) const
  {
    if (!(ctrl == rhs.ctrl))
      return false;
    if (!(op == rhs.op))
      return false;
    if (__isset.pos != rhs.__isset.pos)
      return false;
    else if (__isset.pos && !(pos == rhs.pos))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const FU_LI &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FU_LI & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FU_LI &a, FU_LI &b);

std::ostream& operator<<(std::ostream& out, const FU_LI& obj);

typedef struct _FU_LB__isset {
  _FU_LB__isset() : ctrl(true), op(true), pos(false), v(false) {}
  bool ctrl :1;
  bool op :1;
  bool pos :1;
  bool v :1;
} _FU_LB__isset;

/**
 * Serial LIST_BYTES Field Update
 */
class FU_LB : public virtual ::apache::thrift::TBase {
 public:

  FU_LB(const FU_LB&);
  FU_LB(FU_LB&&) noexcept;
  FU_LB& operator=(const FU_LB&);
  FU_LB& operator=(FU_LB&&) noexcept;
  FU_LB() noexcept
        : ctrl(0),
          op(static_cast<FU_LIST_OP::type>(0)),
          pos(0) {
  }

  virtual ~FU_LB() noexcept;
  int8_t ctrl;
  /**
   * 
   * @see FU_LIST_OP
   */
  FU_LIST_OP::type op;
  int32_t pos;
  std::vector<FU_BYTES>  v;

  _FU_LB__isset __isset;

  void __set_ctrl(const int8_t val);

  void __set_op(const FU_LIST_OP::type val);

  void __set_pos(const int32_t val);

  void __set_v(const std::vector<FU_BYTES> & val);

  bool operator == (const FU_LB & rhs) const
  {
    if (!(ctrl == rhs.ctrl))
      return false;
    if (!(op == rhs.op))
      return false;
    if (__isset.pos != rhs.__isset.pos)
      return false;
    else if (__isset.pos && !(pos == rhs.pos))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const FU_LB &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FU_LB & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FU_LB &a, FU_LB &b);

std::ostream& operator<<(std::ostream& out, const FU_LB& obj);

typedef struct _CellValueSerialOp__isset {
  _CellValueSerialOp__isset() : field_id(false), v_int64(false), v_double(false), v_bytes(false), v_key(false), v_li(false), v_lb(false) {}
  bool field_id :1;
  bool v_int64 :1;
  bool v_double :1;
  bool v_bytes :1;
  bool v_key :1;
  bool v_li :1;
  bool v_lb :1;
} _CellValueSerialOp__isset;

/**
 * The Serial Values Cell field with Update Operation
 */
class CellValueSerialOp : public virtual ::apache::thrift::TBase {
 public:

  CellValueSerialOp(const CellValueSerialOp&);
  CellValueSerialOp(CellValueSerialOp&&) noexcept;
  CellValueSerialOp& operator=(const CellValueSerialOp&);
  CellValueSerialOp& operator=(CellValueSerialOp&&) noexcept;
  CellValueSerialOp() noexcept
                    : field_id(0) {
  }

  virtual ~CellValueSerialOp() noexcept;
  /**
   * The Field ID, a single ID can have any/all the field types
   */
  int32_t field_id;
  /**
   * The INT64 type update-field
   */
  FU_INT64 v_int64;
  /**
   * The DOUBLE type update-field
   */
  FU_DOUBLE v_double;
  /**
   * The BYTES type update-field
   */
  FU_BYTES v_bytes;
  /**
   * The Cell KEY type update-field
   */
  Key v_key;
  /**
   * The LIST INT64 type update-field
   */
  FU_LI v_li;
  /**
   * The LIST BYTES type update-field
   */
  FU_LB v_lb;

  _CellValueSerialOp__isset __isset;

  void __set_field_id(const int32_t val);

  void __set_v_int64(const FU_INT64& val);

  void __set_v_double(const FU_DOUBLE& val);

  void __set_v_bytes(const FU_BYTES& val);

  void __set_v_key(const Key& val);

  void __set_v_li(const FU_LI& val);

  void __set_v_lb(const FU_LB& val);

  bool operator == (const CellValueSerialOp & rhs) const
  {
    if (!(field_id == rhs.field_id))
      return false;
    if (__isset.v_int64 != rhs.__isset.v_int64)
      return false;
    else if (__isset.v_int64 && !(v_int64 == rhs.v_int64))
      return false;
    if (__isset.v_double != rhs.__isset.v_double)
      return false;
    else if (__isset.v_double && !(v_double == rhs.v_double))
      return false;
    if (__isset.v_bytes != rhs.__isset.v_bytes)
      return false;
    else if (__isset.v_bytes && !(v_bytes == rhs.v_bytes))
      return false;
    if (__isset.v_key != rhs.__isset.v_key)
      return false;
    else if (__isset.v_key && !(v_key == rhs.v_key))
      return false;
    if (__isset.v_li != rhs.__isset.v_li)
      return false;
    else if (__isset.v_li && !(v_li == rhs.v_li))
      return false;
    if (__isset.v_lb != rhs.__isset.v_lb)
      return false;
    else if (__isset.v_lb && !(v_lb == rhs.v_lb))
      return false;
    return true;
  }
  bool operator != (const CellValueSerialOp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellValueSerialOp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CellValueSerialOp &a, CellValueSerialOp &b);

std::ostream& operator<<(std::ostream& out, const CellValueSerialOp& obj);

typedef struct _UCellSerial__isset {
  _UCellSerial__isset() : f(false), k(false), ts(false), ts_desc(false), v(false), encoder(false) {}
  bool f :1;
  bool k :1;
  bool ts :1;
  bool ts_desc :1;
  bool v :1;
  bool encoder :1;
} _UCellSerial__isset;

/**
 * The Cell data for using with Update of SERIAL Column Type
 */
class UCellSerial : public virtual ::apache::thrift::TBase {
 public:

  UCellSerial(const UCellSerial&);
  UCellSerial(UCellSerial&&) noexcept;
  UCellSerial& operator=(const UCellSerial&);
  UCellSerial& operator=(UCellSerial&&) noexcept;
  UCellSerial() noexcept
              : f(static_cast<Flag::type>(0)),
                ts(0),
                ts_desc(0),
                encoder(static_cast<EncodingType::type>(0)) {
  }

  virtual ~UCellSerial() noexcept;
  /**
   * The Cell Flag
   * 
   * @see Flag
   */
  Flag::type f;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp in nanoseconds
   */
  int64_t ts;
  /**
   * The Cell Version is in timestamp descending
   */
  bool ts_desc;
  /**
   * The Serial Cell Value fields
   */
  CellValuesSerial v;
  /**
   * Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
   * 
   * @see EncodingType
   */
  EncodingType::type encoder;

  _UCellSerial__isset __isset;

  void __set_f(const Flag::type val);

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_ts_desc(const bool val);

  void __set_v(const CellValuesSerial& val);

  void __set_encoder(const EncodingType::type val);

  bool operator == (const UCellSerial & rhs) const
  {
    if (!(f == rhs.f))
      return false;
    if (!(k == rhs.k))
      return false;
    if (__isset.ts != rhs.__isset.ts)
      return false;
    else if (__isset.ts && !(ts == rhs.ts))
      return false;
    if (__isset.ts_desc != rhs.__isset.ts_desc)
      return false;
    else if (__isset.ts_desc && !(ts_desc == rhs.ts_desc))
      return false;
    if (!(v == rhs.v))
      return false;
    if (__isset.encoder != rhs.__isset.encoder)
      return false;
    else if (__isset.encoder && !(encoder == rhs.encoder))
      return false;
    return true;
  }
  bool operator != (const UCellSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UCellSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(UCellSerial &a, UCellSerial &b);

std::ostream& operator<<(std::ostream& out, const UCellSerial& obj);

typedef struct _CellPlain__isset {
  _CellPlain__isset() : c(false), k(false), ts(false), v(false) {}
  bool c :1;
  bool k :1;
  bool ts :1;
  bool v :1;
} _CellPlain__isset;

/**
 * The Cell for results list of scan
 */
class CellPlain : public virtual ::apache::thrift::TBase {
 public:

  CellPlain(const CellPlain&);
  CellPlain(CellPlain&&) noexcept;
  CellPlain& operator=(const CellPlain&);
  CellPlain& operator=(CellPlain&&) noexcept;
  CellPlain() noexcept
            : c(),
              ts(0),
              v() {
  }

  virtual ~CellPlain() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Value
   */
  std::string v;

  _CellPlain__isset __isset;

  void __set_c(const std::string& val);

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_v(const std::string& val);

  bool operator == (const CellPlain & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(k == rhs.k))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const CellPlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellPlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CellPlain &a, CellPlain &b);

std::ostream& operator<<(std::ostream& out, const CellPlain& obj);

typedef struct _CellCounter__isset {
  _CellCounter__isset() : c(false), k(false), ts(false), v(false), eq(false) {}
  bool c :1;
  bool k :1;
  bool ts :1;
  bool v :1;
  bool eq :1;
} _CellCounter__isset;

/**
 * The Counter Cell for results list of scan
 */
class CellCounter : public virtual ::apache::thrift::TBase {
 public:

  CellCounter(const CellCounter&);
  CellCounter(CellCounter&&) noexcept;
  CellCounter& operator=(const CellCounter&);
  CellCounter& operator=(CellCounter&&) noexcept;
  CellCounter() noexcept
              : c(),
                ts(0),
                v(0),
                eq(0) {
  }

  virtual ~CellCounter() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Counter Value
   */
  int64_t v;
  /**
   * The Counter EQ since ts
   */
  int64_t eq;

  _CellCounter__isset __isset;

  void __set_c(const std::string& val);

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_v(const int64_t val);

  void __set_eq(const int64_t val);

  bool operator == (const CellCounter & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(k == rhs.k))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    if (__isset.eq != rhs.__isset.eq)
      return false;
    else if (__isset.eq && !(eq == rhs.eq))
      return false;
    return true;
  }
  bool operator != (const CellCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CellCounter &a, CellCounter &b);

std::ostream& operator<<(std::ostream& out, const CellCounter& obj);

typedef struct _CellSerial__isset {
  _CellSerial__isset() : c(false), k(false), ts(false), v(false) {}
  bool c :1;
  bool k :1;
  bool ts :1;
  bool v :1;
} _CellSerial__isset;

/**
 * The Serial Cell for results list of scan
 */
class CellSerial : public virtual ::apache::thrift::TBase {
 public:

  CellSerial(const CellSerial&);
  CellSerial(CellSerial&&) noexcept;
  CellSerial& operator=(const CellSerial&);
  CellSerial& operator=(CellSerial&&) noexcept;
  CellSerial() noexcept
             : c(),
               ts(0) {
  }

  virtual ~CellSerial() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Serial Value
   */
  CellValuesSerial v;

  _CellSerial__isset __isset;

  void __set_c(const std::string& val);

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_v(const CellValuesSerial& val);

  bool operator == (const CellSerial & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(k == rhs.k))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const CellSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CellSerial &a, CellSerial &b);

std::ostream& operator<<(std::ostream& out, const CellSerial& obj);

typedef struct _Cells__isset {
  _Cells__isset() : plain_cells(false), counter_cells(false), serial_cells(false) {}
  bool plain_cells :1;
  bool counter_cells :1;
  bool serial_cells :1;
} _Cells__isset;

/**
 * The Cells for results list of scan
 */
class Cells : public virtual ::apache::thrift::TBase {
 public:

  Cells(const Cells&);
  Cells(Cells&&) noexcept;
  Cells& operator=(const Cells&);
  Cells& operator=(Cells&&) noexcept;
  Cells() noexcept {
  }

  virtual ~Cells() noexcept;
  /**
   * The Cells, defined as Cell items in a list-container
   */
  CellsPlain plain_cells;
  /**
   * The Cells, defined as Cell items in a list-container
   */
  CellsCounter counter_cells;
  /**
   * The Serial Cells, defined as CellSerial items in a list-container
   */
  CellsSerial serial_cells;

  _Cells__isset __isset;

  void __set_plain_cells(const CellsPlain& val);

  void __set_counter_cells(const CellsCounter& val);

  void __set_serial_cells(const CellsSerial& val);

  bool operator == (const Cells & rhs) const
  {
    if (!(plain_cells == rhs.plain_cells))
      return false;
    if (!(counter_cells == rhs.counter_cells))
      return false;
    if (!(serial_cells == rhs.serial_cells))
      return false;
    return true;
  }
  bool operator != (const Cells &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Cells & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Cells &a, Cells &b);

std::ostream& operator<<(std::ostream& out, const Cells& obj);

typedef struct _CCellPlain__isset {
  _CCellPlain__isset() : k(false), ts(false), v(false) {}
  bool k :1;
  bool ts :1;
  bool v :1;
} _CCellPlain__isset;

/**
 * The Plain column type Cell for results on Columns of scan
 */
class CCellPlain : public virtual ::apache::thrift::TBase {
 public:

  CCellPlain(const CCellPlain&);
  CCellPlain(CCellPlain&&) noexcept;
  CCellPlain& operator=(const CCellPlain&);
  CCellPlain& operator=(CCellPlain&&) noexcept;
  CCellPlain() noexcept
             : ts(0),
               v() {
  }

  virtual ~CCellPlain() noexcept;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Value
   */
  std::string v;

  _CCellPlain__isset __isset;

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_v(const std::string& val);

  bool operator == (const CCellPlain & rhs) const
  {
    if (!(k == rhs.k))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const CCellPlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CCellPlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CCellPlain &a, CCellPlain &b);

std::ostream& operator<<(std::ostream& out, const CCellPlain& obj);

typedef struct _CCellCounter__isset {
  _CCellCounter__isset() : k(false), ts(false), v(false), eq(false) {}
  bool k :1;
  bool ts :1;
  bool v :1;
  bool eq :1;
} _CCellCounter__isset;

/**
 * The Counter column type Cell for results on Columns of scan
 */
class CCellCounter : public virtual ::apache::thrift::TBase {
 public:

  CCellCounter(const CCellCounter&);
  CCellCounter(CCellCounter&&) noexcept;
  CCellCounter& operator=(const CCellCounter&);
  CCellCounter& operator=(CCellCounter&&) noexcept;
  CCellCounter() noexcept
               : ts(0),
                 v(0),
                 eq(0) {
  }

  virtual ~CCellCounter() noexcept;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Counter Value
   */
  int64_t v;
  /**
   * The Counter EQ since ts
   */
  int64_t eq;

  _CCellCounter__isset __isset;

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_v(const int64_t val);

  void __set_eq(const int64_t val);

  bool operator == (const CCellCounter & rhs) const
  {
    if (!(k == rhs.k))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    if (__isset.eq != rhs.__isset.eq)
      return false;
    else if (__isset.eq && !(eq == rhs.eq))
      return false;
    return true;
  }
  bool operator != (const CCellCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CCellCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CCellCounter &a, CCellCounter &b);

std::ostream& operator<<(std::ostream& out, const CCellCounter& obj);

typedef struct _CCellSerial__isset {
  _CCellSerial__isset() : k(false), ts(false), v(false) {}
  bool k :1;
  bool ts :1;
  bool v :1;
} _CCellSerial__isset;

/**
 * The Serial column type Cell for results on Columns of scan
 */
class CCellSerial : public virtual ::apache::thrift::TBase {
 public:

  CCellSerial(const CCellSerial&);
  CCellSerial(CCellSerial&&) noexcept;
  CCellSerial& operator=(const CCellSerial&);
  CCellSerial& operator=(CCellSerial&&) noexcept;
  CCellSerial() noexcept
              : ts(0) {
  }

  virtual ~CCellSerial() noexcept;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Serial Value
   */
  CellValuesSerial v;

  _CCellSerial__isset __isset;

  void __set_k(const Key& val);

  void __set_ts(const int64_t val);

  void __set_v(const CellValuesSerial& val);

  bool operator == (const CCellSerial & rhs) const
  {
    if (!(k == rhs.k))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const CCellSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CCellSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CCellSerial &a, CCellSerial &b);

std::ostream& operator<<(std::ostream& out, const CCellSerial& obj);

typedef struct _cCells__isset {
  _cCells__isset() : plain_cells(false), counter_cells(false), serial_cells(false) {}
  bool plain_cells :1;
  bool counter_cells :1;
  bool serial_cells :1;
} _cCells__isset;

/**
 * The Column Cells for results on Columns of scan
 */
class cCells : public virtual ::apache::thrift::TBase {
 public:

  cCells(const cCells&);
  cCells(cCells&&) noexcept;
  cCells& operator=(const cCells&);
  cCells& operator=(cCells&&) noexcept;
  cCells() noexcept {
  }

  virtual ~cCells() noexcept;
  /**
   * The Plain type Cells, defined as CCellPlain items in a list-container
   */
  std::vector<CCellPlain>  plain_cells;
  /**
   * The Counter type Cells, defined as CCellCounter items in a list-container
   */
  std::vector<CCellCounter>  counter_cells;
  /**
   * The Serial type Cells, defined as CCellSerial items in a list-container
   */
  std::vector<CCellSerial>  serial_cells;

  _cCells__isset __isset;

  void __set_plain_cells(const std::vector<CCellPlain> & val);

  void __set_counter_cells(const std::vector<CCellCounter> & val);

  void __set_serial_cells(const std::vector<CCellSerial> & val);

  bool operator == (const cCells & rhs) const
  {
    if (!(plain_cells == rhs.plain_cells))
      return false;
    if (!(counter_cells == rhs.counter_cells))
      return false;
    if (!(serial_cells == rhs.serial_cells))
      return false;
    return true;
  }
  bool operator != (const cCells &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const cCells & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(cCells &a, cCells &b);

std::ostream& operator<<(std::ostream& out, const cCells& obj);

typedef struct _KCellPlain__isset {
  _KCellPlain__isset() : c(false), ts(false), v(false) {}
  bool c :1;
  bool ts :1;
  bool v :1;
} _KCellPlain__isset;

/**
 * The Plain column type Key Cell for results on Key of scan
 */
class KCellPlain : public virtual ::apache::thrift::TBase {
 public:

  KCellPlain(const KCellPlain&);
  KCellPlain(KCellPlain&&) noexcept;
  KCellPlain& operator=(const KCellPlain&);
  KCellPlain& operator=(KCellPlain&&) noexcept;
  KCellPlain() noexcept
             : c(),
               ts(0),
               v() {
  }

  virtual ~KCellPlain() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Value
   */
  std::string v;

  _KCellPlain__isset __isset;

  void __set_c(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_v(const std::string& val);

  bool operator == (const KCellPlain & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const KCellPlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KCellPlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(KCellPlain &a, KCellPlain &b);

std::ostream& operator<<(std::ostream& out, const KCellPlain& obj);

typedef struct _KCellCounter__isset {
  _KCellCounter__isset() : c(false), ts(false), v(false), eq(false) {}
  bool c :1;
  bool ts :1;
  bool v :1;
  bool eq :1;
} _KCellCounter__isset;

/**
 * The Counter column type Key Cell for results on Key of scan
 */
class KCellCounter : public virtual ::apache::thrift::TBase {
 public:

  KCellCounter(const KCellCounter&);
  KCellCounter(KCellCounter&&) noexcept;
  KCellCounter& operator=(const KCellCounter&);
  KCellCounter& operator=(KCellCounter&&) noexcept;
  KCellCounter() noexcept
               : c(),
                 ts(0),
                 v(0),
                 eq(0) {
  }

  virtual ~KCellCounter() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Counter Value
   */
  int64_t v;
  /**
   * The Counter EQ since ts
   */
  int64_t eq;

  _KCellCounter__isset __isset;

  void __set_c(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_v(const int64_t val);

  void __set_eq(const int64_t val);

  bool operator == (const KCellCounter & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    if (__isset.eq != rhs.__isset.eq)
      return false;
    else if (__isset.eq && !(eq == rhs.eq))
      return false;
    return true;
  }
  bool operator != (const KCellCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KCellCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(KCellCounter &a, KCellCounter &b);

std::ostream& operator<<(std::ostream& out, const KCellCounter& obj);

typedef struct _KCellSerial__isset {
  _KCellSerial__isset() : c(false), ts(false), v(false) {}
  bool c :1;
  bool ts :1;
  bool v :1;
} _KCellSerial__isset;

/**
 * The Serial column type Key Cell for results on Key of scan
 */
class KCellSerial : public virtual ::apache::thrift::TBase {
 public:

  KCellSerial(const KCellSerial&);
  KCellSerial(KCellSerial&&) noexcept;
  KCellSerial& operator=(const KCellSerial&);
  KCellSerial& operator=(KCellSerial&&) noexcept;
  KCellSerial() noexcept
              : c(),
                ts(0) {
  }

  virtual ~KCellSerial() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Serial Value
   */
  CellValuesSerial v;

  _KCellSerial__isset __isset;

  void __set_c(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_v(const CellValuesSerial& val);

  bool operator == (const KCellSerial & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const KCellSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const KCellSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(KCellSerial &a, KCellSerial &b);

std::ostream& operator<<(std::ostream& out, const KCellSerial& obj);

typedef struct _kCells__isset {
  _kCells__isset() : k(false), plain_cells(false), counter_cells(false), serial_cells(false) {}
  bool k :1;
  bool plain_cells :1;
  bool counter_cells :1;
  bool serial_cells :1;
} _kCells__isset;

/**
 * The Key Cells for results on Key of scan
 */
class kCells : public virtual ::apache::thrift::TBase {
 public:

  kCells(const kCells&);
  kCells(kCells&&) noexcept;
  kCells& operator=(const kCells&);
  kCells& operator=(kCells&&) noexcept;
  kCells() noexcept {
  }

  virtual ~kCells() noexcept;
  /**
   * The Cell Key
   */
  Key k;
  /**
   * The Plain type Key Cells, defined as KCellPlain items in a list-container
   */
  std::vector<KCellPlain>  plain_cells;
  /**
   * The Counter type Key Cells, defined as KCellCounter items in a list-container
   */
  std::vector<KCellCounter>  counter_cells;
  /**
   * The Serial type Key Cells, defined as KCellSerial items in a list-container
   */
  std::vector<KCellSerial>  serial_cells;

  _kCells__isset __isset;

  void __set_k(const Key& val);

  void __set_plain_cells(const std::vector<KCellPlain> & val);

  void __set_counter_cells(const std::vector<KCellCounter> & val);

  void __set_serial_cells(const std::vector<KCellSerial> & val);

  bool operator == (const kCells & rhs) const
  {
    if (!(k == rhs.k))
      return false;
    if (!(plain_cells == rhs.plain_cells))
      return false;
    if (!(counter_cells == rhs.counter_cells))
      return false;
    if (!(serial_cells == rhs.serial_cells))
      return false;
    return true;
  }
  bool operator != (const kCells &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const kCells & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(kCells &a, kCells &b);

std::ostream& operator<<(std::ostream& out, const kCells& obj);

typedef struct _FCellPlain__isset {
  _FCellPlain__isset() : c(false), ts(false), v(false) {}
  bool c :1;
  bool ts :1;
  bool v :1;
} _FCellPlain__isset;

/**
 * The Plain column type Fraction Cell for results on Fraction of scan
 */
class FCellPlain : public virtual ::apache::thrift::TBase {
 public:

  FCellPlain(const FCellPlain&);
  FCellPlain(FCellPlain&&) noexcept;
  FCellPlain& operator=(const FCellPlain&);
  FCellPlain& operator=(FCellPlain&&) noexcept;
  FCellPlain() noexcept
             : c(),
               ts(0),
               v() {
  }

  virtual ~FCellPlain() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Value
   */
  std::string v;

  _FCellPlain__isset __isset;

  void __set_c(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_v(const std::string& val);

  bool operator == (const FCellPlain & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const FCellPlain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FCellPlain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FCellPlain &a, FCellPlain &b);

std::ostream& operator<<(std::ostream& out, const FCellPlain& obj);

typedef struct _FCellCounter__isset {
  _FCellCounter__isset() : c(false), ts(false), v(false), eq(false) {}
  bool c :1;
  bool ts :1;
  bool v :1;
  bool eq :1;
} _FCellCounter__isset;

/**
 * The Counter column type Fraction Cell for results on Fraction of scan
 */
class FCellCounter : public virtual ::apache::thrift::TBase {
 public:

  FCellCounter(const FCellCounter&);
  FCellCounter(FCellCounter&&) noexcept;
  FCellCounter& operator=(const FCellCounter&);
  FCellCounter& operator=(FCellCounter&&) noexcept;
  FCellCounter() noexcept
               : c(),
                 ts(0),
                 v(0),
                 eq(0) {
  }

  virtual ~FCellCounter() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Counter Value
   */
  int64_t v;
  /**
   * The Counter EQ since ts
   */
  int64_t eq;

  _FCellCounter__isset __isset;

  void __set_c(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_v(const int64_t val);

  void __set_eq(const int64_t val);

  bool operator == (const FCellCounter & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    if (__isset.eq != rhs.__isset.eq)
      return false;
    else if (__isset.eq && !(eq == rhs.eq))
      return false;
    return true;
  }
  bool operator != (const FCellCounter &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FCellCounter & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FCellCounter &a, FCellCounter &b);

std::ostream& operator<<(std::ostream& out, const FCellCounter& obj);

typedef struct _FCellSerial__isset {
  _FCellSerial__isset() : c(false), ts(false), v(false) {}
  bool c :1;
  bool ts :1;
  bool v :1;
} _FCellSerial__isset;

/**
 * The Serial column type Fraction Cell for results on Fraction of scan
 */
class FCellSerial : public virtual ::apache::thrift::TBase {
 public:

  FCellSerial(const FCellSerial&);
  FCellSerial(FCellSerial&&) noexcept;
  FCellSerial& operator=(const FCellSerial&);
  FCellSerial& operator=(FCellSerial&&) noexcept;
  FCellSerial() noexcept
              : c(),
                ts(0) {
  }

  virtual ~FCellSerial() noexcept;
  /**
   * The Column Name
   */
  std::string c;
  /**
   * The Cell Timestamp
   */
  int64_t ts;
  /**
   * The Cell Serial Value
   */
  CellValuesSerial v;

  _FCellSerial__isset __isset;

  void __set_c(const std::string& val);

  void __set_ts(const int64_t val);

  void __set_v(const CellValuesSerial& val);

  bool operator == (const FCellSerial & rhs) const
  {
    if (!(c == rhs.c))
      return false;
    if (!(ts == rhs.ts))
      return false;
    if (!(v == rhs.v))
      return false;
    return true;
  }
  bool operator != (const FCellSerial &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FCellSerial & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FCellSerial &a, FCellSerial &b);

std::ostream& operator<<(std::ostream& out, const FCellSerial& obj);

typedef struct _FCells__isset {
  _FCells__isset() : f(false), plain_cells(false), counter_cells(false), serial_cells(false) {}
  bool f :1;
  bool plain_cells :1;
  bool counter_cells :1;
  bool serial_cells :1;
} _FCells__isset;

/**
 * The Fraction Cells for results on Fraction of scan
 */
class FCells : public virtual ::apache::thrift::TBase {
 public:

  FCells(const FCells&);
  FCells(FCells&&) noexcept;
  FCells& operator=(const FCells&);
  FCells& operator=(FCells&&) noexcept;
  FCells() noexcept {
  }

  virtual ~FCells() noexcept;
  /**
   * The Fraction Container for the Next Fractions Tree,  defined as FCells items in a map-container by current Fraction bytes
   */
  std::map<std::string, FCells>  f;
  /**
   * The current Fraction's Cells, defined as FCellPlain items in a list-container
   */
  std::vector<FCellPlain>  plain_cells;
  /**
   * The current Fraction's Cells, defined as FCellCounter items in a list-container
   */
  std::vector<FCellCounter>  counter_cells;
  /**
   * The current Fraction's Serial Cells, defined as FCellSerial items in a list-container
   */
  std::vector<FCellSerial>  serial_cells;

  _FCells__isset __isset;

  void __set_f(const std::map<std::string, FCells> & val);

  void __set_plain_cells(const std::vector<FCellPlain> & val);

  void __set_counter_cells(const std::vector<FCellCounter> & val);

  void __set_serial_cells(const std::vector<FCellSerial> & val);

  bool operator == (const FCells & rhs) const
  {
    if (!(f == rhs.f))
      return false;
    if (!(plain_cells == rhs.plain_cells))
      return false;
    if (!(counter_cells == rhs.counter_cells))
      return false;
    if (!(serial_cells == rhs.serial_cells))
      return false;
    return true;
  }
  bool operator != (const FCells &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FCells & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(FCells &a, FCells &b);

std::ostream& operator<<(std::ostream& out, const FCells& obj);

typedef struct _CellsGroup__isset {
  _CellsGroup__isset() : cells(false), ccells(false), kcells(false), fcells(false) {}
  bool cells :1;
  bool ccells :1;
  bool kcells :1;
  bool fcells :1;
} _CellsGroup__isset;

/**
 * A Grouped Cells result for results of scan, determined by the request's CellsResult enum
 */
class CellsGroup : public virtual ::apache::thrift::TBase {
 public:

  CellsGroup(const CellsGroup&);
  CellsGroup(CellsGroup&&) noexcept;
  CellsGroup& operator=(const CellsGroup&);
  CellsGroup& operator=(CellsGroup&&) noexcept;
  CellsGroup() noexcept {
  }

  virtual ~CellsGroup() noexcept;
  /**
   * The Cells in a list, defined as Cell items in a list-container
   */
  Cells cells;
  /**
   * The Columns Cells in a map-container, defined as cCells items by Column Name
   */
  CCells ccells;
  /**
   * The Keys Cells in a list, defined as kCells items in a list-container
   */
  KCells kcells;
  /**
   * The Fraction Cells in struct FCells
   */
  FCells fcells;

  _CellsGroup__isset __isset;

  void __set_cells(const Cells& val);

  void __set_ccells(const CCells& val);

  void __set_kcells(const KCells& val);

  void __set_fcells(const FCells& val);

  bool operator == (const CellsGroup & rhs) const
  {
    if (!(cells == rhs.cells))
      return false;
    if (!(ccells == rhs.ccells))
      return false;
    if (!(kcells == rhs.kcells))
      return false;
    if (!(fcells == rhs.fcells))
      return false;
    return true;
  }
  bool operator != (const CellsGroup &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CellsGroup & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CellsGroup &a, CellsGroup &b);

std::ostream& operator<<(std::ostream& out, const CellsGroup& obj);

typedef struct _CompactResult__isset {
  _CompactResult__isset() : cid(false), err(false) {}
  bool cid :1;
  bool err :1;
} _CompactResult__isset;

/**
 * The Compact Result
 */
class CompactResult : public virtual ::apache::thrift::TBase {
 public:

  CompactResult(const CompactResult&) noexcept;
  CompactResult(CompactResult&&) noexcept;
  CompactResult& operator=(const CompactResult&) noexcept;
  CompactResult& operator=(CompactResult&&) noexcept;
  CompactResult() noexcept
                : cid(0),
                  err(0) {
  }

  virtual ~CompactResult() noexcept;
  /**
   * Column ID
   */
  int64_t cid;
  /**
   * Error
   */
  int32_t err;

  _CompactResult__isset __isset;

  void __set_cid(const int64_t val);

  void __set_err(const int32_t val);

  bool operator == (const CompactResult & rhs) const
  {
    if (!(cid == rhs.cid))
      return false;
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const CompactResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CompactResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(CompactResult &a, CompactResult &b);

std::ostream& operator<<(std::ostream& out, const CompactResult& obj);

typedef struct _Result__isset {
  _Result__isset() : schemas(false), cells(false), compact(false) {}
  bool schemas :1;
  bool cells :1;
  bool compact :1;
} _Result__isset;

/**
 * The Result of 'exec_sql'
 */
class Result : public virtual ::apache::thrift::TBase {
 public:

  Result(const Result&);
  Result(Result&&) noexcept;
  Result& operator=(const Result&);
  Result& operator=(Result&&) noexcept;
  Result() noexcept {
  }

  virtual ~Result() noexcept;
  /**
   * Set with result for 'list columns' query
   */
  Schemas schemas;
  /**
   * Set with result for 'select' query
   */
  Cells cells;
  /**
   * Set with result for 'compact columns' query
   */
  CompactResults compact;

  _Result__isset __isset;

  void __set_schemas(const Schemas& val);

  void __set_cells(const Cells& val);

  void __set_compact(const CompactResults& val);

  bool operator == (const Result & rhs) const
  {
    if (!(schemas == rhs.schemas))
      return false;
    if (!(cells == rhs.cells))
      return false;
    if (!(compact == rhs.compact))
      return false;
    return true;
  }
  bool operator != (const Result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot) override;
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const override;

  virtual void printTo(std::ostream& out) const;
};

void swap(Result &a, Result &b);

std::ostream& operator<<(std::ostream& out, const Result& obj);

}} // namespace

#endif
