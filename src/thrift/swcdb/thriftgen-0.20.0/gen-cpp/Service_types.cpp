/**
 * Autogenerated by Thrift Compiler (0.20.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Service_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace SWC { namespace Thrift {

int _kKeySeqValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  KeySeq::UNKNOWN,
  /**
   * The Lexical Key Order Sequence
   */
  KeySeq::LEXIC,
  /**
   * The Volumetric Key Order Sequence
   */
  KeySeq::VOLUME,
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  KeySeq::FC_LEXIC,
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  KeySeq::FC_VOLUME
};
const char* _kKeySeqNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * The Lexical Key Order Sequence
   */
  "LEXIC",
  /**
   * The Volumetric Key Order Sequence
   */
  "VOLUME",
  /**
   * The by Fractions Count on Lexical Key Order Sequence
   */
  "FC_LEXIC",
  /**
   * The by Fractions Count on Volumetric Key Order Sequence
   */
  "FC_VOLUME"
};
const std::map<int, const char*> _KeySeq_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kKeySeqValues, _kKeySeqNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const KeySeq::type& val) {
  std::map<int, const char*>::const_iterator it = _KeySeq_VALUES_TO_NAMES.find(val);
  if (it != _KeySeq_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kColumnTypeValues[] = {
  /**
   * Unknown/Unrecognized Type
   */
  ColumnType::UNKNOWN,
  /**
   * A Plain Column Value
   */
  ColumnType::PLAIN,
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  ColumnType::COUNTER_I64,
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  ColumnType::COUNTER_I32,
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  ColumnType::COUNTER_I16,
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  ColumnType::COUNTER_I8,
  /**
   * A Serial Column Value
   */
  ColumnType::SERIAL,
  /**
   * Not used - experimental
   */
  ColumnType::CELL_DEFINED
};
const char* _kColumnTypeNames[] = {
  /**
   * Unknown/Unrecognized Type
   */
  "UNKNOWN",
  /**
   * A Plain Column Value
   */
  "PLAIN",
  /**
   * A Counter Column Value with integrity of signed-64bit
   */
  "COUNTER_I64",
  /**
   * A Counter Column Value with integrity of signed-32bit
   */
  "COUNTER_I32",
  /**
   * A Counter Column Value with integrity of signed-16bit
   */
  "COUNTER_I16",
  /**
   * A Counter Column Value with integrity of signed-8bit
   */
  "COUNTER_I8",
  /**
   * A Serial Column Value
   */
  "SERIAL",
  /**
   * Not used - experimental
   */
  "CELL_DEFINED"
};
const std::map<int, const char*> _ColumnType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(8, _kColumnTypeValues, _kColumnTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ColumnType::type& val) {
  std::map<int, const char*>::const_iterator it = _ColumnType_VALUES_TO_NAMES.find(val);
  if (it != _ColumnType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kEncodingTypeValues[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  EncodingType::DEFAULT,
  /**
   * No Encoding
   */
  EncodingType::PLAIN,
  /**
   * Encode with zlib
   */
  EncodingType::ZLIB,
  /**
   * Encode with snappy
   */
  EncodingType::SNAPPY,
  /**
   * Encode with zstandard
   */
  EncodingType::ZSTD,
  /**
   * Unrecognized Type
   */
  EncodingType::UNKNOWN
};
const char* _kEncodingTypeNames[] = {
  /**
   * Encoding by Ranger DEFAULT configurations
   */
  "DEFAULT",
  /**
   * No Encoding
   */
  "PLAIN",
  /**
   * Encode with zlib
   */
  "ZLIB",
  /**
   * Encode with snappy
   */
  "SNAPPY",
  /**
   * Encode with zstandard
   */
  "ZSTD",
  /**
   * Unrecognized Type
   */
  "UNKNOWN"
};
const std::map<int, const char*> _EncodingType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kEncodingTypeValues, _kEncodingTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const EncodingType::type& val) {
  std::map<int, const char*>::const_iterator it = _EncodingType_VALUES_TO_NAMES.find(val);
  if (it != _EncodingType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSchemaFuncValues[] = {
  /**
   * Create Column Function
   */
  SchemaFunc::CREATE,
  /**
   * Delete Column Function
   */
  SchemaFunc::REMOVE,
  /**
   * Modify Column Function
   */
  SchemaFunc::MODIFY
};
const char* _kSchemaFuncNames[] = {
  /**
   * Create Column Function
   */
  "CREATE",
  /**
   * Delete Column Function
   */
  "REMOVE",
  /**
   * Modify Column Function
   */
  "MODIFY"
};
const std::map<int, const char*> _SchemaFunc_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kSchemaFuncValues, _kSchemaFuncNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SchemaFunc::type& val) {
  std::map<int, const char*>::const_iterator it = _SchemaFunc_VALUES_TO_NAMES.find(val);
  if (it != _SchemaFunc_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCompValues[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  Comp::NONE,
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  Comp::PF,
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  Comp::GT,
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  Comp::GE,
  /**
   * [  =      ]  :   -eq                (equal)
   */
  Comp::EQ,
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  Comp::LE,
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  Comp::LT,
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  Comp::NE,
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  Comp::RE,
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  Comp::VGT,
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  Comp::VGE,
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  Comp::VLE,
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  Comp::VLT,
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  Comp::SBS,
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  Comp::SPS,
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  Comp::POSBS,
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  Comp::POSPS,
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  Comp::FOSBS,
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  Comp::FOSPS,
  /**
   * [ :&lt;   ]  :   -fip  (fraction include prior)
   */
  Comp::FIP,
  /**
   * [ :       ]  :   -fi   (fraction include)
   */
  Comp::FI,
  /**
   * [ ||      ]  :   -or   (match any)
   */
  Comp::OR
};
const char* _kCompNames[] = {
  /**
   * [         ]  :   none               (no comparison applied)
   */
  "NONE",
  /**
   * [  =^     ]  :   -pf [prefix]       (starts-with)
   */
  "PF",
  /**
   * [ &gt;    ]  :   -gt                (greater-than)
   */
  "GT",
  /**
   * [ &gt;=   ]  :   -ge                (greater-equal)
   */
  "GE",
  /**
   * [  =      ]  :   -eq                (equal)
   */
  "EQ",
  /**
   * [ &lt;=   ]  :   -le                (lower-equal)
   */
  "LE",
  /**
   * [ &lt;    ]  :   -lt                (lower-than)
   */
  "LT",
  /**
   * [  !=     ]  :   -ne                (not-equal)
   */
  "NE",
  /**
   * [  re     ]  :   -re [r,regexp]     (regular-expression)
   */
  "RE",
  /**
   * [ v&gt;   ]  :   -vgt               (vol greater-than)
   */
  "VGT",
  /**
   * [ v&gt;=  ]  :   -vge               (vol greater-equal)
   */
  "VGE",
  /**
   * [ v&lt;=  ]  :   -vle               (vol lower-equal)
   */
  "VLE",
  /**
   * [ v&lt;   ]  :   -vlt               (vol lower-than)
   */
  "VLT",
  /**
   * [ %&gt;   ]  :   -subset [sbs]      (subset)
   */
  "SBS",
  /**
   * [ &lt;%   ]  :   -supset [sps]      (superset)
   */
  "SPS",
  /**
   * [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
   */
  "POSBS",
  /**
   * [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
   */
  "POSPS",
  /**
   * [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
   */
  "FOSBS",
  /**
   * [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
   */
  "FOSPS",
  /**
   * [ :&lt;   ]  :   -fip  (fraction include prior)
   */
  "FIP",
  /**
   * [ :       ]  :   -fi   (fraction include)
   */
  "FI",
  /**
   * [ ||      ]  :   -or   (match any)
   */
  "OR"
};
const std::map<int, const char*> _Comp_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(22, _kCompValues, _kCompNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Comp::type& val) {
  std::map<int, const char*>::const_iterator it = _Comp_VALUES_TO_NAMES.find(val);
  if (it != _Comp_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecFlagsOptValues[] = {
  /**
   * No Flag Applied
   */
  SpecFlagsOpt::NONE,
  /**
   * Cells Limit by Keys
   */
  SpecFlagsOpt::LIMIT_BY_KEYS,
  /**
   * Cells Offset by Keys
   */
  SpecFlagsOpt::OFFSET_BY_KEYS,
  /**
   * Select Cells Only Keys without Value data
   */
  SpecFlagsOpt::ONLY_KEYS,
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  SpecFlagsOpt::ONLY_DELETES
};
const char* _kSpecFlagsOptNames[] = {
  /**
   * No Flag Applied
   */
  "NONE",
  /**
   * Cells Limit by Keys
   */
  "LIMIT_BY_KEYS",
  /**
   * Cells Offset by Keys
   */
  "OFFSET_BY_KEYS",
  /**
   * Select Cells Only Keys without Value data
   */
  "ONLY_KEYS",
  /**
   * Select Cells Only with DELETE(cell-flag)
   */
  "ONLY_DELETES"
};
const std::map<int, const char*> _SpecFlagsOpt_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kSpecFlagsOptValues, _kSpecFlagsOptNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecFlagsOpt::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecFlagsOpt_VALUES_TO_NAMES.find(val);
  if (it != _SpecFlagsOpt_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kUpdateOPValues[] = {
  /**
   * The OP supported by column-types: PLAIN, SERIAL, COUNTER. Replaces with the update value (_default as well if other OP not supported by the col-type_)
   */
  UpdateOP::REPLACE,
  /**
   * The OP supported by column-types: PLAIN, SERIAL. Appends the update value to the cell's current
   */
  UpdateOP::APPEND,
  /**
   * The OP supported by column-types: PLAIN, SERIAL. Prepends the update value to the cell's current
   */
  UpdateOP::PREPEND,
  /**
   * The OP supported by column-type PLAIN. Inserts the update value at position in current value (appends if pos above value)
   */
  UpdateOP::INSERT,
  /**
   * The OP supported by column-type PLAIN. Overwrites the current value at position with new value (appends if pos above value)
   */
  UpdateOP::OVERWRITE,
  /**
   * The OP supported by column-type SERIAL. update is done by the inner serial-fields defintions
   */
  UpdateOP::SERIAL
};
const char* _kUpdateOPNames[] = {
  /**
   * The OP supported by column-types: PLAIN, SERIAL, COUNTER. Replaces with the update value (_default as well if other OP not supported by the col-type_)
   */
  "REPLACE",
  /**
   * The OP supported by column-types: PLAIN, SERIAL. Appends the update value to the cell's current
   */
  "APPEND",
  /**
   * The OP supported by column-types: PLAIN, SERIAL. Prepends the update value to the cell's current
   */
  "PREPEND",
  /**
   * The OP supported by column-type PLAIN. Inserts the update value at position in current value (appends if pos above value)
   */
  "INSERT",
  /**
   * The OP supported by column-type PLAIN. Overwrites the current value at position with new value (appends if pos above value)
   */
  "OVERWRITE",
  /**
   * The OP supported by column-type SERIAL. update is done by the inner serial-fields defintions
   */
  "SERIAL"
};
const std::map<int, const char*> _UpdateOP_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kUpdateOPValues, _kUpdateOPNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const UpdateOP::type& val) {
  std::map<int, const char*>::const_iterator it = _UpdateOP_VALUES_TO_NAMES.find(val);
  if (it != _UpdateOP_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const UpdateOP::type& val) {
  std::map<int, const char*>::const_iterator it = _UpdateOP_VALUES_TO_NAMES.find(val);
  if (it != _UpdateOP_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kSpecIntervalOptionsValues[] = {
  /**
   * Update Bit Option
   */
  SpecIntervalOptions::UPDATING,
  /**
   * Delete Bit Option
   */
  SpecIntervalOptions::DELETING
};
const char* _kSpecIntervalOptionsNames[] = {
  /**
   * Update Bit Option
   */
  "UPDATING",
  /**
   * Delete Bit Option
   */
  "DELETING"
};
const std::map<int, const char*> _SpecIntervalOptions_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSpecIntervalOptionsValues, _kSpecIntervalOptionsNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const SpecIntervalOptions::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecIntervalOptions_VALUES_TO_NAMES.find(val);
  if (it != _SpecIntervalOptions_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const SpecIntervalOptions::type& val) {
  std::map<int, const char*>::const_iterator it = _SpecIntervalOptions_VALUES_TO_NAMES.find(val);
  if (it != _SpecIntervalOptions_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFlagValues[] = {
  /**
   * Unknown/Undefined
   */
  Flag::NONE,
  /**
   * The Cell is an insert
   */
  Flag::INSERT,
  /**
   * The Cell is a delete versions lower-equal
   */
  Flag::DELETE_LE,
  /**
   * The Cell is a  delete version equal
   */
  Flag::DELETE_EQ
};
const char* _kFlagNames[] = {
  /**
   * Unknown/Undefined
   */
  "NONE",
  /**
   * The Cell is an insert
   */
  "INSERT",
  /**
   * The Cell is a delete versions lower-equal
   */
  "DELETE_LE",
  /**
   * The Cell is a  delete version equal
   */
  "DELETE_EQ"
};
const std::map<int, const char*> _Flag_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFlagValues, _kFlagNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const Flag::type& val) {
  std::map<int, const char*>::const_iterator it = _Flag_VALUES_TO_NAMES.find(val);
  if (it != _Flag_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFU_MATH_OPValues[] = {
  /**
   * set field value to the new value
   */
  FU_MATH_OP::EQUAL,
  /**
   * plus new value to field's value (negative number allowed)
   */
  FU_MATH_OP::PLUS,
  /**
   * multiply current value by update value
   */
  FU_MATH_OP::MULTIPLY,
  /**
   * divide current value by the new value (ignored at zero)
   */
  FU_MATH_OP::DIVIDE
};
const char* _kFU_MATH_OPNames[] = {
  /**
   * set field value to the new value
   */
  "EQUAL",
  /**
   * plus new value to field's value (negative number allowed)
   */
  "PLUS",
  /**
   * multiply current value by update value
   */
  "MULTIPLY",
  /**
   * divide current value by the new value (ignored at zero)
   */
  "DIVIDE"
};
const std::map<int, const char*> _FU_MATH_OP_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFU_MATH_OPValues, _kFU_MATH_OPNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FU_MATH_OP::type& val) {
  std::map<int, const char*>::const_iterator it = _FU_MATH_OP_VALUES_TO_NAMES.find(val);
  if (it != _FU_MATH_OP_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FU_MATH_OP::type& val) {
  std::map<int, const char*>::const_iterator it = _FU_MATH_OP_VALUES_TO_NAMES.find(val);
  if (it != _FU_MATH_OP_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kFU_LIST_OPValues[] = {
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Replaces with the update value
   */
  FU_LIST_OP::REPLACE,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Appends the update value to a field value
   */
  FU_LIST_OP::APPEND,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Prepends the update value to a field value
   */
  FU_LIST_OP::PREPEND,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Insert the update value at position in a field value (appends if pos above value)
   */
  FU_LIST_OP::INSERT,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Overwrites a field value at position with new value (appends if pos above value)
   */
  FU_LIST_OP::OVERWRITE,
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Erases the position in a field value
   */
  FU_LIST_OP::ERASE,
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP
   */
  FU_LIST_OP::BY_UNIQUE,
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP and Comparator
   */
  FU_LIST_OP::BY_COND,
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value is with Postion and OP in items
   */
  FU_LIST_OP::BY_INDEX
};
const char* _kFU_LIST_OPNames[] = {
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Replaces with the update value
   */
  "REPLACE",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Appends the update value to a field value
   */
  "APPEND",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Prepends the update value to a field value
   */
  "PREPEND",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Insert the update value at position in a field value (appends if pos above value)
   */
  "INSERT",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Overwrites a field value at position with new value (appends if pos above value)
   */
  "OVERWRITE",
  /**
   * Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Erases the position in a field value
   */
  "ERASE",
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP
   */
  "BY_UNIQUE",
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP and Comparator
   */
  "BY_COND",
  /**
   * Supported by field-types: LIST_BYTES, LIST_INT64. The field value is with Postion and OP in items
   */
  "BY_INDEX"
};
const std::map<int, const char*> _FU_LIST_OP_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kFU_LIST_OPValues, _kFU_LIST_OPNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const FU_LIST_OP::type& val) {
  std::map<int, const char*>::const_iterator it = _FU_LIST_OP_VALUES_TO_NAMES.find(val);
  if (it != _FU_LIST_OP_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const FU_LIST_OP::type& val) {
  std::map<int, const char*>::const_iterator it = _FU_LIST_OP_VALUES_TO_NAMES.find(val);
  if (it != _FU_LIST_OP_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kCellsResultValues[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  CellsResult::IN_LIST,
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  CellsResult::ON_COLUMN,
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  CellsResult::ON_KEY,
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  CellsResult::ON_FRACTION
};
const char* _kCellsResultNames[] = {
  /**
   * Correspond to result on Cells (Cells in list)
   */
  "IN_LIST",
  /**
   * Correspond to result on CCells (Columns Cells)
   */
  "ON_COLUMN",
  /**
   * Correspond to result on KCells (Keys Cells)
   */
  "ON_KEY",
  /**
   * Correspond to result on FCells (Fraction Cells)
   */
  "ON_FRACTION"
};
const std::map<int, const char*> _CellsResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCellsResultValues, _kCellsResultNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const CellsResult::type& val) {
  std::map<int, const char*>::const_iterator it = _CellsResult_VALUES_TO_NAMES.find(val);
  if (it != _CellsResult_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


Exception::~Exception() noexcept {
}


void Exception::__set_code(const int32_t val) {
  this->code = val;
}

void Exception::__set_message(const std::string& val) {
  this->message = val;
}
std::ostream& operator<<(std::ostream& out, const Exception& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Exception::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Exception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Exception");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Exception &a, Exception &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Exception::Exception(const Exception& other0) : TException() {
  code = other0.code;
  message = other0.message;
  __isset = other0.__isset;
}
Exception::Exception(Exception&& other1) noexcept : TException() {
  code = other1.code;
  message = std::move(other1.message);
  __isset = other1.__isset;
}
Exception& Exception::operator=(const Exception& other2) {
  code = other2.code;
  message = other2.message;
  __isset = other2.__isset;
  return *this;
}
Exception& Exception::operator=(Exception&& other3) noexcept {
  code = other3.code;
  message = std::move(other3.message);
  __isset = other3.__isset;
  return *this;
}
void Exception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Exception(";
  out << "code=" << to_string(code);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* Exception::what() const noexcept {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Exception";
  }
}


Schema::~Schema() noexcept {
}


void Schema::__set_cid(const int64_t val) {
  this->cid = val;
__isset.cid = true;
}

void Schema::__set_col_name(const std::string& val) {
  this->col_name = val;
__isset.col_name = true;
}

void Schema::__set_col_tags(const std::vector<std::string> & val) {
  this->col_tags = val;
}

void Schema::__set_col_seq(const KeySeq::type val) {
  this->col_seq = val;
__isset.col_seq = true;
}

void Schema::__set_col_type(const ColumnType::type val) {
  this->col_type = val;
__isset.col_type = true;
}

void Schema::__set_cell_versions(const int32_t val) {
  this->cell_versions = val;
__isset.cell_versions = true;
}

void Schema::__set_cell_ttl(const int32_t val) {
  this->cell_ttl = val;
__isset.cell_ttl = true;
}

void Schema::__set_blk_encoding(const EncodingType::type val) {
  this->blk_encoding = val;
__isset.blk_encoding = true;
}

void Schema::__set_blk_size(const int32_t val) {
  this->blk_size = val;
__isset.blk_size = true;
}

void Schema::__set_blk_cells(const int32_t val) {
  this->blk_cells = val;
__isset.blk_cells = true;
}

void Schema::__set_cs_replication(const int8_t val) {
  this->cs_replication = val;
__isset.cs_replication = true;
}

void Schema::__set_cs_size(const int32_t val) {
  this->cs_size = val;
__isset.cs_size = true;
}

void Schema::__set_cs_max(const int8_t val) {
  this->cs_max = val;
__isset.cs_max = true;
}

void Schema::__set_log_rollout_ratio(const int8_t val) {
  this->log_rollout_ratio = val;
__isset.log_rollout_ratio = true;
}

void Schema::__set_log_compact_cointervaling(const int8_t val) {
  this->log_compact_cointervaling = val;
__isset.log_compact_cointervaling = true;
}

void Schema::__set_log_fragment_preload(const int8_t val) {
  this->log_fragment_preload = val;
__isset.log_fragment_preload = true;
}

void Schema::__set_compact_percent(const int8_t val) {
  this->compact_percent = val;
__isset.compact_percent = true;
}

void Schema::__set_revision(const int64_t val) {
  this->revision = val;
__isset.revision = true;
}
std::ostream& operator<<(std::ostream& out, const Schema& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Schema::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->col_name);
          this->__isset.col_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->col_tags.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->col_tags.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readString(this->col_tags[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.col_tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->col_seq = static_cast<KeySeq::type>(ecast9);
          this->__isset.col_seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->col_type = static_cast<ColumnType::type>(ecast10);
          this->__isset.col_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_versions);
          this->__isset.cell_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cell_ttl);
          this->__isset.cell_ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->blk_encoding = static_cast<EncodingType::type>(ecast11);
          this->__isset.blk_encoding = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_size);
          this->__isset.blk_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blk_cells);
          this->__isset.blk_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_replication);
          this->__isset.cs_replication = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cs_size);
          this->__isset.cs_size = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->cs_max);
          this->__isset.cs_max = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_rollout_ratio);
          this->__isset.log_rollout_ratio = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_compact_cointervaling);
          this->__isset.log_compact_cointervaling = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->log_fragment_preload);
          this->__isset.log_fragment_preload = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->compact_percent);
          this->__isset.compact_percent = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->revision);
          this->__isset.revision = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Schema::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Schema");

  if (this->__isset.cid) {
    xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->cid);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_name) {
    xfer += oprot->writeFieldBegin("col_name", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->col_name);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("col_tags", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->col_tags.size()));
    std::vector<std::string> ::const_iterator _iter12;
    for (_iter12 = this->col_tags.begin(); _iter12 != this->col_tags.end(); ++_iter12)
    {
      xfer += oprot->writeString((*_iter12));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.col_seq) {
    xfer += oprot->writeFieldBegin("col_seq", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_seq));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.col_type) {
    xfer += oprot->writeFieldBegin("col_type", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(static_cast<int32_t>(this->col_type));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_versions) {
    xfer += oprot->writeFieldBegin("cell_versions", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->cell_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cell_ttl) {
    xfer += oprot->writeFieldBegin("cell_ttl", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->cell_ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_encoding) {
    xfer += oprot->writeFieldBegin("blk_encoding", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(static_cast<int32_t>(this->blk_encoding));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_size) {
    xfer += oprot->writeFieldBegin("blk_size", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->blk_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.blk_cells) {
    xfer += oprot->writeFieldBegin("blk_cells", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->blk_cells);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_replication) {
    xfer += oprot->writeFieldBegin("cs_replication", ::apache::thrift::protocol::T_BYTE, 11);
    xfer += oprot->writeByte(this->cs_replication);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_size) {
    xfer += oprot->writeFieldBegin("cs_size", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->cs_size);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cs_max) {
    xfer += oprot->writeFieldBegin("cs_max", ::apache::thrift::protocol::T_BYTE, 13);
    xfer += oprot->writeByte(this->cs_max);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_rollout_ratio) {
    xfer += oprot->writeFieldBegin("log_rollout_ratio", ::apache::thrift::protocol::T_BYTE, 14);
    xfer += oprot->writeByte(this->log_rollout_ratio);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_compact_cointervaling) {
    xfer += oprot->writeFieldBegin("log_compact_cointervaling", ::apache::thrift::protocol::T_BYTE, 15);
    xfer += oprot->writeByte(this->log_compact_cointervaling);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.log_fragment_preload) {
    xfer += oprot->writeFieldBegin("log_fragment_preload", ::apache::thrift::protocol::T_BYTE, 16);
    xfer += oprot->writeByte(this->log_fragment_preload);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.compact_percent) {
    xfer += oprot->writeFieldBegin("compact_percent", ::apache::thrift::protocol::T_BYTE, 17);
    xfer += oprot->writeByte(this->compact_percent);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.revision) {
    xfer += oprot->writeFieldBegin("revision", ::apache::thrift::protocol::T_I64, 18);
    xfer += oprot->writeI64(this->revision);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Schema &a, Schema &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.col_name, b.col_name);
  swap(a.col_tags, b.col_tags);
  swap(a.col_seq, b.col_seq);
  swap(a.col_type, b.col_type);
  swap(a.cell_versions, b.cell_versions);
  swap(a.cell_ttl, b.cell_ttl);
  swap(a.blk_encoding, b.blk_encoding);
  swap(a.blk_size, b.blk_size);
  swap(a.blk_cells, b.blk_cells);
  swap(a.cs_replication, b.cs_replication);
  swap(a.cs_size, b.cs_size);
  swap(a.cs_max, b.cs_max);
  swap(a.log_rollout_ratio, b.log_rollout_ratio);
  swap(a.log_compact_cointervaling, b.log_compact_cointervaling);
  swap(a.log_fragment_preload, b.log_fragment_preload);
  swap(a.compact_percent, b.compact_percent);
  swap(a.revision, b.revision);
  swap(a.__isset, b.__isset);
}

Schema::Schema(const Schema& other13) {
  cid = other13.cid;
  col_name = other13.col_name;
  col_tags = other13.col_tags;
  col_seq = other13.col_seq;
  col_type = other13.col_type;
  cell_versions = other13.cell_versions;
  cell_ttl = other13.cell_ttl;
  blk_encoding = other13.blk_encoding;
  blk_size = other13.blk_size;
  blk_cells = other13.blk_cells;
  cs_replication = other13.cs_replication;
  cs_size = other13.cs_size;
  cs_max = other13.cs_max;
  log_rollout_ratio = other13.log_rollout_ratio;
  log_compact_cointervaling = other13.log_compact_cointervaling;
  log_fragment_preload = other13.log_fragment_preload;
  compact_percent = other13.compact_percent;
  revision = other13.revision;
  __isset = other13.__isset;
}
Schema::Schema(Schema&& other14) noexcept {
  cid = other14.cid;
  col_name = std::move(other14.col_name);
  col_tags = std::move(other14.col_tags);
  col_seq = other14.col_seq;
  col_type = other14.col_type;
  cell_versions = other14.cell_versions;
  cell_ttl = other14.cell_ttl;
  blk_encoding = other14.blk_encoding;
  blk_size = other14.blk_size;
  blk_cells = other14.blk_cells;
  cs_replication = other14.cs_replication;
  cs_size = other14.cs_size;
  cs_max = other14.cs_max;
  log_rollout_ratio = other14.log_rollout_ratio;
  log_compact_cointervaling = other14.log_compact_cointervaling;
  log_fragment_preload = other14.log_fragment_preload;
  compact_percent = other14.compact_percent;
  revision = other14.revision;
  __isset = other14.__isset;
}
Schema& Schema::operator=(const Schema& other15) {
  cid = other15.cid;
  col_name = other15.col_name;
  col_tags = other15.col_tags;
  col_seq = other15.col_seq;
  col_type = other15.col_type;
  cell_versions = other15.cell_versions;
  cell_ttl = other15.cell_ttl;
  blk_encoding = other15.blk_encoding;
  blk_size = other15.blk_size;
  blk_cells = other15.blk_cells;
  cs_replication = other15.cs_replication;
  cs_size = other15.cs_size;
  cs_max = other15.cs_max;
  log_rollout_ratio = other15.log_rollout_ratio;
  log_compact_cointervaling = other15.log_compact_cointervaling;
  log_fragment_preload = other15.log_fragment_preload;
  compact_percent = other15.compact_percent;
  revision = other15.revision;
  __isset = other15.__isset;
  return *this;
}
Schema& Schema::operator=(Schema&& other16) noexcept {
  cid = other16.cid;
  col_name = std::move(other16.col_name);
  col_tags = std::move(other16.col_tags);
  col_seq = other16.col_seq;
  col_type = other16.col_type;
  cell_versions = other16.cell_versions;
  cell_ttl = other16.cell_ttl;
  blk_encoding = other16.blk_encoding;
  blk_size = other16.blk_size;
  blk_cells = other16.blk_cells;
  cs_replication = other16.cs_replication;
  cs_size = other16.cs_size;
  cs_max = other16.cs_max;
  log_rollout_ratio = other16.log_rollout_ratio;
  log_compact_cointervaling = other16.log_compact_cointervaling;
  log_fragment_preload = other16.log_fragment_preload;
  compact_percent = other16.compact_percent;
  revision = other16.revision;
  __isset = other16.__isset;
  return *this;
}
void Schema::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Schema(";
  out << "cid="; (__isset.cid ? (out << to_string(cid)) : (out << "<null>"));
  out << ", " << "col_name="; (__isset.col_name ? (out << to_string(col_name)) : (out << "<null>"));
  out << ", " << "col_tags=" << to_string(col_tags);
  out << ", " << "col_seq="; (__isset.col_seq ? (out << to_string(col_seq)) : (out << "<null>"));
  out << ", " << "col_type="; (__isset.col_type ? (out << to_string(col_type)) : (out << "<null>"));
  out << ", " << "cell_versions="; (__isset.cell_versions ? (out << to_string(cell_versions)) : (out << "<null>"));
  out << ", " << "cell_ttl="; (__isset.cell_ttl ? (out << to_string(cell_ttl)) : (out << "<null>"));
  out << ", " << "blk_encoding="; (__isset.blk_encoding ? (out << to_string(blk_encoding)) : (out << "<null>"));
  out << ", " << "blk_size="; (__isset.blk_size ? (out << to_string(blk_size)) : (out << "<null>"));
  out << ", " << "blk_cells="; (__isset.blk_cells ? (out << to_string(blk_cells)) : (out << "<null>"));
  out << ", " << "cs_replication="; (__isset.cs_replication ? (out << to_string(cs_replication)) : (out << "<null>"));
  out << ", " << "cs_size="; (__isset.cs_size ? (out << to_string(cs_size)) : (out << "<null>"));
  out << ", " << "cs_max="; (__isset.cs_max ? (out << to_string(cs_max)) : (out << "<null>"));
  out << ", " << "log_rollout_ratio="; (__isset.log_rollout_ratio ? (out << to_string(log_rollout_ratio)) : (out << "<null>"));
  out << ", " << "log_compact_cointervaling="; (__isset.log_compact_cointervaling ? (out << to_string(log_compact_cointervaling)) : (out << "<null>"));
  out << ", " << "log_fragment_preload="; (__isset.log_fragment_preload ? (out << to_string(log_fragment_preload)) : (out << "<null>"));
  out << ", " << "compact_percent="; (__isset.compact_percent ? (out << to_string(compact_percent)) : (out << "<null>"));
  out << ", " << "revision="; (__isset.revision ? (out << to_string(revision)) : (out << "<null>"));
  out << ")";
}


SchemaPattern::~SchemaPattern() noexcept {
}


void SchemaPattern::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaPattern::__set_value(const std::string& val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPattern& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPattern::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->comp = static_cast<Comp::type>(ecast17);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->value);
          this->__isset.value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPattern::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPattern");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPattern &a, SchemaPattern &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.value, b.value);
  swap(a.__isset, b.__isset);
}

SchemaPattern::SchemaPattern(const SchemaPattern& other18) {
  comp = other18.comp;
  value = other18.value;
  __isset = other18.__isset;
}
SchemaPattern::SchemaPattern(SchemaPattern&& other19) noexcept {
  comp = other19.comp;
  value = std::move(other19.value);
  __isset = other19.__isset;
}
SchemaPattern& SchemaPattern::operator=(const SchemaPattern& other20) {
  comp = other20.comp;
  value = other20.value;
  __isset = other20.__isset;
  return *this;
}
SchemaPattern& SchemaPattern::operator=(SchemaPattern&& other21) noexcept {
  comp = other21.comp;
  value = std::move(other21.value);
  __isset = other21.__isset;
  return *this;
}
void SchemaPattern::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPattern(";
  out << "comp=" << to_string(comp);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


SchemaTagsPatterns::~SchemaTagsPatterns() noexcept {
}


void SchemaTagsPatterns::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SchemaTagsPatterns::__set_values(const std::vector<SchemaPattern> & val) {
  this->values = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaTagsPatterns& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaTagsPatterns::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast22;
          xfer += iprot->readI32(ecast22);
          this->comp = static_cast<Comp::type>(ecast22);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->values.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->values[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaTagsPatterns::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaTagsPatterns");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SchemaPattern> ::const_iterator _iter28;
    for (_iter28 = this->values.begin(); _iter28 != this->values.end(); ++_iter28)
    {
      xfer += (*_iter28).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaTagsPatterns &a, SchemaTagsPatterns &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.values, b.values);
  swap(a.__isset, b.__isset);
}

SchemaTagsPatterns::SchemaTagsPatterns(const SchemaTagsPatterns& other29) {
  comp = other29.comp;
  values = other29.values;
  __isset = other29.__isset;
}
SchemaTagsPatterns::SchemaTagsPatterns(SchemaTagsPatterns&& other30) noexcept {
  comp = other30.comp;
  values = std::move(other30.values);
  __isset = other30.__isset;
}
SchemaTagsPatterns& SchemaTagsPatterns::operator=(const SchemaTagsPatterns& other31) {
  comp = other31.comp;
  values = other31.values;
  __isset = other31.__isset;
  return *this;
}
SchemaTagsPatterns& SchemaTagsPatterns::operator=(SchemaTagsPatterns&& other32) noexcept {
  comp = other32.comp;
  values = std::move(other32.values);
  __isset = other32.__isset;
  return *this;
}
void SchemaTagsPatterns::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaTagsPatterns(";
  out << "comp=" << to_string(comp);
  out << ", " << "values=" << to_string(values);
  out << ")";
}


SchemaPatterns::~SchemaPatterns() noexcept {
}


void SchemaPatterns::__set_names(const std::vector<SchemaPattern> & val) {
  this->names = val;
}

void SchemaPatterns::__set_tags(const SchemaTagsPatterns& val) {
  this->tags = val;
}
std::ostream& operator<<(std::ostream& out, const SchemaPatterns& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SchemaPatterns::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size33;
            ::apache::thrift::protocol::TType _etype36;
            xfer += iprot->readListBegin(_etype36, _size33);
            this->names.resize(_size33);
            uint32_t _i37;
            for (_i37 = 0; _i37 < _size33; ++_i37)
            {
              xfer += this->names[_i37].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->tags.read(iprot);
          this->__isset.tags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SchemaPatterns::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SchemaPatterns");

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->names.size()));
    std::vector<SchemaPattern> ::const_iterator _iter38;
    for (_iter38 = this->names.begin(); _iter38 != this->names.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tags", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->tags.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SchemaPatterns &a, SchemaPatterns &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.tags, b.tags);
  swap(a.__isset, b.__isset);
}

SchemaPatterns::SchemaPatterns(const SchemaPatterns& other39) {
  names = other39.names;
  tags = other39.tags;
  __isset = other39.__isset;
}
SchemaPatterns::SchemaPatterns(SchemaPatterns&& other40) noexcept {
  names = std::move(other40.names);
  tags = std::move(other40.tags);
  __isset = other40.__isset;
}
SchemaPatterns& SchemaPatterns::operator=(const SchemaPatterns& other41) {
  names = other41.names;
  tags = other41.tags;
  __isset = other41.__isset;
  return *this;
}
SchemaPatterns& SchemaPatterns::operator=(SchemaPatterns&& other42) noexcept {
  names = std::move(other42.names);
  tags = std::move(other42.tags);
  __isset = other42.__isset;
  return *this;
}
void SchemaPatterns::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SchemaPatterns(";
  out << "names=" << to_string(names);
  out << ", " << "tags=" << to_string(tags);
  out << ")";
}


SpecSchemas::~SpecSchemas() noexcept {
}


void SpecSchemas::__set_cids(const std::vector<int64_t> & val) {
  this->cids = val;
}

void SpecSchemas::__set_names(const std::vector<std::string> & val) {
  this->names = val;
}

void SpecSchemas::__set_patterns(const SchemaPatterns& val) {
  this->patterns = val;
}
std::ostream& operator<<(std::ostream& out, const SpecSchemas& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecSchemas::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->cids.clear();
            uint32_t _size43;
            ::apache::thrift::protocol::TType _etype46;
            xfer += iprot->readListBegin(_etype46, _size43);
            this->cids.resize(_size43);
            uint32_t _i47;
            for (_i47 = 0; _i47 < _size43; ++_i47)
            {
              xfer += iprot->readI64(this->cids[_i47]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.cids = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size48;
            ::apache::thrift::protocol::TType _etype51;
            xfer += iprot->readListBegin(_etype51, _size48);
            this->names.resize(_size48);
            uint32_t _i52;
            for (_i52 = 0; _i52 < _size48; ++_i52)
            {
              xfer += iprot->readString(this->names[_i52]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->patterns.read(iprot);
          this->__isset.patterns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecSchemas::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecSchemas");

  xfer += oprot->writeFieldBegin("cids", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->cids.size()));
    std::vector<int64_t> ::const_iterator _iter53;
    for (_iter53 = this->cids.begin(); _iter53 != this->cids.end(); ++_iter53)
    {
      xfer += oprot->writeI64((*_iter53));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
    std::vector<std::string> ::const_iterator _iter54;
    for (_iter54 = this->names.begin(); _iter54 != this->names.end(); ++_iter54)
    {
      xfer += oprot->writeString((*_iter54));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("patterns", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->patterns.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecSchemas &a, SpecSchemas &b) {
  using ::std::swap;
  swap(a.cids, b.cids);
  swap(a.names, b.names);
  swap(a.patterns, b.patterns);
  swap(a.__isset, b.__isset);
}

SpecSchemas::SpecSchemas(const SpecSchemas& other55) {
  cids = other55.cids;
  names = other55.names;
  patterns = other55.patterns;
  __isset = other55.__isset;
}
SpecSchemas::SpecSchemas(SpecSchemas&& other56) noexcept {
  cids = std::move(other56.cids);
  names = std::move(other56.names);
  patterns = std::move(other56.patterns);
  __isset = other56.__isset;
}
SpecSchemas& SpecSchemas::operator=(const SpecSchemas& other57) {
  cids = other57.cids;
  names = other57.names;
  patterns = other57.patterns;
  __isset = other57.__isset;
  return *this;
}
SpecSchemas& SpecSchemas::operator=(SpecSchemas&& other58) noexcept {
  cids = std::move(other58.cids);
  names = std::move(other58.names);
  patterns = std::move(other58.patterns);
  __isset = other58.__isset;
  return *this;
}
void SpecSchemas::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecSchemas(";
  out << "cids=" << to_string(cids);
  out << ", " << "names=" << to_string(names);
  out << ", " << "patterns=" << to_string(patterns);
  out << ")";
}


SpecFlags::~SpecFlags() noexcept {
}


void SpecFlags::__set_limit(const int64_t val) {
  this->limit = val;
__isset.limit = true;
}

void SpecFlags::__set_offset(const int64_t val) {
  this->offset = val;
__isset.offset = true;
}

void SpecFlags::__set_max_versions(const int32_t val) {
  this->max_versions = val;
__isset.max_versions = true;
}

void SpecFlags::__set_max_buffer(const int32_t val) {
  this->max_buffer = val;
__isset.max_buffer = true;
}

void SpecFlags::__set_options(const int8_t val) {
  this->options = val;
__isset.options = true;
}
std::ostream& operator<<(std::ostream& out, const SpecFlags& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFlags::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->limit);
          this->__isset.limit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset);
          this->__isset.offset = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_versions);
          this->__isset.max_versions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->max_buffer);
          this->__isset.max_buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->options);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFlags::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFlags");

  if (this->__isset.limit) {
    xfer += oprot->writeFieldBegin("limit", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->limit);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.offset) {
    xfer += oprot->writeFieldBegin("offset", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->offset);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_versions) {
    xfer += oprot->writeFieldBegin("max_versions", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->max_versions);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.max_buffer) {
    xfer += oprot->writeFieldBegin("max_buffer", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->max_buffer);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_BYTE, 5);
    xfer += oprot->writeByte(this->options);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFlags &a, SpecFlags &b) {
  using ::std::swap;
  swap(a.limit, b.limit);
  swap(a.offset, b.offset);
  swap(a.max_versions, b.max_versions);
  swap(a.max_buffer, b.max_buffer);
  swap(a.options, b.options);
  swap(a.__isset, b.__isset);
}

SpecFlags::SpecFlags(const SpecFlags& other59) noexcept {
  limit = other59.limit;
  offset = other59.offset;
  max_versions = other59.max_versions;
  max_buffer = other59.max_buffer;
  options = other59.options;
  __isset = other59.__isset;
}
SpecFlags::SpecFlags(SpecFlags&& other60) noexcept {
  limit = other60.limit;
  offset = other60.offset;
  max_versions = other60.max_versions;
  max_buffer = other60.max_buffer;
  options = other60.options;
  __isset = other60.__isset;
}
SpecFlags& SpecFlags::operator=(const SpecFlags& other61) noexcept {
  limit = other61.limit;
  offset = other61.offset;
  max_versions = other61.max_versions;
  max_buffer = other61.max_buffer;
  options = other61.options;
  __isset = other61.__isset;
  return *this;
}
SpecFlags& SpecFlags::operator=(SpecFlags&& other62) noexcept {
  limit = other62.limit;
  offset = other62.offset;
  max_versions = other62.max_versions;
  max_buffer = other62.max_buffer;
  options = other62.options;
  __isset = other62.__isset;
  return *this;
}
void SpecFlags::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFlags(";
  out << "limit="; (__isset.limit ? (out << to_string(limit)) : (out << "<null>"));
  out << ", " << "offset="; (__isset.offset ? (out << to_string(offset)) : (out << "<null>"));
  out << ", " << "max_versions="; (__isset.max_versions ? (out << to_string(max_versions)) : (out << "<null>"));
  out << ", " << "max_buffer="; (__isset.max_buffer ? (out << to_string(max_buffer)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ")";
}


SpecUpdateOP::~SpecUpdateOP() noexcept {
}


void SpecUpdateOP::__set_op(const UpdateOP::type val) {
  this->op = val;
}

void SpecUpdateOP::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}
std::ostream& operator<<(std::ostream& out, const SpecUpdateOP& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecUpdateOP::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->op = static_cast<UpdateOP::type>(ecast63);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecUpdateOP::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecUpdateOP");

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecUpdateOP &a, SpecUpdateOP &b) {
  using ::std::swap;
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.__isset, b.__isset);
}

SpecUpdateOP::SpecUpdateOP(const SpecUpdateOP& other64) noexcept {
  op = other64.op;
  pos = other64.pos;
  __isset = other64.__isset;
}
SpecUpdateOP::SpecUpdateOP(SpecUpdateOP&& other65) noexcept {
  op = other65.op;
  pos = other65.pos;
  __isset = other65.__isset;
}
SpecUpdateOP& SpecUpdateOP::operator=(const SpecUpdateOP& other66) noexcept {
  op = other66.op;
  pos = other66.pos;
  __isset = other66.__isset;
  return *this;
}
SpecUpdateOP& SpecUpdateOP::operator=(SpecUpdateOP&& other67) noexcept {
  op = other67.op;
  pos = other67.pos;
  __isset = other67.__isset;
  return *this;
}
void SpecUpdateOP::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecUpdateOP(";
  out << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ")";
}


SpecIntervalUpdatePlain::~SpecIntervalUpdatePlain() noexcept {
}


void SpecIntervalUpdatePlain::__set_v(const std::string& val) {
  this->v = val;
}

void SpecIntervalUpdatePlain::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void SpecIntervalUpdatePlain::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}

void SpecIntervalUpdatePlain::__set_update_op(const SpecUpdateOP& val) {
  this->update_op = val;
__isset.update_op = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdatePlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalUpdatePlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast68;
          xfer += iprot->readI32(ecast68);
          this->encoder = static_cast<EncodingType::type>(ecast68);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_op.read(iprot);
          this->__isset.update_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalUpdatePlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalUpdatePlain");

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update_op) {
    xfer += oprot->writeFieldBegin("update_op", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->update_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalUpdatePlain &a, SpecIntervalUpdatePlain &b) {
  using ::std::swap;
  swap(a.v, b.v);
  swap(a.ts, b.ts);
  swap(a.encoder, b.encoder);
  swap(a.update_op, b.update_op);
  swap(a.__isset, b.__isset);
}

SpecIntervalUpdatePlain::SpecIntervalUpdatePlain(const SpecIntervalUpdatePlain& other69) {
  v = other69.v;
  ts = other69.ts;
  encoder = other69.encoder;
  update_op = other69.update_op;
  __isset = other69.__isset;
}
SpecIntervalUpdatePlain::SpecIntervalUpdatePlain(SpecIntervalUpdatePlain&& other70) noexcept {
  v = std::move(other70.v);
  ts = other70.ts;
  encoder = other70.encoder;
  update_op = std::move(other70.update_op);
  __isset = other70.__isset;
}
SpecIntervalUpdatePlain& SpecIntervalUpdatePlain::operator=(const SpecIntervalUpdatePlain& other71) {
  v = other71.v;
  ts = other71.ts;
  encoder = other71.encoder;
  update_op = other71.update_op;
  __isset = other71.__isset;
  return *this;
}
SpecIntervalUpdatePlain& SpecIntervalUpdatePlain::operator=(SpecIntervalUpdatePlain&& other72) noexcept {
  v = std::move(other72.v);
  ts = other72.ts;
  encoder = other72.encoder;
  update_op = std::move(other72.update_op);
  __isset = other72.__isset;
  return *this;
}
void SpecIntervalUpdatePlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalUpdatePlain(";
  out << "v=" << to_string(v);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ", " << "update_op="; (__isset.update_op ? (out << to_string(update_op)) : (out << "<null>"));
  out << ")";
}


SpecIntervalUpdateCounter::~SpecIntervalUpdateCounter() noexcept {
}


void SpecIntervalUpdateCounter::__set_v(const int64_t val) {
  this->v = val;
}

void SpecIntervalUpdateCounter::__set_op(const int64_t val) {
  this->op = val;
}

void SpecIntervalUpdateCounter::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void SpecIntervalUpdateCounter::__set_update_op(const SpecUpdateOP& val) {
  this->update_op = val;
__isset.update_op = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdateCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalUpdateCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->op);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_op.read(iprot);
          this->__isset.update_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalUpdateCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalUpdateCounter");

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->op);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update_op) {
    xfer += oprot->writeFieldBegin("update_op", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->update_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalUpdateCounter &a, SpecIntervalUpdateCounter &b) {
  using ::std::swap;
  swap(a.v, b.v);
  swap(a.op, b.op);
  swap(a.ts, b.ts);
  swap(a.update_op, b.update_op);
  swap(a.__isset, b.__isset);
}

SpecIntervalUpdateCounter::SpecIntervalUpdateCounter(const SpecIntervalUpdateCounter& other73) noexcept {
  v = other73.v;
  op = other73.op;
  ts = other73.ts;
  update_op = other73.update_op;
  __isset = other73.__isset;
}
SpecIntervalUpdateCounter::SpecIntervalUpdateCounter(SpecIntervalUpdateCounter&& other74) noexcept {
  v = other74.v;
  op = other74.op;
  ts = other74.ts;
  update_op = std::move(other74.update_op);
  __isset = other74.__isset;
}
SpecIntervalUpdateCounter& SpecIntervalUpdateCounter::operator=(const SpecIntervalUpdateCounter& other75) noexcept {
  v = other75.v;
  op = other75.op;
  ts = other75.ts;
  update_op = other75.update_op;
  __isset = other75.__isset;
  return *this;
}
SpecIntervalUpdateCounter& SpecIntervalUpdateCounter::operator=(SpecIntervalUpdateCounter&& other76) noexcept {
  v = other76.v;
  op = other76.op;
  ts = other76.ts;
  update_op = std::move(other76.update_op);
  __isset = other76.__isset;
  return *this;
}
void SpecIntervalUpdateCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalUpdateCounter(";
  out << "v=" << to_string(v);
  out << ", " << "op=" << to_string(op);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "update_op="; (__isset.update_op ? (out << to_string(update_op)) : (out << "<null>"));
  out << ")";
}


SpecIntervalUpdateSerial::~SpecIntervalUpdateSerial() noexcept {
}


void SpecIntervalUpdateSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void SpecIntervalUpdateSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}

void SpecIntervalUpdateSerial::__set_v_op(const CellValuesSerialOp& val) {
  this->v_op = val;
}

void SpecIntervalUpdateSerial::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}

void SpecIntervalUpdateSerial::__set_update_op(const SpecUpdateOP& val) {
  this->update_op = val;
__isset.update_op = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalUpdateSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalUpdateSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size77;
            ::apache::thrift::protocol::TType _etype80;
            xfer += iprot->readListBegin(_etype80, _size77);
            this->v.resize(_size77);
            uint32_t _i81;
            for (_i81 = 0; _i81 < _size77; ++_i81)
            {
              xfer += this->v[_i81].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_op.clear();
            uint32_t _size82;
            ::apache::thrift::protocol::TType _etype85;
            xfer += iprot->readListBegin(_etype85, _size82);
            this->v_op.resize(_size82);
            uint32_t _i86;
            for (_i86 = 0; _i86 < _size82; ++_i86)
            {
              xfer += this->v_op[_i86].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast87;
          xfer += iprot->readI32(ecast87);
          this->encoder = static_cast<EncodingType::type>(ecast87);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->update_op.read(iprot);
          this->__isset.update_op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalUpdateSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalUpdateSerial");

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter88;
    for (_iter88 = this->v.begin(); _iter88 != this->v.end(); ++_iter88)
    {
      xfer += (*_iter88).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v_op", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v_op.size()));
    std::vector<CellValueSerialOp> ::const_iterator _iter89;
    for (_iter89 = this->v_op.begin(); _iter89 != this->v_op.end(); ++_iter89)
    {
      xfer += (*_iter89).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.update_op) {
    xfer += oprot->writeFieldBegin("update_op", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->update_op.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalUpdateSerial &a, SpecIntervalUpdateSerial &b) {
  using ::std::swap;
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.v_op, b.v_op);
  swap(a.encoder, b.encoder);
  swap(a.update_op, b.update_op);
  swap(a.__isset, b.__isset);
}

SpecIntervalUpdateSerial::SpecIntervalUpdateSerial(const SpecIntervalUpdateSerial& other90) {
  ts = other90.ts;
  v = other90.v;
  v_op = other90.v_op;
  encoder = other90.encoder;
  update_op = other90.update_op;
  __isset = other90.__isset;
}
SpecIntervalUpdateSerial::SpecIntervalUpdateSerial(SpecIntervalUpdateSerial&& other91) noexcept {
  ts = other91.ts;
  v = std::move(other91.v);
  v_op = std::move(other91.v_op);
  encoder = other91.encoder;
  update_op = std::move(other91.update_op);
  __isset = other91.__isset;
}
SpecIntervalUpdateSerial& SpecIntervalUpdateSerial::operator=(const SpecIntervalUpdateSerial& other92) {
  ts = other92.ts;
  v = other92.v;
  v_op = other92.v_op;
  encoder = other92.encoder;
  update_op = other92.update_op;
  __isset = other92.__isset;
  return *this;
}
SpecIntervalUpdateSerial& SpecIntervalUpdateSerial::operator=(SpecIntervalUpdateSerial&& other93) noexcept {
  ts = other93.ts;
  v = std::move(other93.v);
  v_op = std::move(other93.v_op);
  encoder = other93.encoder;
  update_op = std::move(other93.update_op);
  __isset = other93.__isset;
  return *this;
}
void SpecIntervalUpdateSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalUpdateSerial(";
  out << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ", " << "v_op=" << to_string(v_op);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ", " << "update_op="; (__isset.update_op ? (out << to_string(update_op)) : (out << "<null>"));
  out << ")";
}


SpecValueSerial_INT64::~SpecValueSerial_INT64() noexcept {
}


void SpecValueSerial_INT64::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_INT64::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_INT64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_INT64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast94;
          xfer += iprot->readI32(ecast94);
          this->comp = static_cast<Comp::type>(ecast94);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_INT64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_INT64");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_INT64 &a, SpecValueSerial_INT64 &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_INT64::SpecValueSerial_INT64(const SpecValueSerial_INT64& other95) noexcept {
  comp = other95.comp;
  v = other95.v;
  __isset = other95.__isset;
}
SpecValueSerial_INT64::SpecValueSerial_INT64(SpecValueSerial_INT64&& other96) noexcept {
  comp = other96.comp;
  v = other96.v;
  __isset = other96.__isset;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(const SpecValueSerial_INT64& other97) noexcept {
  comp = other97.comp;
  v = other97.v;
  __isset = other97.__isset;
  return *this;
}
SpecValueSerial_INT64& SpecValueSerial_INT64::operator=(SpecValueSerial_INT64&& other98) noexcept {
  comp = other98.comp;
  v = other98.v;
  __isset = other98.__isset;
  return *this;
}
void SpecValueSerial_INT64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_INT64(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_DOUBLE::~SpecValueSerial_DOUBLE() noexcept {
}


void SpecValueSerial_DOUBLE::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_DOUBLE::__set_v(const double val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_DOUBLE& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_DOUBLE::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast99;
          xfer += iprot->readI32(ecast99);
          this->comp = static_cast<Comp::type>(ecast99);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_DOUBLE::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_DOUBLE");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_DOUBLE &a, SpecValueSerial_DOUBLE &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(const SpecValueSerial_DOUBLE& other100) noexcept {
  comp = other100.comp;
  v = other100.v;
  __isset = other100.__isset;
}
SpecValueSerial_DOUBLE::SpecValueSerial_DOUBLE(SpecValueSerial_DOUBLE&& other101) noexcept {
  comp = other101.comp;
  v = other101.v;
  __isset = other101.__isset;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(const SpecValueSerial_DOUBLE& other102) noexcept {
  comp = other102.comp;
  v = other102.v;
  __isset = other102.__isset;
  return *this;
}
SpecValueSerial_DOUBLE& SpecValueSerial_DOUBLE::operator=(SpecValueSerial_DOUBLE&& other103) noexcept {
  comp = other103.comp;
  v = other103.v;
  __isset = other103.__isset;
  return *this;
}
void SpecValueSerial_DOUBLE::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_DOUBLE(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_BYTES::~SpecValueSerial_BYTES() noexcept {
}


void SpecValueSerial_BYTES::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_BYTES::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_BYTES& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_BYTES::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast104;
          xfer += iprot->readI32(ecast104);
          this->comp = static_cast<Comp::type>(ecast104);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_BYTES::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_BYTES");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_BYTES &a, SpecValueSerial_BYTES &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_BYTES::SpecValueSerial_BYTES(const SpecValueSerial_BYTES& other105) {
  comp = other105.comp;
  v = other105.v;
  __isset = other105.__isset;
}
SpecValueSerial_BYTES::SpecValueSerial_BYTES(SpecValueSerial_BYTES&& other106) noexcept {
  comp = other106.comp;
  v = std::move(other106.v);
  __isset = other106.__isset;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(const SpecValueSerial_BYTES& other107) {
  comp = other107.comp;
  v = other107.v;
  __isset = other107.__isset;
  return *this;
}
SpecValueSerial_BYTES& SpecValueSerial_BYTES::operator=(SpecValueSerial_BYTES&& other108) noexcept {
  comp = other108.comp;
  v = std::move(other108.v);
  __isset = other108.__isset;
  return *this;
}
void SpecValueSerial_BYTES::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_BYTES(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_KEY::~SpecValueSerial_KEY() noexcept {
}


void SpecValueSerial_KEY::__set_seq(const KeySeq::type val) {
  this->seq = val;
}

void SpecValueSerial_KEY::__set_v(const SpecKey& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_KEY& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_KEY::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast109;
          xfer += iprot->readI32(ecast109);
          this->seq = static_cast<KeySeq::type>(ecast109);
          this->__isset.seq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _etype113;
            xfer += iprot->readListBegin(_etype113, _size110);
            this->v.resize(_size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              xfer += this->v[_i114].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_KEY::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_KEY");

  xfer += oprot->writeFieldBegin("seq", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->seq));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecFraction> ::const_iterator _iter115;
    for (_iter115 = this->v.begin(); _iter115 != this->v.end(); ++_iter115)
    {
      xfer += (*_iter115).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_KEY &a, SpecValueSerial_KEY &b) {
  using ::std::swap;
  swap(a.seq, b.seq);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_KEY::SpecValueSerial_KEY(const SpecValueSerial_KEY& other116) {
  seq = other116.seq;
  v = other116.v;
  __isset = other116.__isset;
}
SpecValueSerial_KEY::SpecValueSerial_KEY(SpecValueSerial_KEY&& other117) noexcept {
  seq = other117.seq;
  v = std::move(other117.v);
  __isset = other117.__isset;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(const SpecValueSerial_KEY& other118) {
  seq = other118.seq;
  v = other118.v;
  __isset = other118.__isset;
  return *this;
}
SpecValueSerial_KEY& SpecValueSerial_KEY::operator=(SpecValueSerial_KEY&& other119) noexcept {
  seq = other119.seq;
  v = std::move(other119.v);
  __isset = other119.__isset;
  return *this;
}
void SpecValueSerial_KEY::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_KEY(";
  out << "seq=" << to_string(seq);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LI::~SpecValueSerial_LI() noexcept {
}


void SpecValueSerial_LI::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LI::__set_v(const std::vector<SpecValueSerial_INT64> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LI& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LI::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast120;
          xfer += iprot->readI32(ecast120);
          this->comp = static_cast<Comp::type>(ecast120);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size121;
            ::apache::thrift::protocol::TType _etype124;
            xfer += iprot->readListBegin(_etype124, _size121);
            this->v.resize(_size121);
            uint32_t _i125;
            for (_i125 = 0; _i125 < _size121; ++_i125)
            {
              xfer += this->v[_i125].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LI::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LI");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_INT64> ::const_iterator _iter126;
    for (_iter126 = this->v.begin(); _iter126 != this->v.end(); ++_iter126)
    {
      xfer += (*_iter126).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LI &a, SpecValueSerial_LI &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LI::SpecValueSerial_LI(const SpecValueSerial_LI& other127) {
  comp = other127.comp;
  v = other127.v;
  __isset = other127.__isset;
}
SpecValueSerial_LI::SpecValueSerial_LI(SpecValueSerial_LI&& other128) noexcept {
  comp = other128.comp;
  v = std::move(other128.v);
  __isset = other128.__isset;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(const SpecValueSerial_LI& other129) {
  comp = other129.comp;
  v = other129.v;
  __isset = other129.__isset;
  return *this;
}
SpecValueSerial_LI& SpecValueSerial_LI::operator=(SpecValueSerial_LI&& other130) noexcept {
  comp = other130.comp;
  v = std::move(other130.v);
  __isset = other130.__isset;
  return *this;
}
void SpecValueSerial_LI::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LI(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial_LB::~SpecValueSerial_LB() noexcept {
}


void SpecValueSerial_LB::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial_LB::__set_v(const std::vector<SpecValueSerial_BYTES> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial_LB& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial_LB::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast131;
          xfer += iprot->readI32(ecast131);
          this->comp = static_cast<Comp::type>(ecast131);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size132;
            ::apache::thrift::protocol::TType _etype135;
            xfer += iprot->readListBegin(_etype135, _size132);
            this->v.resize(_size132);
            uint32_t _i136;
            for (_i136 = 0; _i136 < _size132; ++_i136)
            {
              xfer += this->v[_i136].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial_LB::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial_LB");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<SpecValueSerial_BYTES> ::const_iterator _iter137;
    for (_iter137 = this->v.begin(); _iter137 != this->v.end(); ++_iter137)
    {
      xfer += (*_iter137).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial_LB &a, SpecValueSerial_LB &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueSerial_LB::SpecValueSerial_LB(const SpecValueSerial_LB& other138) {
  comp = other138.comp;
  v = other138.v;
  __isset = other138.__isset;
}
SpecValueSerial_LB::SpecValueSerial_LB(SpecValueSerial_LB&& other139) noexcept {
  comp = other139.comp;
  v = std::move(other139.v);
  __isset = other139.__isset;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(const SpecValueSerial_LB& other140) {
  comp = other140.comp;
  v = other140.v;
  __isset = other140.__isset;
  return *this;
}
SpecValueSerial_LB& SpecValueSerial_LB::operator=(SpecValueSerial_LB&& other141) noexcept {
  comp = other141.comp;
  v = std::move(other141.v);
  __isset = other141.__isset;
  return *this;
}
void SpecValueSerial_LB::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial_LB(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerialField::~SpecValueSerialField() noexcept {
}


void SpecValueSerialField::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void SpecValueSerialField::__set_spec_int64(const SpecValueSerial_INT64& val) {
  this->spec_int64 = val;
__isset.spec_int64 = true;
}

void SpecValueSerialField::__set_spec_double(const SpecValueSerial_DOUBLE& val) {
  this->spec_double = val;
__isset.spec_double = true;
}

void SpecValueSerialField::__set_spec_bytes(const SpecValueSerial_BYTES& val) {
  this->spec_bytes = val;
}

void SpecValueSerialField::__set_spec_key(const SpecValueSerial_KEY& val) {
  this->spec_key = val;
}

void SpecValueSerialField::__set_spec_li(const SpecValueSerial_LI& val) {
  this->spec_li = val;
}

void SpecValueSerialField::__set_spec_lb(const SpecValueSerial_LB& val) {
  this->spec_lb = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerialField& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerialField::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_int64.read(iprot);
          this->__isset.spec_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_double.read(iprot);
          this->__isset.spec_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_bytes.read(iprot);
          this->__isset.spec_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_key.read(iprot);
          this->__isset.spec_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_li.read(iprot);
          this->__isset.spec_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->spec_lb.read(iprot);
          this->__isset.spec_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerialField::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerialField");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.spec_int64) {
    xfer += oprot->writeFieldBegin("spec_int64", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->spec_int64.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.spec_double) {
    xfer += oprot->writeFieldBegin("spec_double", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->spec_double.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("spec_bytes", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->spec_bytes.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_key", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->spec_key.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_li", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->spec_li.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("spec_lb", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->spec_lb.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerialField &a, SpecValueSerialField &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.spec_int64, b.spec_int64);
  swap(a.spec_double, b.spec_double);
  swap(a.spec_bytes, b.spec_bytes);
  swap(a.spec_key, b.spec_key);
  swap(a.spec_li, b.spec_li);
  swap(a.spec_lb, b.spec_lb);
  swap(a.__isset, b.__isset);
}

SpecValueSerialField::SpecValueSerialField(const SpecValueSerialField& other142) {
  field_id = other142.field_id;
  spec_int64 = other142.spec_int64;
  spec_double = other142.spec_double;
  spec_bytes = other142.spec_bytes;
  spec_key = other142.spec_key;
  spec_li = other142.spec_li;
  spec_lb = other142.spec_lb;
  __isset = other142.__isset;
}
SpecValueSerialField::SpecValueSerialField(SpecValueSerialField&& other143) noexcept {
  field_id = other143.field_id;
  spec_int64 = std::move(other143.spec_int64);
  spec_double = std::move(other143.spec_double);
  spec_bytes = std::move(other143.spec_bytes);
  spec_key = std::move(other143.spec_key);
  spec_li = std::move(other143.spec_li);
  spec_lb = std::move(other143.spec_lb);
  __isset = other143.__isset;
}
SpecValueSerialField& SpecValueSerialField::operator=(const SpecValueSerialField& other144) {
  field_id = other144.field_id;
  spec_int64 = other144.spec_int64;
  spec_double = other144.spec_double;
  spec_bytes = other144.spec_bytes;
  spec_key = other144.spec_key;
  spec_li = other144.spec_li;
  spec_lb = other144.spec_lb;
  __isset = other144.__isset;
  return *this;
}
SpecValueSerialField& SpecValueSerialField::operator=(SpecValueSerialField&& other145) noexcept {
  field_id = other145.field_id;
  spec_int64 = std::move(other145.spec_int64);
  spec_double = std::move(other145.spec_double);
  spec_bytes = std::move(other145.spec_bytes);
  spec_key = std::move(other145.spec_key);
  spec_li = std::move(other145.spec_li);
  spec_lb = std::move(other145.spec_lb);
  __isset = other145.__isset;
  return *this;
}
void SpecValueSerialField::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerialField(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "spec_int64="; (__isset.spec_int64 ? (out << to_string(spec_int64)) : (out << "<null>"));
  out << ", " << "spec_double="; (__isset.spec_double ? (out << to_string(spec_double)) : (out << "<null>"));
  out << ", " << "spec_bytes=" << to_string(spec_bytes);
  out << ", " << "spec_key=" << to_string(spec_key);
  out << ", " << "spec_li=" << to_string(spec_li);
  out << ", " << "spec_lb=" << to_string(spec_lb);
  out << ")";
}


SpecValuePlain::~SpecValuePlain() noexcept {
}


void SpecValuePlain::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValuePlain::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValuePlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValuePlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast146;
          xfer += iprot->readI32(ecast146);
          this->comp = static_cast<Comp::type>(ecast146);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValuePlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValuePlain");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValuePlain &a, SpecValuePlain &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValuePlain::SpecValuePlain(const SpecValuePlain& other147) {
  comp = other147.comp;
  v = other147.v;
  __isset = other147.__isset;
}
SpecValuePlain::SpecValuePlain(SpecValuePlain&& other148) noexcept {
  comp = other148.comp;
  v = std::move(other148.v);
  __isset = other148.__isset;
}
SpecValuePlain& SpecValuePlain::operator=(const SpecValuePlain& other149) {
  comp = other149.comp;
  v = other149.v;
  __isset = other149.__isset;
  return *this;
}
SpecValuePlain& SpecValuePlain::operator=(SpecValuePlain&& other150) noexcept {
  comp = other150.comp;
  v = std::move(other150.v);
  __isset = other150.__isset;
  return *this;
}
void SpecValuePlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValuePlain(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueCounter::~SpecValueCounter() noexcept {
}


void SpecValueCounter::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueCounter::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast151;
          xfer += iprot->readI32(ecast151);
          this->comp = static_cast<Comp::type>(ecast151);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueCounter");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueCounter &a, SpecValueCounter &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

SpecValueCounter::SpecValueCounter(const SpecValueCounter& other152) noexcept {
  comp = other152.comp;
  v = other152.v;
  __isset = other152.__isset;
}
SpecValueCounter::SpecValueCounter(SpecValueCounter&& other153) noexcept {
  comp = other153.comp;
  v = other153.v;
  __isset = other153.__isset;
}
SpecValueCounter& SpecValueCounter::operator=(const SpecValueCounter& other154) noexcept {
  comp = other154.comp;
  v = other154.v;
  __isset = other154.__isset;
  return *this;
}
SpecValueCounter& SpecValueCounter::operator=(SpecValueCounter&& other155) noexcept {
  comp = other155.comp;
  v = other155.v;
  __isset = other155.__isset;
  return *this;
}
void SpecValueCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueCounter(";
  out << "comp=" << to_string(comp);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


SpecValueSerial::~SpecValueSerial() noexcept {
}


void SpecValueSerial::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecValueSerial::__set_fields(const SpecValueSerialFields& val) {
  this->fields = val;
}
std::ostream& operator<<(std::ostream& out, const SpecValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast156;
          xfer += iprot->readI32(ecast156);
          this->comp = static_cast<Comp::type>(ecast156);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->fields.clear();
            uint32_t _size157;
            ::apache::thrift::protocol::TType _etype160;
            xfer += iprot->readListBegin(_etype160, _size157);
            this->fields.resize(_size157);
            uint32_t _i161;
            for (_i161 = 0; _i161 < _size157; ++_i161)
            {
              xfer += this->fields[_i161].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.fields = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecValueSerial");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fields", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->fields.size()));
    std::vector<SpecValueSerialField> ::const_iterator _iter162;
    for (_iter162 = this->fields.begin(); _iter162 != this->fields.end(); ++_iter162)
    {
      xfer += (*_iter162).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecValueSerial &a, SpecValueSerial &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.fields, b.fields);
  swap(a.__isset, b.__isset);
}

SpecValueSerial::SpecValueSerial(const SpecValueSerial& other163) {
  comp = other163.comp;
  fields = other163.fields;
  __isset = other163.__isset;
}
SpecValueSerial::SpecValueSerial(SpecValueSerial&& other164) noexcept {
  comp = other164.comp;
  fields = std::move(other164.fields);
  __isset = other164.__isset;
}
SpecValueSerial& SpecValueSerial::operator=(const SpecValueSerial& other165) {
  comp = other165.comp;
  fields = other165.fields;
  __isset = other165.__isset;
  return *this;
}
SpecValueSerial& SpecValueSerial::operator=(SpecValueSerial&& other166) noexcept {
  comp = other166.comp;
  fields = std::move(other166.fields);
  __isset = other166.__isset;
  return *this;
}
void SpecValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecValueSerial(";
  out << "comp=" << to_string(comp);
  out << ", " << "fields=" << to_string(fields);
  out << ")";
}


SpecFraction::~SpecFraction() noexcept {
}


void SpecFraction::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecFraction::__set_f(const std::string& val) {
  this->f = val;
}
std::ostream& operator<<(std::ostream& out, const SpecFraction& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecFraction::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast167;
          xfer += iprot->readI32(ecast167);
          this->comp = static_cast<Comp::type>(ecast167);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->f);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecFraction::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecFraction");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->f);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecFraction &a, SpecFraction &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.f, b.f);
  swap(a.__isset, b.__isset);
}

SpecFraction::SpecFraction(const SpecFraction& other168) {
  comp = other168.comp;
  f = other168.f;
  __isset = other168.__isset;
}
SpecFraction::SpecFraction(SpecFraction&& other169) noexcept {
  comp = other169.comp;
  f = std::move(other169.f);
  __isset = other169.__isset;
}
SpecFraction& SpecFraction::operator=(const SpecFraction& other170) {
  comp = other170.comp;
  f = other170.f;
  __isset = other170.__isset;
  return *this;
}
SpecFraction& SpecFraction::operator=(SpecFraction&& other171) noexcept {
  comp = other171.comp;
  f = std::move(other171.f);
  __isset = other171.__isset;
  return *this;
}
void SpecFraction::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecFraction(";
  out << "comp=" << to_string(comp);
  out << ", " << "f=" << to_string(f);
  out << ")";
}


SpecTimestamp::~SpecTimestamp() noexcept {
}


void SpecTimestamp::__set_comp(const Comp::type val) {
  this->comp = val;
}

void SpecTimestamp::__set_ts(const int64_t val) {
  this->ts = val;
}
std::ostream& operator<<(std::ostream& out, const SpecTimestamp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecTimestamp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast172;
          xfer += iprot->readI32(ecast172);
          this->comp = static_cast<Comp::type>(ecast172);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecTimestamp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecTimestamp");

  xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecTimestamp &a, SpecTimestamp &b) {
  using ::std::swap;
  swap(a.comp, b.comp);
  swap(a.ts, b.ts);
  swap(a.__isset, b.__isset);
}

SpecTimestamp::SpecTimestamp(const SpecTimestamp& other173) noexcept {
  comp = other173.comp;
  ts = other173.ts;
  __isset = other173.__isset;
}
SpecTimestamp::SpecTimestamp(SpecTimestamp&& other174) noexcept {
  comp = other174.comp;
  ts = other174.ts;
  __isset = other174.__isset;
}
SpecTimestamp& SpecTimestamp::operator=(const SpecTimestamp& other175) noexcept {
  comp = other175.comp;
  ts = other175.ts;
  __isset = other175.__isset;
  return *this;
}
SpecTimestamp& SpecTimestamp::operator=(SpecTimestamp&& other176) noexcept {
  comp = other176.comp;
  ts = other176.ts;
  __isset = other176.__isset;
  return *this;
}
void SpecTimestamp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecTimestamp(";
  out << "comp=" << to_string(comp);
  out << ", " << "ts=" << to_string(ts);
  out << ")";
}


SpecKeyInterval::~SpecKeyInterval() noexcept {
}


void SpecKeyInterval::__set_start(const SpecKey& val) {
  this->start = val;
}

void SpecKeyInterval::__set_finish(const SpecKey& val) {
  this->finish = val;
}
std::ostream& operator<<(std::ostream& out, const SpecKeyInterval& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecKeyInterval::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->start.clear();
            uint32_t _size177;
            ::apache::thrift::protocol::TType _etype180;
            xfer += iprot->readListBegin(_etype180, _size177);
            this->start.resize(_size177);
            uint32_t _i181;
            for (_i181 = 0; _i181 < _size177; ++_i181)
            {
              xfer += this->start[_i181].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->finish.clear();
            uint32_t _size182;
            ::apache::thrift::protocol::TType _etype185;
            xfer += iprot->readListBegin(_etype185, _size182);
            this->finish.resize(_size182);
            uint32_t _i186;
            for (_i186 = 0; _i186 < _size182; ++_i186)
            {
              xfer += this->finish[_i186].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecKeyInterval::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecKeyInterval");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->start.size()));
    std::vector<SpecFraction> ::const_iterator _iter187;
    for (_iter187 = this->start.begin(); _iter187 != this->start.end(); ++_iter187)
    {
      xfer += (*_iter187).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("finish", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->finish.size()));
    std::vector<SpecFraction> ::const_iterator _iter188;
    for (_iter188 = this->finish.begin(); _iter188 != this->finish.end(); ++_iter188)
    {
      xfer += (*_iter188).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecKeyInterval &a, SpecKeyInterval &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.finish, b.finish);
  swap(a.__isset, b.__isset);
}

SpecKeyInterval::SpecKeyInterval(const SpecKeyInterval& other189) {
  start = other189.start;
  finish = other189.finish;
  __isset = other189.__isset;
}
SpecKeyInterval::SpecKeyInterval(SpecKeyInterval&& other190) noexcept {
  start = std::move(other190.start);
  finish = std::move(other190.finish);
  __isset = other190.__isset;
}
SpecKeyInterval& SpecKeyInterval::operator=(const SpecKeyInterval& other191) {
  start = other191.start;
  finish = other191.finish;
  __isset = other191.__isset;
  return *this;
}
SpecKeyInterval& SpecKeyInterval::operator=(SpecKeyInterval&& other192) noexcept {
  start = std::move(other192.start);
  finish = std::move(other192.finish);
  __isset = other192.__isset;
  return *this;
}
void SpecKeyInterval::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecKeyInterval(";
  out << "start=" << to_string(start);
  out << ", " << "finish=" << to_string(finish);
  out << ")";
}


SpecIntervalPlain::~SpecIntervalPlain() noexcept {
}


void SpecIntervalPlain::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecIntervalPlain::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecIntervalPlain::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecIntervalPlain::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecIntervalPlain::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecIntervalPlain::__set_values(const SpecValuesPlain& val) {
  this->values = val;
}

void SpecIntervalPlain::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecIntervalPlain::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecIntervalPlain::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}

void SpecIntervalPlain::__set_options(const SpecIntervalOptions::type val) {
  this->options = val;
__isset.options = true;
}

void SpecIntervalPlain::__set_updating(const SpecIntervalUpdatePlain& val) {
  this->updating = val;
__isset.updating = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalPlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalPlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size193;
            ::apache::thrift::protocol::TType _etype196;
            xfer += iprot->readListBegin(_etype196, _size193);
            this->range_begin.resize(_size193);
            uint32_t _i197;
            for (_i197 = 0; _i197 < _size193; ++_i197)
            {
              xfer += iprot->readBinary(this->range_begin[_i197]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size198;
            ::apache::thrift::protocol::TType _etype201;
            xfer += iprot->readListBegin(_etype201, _size198);
            this->range_end.resize(_size198);
            uint32_t _i202;
            for (_i202 = 0; _i202 < _size198; ++_i202)
            {
              xfer += iprot->readBinary(this->range_end[_i202]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size203;
            ::apache::thrift::protocol::TType _etype206;
            xfer += iprot->readListBegin(_etype206, _size203);
            this->offset_key.resize(_size203);
            uint32_t _i207;
            for (_i207 = 0; _i207 < _size203; ++_i207)
            {
              xfer += iprot->readBinary(this->offset_key[_i207]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size208;
            ::apache::thrift::protocol::TType _etype211;
            xfer += iprot->readListBegin(_etype211, _size208);
            this->key_intervals.resize(_size208);
            uint32_t _i212;
            for (_i212 = 0; _i212 < _size208; ++_i212)
            {
              xfer += this->key_intervals[_i212].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size213;
            ::apache::thrift::protocol::TType _etype216;
            xfer += iprot->readListBegin(_etype216, _size213);
            this->values.resize(_size213);
            uint32_t _i217;
            for (_i217 = 0; _i217 < _size213; ++_i217)
            {
              xfer += this->values[_i217].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast218;
          xfer += iprot->readI32(ecast218);
          this->options = static_cast<SpecIntervalOptions::type>(ecast218);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->updating.read(iprot);
          this->__isset.updating = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalPlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalPlain");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter219;
    for (_iter219 = this->range_begin.begin(); _iter219 != this->range_begin.end(); ++_iter219)
    {
      xfer += oprot->writeBinary((*_iter219));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter220;
    for (_iter220 = this->range_end.begin(); _iter220 != this->range_end.end(); ++_iter220)
    {
      xfer += oprot->writeBinary((*_iter220));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter221;
    for (_iter221 = this->offset_key.begin(); _iter221 != this->offset_key.end(); ++_iter221)
    {
      xfer += oprot->writeBinary((*_iter221));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter222;
    for (_iter222 = this->key_intervals.begin(); _iter222 != this->key_intervals.end(); ++_iter222)
    {
      xfer += (*_iter222).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValuePlain> ::const_iterator _iter223;
    for (_iter223 = this->values.begin(); _iter223 != this->values.end(); ++_iter223)
    {
      xfer += (*_iter223).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(static_cast<int32_t>(this->options));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updating) {
    xfer += oprot->writeFieldBegin("updating", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->updating.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalPlain &a, SpecIntervalPlain &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.options, b.options);
  swap(a.updating, b.updating);
  swap(a.__isset, b.__isset);
}

SpecIntervalPlain::SpecIntervalPlain(const SpecIntervalPlain& other224) {
  range_begin = other224.range_begin;
  range_end = other224.range_end;
  offset_key = other224.offset_key;
  offset_rev = other224.offset_rev;
  key_intervals = other224.key_intervals;
  values = other224.values;
  ts_start = other224.ts_start;
  ts_finish = other224.ts_finish;
  flags = other224.flags;
  options = other224.options;
  updating = other224.updating;
  __isset = other224.__isset;
}
SpecIntervalPlain::SpecIntervalPlain(SpecIntervalPlain&& other225) noexcept {
  range_begin = std::move(other225.range_begin);
  range_end = std::move(other225.range_end);
  offset_key = std::move(other225.offset_key);
  offset_rev = other225.offset_rev;
  key_intervals = std::move(other225.key_intervals);
  values = std::move(other225.values);
  ts_start = std::move(other225.ts_start);
  ts_finish = std::move(other225.ts_finish);
  flags = std::move(other225.flags);
  options = other225.options;
  updating = std::move(other225.updating);
  __isset = other225.__isset;
}
SpecIntervalPlain& SpecIntervalPlain::operator=(const SpecIntervalPlain& other226) {
  range_begin = other226.range_begin;
  range_end = other226.range_end;
  offset_key = other226.offset_key;
  offset_rev = other226.offset_rev;
  key_intervals = other226.key_intervals;
  values = other226.values;
  ts_start = other226.ts_start;
  ts_finish = other226.ts_finish;
  flags = other226.flags;
  options = other226.options;
  updating = other226.updating;
  __isset = other226.__isset;
  return *this;
}
SpecIntervalPlain& SpecIntervalPlain::operator=(SpecIntervalPlain&& other227) noexcept {
  range_begin = std::move(other227.range_begin);
  range_end = std::move(other227.range_end);
  offset_key = std::move(other227.offset_key);
  offset_rev = other227.offset_rev;
  key_intervals = std::move(other227.key_intervals);
  values = std::move(other227.values);
  ts_start = std::move(other227.ts_start);
  ts_finish = std::move(other227.ts_finish);
  flags = std::move(other227.flags);
  options = other227.options;
  updating = std::move(other227.updating);
  __isset = other227.__isset;
  return *this;
}
void SpecIntervalPlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalPlain(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "updating="; (__isset.updating ? (out << to_string(updating)) : (out << "<null>"));
  out << ")";
}


SpecIntervalCounter::~SpecIntervalCounter() noexcept {
}


void SpecIntervalCounter::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecIntervalCounter::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecIntervalCounter::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecIntervalCounter::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecIntervalCounter::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecIntervalCounter::__set_values(const SpecValuesCounter& val) {
  this->values = val;
}

void SpecIntervalCounter::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecIntervalCounter::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecIntervalCounter::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}

void SpecIntervalCounter::__set_options(const SpecIntervalOptions::type val) {
  this->options = val;
__isset.options = true;
}

void SpecIntervalCounter::__set_updating(const SpecIntervalUpdateCounter& val) {
  this->updating = val;
__isset.updating = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size228;
            ::apache::thrift::protocol::TType _etype231;
            xfer += iprot->readListBegin(_etype231, _size228);
            this->range_begin.resize(_size228);
            uint32_t _i232;
            for (_i232 = 0; _i232 < _size228; ++_i232)
            {
              xfer += iprot->readBinary(this->range_begin[_i232]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size233;
            ::apache::thrift::protocol::TType _etype236;
            xfer += iprot->readListBegin(_etype236, _size233);
            this->range_end.resize(_size233);
            uint32_t _i237;
            for (_i237 = 0; _i237 < _size233; ++_i237)
            {
              xfer += iprot->readBinary(this->range_end[_i237]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size238;
            ::apache::thrift::protocol::TType _etype241;
            xfer += iprot->readListBegin(_etype241, _size238);
            this->offset_key.resize(_size238);
            uint32_t _i242;
            for (_i242 = 0; _i242 < _size238; ++_i242)
            {
              xfer += iprot->readBinary(this->offset_key[_i242]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size243;
            ::apache::thrift::protocol::TType _etype246;
            xfer += iprot->readListBegin(_etype246, _size243);
            this->key_intervals.resize(_size243);
            uint32_t _i247;
            for (_i247 = 0; _i247 < _size243; ++_i247)
            {
              xfer += this->key_intervals[_i247].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size248;
            ::apache::thrift::protocol::TType _etype251;
            xfer += iprot->readListBegin(_etype251, _size248);
            this->values.resize(_size248);
            uint32_t _i252;
            for (_i252 = 0; _i252 < _size248; ++_i252)
            {
              xfer += this->values[_i252].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast253;
          xfer += iprot->readI32(ecast253);
          this->options = static_cast<SpecIntervalOptions::type>(ecast253);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->updating.read(iprot);
          this->__isset.updating = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalCounter");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter254;
    for (_iter254 = this->range_begin.begin(); _iter254 != this->range_begin.end(); ++_iter254)
    {
      xfer += oprot->writeBinary((*_iter254));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter255;
    for (_iter255 = this->range_end.begin(); _iter255 != this->range_end.end(); ++_iter255)
    {
      xfer += oprot->writeBinary((*_iter255));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter256;
    for (_iter256 = this->offset_key.begin(); _iter256 != this->offset_key.end(); ++_iter256)
    {
      xfer += oprot->writeBinary((*_iter256));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter257;
    for (_iter257 = this->key_intervals.begin(); _iter257 != this->key_intervals.end(); ++_iter257)
    {
      xfer += (*_iter257).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValueCounter> ::const_iterator _iter258;
    for (_iter258 = this->values.begin(); _iter258 != this->values.end(); ++_iter258)
    {
      xfer += (*_iter258).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(static_cast<int32_t>(this->options));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updating) {
    xfer += oprot->writeFieldBegin("updating", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->updating.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalCounter &a, SpecIntervalCounter &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.options, b.options);
  swap(a.updating, b.updating);
  swap(a.__isset, b.__isset);
}

SpecIntervalCounter::SpecIntervalCounter(const SpecIntervalCounter& other259) {
  range_begin = other259.range_begin;
  range_end = other259.range_end;
  offset_key = other259.offset_key;
  offset_rev = other259.offset_rev;
  key_intervals = other259.key_intervals;
  values = other259.values;
  ts_start = other259.ts_start;
  ts_finish = other259.ts_finish;
  flags = other259.flags;
  options = other259.options;
  updating = other259.updating;
  __isset = other259.__isset;
}
SpecIntervalCounter::SpecIntervalCounter(SpecIntervalCounter&& other260) noexcept {
  range_begin = std::move(other260.range_begin);
  range_end = std::move(other260.range_end);
  offset_key = std::move(other260.offset_key);
  offset_rev = other260.offset_rev;
  key_intervals = std::move(other260.key_intervals);
  values = std::move(other260.values);
  ts_start = std::move(other260.ts_start);
  ts_finish = std::move(other260.ts_finish);
  flags = std::move(other260.flags);
  options = other260.options;
  updating = std::move(other260.updating);
  __isset = other260.__isset;
}
SpecIntervalCounter& SpecIntervalCounter::operator=(const SpecIntervalCounter& other261) {
  range_begin = other261.range_begin;
  range_end = other261.range_end;
  offset_key = other261.offset_key;
  offset_rev = other261.offset_rev;
  key_intervals = other261.key_intervals;
  values = other261.values;
  ts_start = other261.ts_start;
  ts_finish = other261.ts_finish;
  flags = other261.flags;
  options = other261.options;
  updating = other261.updating;
  __isset = other261.__isset;
  return *this;
}
SpecIntervalCounter& SpecIntervalCounter::operator=(SpecIntervalCounter&& other262) noexcept {
  range_begin = std::move(other262.range_begin);
  range_end = std::move(other262.range_end);
  offset_key = std::move(other262.offset_key);
  offset_rev = other262.offset_rev;
  key_intervals = std::move(other262.key_intervals);
  values = std::move(other262.values);
  ts_start = std::move(other262.ts_start);
  ts_finish = std::move(other262.ts_finish);
  flags = std::move(other262.flags);
  options = other262.options;
  updating = std::move(other262.updating);
  __isset = other262.__isset;
  return *this;
}
void SpecIntervalCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalCounter(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "updating="; (__isset.updating ? (out << to_string(updating)) : (out << "<null>"));
  out << ")";
}


SpecIntervalSerial::~SpecIntervalSerial() noexcept {
}


void SpecIntervalSerial::__set_range_begin(const Key& val) {
  this->range_begin = val;
}

void SpecIntervalSerial::__set_range_end(const Key& val) {
  this->range_end = val;
}

void SpecIntervalSerial::__set_offset_key(const Key& val) {
  this->offset_key = val;
}

void SpecIntervalSerial::__set_offset_rev(const int64_t val) {
  this->offset_rev = val;
__isset.offset_rev = true;
}

void SpecIntervalSerial::__set_key_intervals(const SpecKeyIntervals& val) {
  this->key_intervals = val;
}

void SpecIntervalSerial::__set_values(const SpecValuesSerial& val) {
  this->values = val;
}

void SpecIntervalSerial::__set_ts_start(const SpecTimestamp& val) {
  this->ts_start = val;
__isset.ts_start = true;
}

void SpecIntervalSerial::__set_ts_finish(const SpecTimestamp& val) {
  this->ts_finish = val;
__isset.ts_finish = true;
}

void SpecIntervalSerial::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}

void SpecIntervalSerial::__set_options(const SpecIntervalOptions::type val) {
  this->options = val;
__isset.options = true;
}

void SpecIntervalSerial::__set_updating(const SpecIntervalUpdateSerial& val) {
  this->updating = val;
__isset.updating = true;
}
std::ostream& operator<<(std::ostream& out, const SpecIntervalSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecIntervalSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_begin.clear();
            uint32_t _size263;
            ::apache::thrift::protocol::TType _etype266;
            xfer += iprot->readListBegin(_etype266, _size263);
            this->range_begin.resize(_size263);
            uint32_t _i267;
            for (_i267 = 0; _i267 < _size263; ++_i267)
            {
              xfer += iprot->readBinary(this->range_begin[_i267]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_begin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->range_end.clear();
            uint32_t _size268;
            ::apache::thrift::protocol::TType _etype271;
            xfer += iprot->readListBegin(_etype271, _size268);
            this->range_end.resize(_size268);
            uint32_t _i272;
            for (_i272 = 0; _i272 < _size268; ++_i272)
            {
              xfer += iprot->readBinary(this->range_end[_i272]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.range_end = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->offset_key.clear();
            uint32_t _size273;
            ::apache::thrift::protocol::TType _etype276;
            xfer += iprot->readListBegin(_etype276, _size273);
            this->offset_key.resize(_size273);
            uint32_t _i277;
            for (_i277 = 0; _i277 < _size273; ++_i277)
            {
              xfer += iprot->readBinary(this->offset_key[_i277]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.offset_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->offset_rev);
          this->__isset.offset_rev = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->key_intervals.clear();
            uint32_t _size278;
            ::apache::thrift::protocol::TType _etype281;
            xfer += iprot->readListBegin(_etype281, _size278);
            this->key_intervals.resize(_size278);
            uint32_t _i282;
            for (_i282 = 0; _i282 < _size278; ++_i282)
            {
              xfer += this->key_intervals[_i282].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.key_intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->values.clear();
            uint32_t _size283;
            ::apache::thrift::protocol::TType _etype286;
            xfer += iprot->readListBegin(_etype286, _size283);
            this->values.resize(_size283);
            uint32_t _i287;
            for (_i287 = 0; _i287 < _size283; ++_i287)
            {
              xfer += this->values[_i287].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.values = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_start.read(iprot);
          this->__isset.ts_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ts_finish.read(iprot);
          this->__isset.ts_finish = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast288;
          xfer += iprot->readI32(ecast288);
          this->options = static_cast<SpecIntervalOptions::type>(ecast288);
          this->__isset.options = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->updating.read(iprot);
          this->__isset.updating = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecIntervalSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecIntervalSerial");

  xfer += oprot->writeFieldBegin("range_begin", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_begin.size()));
    std::vector<std::string> ::const_iterator _iter289;
    for (_iter289 = this->range_begin.begin(); _iter289 != this->range_begin.end(); ++_iter289)
    {
      xfer += oprot->writeBinary((*_iter289));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("range_end", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->range_end.size()));
    std::vector<std::string> ::const_iterator _iter290;
    for (_iter290 = this->range_end.begin(); _iter290 != this->range_end.end(); ++_iter290)
    {
      xfer += oprot->writeBinary((*_iter290));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("offset_key", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->offset_key.size()));
    std::vector<std::string> ::const_iterator _iter291;
    for (_iter291 = this->offset_key.begin(); _iter291 != this->offset_key.end(); ++_iter291)
    {
      xfer += oprot->writeBinary((*_iter291));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.offset_rev) {
    xfer += oprot->writeFieldBegin("offset_rev", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->offset_rev);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("key_intervals", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->key_intervals.size()));
    std::vector<SpecKeyInterval> ::const_iterator _iter292;
    for (_iter292 = this->key_intervals.begin(); _iter292 != this->key_intervals.end(); ++_iter292)
    {
      xfer += (*_iter292).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("values", ::apache::thrift::protocol::T_LIST, 6);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->values.size()));
    std::vector<SpecValueSerial> ::const_iterator _iter293;
    for (_iter293 = this->values.begin(); _iter293 != this->values.end(); ++_iter293)
    {
      xfer += (*_iter293).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts_start) {
    xfer += oprot->writeFieldBegin("ts_start", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->ts_start.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_finish) {
    xfer += oprot->writeFieldBegin("ts_finish", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ts_finish.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.options) {
    xfer += oprot->writeFieldBegin("options", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(static_cast<int32_t>(this->options));
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.updating) {
    xfer += oprot->writeFieldBegin("updating", ::apache::thrift::protocol::T_STRUCT, 11);
    xfer += this->updating.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecIntervalSerial &a, SpecIntervalSerial &b) {
  using ::std::swap;
  swap(a.range_begin, b.range_begin);
  swap(a.range_end, b.range_end);
  swap(a.offset_key, b.offset_key);
  swap(a.offset_rev, b.offset_rev);
  swap(a.key_intervals, b.key_intervals);
  swap(a.values, b.values);
  swap(a.ts_start, b.ts_start);
  swap(a.ts_finish, b.ts_finish);
  swap(a.flags, b.flags);
  swap(a.options, b.options);
  swap(a.updating, b.updating);
  swap(a.__isset, b.__isset);
}

SpecIntervalSerial::SpecIntervalSerial(const SpecIntervalSerial& other294) {
  range_begin = other294.range_begin;
  range_end = other294.range_end;
  offset_key = other294.offset_key;
  offset_rev = other294.offset_rev;
  key_intervals = other294.key_intervals;
  values = other294.values;
  ts_start = other294.ts_start;
  ts_finish = other294.ts_finish;
  flags = other294.flags;
  options = other294.options;
  updating = other294.updating;
  __isset = other294.__isset;
}
SpecIntervalSerial::SpecIntervalSerial(SpecIntervalSerial&& other295) noexcept {
  range_begin = std::move(other295.range_begin);
  range_end = std::move(other295.range_end);
  offset_key = std::move(other295.offset_key);
  offset_rev = other295.offset_rev;
  key_intervals = std::move(other295.key_intervals);
  values = std::move(other295.values);
  ts_start = std::move(other295.ts_start);
  ts_finish = std::move(other295.ts_finish);
  flags = std::move(other295.flags);
  options = other295.options;
  updating = std::move(other295.updating);
  __isset = other295.__isset;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(const SpecIntervalSerial& other296) {
  range_begin = other296.range_begin;
  range_end = other296.range_end;
  offset_key = other296.offset_key;
  offset_rev = other296.offset_rev;
  key_intervals = other296.key_intervals;
  values = other296.values;
  ts_start = other296.ts_start;
  ts_finish = other296.ts_finish;
  flags = other296.flags;
  options = other296.options;
  updating = other296.updating;
  __isset = other296.__isset;
  return *this;
}
SpecIntervalSerial& SpecIntervalSerial::operator=(SpecIntervalSerial&& other297) noexcept {
  range_begin = std::move(other297.range_begin);
  range_end = std::move(other297.range_end);
  offset_key = std::move(other297.offset_key);
  offset_rev = other297.offset_rev;
  key_intervals = std::move(other297.key_intervals);
  values = std::move(other297.values);
  ts_start = std::move(other297.ts_start);
  ts_finish = std::move(other297.ts_finish);
  flags = std::move(other297.flags);
  options = other297.options;
  updating = std::move(other297.updating);
  __isset = other297.__isset;
  return *this;
}
void SpecIntervalSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecIntervalSerial(";
  out << "range_begin=" << to_string(range_begin);
  out << ", " << "range_end=" << to_string(range_end);
  out << ", " << "offset_key=" << to_string(offset_key);
  out << ", " << "offset_rev="; (__isset.offset_rev ? (out << to_string(offset_rev)) : (out << "<null>"));
  out << ", " << "key_intervals=" << to_string(key_intervals);
  out << ", " << "values=" << to_string(values);
  out << ", " << "ts_start="; (__isset.ts_start ? (out << to_string(ts_start)) : (out << "<null>"));
  out << ", " << "ts_finish="; (__isset.ts_finish ? (out << to_string(ts_finish)) : (out << "<null>"));
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ", " << "options="; (__isset.options ? (out << to_string(options)) : (out << "<null>"));
  out << ", " << "updating="; (__isset.updating ? (out << to_string(updating)) : (out << "<null>"));
  out << ")";
}


SpecColumnPlain::~SpecColumnPlain() noexcept {
}


void SpecColumnPlain::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumnPlain::__set_intervals(const std::vector<SpecIntervalPlain> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumnPlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumnPlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size298;
            ::apache::thrift::protocol::TType _etype301;
            xfer += iprot->readListBegin(_etype301, _size298);
            this->intervals.resize(_size298);
            uint32_t _i302;
            for (_i302 = 0; _i302 < _size298; ++_i302)
            {
              xfer += this->intervals[_i302].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumnPlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumnPlain");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecIntervalPlain> ::const_iterator _iter303;
    for (_iter303 = this->intervals.begin(); _iter303 != this->intervals.end(); ++_iter303)
    {
      xfer += (*_iter303).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumnPlain &a, SpecColumnPlain &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumnPlain::SpecColumnPlain(const SpecColumnPlain& other304) {
  cid = other304.cid;
  intervals = other304.intervals;
  __isset = other304.__isset;
}
SpecColumnPlain::SpecColumnPlain(SpecColumnPlain&& other305) noexcept {
  cid = other305.cid;
  intervals = std::move(other305.intervals);
  __isset = other305.__isset;
}
SpecColumnPlain& SpecColumnPlain::operator=(const SpecColumnPlain& other306) {
  cid = other306.cid;
  intervals = other306.intervals;
  __isset = other306.__isset;
  return *this;
}
SpecColumnPlain& SpecColumnPlain::operator=(SpecColumnPlain&& other307) noexcept {
  cid = other307.cid;
  intervals = std::move(other307.intervals);
  __isset = other307.__isset;
  return *this;
}
void SpecColumnPlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumnPlain(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecColumnCounter::~SpecColumnCounter() noexcept {
}


void SpecColumnCounter::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumnCounter::__set_intervals(const std::vector<SpecIntervalCounter> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumnCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumnCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size308;
            ::apache::thrift::protocol::TType _etype311;
            xfer += iprot->readListBegin(_etype311, _size308);
            this->intervals.resize(_size308);
            uint32_t _i312;
            for (_i312 = 0; _i312 < _size308; ++_i312)
            {
              xfer += this->intervals[_i312].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumnCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumnCounter");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecIntervalCounter> ::const_iterator _iter313;
    for (_iter313 = this->intervals.begin(); _iter313 != this->intervals.end(); ++_iter313)
    {
      xfer += (*_iter313).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumnCounter &a, SpecColumnCounter &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumnCounter::SpecColumnCounter(const SpecColumnCounter& other314) {
  cid = other314.cid;
  intervals = other314.intervals;
  __isset = other314.__isset;
}
SpecColumnCounter::SpecColumnCounter(SpecColumnCounter&& other315) noexcept {
  cid = other315.cid;
  intervals = std::move(other315.intervals);
  __isset = other315.__isset;
}
SpecColumnCounter& SpecColumnCounter::operator=(const SpecColumnCounter& other316) {
  cid = other316.cid;
  intervals = other316.intervals;
  __isset = other316.__isset;
  return *this;
}
SpecColumnCounter& SpecColumnCounter::operator=(SpecColumnCounter&& other317) noexcept {
  cid = other317.cid;
  intervals = std::move(other317.intervals);
  __isset = other317.__isset;
  return *this;
}
void SpecColumnCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumnCounter(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecColumnSerial::~SpecColumnSerial() noexcept {
}


void SpecColumnSerial::__set_cid(const int64_t val) {
  this->cid = val;
}

void SpecColumnSerial::__set_intervals(const std::vector<SpecIntervalSerial> & val) {
  this->intervals = val;
}
std::ostream& operator<<(std::ostream& out, const SpecColumnSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecColumnSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->intervals.clear();
            uint32_t _size318;
            ::apache::thrift::protocol::TType _etype321;
            xfer += iprot->readListBegin(_etype321, _size318);
            this->intervals.resize(_size318);
            uint32_t _i322;
            for (_i322 = 0; _i322 < _size318; ++_i322)
            {
              xfer += this->intervals[_i322].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.intervals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecColumnSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecColumnSerial");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("intervals", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->intervals.size()));
    std::vector<SpecIntervalSerial> ::const_iterator _iter323;
    for (_iter323 = this->intervals.begin(); _iter323 != this->intervals.end(); ++_iter323)
    {
      xfer += (*_iter323).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecColumnSerial &a, SpecColumnSerial &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.intervals, b.intervals);
  swap(a.__isset, b.__isset);
}

SpecColumnSerial::SpecColumnSerial(const SpecColumnSerial& other324) {
  cid = other324.cid;
  intervals = other324.intervals;
  __isset = other324.__isset;
}
SpecColumnSerial::SpecColumnSerial(SpecColumnSerial&& other325) noexcept {
  cid = other325.cid;
  intervals = std::move(other325.intervals);
  __isset = other325.__isset;
}
SpecColumnSerial& SpecColumnSerial::operator=(const SpecColumnSerial& other326) {
  cid = other326.cid;
  intervals = other326.intervals;
  __isset = other326.__isset;
  return *this;
}
SpecColumnSerial& SpecColumnSerial::operator=(SpecColumnSerial&& other327) noexcept {
  cid = other327.cid;
  intervals = std::move(other327.intervals);
  __isset = other327.__isset;
  return *this;
}
void SpecColumnSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecColumnSerial(";
  out << "cid=" << to_string(cid);
  out << ", " << "intervals=" << to_string(intervals);
  out << ")";
}


SpecScan::~SpecScan() noexcept {
}


void SpecScan::__set_columns_plain(const std::vector<SpecColumnPlain> & val) {
  this->columns_plain = val;
}

void SpecScan::__set_columns_counter(const std::vector<SpecColumnCounter> & val) {
  this->columns_counter = val;
}

void SpecScan::__set_columns_serial(const std::vector<SpecColumnSerial> & val) {
  this->columns_serial = val;
}

void SpecScan::__set_flags(const SpecFlags& val) {
  this->flags = val;
__isset.flags = true;
}
std::ostream& operator<<(std::ostream& out, const SpecScan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t SpecScan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns_plain.clear();
            uint32_t _size328;
            ::apache::thrift::protocol::TType _etype331;
            xfer += iprot->readListBegin(_etype331, _size328);
            this->columns_plain.resize(_size328);
            uint32_t _i332;
            for (_i332 = 0; _i332 < _size328; ++_i332)
            {
              xfer += this->columns_plain[_i332].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns_plain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns_counter.clear();
            uint32_t _size333;
            ::apache::thrift::protocol::TType _etype336;
            xfer += iprot->readListBegin(_etype336, _size333);
            this->columns_counter.resize(_size333);
            uint32_t _i337;
            for (_i337 = 0; _i337 < _size333; ++_i337)
            {
              xfer += this->columns_counter[_i337].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns_counter = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->columns_serial.clear();
            uint32_t _size338;
            ::apache::thrift::protocol::TType _etype341;
            xfer += iprot->readListBegin(_etype341, _size338);
            this->columns_serial.resize(_size338);
            uint32_t _i342;
            for (_i342 = 0; _i342 < _size338; ++_i342)
            {
              xfer += this->columns_serial[_i342].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.columns_serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->flags.read(iprot);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SpecScan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SpecScan");

  xfer += oprot->writeFieldBegin("columns_plain", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns_plain.size()));
    std::vector<SpecColumnPlain> ::const_iterator _iter343;
    for (_iter343 = this->columns_plain.begin(); _iter343 != this->columns_plain.end(); ++_iter343)
    {
      xfer += (*_iter343).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns_counter", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns_counter.size()));
    std::vector<SpecColumnCounter> ::const_iterator _iter344;
    for (_iter344 = this->columns_counter.begin(); _iter344 != this->columns_counter.end(); ++_iter344)
    {
      xfer += (*_iter344).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columns_serial", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->columns_serial.size()));
    std::vector<SpecColumnSerial> ::const_iterator _iter345;
    for (_iter345 = this->columns_serial.begin(); _iter345 != this->columns_serial.end(); ++_iter345)
    {
      xfer += (*_iter345).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.flags) {
    xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->flags.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SpecScan &a, SpecScan &b) {
  using ::std::swap;
  swap(a.columns_plain, b.columns_plain);
  swap(a.columns_counter, b.columns_counter);
  swap(a.columns_serial, b.columns_serial);
  swap(a.flags, b.flags);
  swap(a.__isset, b.__isset);
}

SpecScan::SpecScan(const SpecScan& other346) {
  columns_plain = other346.columns_plain;
  columns_counter = other346.columns_counter;
  columns_serial = other346.columns_serial;
  flags = other346.flags;
  __isset = other346.__isset;
}
SpecScan::SpecScan(SpecScan&& other347) noexcept {
  columns_plain = std::move(other347.columns_plain);
  columns_counter = std::move(other347.columns_counter);
  columns_serial = std::move(other347.columns_serial);
  flags = std::move(other347.flags);
  __isset = other347.__isset;
}
SpecScan& SpecScan::operator=(const SpecScan& other348) {
  columns_plain = other348.columns_plain;
  columns_counter = other348.columns_counter;
  columns_serial = other348.columns_serial;
  flags = other348.flags;
  __isset = other348.__isset;
  return *this;
}
SpecScan& SpecScan::operator=(SpecScan&& other349) noexcept {
  columns_plain = std::move(other349.columns_plain);
  columns_counter = std::move(other349.columns_counter);
  columns_serial = std::move(other349.columns_serial);
  flags = std::move(other349.flags);
  __isset = other349.__isset;
  return *this;
}
void SpecScan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SpecScan(";
  out << "columns_plain=" << to_string(columns_plain);
  out << ", " << "columns_counter=" << to_string(columns_counter);
  out << ", " << "columns_serial=" << to_string(columns_serial);
  out << ", " << "flags="; (__isset.flags ? (out << to_string(flags)) : (out << "<null>"));
  out << ")";
}


UCellPlain::~UCellPlain() noexcept {
}


void UCellPlain::__set_f(const Flag::type val) {
  this->f = val;
}

void UCellPlain::__set_k(const Key& val) {
  this->k = val;
}

void UCellPlain::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCellPlain::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCellPlain::__set_v(const std::string& val) {
  this->v = val;
}

void UCellPlain::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCellPlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCellPlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast350;
          xfer += iprot->readI32(ecast350);
          this->f = static_cast<Flag::type>(ecast350);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size351;
            ::apache::thrift::protocol::TType _etype354;
            xfer += iprot->readListBegin(_etype354, _size351);
            this->k.resize(_size351);
            uint32_t _i355;
            for (_i355 = 0; _i355 < _size351; ++_i355)
            {
              xfer += iprot->readBinary(this->k[_i355]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast356;
          xfer += iprot->readI32(ecast356);
          this->encoder = static_cast<EncodingType::type>(ecast356);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCellPlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCellPlain");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter357;
    for (_iter357 = this->k.begin(); _iter357 != this->k.end(); ++_iter357)
    {
      xfer += oprot->writeBinary((*_iter357));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCellPlain &a, UCellPlain &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCellPlain::UCellPlain(const UCellPlain& other358) {
  f = other358.f;
  k = other358.k;
  ts = other358.ts;
  ts_desc = other358.ts_desc;
  v = other358.v;
  encoder = other358.encoder;
  __isset = other358.__isset;
}
UCellPlain::UCellPlain(UCellPlain&& other359) noexcept {
  f = other359.f;
  k = std::move(other359.k);
  ts = other359.ts;
  ts_desc = other359.ts_desc;
  v = std::move(other359.v);
  encoder = other359.encoder;
  __isset = other359.__isset;
}
UCellPlain& UCellPlain::operator=(const UCellPlain& other360) {
  f = other360.f;
  k = other360.k;
  ts = other360.ts;
  ts_desc = other360.ts_desc;
  v = other360.v;
  encoder = other360.encoder;
  __isset = other360.__isset;
  return *this;
}
UCellPlain& UCellPlain::operator=(UCellPlain&& other361) noexcept {
  f = other361.f;
  k = std::move(other361.k);
  ts = other361.ts;
  ts_desc = other361.ts_desc;
  v = std::move(other361.v);
  encoder = other361.encoder;
  __isset = other361.__isset;
  return *this;
}
void UCellPlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCellPlain(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


UCellCounter::~UCellCounter() noexcept {
}


void UCellCounter::__set_f(const Flag::type val) {
  this->f = val;
}

void UCellCounter::__set_k(const Key& val) {
  this->k = val;
}

void UCellCounter::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCellCounter::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCellCounter::__set_op(const int8_t val) {
  this->op = val;
}

void UCellCounter::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const UCellCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCellCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast362;
          xfer += iprot->readI32(ecast362);
          this->f = static_cast<Flag::type>(ecast362);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size363;
            ::apache::thrift::protocol::TType _etype366;
            xfer += iprot->readListBegin(_etype366, _size363);
            this->k.resize(_size363);
            uint32_t _i367;
            for (_i367 = 0; _i367 < _size363; ++_i367)
            {
              xfer += iprot->readBinary(this->k[_i367]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->op);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCellCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCellCounter");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter368;
    for (_iter368 = this->k.begin(); _iter368 != this->k.end(); ++_iter368)
    {
      xfer += oprot->writeBinary((*_iter368));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->op);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 6);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCellCounter &a, UCellCounter &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.op, b.op);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

UCellCounter::UCellCounter(const UCellCounter& other369) {
  f = other369.f;
  k = other369.k;
  ts = other369.ts;
  ts_desc = other369.ts_desc;
  op = other369.op;
  v = other369.v;
  __isset = other369.__isset;
}
UCellCounter::UCellCounter(UCellCounter&& other370) noexcept {
  f = other370.f;
  k = std::move(other370.k);
  ts = other370.ts;
  ts_desc = other370.ts_desc;
  op = other370.op;
  v = other370.v;
  __isset = other370.__isset;
}
UCellCounter& UCellCounter::operator=(const UCellCounter& other371) {
  f = other371.f;
  k = other371.k;
  ts = other371.ts;
  ts_desc = other371.ts_desc;
  op = other371.op;
  v = other371.v;
  __isset = other371.__isset;
  return *this;
}
UCellCounter& UCellCounter::operator=(UCellCounter&& other372) noexcept {
  f = other372.f;
  k = std::move(other372.k);
  ts = other372.ts;
  ts_desc = other372.ts_desc;
  op = other372.op;
  v = other372.v;
  __isset = other372.__isset;
  return *this;
}
void UCellCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCellCounter(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "op=" << to_string(op);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CellValueSerial::~CellValueSerial() noexcept {
}


void CellValueSerial::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void CellValueSerial::__set_v_int64(const int64_t val) {
  this->v_int64 = val;
__isset.v_int64 = true;
}

void CellValueSerial::__set_v_double(const double val) {
  this->v_double = val;
__isset.v_double = true;
}

void CellValueSerial::__set_v_bytes(const std::string& val) {
  this->v_bytes = val;
__isset.v_bytes = true;
}

void CellValueSerial::__set_v_key(const Key& val) {
  this->v_key = val;
__isset.v_key = true;
}

void CellValueSerial::__set_v_li(const std::vector<int64_t> & val) {
  this->v_li = val;
__isset.v_li = true;
}

void CellValueSerial::__set_v_lb(const std::vector<std::string> & val) {
  this->v_lb = val;
__isset.v_lb = true;
}
std::ostream& operator<<(std::ostream& out, const CellValueSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellValueSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v_int64);
          this->__isset.v_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v_double);
          this->__isset.v_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v_bytes);
          this->__isset.v_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_key.clear();
            uint32_t _size373;
            ::apache::thrift::protocol::TType _etype376;
            xfer += iprot->readListBegin(_etype376, _size373);
            this->v_key.resize(_size373);
            uint32_t _i377;
            for (_i377 = 0; _i377 < _size373; ++_i377)
            {
              xfer += iprot->readBinary(this->v_key[_i377]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_li.clear();
            uint32_t _size378;
            ::apache::thrift::protocol::TType _etype381;
            xfer += iprot->readListBegin(_etype381, _size378);
            this->v_li.resize(_size378);
            uint32_t _i382;
            for (_i382 = 0; _i382 < _size378; ++_i382)
            {
              xfer += iprot->readI64(this->v_li[_i382]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_lb.clear();
            uint32_t _size383;
            ::apache::thrift::protocol::TType _etype386;
            xfer += iprot->readListBegin(_etype386, _size383);
            this->v_lb.resize(_size383);
            uint32_t _i387;
            for (_i387 = 0; _i387 < _size383; ++_i387)
            {
              xfer += iprot->readBinary(this->v_lb[_i387]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellValueSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellValueSerial");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v_int64) {
    xfer += oprot->writeFieldBegin("v_int64", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->v_int64);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double) {
    xfer += oprot->writeFieldBegin("v_double", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->v_double);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_bytes) {
    xfer += oprot->writeFieldBegin("v_bytes", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeBinary(this->v_bytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_key) {
    xfer += oprot->writeFieldBegin("v_key", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_key.size()));
      std::vector<std::string> ::const_iterator _iter388;
      for (_iter388 = this->v_key.begin(); _iter388 != this->v_key.end(); ++_iter388)
      {
        xfer += oprot->writeBinary((*_iter388));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_li) {
    xfer += oprot->writeFieldBegin("v_li", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I64, static_cast<uint32_t>(this->v_li.size()));
      std::vector<int64_t> ::const_iterator _iter389;
      for (_iter389 = this->v_li.begin(); _iter389 != this->v_li.end(); ++_iter389)
      {
        xfer += oprot->writeI64((*_iter389));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_lb) {
    xfer += oprot->writeFieldBegin("v_lb", ::apache::thrift::protocol::T_LIST, 7);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_lb.size()));
      std::vector<std::string> ::const_iterator _iter390;
      for (_iter390 = this->v_lb.begin(); _iter390 != this->v_lb.end(); ++_iter390)
      {
        xfer += oprot->writeBinary((*_iter390));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellValueSerial &a, CellValueSerial &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.v_int64, b.v_int64);
  swap(a.v_double, b.v_double);
  swap(a.v_bytes, b.v_bytes);
  swap(a.v_key, b.v_key);
  swap(a.v_li, b.v_li);
  swap(a.v_lb, b.v_lb);
  swap(a.__isset, b.__isset);
}

CellValueSerial::CellValueSerial(const CellValueSerial& other391) {
  field_id = other391.field_id;
  v_int64 = other391.v_int64;
  v_double = other391.v_double;
  v_bytes = other391.v_bytes;
  v_key = other391.v_key;
  v_li = other391.v_li;
  v_lb = other391.v_lb;
  __isset = other391.__isset;
}
CellValueSerial::CellValueSerial(CellValueSerial&& other392) noexcept {
  field_id = other392.field_id;
  v_int64 = other392.v_int64;
  v_double = other392.v_double;
  v_bytes = std::move(other392.v_bytes);
  v_key = std::move(other392.v_key);
  v_li = std::move(other392.v_li);
  v_lb = std::move(other392.v_lb);
  __isset = other392.__isset;
}
CellValueSerial& CellValueSerial::operator=(const CellValueSerial& other393) {
  field_id = other393.field_id;
  v_int64 = other393.v_int64;
  v_double = other393.v_double;
  v_bytes = other393.v_bytes;
  v_key = other393.v_key;
  v_li = other393.v_li;
  v_lb = other393.v_lb;
  __isset = other393.__isset;
  return *this;
}
CellValueSerial& CellValueSerial::operator=(CellValueSerial&& other394) noexcept {
  field_id = other394.field_id;
  v_int64 = other394.v_int64;
  v_double = other394.v_double;
  v_bytes = std::move(other394.v_bytes);
  v_key = std::move(other394.v_key);
  v_li = std::move(other394.v_li);
  v_lb = std::move(other394.v_lb);
  __isset = other394.__isset;
  return *this;
}
void CellValueSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellValueSerial(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "v_int64="; (__isset.v_int64 ? (out << to_string(v_int64)) : (out << "<null>"));
  out << ", " << "v_double="; (__isset.v_double ? (out << to_string(v_double)) : (out << "<null>"));
  out << ", " << "v_bytes="; (__isset.v_bytes ? (out << to_string(v_bytes)) : (out << "<null>"));
  out << ", " << "v_key="; (__isset.v_key ? (out << to_string(v_key)) : (out << "<null>"));
  out << ", " << "v_li="; (__isset.v_li ? (out << to_string(v_li)) : (out << "<null>"));
  out << ", " << "v_lb="; (__isset.v_lb ? (out << to_string(v_lb)) : (out << "<null>"));
  out << ")";
}


FU_INT64::~FU_INT64() noexcept {
}


void FU_INT64::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_INT64::__set_op(const FU_MATH_OP::type val) {
  this->op = val;
}

void FU_INT64::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_INT64::__set_comp(const Comp::type val) {
  this->comp = val;
__isset.comp = true;
}

void FU_INT64::__set_v(const int64_t val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_INT64& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_INT64::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast395;
          xfer += iprot->readI32(ecast395);
          this->op = static_cast<FU_MATH_OP::type>(ecast395);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast396;
          xfer += iprot->readI32(ecast396);
          this->comp = static_cast<Comp::type>(ecast396);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_INT64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_INT64");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comp) {
    xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_INT64 &a, FU_INT64 &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_INT64::FU_INT64(const FU_INT64& other397) noexcept {
  ctrl = other397.ctrl;
  op = other397.op;
  pos = other397.pos;
  comp = other397.comp;
  v = other397.v;
  __isset = other397.__isset;
}
FU_INT64::FU_INT64(FU_INT64&& other398) noexcept {
  ctrl = other398.ctrl;
  op = other398.op;
  pos = other398.pos;
  comp = other398.comp;
  v = other398.v;
  __isset = other398.__isset;
}
FU_INT64& FU_INT64::operator=(const FU_INT64& other399) noexcept {
  ctrl = other399.ctrl;
  op = other399.op;
  pos = other399.pos;
  comp = other399.comp;
  v = other399.v;
  __isset = other399.__isset;
  return *this;
}
FU_INT64& FU_INT64::operator=(FU_INT64&& other400) noexcept {
  ctrl = other400.ctrl;
  op = other400.op;
  pos = other400.pos;
  comp = other400.comp;
  v = other400.v;
  __isset = other400.__isset;
  return *this;
}
void FU_INT64::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_INT64(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "comp="; (__isset.comp ? (out << to_string(comp)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FU_DOUBLE::~FU_DOUBLE() noexcept {
}


void FU_DOUBLE::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_DOUBLE::__set_op(const FU_MATH_OP::type val) {
  this->op = val;
}

void FU_DOUBLE::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_DOUBLE::__set_comp(const Comp::type val) {
  this->comp = val;
__isset.comp = true;
}

void FU_DOUBLE::__set_v(const double val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_DOUBLE& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_DOUBLE::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast401;
          xfer += iprot->readI32(ecast401);
          this->op = static_cast<FU_MATH_OP::type>(ecast401);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast402;
          xfer += iprot->readI32(ecast402);
          this->comp = static_cast<Comp::type>(ecast402);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_DOUBLE::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_DOUBLE");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comp) {
    xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_DOUBLE &a, FU_DOUBLE &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_DOUBLE::FU_DOUBLE(const FU_DOUBLE& other403) noexcept {
  ctrl = other403.ctrl;
  op = other403.op;
  pos = other403.pos;
  comp = other403.comp;
  v = other403.v;
  __isset = other403.__isset;
}
FU_DOUBLE::FU_DOUBLE(FU_DOUBLE&& other404) noexcept {
  ctrl = other404.ctrl;
  op = other404.op;
  pos = other404.pos;
  comp = other404.comp;
  v = other404.v;
  __isset = other404.__isset;
}
FU_DOUBLE& FU_DOUBLE::operator=(const FU_DOUBLE& other405) noexcept {
  ctrl = other405.ctrl;
  op = other405.op;
  pos = other405.pos;
  comp = other405.comp;
  v = other405.v;
  __isset = other405.__isset;
  return *this;
}
FU_DOUBLE& FU_DOUBLE::operator=(FU_DOUBLE&& other406) noexcept {
  ctrl = other406.ctrl;
  op = other406.op;
  pos = other406.pos;
  comp = other406.comp;
  v = other406.v;
  __isset = other406.__isset;
  return *this;
}
void FU_DOUBLE::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_DOUBLE(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "comp="; (__isset.comp ? (out << to_string(comp)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FU_BYTES::~FU_BYTES() noexcept {
}


void FU_BYTES::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_BYTES::__set_op(const FU_LIST_OP::type val) {
  this->op = val;
}

void FU_BYTES::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_BYTES::__set_comp(const Comp::type val) {
  this->comp = val;
__isset.comp = true;
}

void FU_BYTES::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_BYTES& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_BYTES::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast407;
          xfer += iprot->readI32(ecast407);
          this->op = static_cast<FU_LIST_OP::type>(ecast407);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast408;
          xfer += iprot->readI32(ecast408);
          this->comp = static_cast<Comp::type>(ecast408);
          this->__isset.comp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_BYTES::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_BYTES");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comp) {
    xfer += oprot->writeFieldBegin("comp", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(static_cast<int32_t>(this->comp));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_BYTES &a, FU_BYTES &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.comp, b.comp);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_BYTES::FU_BYTES(const FU_BYTES& other409) {
  ctrl = other409.ctrl;
  op = other409.op;
  pos = other409.pos;
  comp = other409.comp;
  v = other409.v;
  __isset = other409.__isset;
}
FU_BYTES::FU_BYTES(FU_BYTES&& other410) noexcept {
  ctrl = other410.ctrl;
  op = other410.op;
  pos = other410.pos;
  comp = other410.comp;
  v = std::move(other410.v);
  __isset = other410.__isset;
}
FU_BYTES& FU_BYTES::operator=(const FU_BYTES& other411) {
  ctrl = other411.ctrl;
  op = other411.op;
  pos = other411.pos;
  comp = other411.comp;
  v = other411.v;
  __isset = other411.__isset;
  return *this;
}
FU_BYTES& FU_BYTES::operator=(FU_BYTES&& other412) noexcept {
  ctrl = other412.ctrl;
  op = other412.op;
  pos = other412.pos;
  comp = other412.comp;
  v = std::move(other412.v);
  __isset = other412.__isset;
  return *this;
}
void FU_BYTES::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_BYTES(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "comp="; (__isset.comp ? (out << to_string(comp)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FU_LI::~FU_LI() noexcept {
}


void FU_LI::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_LI::__set_op(const FU_LIST_OP::type val) {
  this->op = val;
}

void FU_LI::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_LI::__set_v(const std::vector<FU_INT64> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_LI& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_LI::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast413;
          xfer += iprot->readI32(ecast413);
          this->op = static_cast<FU_LIST_OP::type>(ecast413);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size414;
            ::apache::thrift::protocol::TType _etype417;
            xfer += iprot->readListBegin(_etype417, _size414);
            this->v.resize(_size414);
            uint32_t _i418;
            for (_i418 = 0; _i418 < _size414; ++_i418)
            {
              xfer += this->v[_i418].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_LI::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_LI");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<FU_INT64> ::const_iterator _iter419;
    for (_iter419 = this->v.begin(); _iter419 != this->v.end(); ++_iter419)
    {
      xfer += (*_iter419).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_LI &a, FU_LI &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_LI::FU_LI(const FU_LI& other420) {
  ctrl = other420.ctrl;
  op = other420.op;
  pos = other420.pos;
  v = other420.v;
  __isset = other420.__isset;
}
FU_LI::FU_LI(FU_LI&& other421) noexcept {
  ctrl = other421.ctrl;
  op = other421.op;
  pos = other421.pos;
  v = std::move(other421.v);
  __isset = other421.__isset;
}
FU_LI& FU_LI::operator=(const FU_LI& other422) {
  ctrl = other422.ctrl;
  op = other422.op;
  pos = other422.pos;
  v = other422.v;
  __isset = other422.__isset;
  return *this;
}
FU_LI& FU_LI::operator=(FU_LI&& other423) noexcept {
  ctrl = other423.ctrl;
  op = other423.op;
  pos = other423.pos;
  v = std::move(other423.v);
  __isset = other423.__isset;
  return *this;
}
void FU_LI::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_LI(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FU_LB::~FU_LB() noexcept {
}


void FU_LB::__set_ctrl(const int8_t val) {
  this->ctrl = val;
}

void FU_LB::__set_op(const FU_LIST_OP::type val) {
  this->op = val;
}

void FU_LB::__set_pos(const int32_t val) {
  this->pos = val;
__isset.pos = true;
}

void FU_LB::__set_v(const std::vector<FU_BYTES> & val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FU_LB& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FU_LB::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->ctrl);
          this->__isset.ctrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast424;
          xfer += iprot->readI32(ecast424);
          this->op = static_cast<FU_LIST_OP::type>(ecast424);
          this->__isset.op = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pos);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size425;
            ::apache::thrift::protocol::TType _etype428;
            xfer += iprot->readListBegin(_etype428, _size425);
            this->v.resize(_size425);
            uint32_t _i429;
            for (_i429 = 0; _i429 < _size425; ++_i429)
            {
              xfer += this->v[_i429].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FU_LB::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FU_LB");

  xfer += oprot->writeFieldBegin("ctrl", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->ctrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("op", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(static_cast<int32_t>(this->op));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.pos) {
    xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->pos);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<FU_BYTES> ::const_iterator _iter430;
    for (_iter430 = this->v.begin(); _iter430 != this->v.end(); ++_iter430)
    {
      xfer += (*_iter430).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FU_LB &a, FU_LB &b) {
  using ::std::swap;
  swap(a.ctrl, b.ctrl);
  swap(a.op, b.op);
  swap(a.pos, b.pos);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FU_LB::FU_LB(const FU_LB& other431) {
  ctrl = other431.ctrl;
  op = other431.op;
  pos = other431.pos;
  v = other431.v;
  __isset = other431.__isset;
}
FU_LB::FU_LB(FU_LB&& other432) noexcept {
  ctrl = other432.ctrl;
  op = other432.op;
  pos = other432.pos;
  v = std::move(other432.v);
  __isset = other432.__isset;
}
FU_LB& FU_LB::operator=(const FU_LB& other433) {
  ctrl = other433.ctrl;
  op = other433.op;
  pos = other433.pos;
  v = other433.v;
  __isset = other433.__isset;
  return *this;
}
FU_LB& FU_LB::operator=(FU_LB&& other434) noexcept {
  ctrl = other434.ctrl;
  op = other434.op;
  pos = other434.pos;
  v = std::move(other434.v);
  __isset = other434.__isset;
  return *this;
}
void FU_LB::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FU_LB(";
  out << "ctrl=" << to_string(ctrl);
  out << ", " << "op=" << to_string(op);
  out << ", " << "pos="; (__isset.pos ? (out << to_string(pos)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CellValueSerialOp::~CellValueSerialOp() noexcept {
}


void CellValueSerialOp::__set_field_id(const int32_t val) {
  this->field_id = val;
}

void CellValueSerialOp::__set_v_int64(const FU_INT64& val) {
  this->v_int64 = val;
__isset.v_int64 = true;
}

void CellValueSerialOp::__set_v_double(const FU_DOUBLE& val) {
  this->v_double = val;
__isset.v_double = true;
}

void CellValueSerialOp::__set_v_bytes(const FU_BYTES& val) {
  this->v_bytes = val;
__isset.v_bytes = true;
}

void CellValueSerialOp::__set_v_key(const Key& val) {
  this->v_key = val;
__isset.v_key = true;
}

void CellValueSerialOp::__set_v_li(const FU_LI& val) {
  this->v_li = val;
__isset.v_li = true;
}

void CellValueSerialOp::__set_v_lb(const FU_LB& val) {
  this->v_lb = val;
__isset.v_lb = true;
}
std::ostream& operator<<(std::ostream& out, const CellValueSerialOp& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellValueSerialOp::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->field_id);
          this->__isset.field_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_int64.read(iprot);
          this->__isset.v_int64 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_double.read(iprot);
          this->__isset.v_double = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_bytes.read(iprot);
          this->__isset.v_bytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v_key.clear();
            uint32_t _size435;
            ::apache::thrift::protocol::TType _etype438;
            xfer += iprot->readListBegin(_etype438, _size435);
            this->v_key.resize(_size435);
            uint32_t _i439;
            for (_i439 = 0; _i439 < _size435; ++_i439)
            {
              xfer += iprot->readBinary(this->v_key[_i439]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v_key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_li.read(iprot);
          this->__isset.v_li = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->v_lb.read(iprot);
          this->__isset.v_lb = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellValueSerialOp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellValueSerialOp");

  xfer += oprot->writeFieldBegin("field_id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->field_id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.v_int64) {
    xfer += oprot->writeFieldBegin("v_int64", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->v_int64.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_double) {
    xfer += oprot->writeFieldBegin("v_double", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->v_double.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_bytes) {
    xfer += oprot->writeFieldBegin("v_bytes", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->v_bytes.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_key) {
    xfer += oprot->writeFieldBegin("v_key", ::apache::thrift::protocol::T_LIST, 5);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->v_key.size()));
      std::vector<std::string> ::const_iterator _iter440;
      for (_iter440 = this->v_key.begin(); _iter440 != this->v_key.end(); ++_iter440)
      {
        xfer += oprot->writeBinary((*_iter440));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_li) {
    xfer += oprot->writeFieldBegin("v_li", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->v_li.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.v_lb) {
    xfer += oprot->writeFieldBegin("v_lb", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->v_lb.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellValueSerialOp &a, CellValueSerialOp &b) {
  using ::std::swap;
  swap(a.field_id, b.field_id);
  swap(a.v_int64, b.v_int64);
  swap(a.v_double, b.v_double);
  swap(a.v_bytes, b.v_bytes);
  swap(a.v_key, b.v_key);
  swap(a.v_li, b.v_li);
  swap(a.v_lb, b.v_lb);
  swap(a.__isset, b.__isset);
}

CellValueSerialOp::CellValueSerialOp(const CellValueSerialOp& other441) {
  field_id = other441.field_id;
  v_int64 = other441.v_int64;
  v_double = other441.v_double;
  v_bytes = other441.v_bytes;
  v_key = other441.v_key;
  v_li = other441.v_li;
  v_lb = other441.v_lb;
  __isset = other441.__isset;
}
CellValueSerialOp::CellValueSerialOp(CellValueSerialOp&& other442) noexcept {
  field_id = other442.field_id;
  v_int64 = std::move(other442.v_int64);
  v_double = std::move(other442.v_double);
  v_bytes = std::move(other442.v_bytes);
  v_key = std::move(other442.v_key);
  v_li = std::move(other442.v_li);
  v_lb = std::move(other442.v_lb);
  __isset = other442.__isset;
}
CellValueSerialOp& CellValueSerialOp::operator=(const CellValueSerialOp& other443) {
  field_id = other443.field_id;
  v_int64 = other443.v_int64;
  v_double = other443.v_double;
  v_bytes = other443.v_bytes;
  v_key = other443.v_key;
  v_li = other443.v_li;
  v_lb = other443.v_lb;
  __isset = other443.__isset;
  return *this;
}
CellValueSerialOp& CellValueSerialOp::operator=(CellValueSerialOp&& other444) noexcept {
  field_id = other444.field_id;
  v_int64 = std::move(other444.v_int64);
  v_double = std::move(other444.v_double);
  v_bytes = std::move(other444.v_bytes);
  v_key = std::move(other444.v_key);
  v_li = std::move(other444.v_li);
  v_lb = std::move(other444.v_lb);
  __isset = other444.__isset;
  return *this;
}
void CellValueSerialOp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellValueSerialOp(";
  out << "field_id=" << to_string(field_id);
  out << ", " << "v_int64="; (__isset.v_int64 ? (out << to_string(v_int64)) : (out << "<null>"));
  out << ", " << "v_double="; (__isset.v_double ? (out << to_string(v_double)) : (out << "<null>"));
  out << ", " << "v_bytes="; (__isset.v_bytes ? (out << to_string(v_bytes)) : (out << "<null>"));
  out << ", " << "v_key="; (__isset.v_key ? (out << to_string(v_key)) : (out << "<null>"));
  out << ", " << "v_li="; (__isset.v_li ? (out << to_string(v_li)) : (out << "<null>"));
  out << ", " << "v_lb="; (__isset.v_lb ? (out << to_string(v_lb)) : (out << "<null>"));
  out << ")";
}


UCellSerial::~UCellSerial() noexcept {
}


void UCellSerial::__set_f(const Flag::type val) {
  this->f = val;
}

void UCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void UCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
__isset.ts = true;
}

void UCellSerial::__set_ts_desc(const bool val) {
  this->ts_desc = val;
__isset.ts_desc = true;
}

void UCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}

void UCellSerial::__set_encoder(const EncodingType::type val) {
  this->encoder = val;
__isset.encoder = true;
}
std::ostream& operator<<(std::ostream& out, const UCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t UCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast445;
          xfer += iprot->readI32(ecast445);
          this->f = static_cast<Flag::type>(ecast445);
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size446;
            ::apache::thrift::protocol::TType _etype449;
            xfer += iprot->readListBegin(_etype449, _size446);
            this->k.resize(_size446);
            uint32_t _i450;
            for (_i450 = 0; _i450 < _size446; ++_i450)
            {
              xfer += iprot->readBinary(this->k[_i450]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->ts_desc);
          this->__isset.ts_desc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size451;
            ::apache::thrift::protocol::TType _etype454;
            xfer += iprot->readListBegin(_etype454, _size451);
            this->v.resize(_size451);
            uint32_t _i455;
            for (_i455 = 0; _i455 < _size451; ++_i455)
            {
              xfer += this->v[_i455].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast456;
          xfer += iprot->readI32(ecast456);
          this->encoder = static_cast<EncodingType::type>(ecast456);
          this->__isset.encoder = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UCellSerial");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->f));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter457;
    for (_iter457 = this->k.begin(); _iter457 != this->k.end(); ++_iter457)
    {
      xfer += oprot->writeBinary((*_iter457));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ts) {
    xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->ts);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ts_desc) {
    xfer += oprot->writeFieldBegin("ts_desc", ::apache::thrift::protocol::T_BOOL, 4);
    xfer += oprot->writeBool(this->ts_desc);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter458;
    for (_iter458 = this->v.begin(); _iter458 != this->v.end(); ++_iter458)
    {
      xfer += (*_iter458).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.encoder) {
    xfer += oprot->writeFieldBegin("encoder", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(static_cast<int32_t>(this->encoder));
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UCellSerial &a, UCellSerial &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.ts_desc, b.ts_desc);
  swap(a.v, b.v);
  swap(a.encoder, b.encoder);
  swap(a.__isset, b.__isset);
}

UCellSerial::UCellSerial(const UCellSerial& other459) {
  f = other459.f;
  k = other459.k;
  ts = other459.ts;
  ts_desc = other459.ts_desc;
  v = other459.v;
  encoder = other459.encoder;
  __isset = other459.__isset;
}
UCellSerial::UCellSerial(UCellSerial&& other460) noexcept {
  f = other460.f;
  k = std::move(other460.k);
  ts = other460.ts;
  ts_desc = other460.ts_desc;
  v = std::move(other460.v);
  encoder = other460.encoder;
  __isset = other460.__isset;
}
UCellSerial& UCellSerial::operator=(const UCellSerial& other461) {
  f = other461.f;
  k = other461.k;
  ts = other461.ts;
  ts_desc = other461.ts_desc;
  v = other461.v;
  encoder = other461.encoder;
  __isset = other461.__isset;
  return *this;
}
UCellSerial& UCellSerial::operator=(UCellSerial&& other462) noexcept {
  f = other462.f;
  k = std::move(other462.k);
  ts = other462.ts;
  ts_desc = other462.ts_desc;
  v = std::move(other462.v);
  encoder = other462.encoder;
  __isset = other462.__isset;
  return *this;
}
void UCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UCellSerial(";
  out << "f=" << to_string(f);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts="; (__isset.ts ? (out << to_string(ts)) : (out << "<null>"));
  out << ", " << "ts_desc="; (__isset.ts_desc ? (out << to_string(ts_desc)) : (out << "<null>"));
  out << ", " << "v=" << to_string(v);
  out << ", " << "encoder="; (__isset.encoder ? (out << to_string(encoder)) : (out << "<null>"));
  out << ")";
}


CellPlain::~CellPlain() noexcept {
}


void CellPlain::__set_c(const std::string& val) {
  this->c = val;
}

void CellPlain::__set_k(const Key& val) {
  this->k = val;
}

void CellPlain::__set_ts(const int64_t val) {
  this->ts = val;
}

void CellPlain::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CellPlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellPlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _etype466;
            xfer += iprot->readListBegin(_etype466, _size463);
            this->k.resize(_size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              xfer += iprot->readBinary(this->k[_i467]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellPlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellPlain");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter468;
    for (_iter468 = this->k.begin(); _iter468 != this->k.end(); ++_iter468)
    {
      xfer += oprot->writeBinary((*_iter468));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellPlain &a, CellPlain &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CellPlain::CellPlain(const CellPlain& other469) {
  c = other469.c;
  k = other469.k;
  ts = other469.ts;
  v = other469.v;
  __isset = other469.__isset;
}
CellPlain::CellPlain(CellPlain&& other470) noexcept {
  c = std::move(other470.c);
  k = std::move(other470.k);
  ts = other470.ts;
  v = std::move(other470.v);
  __isset = other470.__isset;
}
CellPlain& CellPlain::operator=(const CellPlain& other471) {
  c = other471.c;
  k = other471.k;
  ts = other471.ts;
  v = other471.v;
  __isset = other471.__isset;
  return *this;
}
CellPlain& CellPlain::operator=(CellPlain&& other472) noexcept {
  c = std::move(other472.c);
  k = std::move(other472.k);
  ts = other472.ts;
  v = std::move(other472.v);
  __isset = other472.__isset;
  return *this;
}
void CellPlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellPlain(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CellCounter::~CellCounter() noexcept {
}


void CellCounter::__set_c(const std::string& val) {
  this->c = val;
}

void CellCounter::__set_k(const Key& val) {
  this->k = val;
}

void CellCounter::__set_ts(const int64_t val) {
  this->ts = val;
}

void CellCounter::__set_v(const int64_t val) {
  this->v = val;
}

void CellCounter::__set_eq(const int64_t val) {
  this->eq = val;
__isset.eq = true;
}
std::ostream& operator<<(std::ostream& out, const CellCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size473;
            ::apache::thrift::protocol::TType _etype476;
            xfer += iprot->readListBegin(_etype476, _size473);
            this->k.resize(_size473);
            uint32_t _i477;
            for (_i477 = 0; _i477 < _size473; ++_i477)
            {
              xfer += iprot->readBinary(this->k[_i477]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eq);
          this->__isset.eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellCounter");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter478;
    for (_iter478 = this->k.begin(); _iter478 != this->k.end(); ++_iter478)
    {
      xfer += oprot->writeBinary((*_iter478));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.eq) {
    xfer += oprot->writeFieldBegin("eq", ::apache::thrift::protocol::T_I64, 5);
    xfer += oprot->writeI64(this->eq);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellCounter &a, CellCounter &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.eq, b.eq);
  swap(a.__isset, b.__isset);
}

CellCounter::CellCounter(const CellCounter& other479) {
  c = other479.c;
  k = other479.k;
  ts = other479.ts;
  v = other479.v;
  eq = other479.eq;
  __isset = other479.__isset;
}
CellCounter::CellCounter(CellCounter&& other480) noexcept {
  c = std::move(other480.c);
  k = std::move(other480.k);
  ts = other480.ts;
  v = other480.v;
  eq = other480.eq;
  __isset = other480.__isset;
}
CellCounter& CellCounter::operator=(const CellCounter& other481) {
  c = other481.c;
  k = other481.k;
  ts = other481.ts;
  v = other481.v;
  eq = other481.eq;
  __isset = other481.__isset;
  return *this;
}
CellCounter& CellCounter::operator=(CellCounter&& other482) noexcept {
  c = std::move(other482.c);
  k = std::move(other482.k);
  ts = other482.ts;
  v = other482.v;
  eq = other482.eq;
  __isset = other482.__isset;
  return *this;
}
void CellCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellCounter(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ", " << "eq="; (__isset.eq ? (out << to_string(eq)) : (out << "<null>"));
  out << ")";
}


CellSerial::~CellSerial() noexcept {
}


void CellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void CellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size483;
            ::apache::thrift::protocol::TType _etype486;
            xfer += iprot->readListBegin(_etype486, _size483);
            this->k.resize(_size483);
            uint32_t _i487;
            for (_i487 = 0; _i487 < _size483; ++_i487)
            {
              xfer += iprot->readBinary(this->k[_i487]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size488;
            ::apache::thrift::protocol::TType _etype491;
            xfer += iprot->readListBegin(_etype491, _size488);
            this->v.resize(_size488);
            uint32_t _i492;
            for (_i492 = 0; _i492 < _size488; ++_i492)
            {
              xfer += this->v[_i492].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter493;
    for (_iter493 = this->k.begin(); _iter493 != this->k.end(); ++_iter493)
    {
      xfer += oprot->writeBinary((*_iter493));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter494;
    for (_iter494 = this->v.begin(); _iter494 != this->v.end(); ++_iter494)
    {
      xfer += (*_iter494).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellSerial &a, CellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CellSerial::CellSerial(const CellSerial& other495) {
  c = other495.c;
  k = other495.k;
  ts = other495.ts;
  v = other495.v;
  __isset = other495.__isset;
}
CellSerial::CellSerial(CellSerial&& other496) noexcept {
  c = std::move(other496.c);
  k = std::move(other496.k);
  ts = other496.ts;
  v = std::move(other496.v);
  __isset = other496.__isset;
}
CellSerial& CellSerial::operator=(const CellSerial& other497) {
  c = other497.c;
  k = other497.k;
  ts = other497.ts;
  v = other497.v;
  __isset = other497.__isset;
  return *this;
}
CellSerial& CellSerial::operator=(CellSerial&& other498) noexcept {
  c = std::move(other498.c);
  k = std::move(other498.k);
  ts = other498.ts;
  v = std::move(other498.v);
  __isset = other498.__isset;
  return *this;
}
void CellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


Cells::~Cells() noexcept {
}


void Cells::__set_plain_cells(const CellsPlain& val) {
  this->plain_cells = val;
}

void Cells::__set_counter_cells(const CellsCounter& val) {
  this->counter_cells = val;
}

void Cells::__set_serial_cells(const CellsSerial& val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const Cells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Cells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->plain_cells.clear();
            uint32_t _size499;
            ::apache::thrift::protocol::TType _etype502;
            xfer += iprot->readListBegin(_etype502, _size499);
            this->plain_cells.resize(_size499);
            uint32_t _i503;
            for (_i503 = 0; _i503 < _size499; ++_i503)
            {
              xfer += this->plain_cells[_i503].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.plain_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_cells.clear();
            uint32_t _size504;
            ::apache::thrift::protocol::TType _etype507;
            xfer += iprot->readListBegin(_etype507, _size504);
            this->counter_cells.resize(_size504);
            uint32_t _i508;
            for (_i508 = 0; _i508 < _size504; ++_i508)
            {
              xfer += this->counter_cells[_i508].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size509;
            ::apache::thrift::protocol::TType _etype512;
            xfer += iprot->readListBegin(_etype512, _size509);
            this->serial_cells.resize(_size509);
            uint32_t _i513;
            for (_i513 = 0; _i513 < _size509; ++_i513)
            {
              xfer += this->serial_cells[_i513].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Cells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Cells");

  xfer += oprot->writeFieldBegin("plain_cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->plain_cells.size()));
    std::vector<CellPlain> ::const_iterator _iter514;
    for (_iter514 = this->plain_cells.begin(); _iter514 != this->plain_cells.end(); ++_iter514)
    {
      xfer += (*_iter514).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->counter_cells.size()));
    std::vector<CellCounter> ::const_iterator _iter515;
    for (_iter515 = this->counter_cells.begin(); _iter515 != this->counter_cells.end(); ++_iter515)
    {
      xfer += (*_iter515).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CellSerial> ::const_iterator _iter516;
    for (_iter516 = this->serial_cells.begin(); _iter516 != this->serial_cells.end(); ++_iter516)
    {
      xfer += (*_iter516).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Cells &a, Cells &b) {
  using ::std::swap;
  swap(a.plain_cells, b.plain_cells);
  swap(a.counter_cells, b.counter_cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

Cells::Cells(const Cells& other517) {
  plain_cells = other517.plain_cells;
  counter_cells = other517.counter_cells;
  serial_cells = other517.serial_cells;
  __isset = other517.__isset;
}
Cells::Cells(Cells&& other518) noexcept {
  plain_cells = std::move(other518.plain_cells);
  counter_cells = std::move(other518.counter_cells);
  serial_cells = std::move(other518.serial_cells);
  __isset = other518.__isset;
}
Cells& Cells::operator=(const Cells& other519) {
  plain_cells = other519.plain_cells;
  counter_cells = other519.counter_cells;
  serial_cells = other519.serial_cells;
  __isset = other519.__isset;
  return *this;
}
Cells& Cells::operator=(Cells&& other520) noexcept {
  plain_cells = std::move(other520.plain_cells);
  counter_cells = std::move(other520.counter_cells);
  serial_cells = std::move(other520.serial_cells);
  __isset = other520.__isset;
  return *this;
}
void Cells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Cells(";
  out << "plain_cells=" << to_string(plain_cells);
  out << ", " << "counter_cells=" << to_string(counter_cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CCellPlain::~CCellPlain() noexcept {
}


void CCellPlain::__set_k(const Key& val) {
  this->k = val;
}

void CCellPlain::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCellPlain::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCellPlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCellPlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size521;
            ::apache::thrift::protocol::TType _etype524;
            xfer += iprot->readListBegin(_etype524, _size521);
            this->k.resize(_size521);
            uint32_t _i525;
            for (_i525 = 0; _i525 < _size521; ++_i525)
            {
              xfer += iprot->readBinary(this->k[_i525]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCellPlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCellPlain");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter526;
    for (_iter526 = this->k.begin(); _iter526 != this->k.end(); ++_iter526)
    {
      xfer += oprot->writeBinary((*_iter526));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCellPlain &a, CCellPlain &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCellPlain::CCellPlain(const CCellPlain& other527) {
  k = other527.k;
  ts = other527.ts;
  v = other527.v;
  __isset = other527.__isset;
}
CCellPlain::CCellPlain(CCellPlain&& other528) noexcept {
  k = std::move(other528.k);
  ts = other528.ts;
  v = std::move(other528.v);
  __isset = other528.__isset;
}
CCellPlain& CCellPlain::operator=(const CCellPlain& other529) {
  k = other529.k;
  ts = other529.ts;
  v = other529.v;
  __isset = other529.__isset;
  return *this;
}
CCellPlain& CCellPlain::operator=(CCellPlain&& other530) noexcept {
  k = std::move(other530.k);
  ts = other530.ts;
  v = std::move(other530.v);
  __isset = other530.__isset;
  return *this;
}
void CCellPlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCellPlain(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


CCellCounter::~CCellCounter() noexcept {
}


void CCellCounter::__set_k(const Key& val) {
  this->k = val;
}

void CCellCounter::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCellCounter::__set_v(const int64_t val) {
  this->v = val;
}

void CCellCounter::__set_eq(const int64_t val) {
  this->eq = val;
__isset.eq = true;
}
std::ostream& operator<<(std::ostream& out, const CCellCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCellCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size531;
            ::apache::thrift::protocol::TType _etype534;
            xfer += iprot->readListBegin(_etype534, _size531);
            this->k.resize(_size531);
            uint32_t _i535;
            for (_i535 = 0; _i535 < _size531; ++_i535)
            {
              xfer += iprot->readBinary(this->k[_i535]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eq);
          this->__isset.eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCellCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCellCounter");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter536;
    for (_iter536 = this->k.begin(); _iter536 != this->k.end(); ++_iter536)
    {
      xfer += oprot->writeBinary((*_iter536));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.eq) {
    xfer += oprot->writeFieldBegin("eq", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->eq);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCellCounter &a, CCellCounter &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.eq, b.eq);
  swap(a.__isset, b.__isset);
}

CCellCounter::CCellCounter(const CCellCounter& other537) {
  k = other537.k;
  ts = other537.ts;
  v = other537.v;
  eq = other537.eq;
  __isset = other537.__isset;
}
CCellCounter::CCellCounter(CCellCounter&& other538) noexcept {
  k = std::move(other538.k);
  ts = other538.ts;
  v = other538.v;
  eq = other538.eq;
  __isset = other538.__isset;
}
CCellCounter& CCellCounter::operator=(const CCellCounter& other539) {
  k = other539.k;
  ts = other539.ts;
  v = other539.v;
  eq = other539.eq;
  __isset = other539.__isset;
  return *this;
}
CCellCounter& CCellCounter::operator=(CCellCounter&& other540) noexcept {
  k = std::move(other540.k);
  ts = other540.ts;
  v = other540.v;
  eq = other540.eq;
  __isset = other540.__isset;
  return *this;
}
void CCellCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCellCounter(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ", " << "eq="; (__isset.eq ? (out << to_string(eq)) : (out << "<null>"));
  out << ")";
}


CCellSerial::~CCellSerial() noexcept {
}


void CCellSerial::__set_k(const Key& val) {
  this->k = val;
}

void CCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void CCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const CCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size541;
            ::apache::thrift::protocol::TType _etype544;
            xfer += iprot->readListBegin(_etype544, _size541);
            this->k.resize(_size541);
            uint32_t _i545;
            for (_i545 = 0; _i545 < _size541; ++_i545)
            {
              xfer += iprot->readBinary(this->k[_i545]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size546;
            ::apache::thrift::protocol::TType _etype549;
            xfer += iprot->readListBegin(_etype549, _size546);
            this->v.resize(_size546);
            uint32_t _i550;
            for (_i550 = 0; _i550 < _size546; ++_i550)
            {
              xfer += this->v[_i550].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CCellSerial");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter551;
    for (_iter551 = this->k.begin(); _iter551 != this->k.end(); ++_iter551)
    {
      xfer += oprot->writeBinary((*_iter551));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter552;
    for (_iter552 = this->v.begin(); _iter552 != this->v.end(); ++_iter552)
    {
      xfer += (*_iter552).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CCellSerial &a, CCellSerial &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

CCellSerial::CCellSerial(const CCellSerial& other553) {
  k = other553.k;
  ts = other553.ts;
  v = other553.v;
  __isset = other553.__isset;
}
CCellSerial::CCellSerial(CCellSerial&& other554) noexcept {
  k = std::move(other554.k);
  ts = other554.ts;
  v = std::move(other554.v);
  __isset = other554.__isset;
}
CCellSerial& CCellSerial::operator=(const CCellSerial& other555) {
  k = other555.k;
  ts = other555.ts;
  v = other555.v;
  __isset = other555.__isset;
  return *this;
}
CCellSerial& CCellSerial::operator=(CCellSerial&& other556) noexcept {
  k = std::move(other556.k);
  ts = other556.ts;
  v = std::move(other556.v);
  __isset = other556.__isset;
  return *this;
}
void CCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CCellSerial(";
  out << "k=" << to_string(k);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


cCells::~cCells() noexcept {
}


void cCells::__set_plain_cells(const std::vector<CCellPlain> & val) {
  this->plain_cells = val;
}

void cCells::__set_counter_cells(const std::vector<CCellCounter> & val) {
  this->counter_cells = val;
}

void cCells::__set_serial_cells(const std::vector<CCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const cCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t cCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->plain_cells.clear();
            uint32_t _size557;
            ::apache::thrift::protocol::TType _etype560;
            xfer += iprot->readListBegin(_etype560, _size557);
            this->plain_cells.resize(_size557);
            uint32_t _i561;
            for (_i561 = 0; _i561 < _size557; ++_i561)
            {
              xfer += this->plain_cells[_i561].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.plain_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_cells.clear();
            uint32_t _size562;
            ::apache::thrift::protocol::TType _etype565;
            xfer += iprot->readListBegin(_etype565, _size562);
            this->counter_cells.resize(_size562);
            uint32_t _i566;
            for (_i566 = 0; _i566 < _size562; ++_i566)
            {
              xfer += this->counter_cells[_i566].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size567;
            ::apache::thrift::protocol::TType _etype570;
            xfer += iprot->readListBegin(_etype570, _size567);
            this->serial_cells.resize(_size567);
            uint32_t _i571;
            for (_i571 = 0; _i571 < _size567; ++_i571)
            {
              xfer += this->serial_cells[_i571].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t cCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("cCells");

  xfer += oprot->writeFieldBegin("plain_cells", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->plain_cells.size()));
    std::vector<CCellPlain> ::const_iterator _iter572;
    for (_iter572 = this->plain_cells.begin(); _iter572 != this->plain_cells.end(); ++_iter572)
    {
      xfer += (*_iter572).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->counter_cells.size()));
    std::vector<CCellCounter> ::const_iterator _iter573;
    for (_iter573 = this->counter_cells.begin(); _iter573 != this->counter_cells.end(); ++_iter573)
    {
      xfer += (*_iter573).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<CCellSerial> ::const_iterator _iter574;
    for (_iter574 = this->serial_cells.begin(); _iter574 != this->serial_cells.end(); ++_iter574)
    {
      xfer += (*_iter574).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(cCells &a, cCells &b) {
  using ::std::swap;
  swap(a.plain_cells, b.plain_cells);
  swap(a.counter_cells, b.counter_cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

cCells::cCells(const cCells& other575) {
  plain_cells = other575.plain_cells;
  counter_cells = other575.counter_cells;
  serial_cells = other575.serial_cells;
  __isset = other575.__isset;
}
cCells::cCells(cCells&& other576) noexcept {
  plain_cells = std::move(other576.plain_cells);
  counter_cells = std::move(other576.counter_cells);
  serial_cells = std::move(other576.serial_cells);
  __isset = other576.__isset;
}
cCells& cCells::operator=(const cCells& other577) {
  plain_cells = other577.plain_cells;
  counter_cells = other577.counter_cells;
  serial_cells = other577.serial_cells;
  __isset = other577.__isset;
  return *this;
}
cCells& cCells::operator=(cCells&& other578) noexcept {
  plain_cells = std::move(other578.plain_cells);
  counter_cells = std::move(other578.counter_cells);
  serial_cells = std::move(other578.serial_cells);
  __isset = other578.__isset;
  return *this;
}
void cCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "cCells(";
  out << "plain_cells=" << to_string(plain_cells);
  out << ", " << "counter_cells=" << to_string(counter_cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


KCellPlain::~KCellPlain() noexcept {
}


void KCellPlain::__set_c(const std::string& val) {
  this->c = val;
}

void KCellPlain::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCellPlain::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCellPlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCellPlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCellPlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCellPlain");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCellPlain &a, KCellPlain &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCellPlain::KCellPlain(const KCellPlain& other579) {
  c = other579.c;
  ts = other579.ts;
  v = other579.v;
  __isset = other579.__isset;
}
KCellPlain::KCellPlain(KCellPlain&& other580) noexcept {
  c = std::move(other580.c);
  ts = other580.ts;
  v = std::move(other580.v);
  __isset = other580.__isset;
}
KCellPlain& KCellPlain::operator=(const KCellPlain& other581) {
  c = other581.c;
  ts = other581.ts;
  v = other581.v;
  __isset = other581.__isset;
  return *this;
}
KCellPlain& KCellPlain::operator=(KCellPlain&& other582) noexcept {
  c = std::move(other582.c);
  ts = other582.ts;
  v = std::move(other582.v);
  __isset = other582.__isset;
  return *this;
}
void KCellPlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCellPlain(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


KCellCounter::~KCellCounter() noexcept {
}


void KCellCounter::__set_c(const std::string& val) {
  this->c = val;
}

void KCellCounter::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCellCounter::__set_v(const int64_t val) {
  this->v = val;
}

void KCellCounter::__set_eq(const int64_t val) {
  this->eq = val;
__isset.eq = true;
}
std::ostream& operator<<(std::ostream& out, const KCellCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCellCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eq);
          this->__isset.eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCellCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCellCounter");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.eq) {
    xfer += oprot->writeFieldBegin("eq", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->eq);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCellCounter &a, KCellCounter &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.eq, b.eq);
  swap(a.__isset, b.__isset);
}

KCellCounter::KCellCounter(const KCellCounter& other583) {
  c = other583.c;
  ts = other583.ts;
  v = other583.v;
  eq = other583.eq;
  __isset = other583.__isset;
}
KCellCounter::KCellCounter(KCellCounter&& other584) noexcept {
  c = std::move(other584.c);
  ts = other584.ts;
  v = other584.v;
  eq = other584.eq;
  __isset = other584.__isset;
}
KCellCounter& KCellCounter::operator=(const KCellCounter& other585) {
  c = other585.c;
  ts = other585.ts;
  v = other585.v;
  eq = other585.eq;
  __isset = other585.__isset;
  return *this;
}
KCellCounter& KCellCounter::operator=(KCellCounter&& other586) noexcept {
  c = std::move(other586.c);
  ts = other586.ts;
  v = other586.v;
  eq = other586.eq;
  __isset = other586.__isset;
  return *this;
}
void KCellCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCellCounter(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ", " << "eq="; (__isset.eq ? (out << to_string(eq)) : (out << "<null>"));
  out << ")";
}


KCellSerial::~KCellSerial() noexcept {
}


void KCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void KCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void KCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const KCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t KCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size587;
            ::apache::thrift::protocol::TType _etype590;
            xfer += iprot->readListBegin(_etype590, _size587);
            this->v.resize(_size587);
            uint32_t _i591;
            for (_i591 = 0; _i591 < _size587; ++_i591)
            {
              xfer += this->v[_i591].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t KCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("KCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter592;
    for (_iter592 = this->v.begin(); _iter592 != this->v.end(); ++_iter592)
    {
      xfer += (*_iter592).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(KCellSerial &a, KCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

KCellSerial::KCellSerial(const KCellSerial& other593) {
  c = other593.c;
  ts = other593.ts;
  v = other593.v;
  __isset = other593.__isset;
}
KCellSerial::KCellSerial(KCellSerial&& other594) noexcept {
  c = std::move(other594.c);
  ts = other594.ts;
  v = std::move(other594.v);
  __isset = other594.__isset;
}
KCellSerial& KCellSerial::operator=(const KCellSerial& other595) {
  c = other595.c;
  ts = other595.ts;
  v = other595.v;
  __isset = other595.__isset;
  return *this;
}
KCellSerial& KCellSerial::operator=(KCellSerial&& other596) noexcept {
  c = std::move(other596.c);
  ts = other596.ts;
  v = std::move(other596.v);
  __isset = other596.__isset;
  return *this;
}
void KCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "KCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


kCells::~kCells() noexcept {
}


void kCells::__set_k(const Key& val) {
  this->k = val;
}

void kCells::__set_plain_cells(const std::vector<KCellPlain> & val) {
  this->plain_cells = val;
}

void kCells::__set_counter_cells(const std::vector<KCellCounter> & val) {
  this->counter_cells = val;
}

void kCells::__set_serial_cells(const std::vector<KCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const kCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t kCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->k.clear();
            uint32_t _size597;
            ::apache::thrift::protocol::TType _etype600;
            xfer += iprot->readListBegin(_etype600, _size597);
            this->k.resize(_size597);
            uint32_t _i601;
            for (_i601 = 0; _i601 < _size597; ++_i601)
            {
              xfer += iprot->readBinary(this->k[_i601]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.k = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->plain_cells.clear();
            uint32_t _size602;
            ::apache::thrift::protocol::TType _etype605;
            xfer += iprot->readListBegin(_etype605, _size602);
            this->plain_cells.resize(_size602);
            uint32_t _i606;
            for (_i606 = 0; _i606 < _size602; ++_i606)
            {
              xfer += this->plain_cells[_i606].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.plain_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_cells.clear();
            uint32_t _size607;
            ::apache::thrift::protocol::TType _etype610;
            xfer += iprot->readListBegin(_etype610, _size607);
            this->counter_cells.resize(_size607);
            uint32_t _i611;
            for (_i611 = 0; _i611 < _size607; ++_i611)
            {
              xfer += this->counter_cells[_i611].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size612;
            ::apache::thrift::protocol::TType _etype615;
            xfer += iprot->readListBegin(_etype615, _size612);
            this->serial_cells.resize(_size612);
            uint32_t _i616;
            for (_i616 = 0; _i616 < _size612; ++_i616)
            {
              xfer += this->serial_cells[_i616].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t kCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("kCells");

  xfer += oprot->writeFieldBegin("k", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->k.size()));
    std::vector<std::string> ::const_iterator _iter617;
    for (_iter617 = this->k.begin(); _iter617 != this->k.end(); ++_iter617)
    {
      xfer += oprot->writeBinary((*_iter617));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("plain_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->plain_cells.size()));
    std::vector<KCellPlain> ::const_iterator _iter618;
    for (_iter618 = this->plain_cells.begin(); _iter618 != this->plain_cells.end(); ++_iter618)
    {
      xfer += (*_iter618).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->counter_cells.size()));
    std::vector<KCellCounter> ::const_iterator _iter619;
    for (_iter619 = this->counter_cells.begin(); _iter619 != this->counter_cells.end(); ++_iter619)
    {
      xfer += (*_iter619).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<KCellSerial> ::const_iterator _iter620;
    for (_iter620 = this->serial_cells.begin(); _iter620 != this->serial_cells.end(); ++_iter620)
    {
      xfer += (*_iter620).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(kCells &a, kCells &b) {
  using ::std::swap;
  swap(a.k, b.k);
  swap(a.plain_cells, b.plain_cells);
  swap(a.counter_cells, b.counter_cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

kCells::kCells(const kCells& other621) {
  k = other621.k;
  plain_cells = other621.plain_cells;
  counter_cells = other621.counter_cells;
  serial_cells = other621.serial_cells;
  __isset = other621.__isset;
}
kCells::kCells(kCells&& other622) noexcept {
  k = std::move(other622.k);
  plain_cells = std::move(other622.plain_cells);
  counter_cells = std::move(other622.counter_cells);
  serial_cells = std::move(other622.serial_cells);
  __isset = other622.__isset;
}
kCells& kCells::operator=(const kCells& other623) {
  k = other623.k;
  plain_cells = other623.plain_cells;
  counter_cells = other623.counter_cells;
  serial_cells = other623.serial_cells;
  __isset = other623.__isset;
  return *this;
}
kCells& kCells::operator=(kCells&& other624) noexcept {
  k = std::move(other624.k);
  plain_cells = std::move(other624.plain_cells);
  counter_cells = std::move(other624.counter_cells);
  serial_cells = std::move(other624.serial_cells);
  __isset = other624.__isset;
  return *this;
}
void kCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "kCells(";
  out << "k=" << to_string(k);
  out << ", " << "plain_cells=" << to_string(plain_cells);
  out << ", " << "counter_cells=" << to_string(counter_cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


FCellPlain::~FCellPlain() noexcept {
}


void FCellPlain::__set_c(const std::string& val) {
  this->c = val;
}

void FCellPlain::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCellPlain::__set_v(const std::string& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCellPlain& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCellPlain::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCellPlain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCellPlain");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeBinary(this->v);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCellPlain &a, FCellPlain &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCellPlain::FCellPlain(const FCellPlain& other625) {
  c = other625.c;
  ts = other625.ts;
  v = other625.v;
  __isset = other625.__isset;
}
FCellPlain::FCellPlain(FCellPlain&& other626) noexcept {
  c = std::move(other626.c);
  ts = other626.ts;
  v = std::move(other626.v);
  __isset = other626.__isset;
}
FCellPlain& FCellPlain::operator=(const FCellPlain& other627) {
  c = other627.c;
  ts = other627.ts;
  v = other627.v;
  __isset = other627.__isset;
  return *this;
}
FCellPlain& FCellPlain::operator=(FCellPlain&& other628) noexcept {
  c = std::move(other628.c);
  ts = other628.ts;
  v = std::move(other628.v);
  __isset = other628.__isset;
  return *this;
}
void FCellPlain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCellPlain(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCellCounter::~FCellCounter() noexcept {
}


void FCellCounter::__set_c(const std::string& val) {
  this->c = val;
}

void FCellCounter::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCellCounter::__set_v(const int64_t val) {
  this->v = val;
}

void FCellCounter::__set_eq(const int64_t val) {
  this->eq = val;
__isset.eq = true;
}
std::ostream& operator<<(std::ostream& out, const FCellCounter& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCellCounter::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->v);
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->eq);
          this->__isset.eq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCellCounter::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCellCounter");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->v);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.eq) {
    xfer += oprot->writeFieldBegin("eq", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->eq);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCellCounter &a, FCellCounter &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.eq, b.eq);
  swap(a.__isset, b.__isset);
}

FCellCounter::FCellCounter(const FCellCounter& other629) {
  c = other629.c;
  ts = other629.ts;
  v = other629.v;
  eq = other629.eq;
  __isset = other629.__isset;
}
FCellCounter::FCellCounter(FCellCounter&& other630) noexcept {
  c = std::move(other630.c);
  ts = other630.ts;
  v = other630.v;
  eq = other630.eq;
  __isset = other630.__isset;
}
FCellCounter& FCellCounter::operator=(const FCellCounter& other631) {
  c = other631.c;
  ts = other631.ts;
  v = other631.v;
  eq = other631.eq;
  __isset = other631.__isset;
  return *this;
}
FCellCounter& FCellCounter::operator=(FCellCounter&& other632) noexcept {
  c = std::move(other632.c);
  ts = other632.ts;
  v = other632.v;
  eq = other632.eq;
  __isset = other632.__isset;
  return *this;
}
void FCellCounter::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCellCounter(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ", " << "eq="; (__isset.eq ? (out << to_string(eq)) : (out << "<null>"));
  out << ")";
}


FCellSerial::~FCellSerial() noexcept {
}


void FCellSerial::__set_c(const std::string& val) {
  this->c = val;
}

void FCellSerial::__set_ts(const int64_t val) {
  this->ts = val;
}

void FCellSerial::__set_v(const CellValuesSerial& val) {
  this->v = val;
}
std::ostream& operator<<(std::ostream& out, const FCellSerial& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCellSerial::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->c);
          this->__isset.c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->ts);
          this->__isset.ts = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->v.clear();
            uint32_t _size633;
            ::apache::thrift::protocol::TType _etype636;
            xfer += iprot->readListBegin(_etype636, _size633);
            this->v.resize(_size633);
            uint32_t _i637;
            for (_i637 = 0; _i637 < _size633; ++_i637)
            {
              xfer += this->v[_i637].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.v = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCellSerial::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCellSerial");

  xfer += oprot->writeFieldBegin("c", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ts", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->ts);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("v", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->v.size()));
    std::vector<CellValueSerial> ::const_iterator _iter638;
    for (_iter638 = this->v.begin(); _iter638 != this->v.end(); ++_iter638)
    {
      xfer += (*_iter638).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCellSerial &a, FCellSerial &b) {
  using ::std::swap;
  swap(a.c, b.c);
  swap(a.ts, b.ts);
  swap(a.v, b.v);
  swap(a.__isset, b.__isset);
}

FCellSerial::FCellSerial(const FCellSerial& other639) {
  c = other639.c;
  ts = other639.ts;
  v = other639.v;
  __isset = other639.__isset;
}
FCellSerial::FCellSerial(FCellSerial&& other640) noexcept {
  c = std::move(other640.c);
  ts = other640.ts;
  v = std::move(other640.v);
  __isset = other640.__isset;
}
FCellSerial& FCellSerial::operator=(const FCellSerial& other641) {
  c = other641.c;
  ts = other641.ts;
  v = other641.v;
  __isset = other641.__isset;
  return *this;
}
FCellSerial& FCellSerial::operator=(FCellSerial&& other642) noexcept {
  c = std::move(other642.c);
  ts = other642.ts;
  v = std::move(other642.v);
  __isset = other642.__isset;
  return *this;
}
void FCellSerial::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCellSerial(";
  out << "c=" << to_string(c);
  out << ", " << "ts=" << to_string(ts);
  out << ", " << "v=" << to_string(v);
  out << ")";
}


FCells::~FCells() noexcept {
}


void FCells::__set_f(const std::map<std::string, FCells> & val) {
  this->f = val;
}

void FCells::__set_plain_cells(const std::vector<FCellPlain> & val) {
  this->plain_cells = val;
}

void FCells::__set_counter_cells(const std::vector<FCellCounter> & val) {
  this->counter_cells = val;
}

void FCells::__set_serial_cells(const std::vector<FCellSerial> & val) {
  this->serial_cells = val;
}
std::ostream& operator<<(std::ostream& out, const FCells& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t FCells::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->f.clear();
            uint32_t _size643;
            ::apache::thrift::protocol::TType _ktype644;
            ::apache::thrift::protocol::TType _vtype645;
            xfer += iprot->readMapBegin(_ktype644, _vtype645, _size643);
            uint32_t _i647;
            for (_i647 = 0; _i647 < _size643; ++_i647)
            {
              std::string _key648;
              xfer += iprot->readBinary(_key648);
              FCells& _val649 = this->f[_key648];
              xfer += _val649.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.f = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->plain_cells.clear();
            uint32_t _size650;
            ::apache::thrift::protocol::TType _etype653;
            xfer += iprot->readListBegin(_etype653, _size650);
            this->plain_cells.resize(_size650);
            uint32_t _i654;
            for (_i654 = 0; _i654 < _size650; ++_i654)
            {
              xfer += this->plain_cells[_i654].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.plain_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->counter_cells.clear();
            uint32_t _size655;
            ::apache::thrift::protocol::TType _etype658;
            xfer += iprot->readListBegin(_etype658, _size655);
            this->counter_cells.resize(_size655);
            uint32_t _i659;
            for (_i659 = 0; _i659 < _size655; ++_i659)
            {
              xfer += this->counter_cells[_i659].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.counter_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->serial_cells.clear();
            uint32_t _size660;
            ::apache::thrift::protocol::TType _etype663;
            xfer += iprot->readListBegin(_etype663, _size660);
            this->serial_cells.resize(_size660);
            uint32_t _i664;
            for (_i664 = 0; _i664 < _size660; ++_i664)
            {
              xfer += this->serial_cells[_i664].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.serial_cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FCells::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FCells");

  xfer += oprot->writeFieldBegin("f", ::apache::thrift::protocol::T_MAP, 1);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->f.size()));
    std::map<std::string, FCells> ::const_iterator _iter665;
    for (_iter665 = this->f.begin(); _iter665 != this->f.end(); ++_iter665)
    {
      xfer += oprot->writeBinary(_iter665->first);
      xfer += _iter665->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("plain_cells", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->plain_cells.size()));
    std::vector<FCellPlain> ::const_iterator _iter666;
    for (_iter666 = this->plain_cells.begin(); _iter666 != this->plain_cells.end(); ++_iter666)
    {
      xfer += (*_iter666).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("counter_cells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->counter_cells.size()));
    std::vector<FCellCounter> ::const_iterator _iter667;
    for (_iter667 = this->counter_cells.begin(); _iter667 != this->counter_cells.end(); ++_iter667)
    {
      xfer += (*_iter667).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serial_cells", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->serial_cells.size()));
    std::vector<FCellSerial> ::const_iterator _iter668;
    for (_iter668 = this->serial_cells.begin(); _iter668 != this->serial_cells.end(); ++_iter668)
    {
      xfer += (*_iter668).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FCells &a, FCells &b) {
  using ::std::swap;
  swap(a.f, b.f);
  swap(a.plain_cells, b.plain_cells);
  swap(a.counter_cells, b.counter_cells);
  swap(a.serial_cells, b.serial_cells);
  swap(a.__isset, b.__isset);
}

FCells::FCells(const FCells& other669) {
  f = other669.f;
  plain_cells = other669.plain_cells;
  counter_cells = other669.counter_cells;
  serial_cells = other669.serial_cells;
  __isset = other669.__isset;
}
FCells::FCells(FCells&& other670) noexcept {
  f = std::move(other670.f);
  plain_cells = std::move(other670.plain_cells);
  counter_cells = std::move(other670.counter_cells);
  serial_cells = std::move(other670.serial_cells);
  __isset = other670.__isset;
}
FCells& FCells::operator=(const FCells& other671) {
  f = other671.f;
  plain_cells = other671.plain_cells;
  counter_cells = other671.counter_cells;
  serial_cells = other671.serial_cells;
  __isset = other671.__isset;
  return *this;
}
FCells& FCells::operator=(FCells&& other672) noexcept {
  f = std::move(other672.f);
  plain_cells = std::move(other672.plain_cells);
  counter_cells = std::move(other672.counter_cells);
  serial_cells = std::move(other672.serial_cells);
  __isset = other672.__isset;
  return *this;
}
void FCells::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FCells(";
  out << "f=" << to_string(f);
  out << ", " << "plain_cells=" << to_string(plain_cells);
  out << ", " << "counter_cells=" << to_string(counter_cells);
  out << ", " << "serial_cells=" << to_string(serial_cells);
  out << ")";
}


CellsGroup::~CellsGroup() noexcept {
}


void CellsGroup::__set_cells(const Cells& val) {
  this->cells = val;
}

void CellsGroup::__set_ccells(const CCells& val) {
  this->ccells = val;
}

void CellsGroup::__set_kcells(const KCells& val) {
  this->kcells = val;
}

void CellsGroup::__set_fcells(const FCells& val) {
  this->fcells = val;
}
std::ostream& operator<<(std::ostream& out, const CellsGroup& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CellsGroup::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->ccells.clear();
            uint32_t _size673;
            ::apache::thrift::protocol::TType _ktype674;
            ::apache::thrift::protocol::TType _vtype675;
            xfer += iprot->readMapBegin(_ktype674, _vtype675, _size673);
            uint32_t _i677;
            for (_i677 = 0; _i677 < _size673; ++_i677)
            {
              std::string _key678;
              xfer += iprot->readString(_key678);
              cCells& _val679 = this->ccells[_key678];
              xfer += _val679.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.ccells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->kcells.clear();
            uint32_t _size680;
            ::apache::thrift::protocol::TType _etype683;
            xfer += iprot->readListBegin(_etype683, _size680);
            this->kcells.resize(_size680);
            uint32_t _i684;
            for (_i684 = 0; _i684 < _size680; ++_i684)
            {
              xfer += this->kcells[_i684].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.kcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->fcells.read(iprot);
          this->__isset.fcells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CellsGroup::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CellsGroup");

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ccells", ::apache::thrift::protocol::T_MAP, 2);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->ccells.size()));
    std::map<std::string, cCells> ::const_iterator _iter685;
    for (_iter685 = this->ccells.begin(); _iter685 != this->ccells.end(); ++_iter685)
    {
      xfer += oprot->writeString(_iter685->first);
      xfer += _iter685->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("kcells", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->kcells.size()));
    std::vector<kCells> ::const_iterator _iter686;
    for (_iter686 = this->kcells.begin(); _iter686 != this->kcells.end(); ++_iter686)
    {
      xfer += (*_iter686).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fcells", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->fcells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CellsGroup &a, CellsGroup &b) {
  using ::std::swap;
  swap(a.cells, b.cells);
  swap(a.ccells, b.ccells);
  swap(a.kcells, b.kcells);
  swap(a.fcells, b.fcells);
  swap(a.__isset, b.__isset);
}

CellsGroup::CellsGroup(const CellsGroup& other687) {
  cells = other687.cells;
  ccells = other687.ccells;
  kcells = other687.kcells;
  fcells = other687.fcells;
  __isset = other687.__isset;
}
CellsGroup::CellsGroup(CellsGroup&& other688) noexcept {
  cells = std::move(other688.cells);
  ccells = std::move(other688.ccells);
  kcells = std::move(other688.kcells);
  fcells = std::move(other688.fcells);
  __isset = other688.__isset;
}
CellsGroup& CellsGroup::operator=(const CellsGroup& other689) {
  cells = other689.cells;
  ccells = other689.ccells;
  kcells = other689.kcells;
  fcells = other689.fcells;
  __isset = other689.__isset;
  return *this;
}
CellsGroup& CellsGroup::operator=(CellsGroup&& other690) noexcept {
  cells = std::move(other690.cells);
  ccells = std::move(other690.ccells);
  kcells = std::move(other690.kcells);
  fcells = std::move(other690.fcells);
  __isset = other690.__isset;
  return *this;
}
void CellsGroup::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CellsGroup(";
  out << "cells=" << to_string(cells);
  out << ", " << "ccells=" << to_string(ccells);
  out << ", " << "kcells=" << to_string(kcells);
  out << ", " << "fcells=" << to_string(fcells);
  out << ")";
}


CompactResult::~CompactResult() noexcept {
}


void CompactResult::__set_cid(const int64_t val) {
  this->cid = val;
}

void CompactResult::__set_err(const int32_t val) {
  this->err = val;
}
std::ostream& operator<<(std::ostream& out, const CompactResult& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t CompactResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cid);
          this->__isset.cid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->err);
          this->__isset.err = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CompactResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CompactResult");

  xfer += oprot->writeFieldBegin("cid", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->cid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("err", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->err);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CompactResult &a, CompactResult &b) {
  using ::std::swap;
  swap(a.cid, b.cid);
  swap(a.err, b.err);
  swap(a.__isset, b.__isset);
}

CompactResult::CompactResult(const CompactResult& other691) noexcept {
  cid = other691.cid;
  err = other691.err;
  __isset = other691.__isset;
}
CompactResult::CompactResult(CompactResult&& other692) noexcept {
  cid = other692.cid;
  err = other692.err;
  __isset = other692.__isset;
}
CompactResult& CompactResult::operator=(const CompactResult& other693) noexcept {
  cid = other693.cid;
  err = other693.err;
  __isset = other693.__isset;
  return *this;
}
CompactResult& CompactResult::operator=(CompactResult&& other694) noexcept {
  cid = other694.cid;
  err = other694.err;
  __isset = other694.__isset;
  return *this;
}
void CompactResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CompactResult(";
  out << "cid=" << to_string(cid);
  out << ", " << "err=" << to_string(err);
  out << ")";
}


Result::~Result() noexcept {
}


void Result::__set_schemas(const Schemas& val) {
  this->schemas = val;
}

void Result::__set_cells(const Cells& val) {
  this->cells = val;
}

void Result::__set_compact(const CompactResults& val) {
  this->compact = val;
}
std::ostream& operator<<(std::ostream& out, const Result& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Result::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->schemas.clear();
            uint32_t _size695;
            ::apache::thrift::protocol::TType _etype698;
            xfer += iprot->readListBegin(_etype698, _size695);
            this->schemas.resize(_size695);
            uint32_t _i699;
            for (_i699 = 0; _i699 < _size695; ++_i699)
            {
              xfer += this->schemas[_i699].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.schemas = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cells.read(iprot);
          this->__isset.cells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->compact.clear();
            uint32_t _size700;
            ::apache::thrift::protocol::TType _etype703;
            xfer += iprot->readListBegin(_etype703, _size700);
            this->compact.resize(_size700);
            uint32_t _i704;
            for (_i704 = 0; _i704 < _size700; ++_i704)
            {
              xfer += this->compact[_i704].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.compact = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Result::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Result");

  xfer += oprot->writeFieldBegin("schemas", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->schemas.size()));
    std::vector<Schema> ::const_iterator _iter705;
    for (_iter705 = this->schemas.begin(); _iter705 != this->schemas.end(); ++_iter705)
    {
      xfer += (*_iter705).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cells", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->cells.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("compact", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->compact.size()));
    std::vector<CompactResult> ::const_iterator _iter706;
    for (_iter706 = this->compact.begin(); _iter706 != this->compact.end(); ++_iter706)
    {
      xfer += (*_iter706).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Result &a, Result &b) {
  using ::std::swap;
  swap(a.schemas, b.schemas);
  swap(a.cells, b.cells);
  swap(a.compact, b.compact);
  swap(a.__isset, b.__isset);
}

Result::Result(const Result& other707) {
  schemas = other707.schemas;
  cells = other707.cells;
  compact = other707.compact;
  __isset = other707.__isset;
}
Result::Result(Result&& other708) noexcept {
  schemas = std::move(other708.schemas);
  cells = std::move(other708.cells);
  compact = std::move(other708.compact);
  __isset = other708.__isset;
}
Result& Result::operator=(const Result& other709) {
  schemas = other709.schemas;
  cells = other709.cells;
  compact = other709.compact;
  __isset = other709.__isset;
  return *this;
}
Result& Result::operator=(Result&& other710) noexcept {
  schemas = std::move(other710.schemas);
  cells = std::move(other710.cells);
  compact = std::move(other710.compact);
  __isset = other710.__isset;
  return *this;
}
void Result::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Result(";
  out << "schemas=" << to_string(schemas);
  out << ", " << "cells=" << to_string(cells);
  out << ", " << "compact=" << to_string(compact);
  out << ")";
}

}} // namespace
