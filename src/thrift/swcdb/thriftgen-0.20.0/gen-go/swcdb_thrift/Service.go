// Code generated by Thrift Compiler (0.20.0). DO NOT EDIT.

package swcdb_thrift

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"log/slog"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"strings"
	"regexp"
)

// (needed to ensure safety because of naive import list construction.)
var _ = bytes.Equal
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = slog.Log
var _ = time.Now
var _ = thrift.ZERO
// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

//Column Key Sequences
type KeySeq int64
const (
  KeySeq_UNKNOWN KeySeq = 0
  KeySeq_LEXIC KeySeq = 1
  KeySeq_VOLUME KeySeq = 2
  KeySeq_FC_LEXIC KeySeq = 3
  KeySeq_FC_VOLUME KeySeq = 4
)

func (p KeySeq) String() string {
  switch p {
  case KeySeq_UNKNOWN: return "UNKNOWN"
  case KeySeq_LEXIC: return "LEXIC"
  case KeySeq_VOLUME: return "VOLUME"
  case KeySeq_FC_LEXIC: return "FC_LEXIC"
  case KeySeq_FC_VOLUME: return "FC_VOLUME"
  }
  return "<UNSET>"
}

func KeySeqFromString(s string) (KeySeq, error) {
  switch s {
  case "UNKNOWN": return KeySeq_UNKNOWN, nil 
  case "LEXIC": return KeySeq_LEXIC, nil 
  case "VOLUME": return KeySeq_VOLUME, nil 
  case "FC_LEXIC": return KeySeq_FC_LEXIC, nil 
  case "FC_VOLUME": return KeySeq_FC_VOLUME, nil 
  }
  return KeySeq(0), fmt.Errorf("not a valid KeySeq string")
}


func KeySeqPtr(v KeySeq) *KeySeq { return &v }

func (p KeySeq) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *KeySeq) UnmarshalText(text []byte) error {
q, err := KeySeqFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *KeySeq) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = KeySeq(v)
return nil
}

func (p * KeySeq) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Column Value Types
type ColumnType int64
const (
  ColumnType_UNKNOWN ColumnType = 0
  ColumnType_PLAIN ColumnType = 1
  ColumnType_COUNTER_I64 ColumnType = 2
  ColumnType_COUNTER_I32 ColumnType = 3
  ColumnType_COUNTER_I16 ColumnType = 4
  ColumnType_COUNTER_I8 ColumnType = 5
  ColumnType_SERIAL ColumnType = 6
  ColumnType_CELL_DEFINED ColumnType = 15
)

func (p ColumnType) String() string {
  switch p {
  case ColumnType_UNKNOWN: return "UNKNOWN"
  case ColumnType_PLAIN: return "PLAIN"
  case ColumnType_COUNTER_I64: return "COUNTER_I64"
  case ColumnType_COUNTER_I32: return "COUNTER_I32"
  case ColumnType_COUNTER_I16: return "COUNTER_I16"
  case ColumnType_COUNTER_I8: return "COUNTER_I8"
  case ColumnType_SERIAL: return "SERIAL"
  case ColumnType_CELL_DEFINED: return "CELL_DEFINED"
  }
  return "<UNSET>"
}

func ColumnTypeFromString(s string) (ColumnType, error) {
  switch s {
  case "UNKNOWN": return ColumnType_UNKNOWN, nil 
  case "PLAIN": return ColumnType_PLAIN, nil 
  case "COUNTER_I64": return ColumnType_COUNTER_I64, nil 
  case "COUNTER_I32": return ColumnType_COUNTER_I32, nil 
  case "COUNTER_I16": return ColumnType_COUNTER_I16, nil 
  case "COUNTER_I8": return ColumnType_COUNTER_I8, nil 
  case "SERIAL": return ColumnType_SERIAL, nil 
  case "CELL_DEFINED": return ColumnType_CELL_DEFINED, nil 
  }
  return ColumnType(0), fmt.Errorf("not a valid ColumnType string")
}


func ColumnTypePtr(v ColumnType) *ColumnType { return &v }

func (p ColumnType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *ColumnType) UnmarshalText(text []byte) error {
q, err := ColumnTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *ColumnType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = ColumnType(v)
return nil
}

func (p * ColumnType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Data Encoding Types
type EncodingType int64
const (
  EncodingType_DEFAULT EncodingType = 0
  EncodingType_PLAIN EncodingType = 1
  EncodingType_ZLIB EncodingType = 2
  EncodingType_SNAPPY EncodingType = 3
  EncodingType_ZSTD EncodingType = 4
  EncodingType_UNKNOWN EncodingType = 255
)

func (p EncodingType) String() string {
  switch p {
  case EncodingType_DEFAULT: return "DEFAULT"
  case EncodingType_PLAIN: return "PLAIN"
  case EncodingType_ZLIB: return "ZLIB"
  case EncodingType_SNAPPY: return "SNAPPY"
  case EncodingType_ZSTD: return "ZSTD"
  case EncodingType_UNKNOWN: return "UNKNOWN"
  }
  return "<UNSET>"
}

func EncodingTypeFromString(s string) (EncodingType, error) {
  switch s {
  case "DEFAULT": return EncodingType_DEFAULT, nil 
  case "PLAIN": return EncodingType_PLAIN, nil 
  case "ZLIB": return EncodingType_ZLIB, nil 
  case "SNAPPY": return EncodingType_SNAPPY, nil 
  case "ZSTD": return EncodingType_ZSTD, nil 
  case "UNKNOWN": return EncodingType_UNKNOWN, nil 
  }
  return EncodingType(0), fmt.Errorf("not a valid EncodingType string")
}


func EncodingTypePtr(v EncodingType) *EncodingType { return &v }

func (p EncodingType) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *EncodingType) UnmarshalText(text []byte) error {
q, err := EncodingTypeFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *EncodingType) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = EncodingType(v)
return nil
}

func (p * EncodingType) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//Manage Columns schema function Flags
type SchemaFunc int64
const (
  SchemaFunc_CREATE SchemaFunc = 3
  SchemaFunc_REMOVE SchemaFunc = 5
  SchemaFunc_MODIFY SchemaFunc = 7
)

func (p SchemaFunc) String() string {
  switch p {
  case SchemaFunc_CREATE: return "CREATE"
  case SchemaFunc_REMOVE: return "REMOVE"
  case SchemaFunc_MODIFY: return "MODIFY"
  }
  return "<UNSET>"
}

func SchemaFuncFromString(s string) (SchemaFunc, error) {
  switch s {
  case "CREATE": return SchemaFunc_CREATE, nil 
  case "REMOVE": return SchemaFunc_REMOVE, nil 
  case "MODIFY": return SchemaFunc_MODIFY, nil 
  }
  return SchemaFunc(0), fmt.Errorf("not a valid SchemaFunc string")
}


func SchemaFuncPtr(v SchemaFunc) *SchemaFunc { return &v }

func (p SchemaFunc) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *SchemaFunc) UnmarshalText(text []byte) error {
q, err := SchemaFuncFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *SchemaFunc) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = SchemaFunc(v)
return nil
}

func (p * SchemaFunc) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//The available logical Comparators, plus extended logic options applied with 'v' for VOLUME
type Comp int64
const (
  Comp_NONE Comp = 0
  Comp_PF Comp = 1
  Comp_GT Comp = 2
  Comp_GE Comp = 3
  Comp_EQ Comp = 4
  Comp_LE Comp = 5
  Comp_LT Comp = 6
  Comp_NE Comp = 7
  Comp_RE Comp = 8
  Comp_VGT Comp = 9
  Comp_VGE Comp = 10
  Comp_VLE Comp = 11
  Comp_VLT Comp = 12
  Comp_SBS Comp = 13
  Comp_SPS Comp = 14
  Comp_POSBS Comp = 15
  Comp_POSPS Comp = 16
  Comp_FOSBS Comp = 17
  Comp_FOSPS Comp = 18
  Comp_FIP Comp = 19
  Comp_FI Comp = 20
  Comp_OR Comp = 21
)

func (p Comp) String() string {
  switch p {
  case Comp_NONE: return "NONE"
  case Comp_PF: return "PF"
  case Comp_GT: return "GT"
  case Comp_GE: return "GE"
  case Comp_EQ: return "EQ"
  case Comp_LE: return "LE"
  case Comp_LT: return "LT"
  case Comp_NE: return "NE"
  case Comp_RE: return "RE"
  case Comp_VGT: return "VGT"
  case Comp_VGE: return "VGE"
  case Comp_VLE: return "VLE"
  case Comp_VLT: return "VLT"
  case Comp_SBS: return "SBS"
  case Comp_SPS: return "SPS"
  case Comp_POSBS: return "POSBS"
  case Comp_POSPS: return "POSPS"
  case Comp_FOSBS: return "FOSBS"
  case Comp_FOSPS: return "FOSPS"
  case Comp_FIP: return "FIP"
  case Comp_FI: return "FI"
  case Comp_OR: return "OR"
  }
  return "<UNSET>"
}

func CompFromString(s string) (Comp, error) {
  switch s {
  case "NONE": return Comp_NONE, nil 
  case "PF": return Comp_PF, nil 
  case "GT": return Comp_GT, nil 
  case "GE": return Comp_GE, nil 
  case "EQ": return Comp_EQ, nil 
  case "LE": return Comp_LE, nil 
  case "LT": return Comp_LT, nil 
  case "NE": return Comp_NE, nil 
  case "RE": return Comp_RE, nil 
  case "VGT": return Comp_VGT, nil 
  case "VGE": return Comp_VGE, nil 
  case "VLE": return Comp_VLE, nil 
  case "VLT": return Comp_VLT, nil 
  case "SBS": return Comp_SBS, nil 
  case "SPS": return Comp_SPS, nil 
  case "POSBS": return Comp_POSBS, nil 
  case "POSPS": return Comp_POSPS, nil 
  case "FOSBS": return Comp_FOSBS, nil 
  case "FOSPS": return Comp_FOSPS, nil 
  case "FIP": return Comp_FIP, nil 
  case "FI": return Comp_FI, nil 
  case "OR": return Comp_OR, nil 
  }
  return Comp(0), fmt.Errorf("not a valid Comp string")
}


func CompPtr(v Comp) *Comp { return &v }

func (p Comp) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *Comp) UnmarshalText(text []byte) error {
q, err := CompFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *Comp) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = Comp(v)
return nil
}

func (p * Comp) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//The Scan options Flags Specifications for the SpecFlags 'options' bit
type SpecFlagsOpt int64
const (
  SpecFlagsOpt_NONE SpecFlagsOpt = 0
  SpecFlagsOpt_LIMIT_BY_KEYS SpecFlagsOpt = 1
  SpecFlagsOpt_OFFSET_BY_KEYS SpecFlagsOpt = 4
  SpecFlagsOpt_ONLY_KEYS SpecFlagsOpt = 8
  SpecFlagsOpt_ONLY_DELETES SpecFlagsOpt = 10
)

func (p SpecFlagsOpt) String() string {
  switch p {
  case SpecFlagsOpt_NONE: return "NONE"
  case SpecFlagsOpt_LIMIT_BY_KEYS: return "LIMIT_BY_KEYS"
  case SpecFlagsOpt_OFFSET_BY_KEYS: return "OFFSET_BY_KEYS"
  case SpecFlagsOpt_ONLY_KEYS: return "ONLY_KEYS"
  case SpecFlagsOpt_ONLY_DELETES: return "ONLY_DELETES"
  }
  return "<UNSET>"
}

func SpecFlagsOptFromString(s string) (SpecFlagsOpt, error) {
  switch s {
  case "NONE": return SpecFlagsOpt_NONE, nil 
  case "LIMIT_BY_KEYS": return SpecFlagsOpt_LIMIT_BY_KEYS, nil 
  case "OFFSET_BY_KEYS": return SpecFlagsOpt_OFFSET_BY_KEYS, nil 
  case "ONLY_KEYS": return SpecFlagsOpt_ONLY_KEYS, nil 
  case "ONLY_DELETES": return SpecFlagsOpt_ONLY_DELETES, nil 
  }
  return SpecFlagsOpt(0), fmt.Errorf("not a valid SpecFlagsOpt string")
}


func SpecFlagsOptPtr(v SpecFlagsOpt) *SpecFlagsOpt { return &v }

func (p SpecFlagsOpt) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *SpecFlagsOpt) UnmarshalText(text []byte) error {
q, err := SpecFlagsOptFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *SpecFlagsOpt) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = SpecFlagsOpt(v)
return nil
}

func (p * SpecFlagsOpt) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
type UpdateOP int64
const (
  UpdateOP_REPLACE UpdateOP = 0
  UpdateOP_APPEND UpdateOP = 1
  UpdateOP_PREPEND UpdateOP = 2
  UpdateOP_INSERT UpdateOP = 3
  UpdateOP_OVERWRITE UpdateOP = 4
  UpdateOP_SERIAL UpdateOP = 5
)

func (p UpdateOP) String() string {
  switch p {
  case UpdateOP_REPLACE: return "REPLACE"
  case UpdateOP_APPEND: return "APPEND"
  case UpdateOP_PREPEND: return "PREPEND"
  case UpdateOP_INSERT: return "INSERT"
  case UpdateOP_OVERWRITE: return "OVERWRITE"
  case UpdateOP_SERIAL: return "SERIAL"
  }
  return "<UNSET>"
}

func UpdateOPFromString(s string) (UpdateOP, error) {
  switch s {
  case "REPLACE": return UpdateOP_REPLACE, nil 
  case "APPEND": return UpdateOP_APPEND, nil 
  case "PREPEND": return UpdateOP_PREPEND, nil 
  case "INSERT": return UpdateOP_INSERT, nil 
  case "OVERWRITE": return UpdateOP_OVERWRITE, nil 
  case "SERIAL": return UpdateOP_SERIAL, nil 
  }
  return UpdateOP(0), fmt.Errorf("not a valid UpdateOP string")
}


func UpdateOPPtr(v UpdateOP) *UpdateOP { return &v }

func (p UpdateOP) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *UpdateOP) UnmarshalText(text []byte) error {
q, err := UpdateOPFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *UpdateOP) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = UpdateOP(v)
return nil
}

func (p * UpdateOP) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//The Scan Interval Specs Options for the SpecIntervalPlain, SpecIntervalCounter and SpecIntervalSerial 'options' bit
type SpecIntervalOptions int64
const (
  SpecIntervalOptions_UPDATING SpecIntervalOptions = 4
  SpecIntervalOptions_DELETING SpecIntervalOptions = 8
)

func (p SpecIntervalOptions) String() string {
  switch p {
  case SpecIntervalOptions_UPDATING: return "UPDATING"
  case SpecIntervalOptions_DELETING: return "DELETING"
  }
  return "<UNSET>"
}

func SpecIntervalOptionsFromString(s string) (SpecIntervalOptions, error) {
  switch s {
  case "UPDATING": return SpecIntervalOptions_UPDATING, nil 
  case "DELETING": return SpecIntervalOptions_DELETING, nil 
  }
  return SpecIntervalOptions(0), fmt.Errorf("not a valid SpecIntervalOptions string")
}


func SpecIntervalOptionsPtr(v SpecIntervalOptions) *SpecIntervalOptions { return &v }

func (p SpecIntervalOptions) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *SpecIntervalOptions) UnmarshalText(text []byte) error {
q, err := SpecIntervalOptionsFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *SpecIntervalOptions) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = SpecIntervalOptions(v)
return nil
}

func (p * SpecIntervalOptions) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//The Cell Flag
type Flag int64
const (
  Flag_NONE Flag = 0
  Flag_INSERT Flag = 1
  Flag_DELETE_LE Flag = 2
  Flag_DELETE_EQ Flag = 3
)

func (p Flag) String() string {
  switch p {
  case Flag_NONE: return "NONE"
  case Flag_INSERT: return "INSERT"
  case Flag_DELETE_LE: return "DELETE_LE"
  case Flag_DELETE_EQ: return "DELETE_EQ"
  }
  return "<UNSET>"
}

func FlagFromString(s string) (Flag, error) {
  switch s {
  case "NONE": return Flag_NONE, nil 
  case "INSERT": return Flag_INSERT, nil 
  case "DELETE_LE": return Flag_DELETE_LE, nil 
  case "DELETE_EQ": return Flag_DELETE_EQ, nil 
  }
  return Flag(0), fmt.Errorf("not a valid Flag string")
}


func FlagPtr(v Flag) *Flag { return &v }

func (p Flag) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *Flag) UnmarshalText(text []byte) error {
q, err := FlagFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *Flag) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = Flag(v)
return nil
}

func (p * Flag) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//MATH Operations for Serial Field Update of types INT64 and DOUBLE
type FU_MATH_OP int64
const (
  FU_MATH_OP_EQUAL FU_MATH_OP = 0
  FU_MATH_OP_PLUS FU_MATH_OP = 1
  FU_MATH_OP_MULTIPLY FU_MATH_OP = 2
  FU_MATH_OP_DIVIDE FU_MATH_OP = 3
)

func (p FU_MATH_OP) String() string {
  switch p {
  case FU_MATH_OP_EQUAL: return "EQUAL"
  case FU_MATH_OP_PLUS: return "PLUS"
  case FU_MATH_OP_MULTIPLY: return "MULTIPLY"
  case FU_MATH_OP_DIVIDE: return "DIVIDE"
  }
  return "<UNSET>"
}

func FU_MATH_OPFromString(s string) (FU_MATH_OP, error) {
  switch s {
  case "EQUAL": return FU_MATH_OP_EQUAL, nil 
  case "PLUS": return FU_MATH_OP_PLUS, nil 
  case "MULTIPLY": return FU_MATH_OP_MULTIPLY, nil 
  case "DIVIDE": return FU_MATH_OP_DIVIDE, nil 
  }
  return FU_MATH_OP(0), fmt.Errorf("not a valid FU_MATH_OP string")
}


func FU_MATH_OPPtr(v FU_MATH_OP) *FU_MATH_OP { return &v }

func (p FU_MATH_OP) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *FU_MATH_OP) UnmarshalText(text []byte) error {
q, err := FU_MATH_OPFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *FU_MATH_OP) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = FU_MATH_OP(v)
return nil
}

func (p * FU_MATH_OP) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//LIST Operations for Serial Field Update of array/list/bytes with LIST-op in the inner SERIAL fields
type FU_LIST_OP int64
const (
  FU_LIST_OP_REPLACE FU_LIST_OP = 0
  FU_LIST_OP_APPEND FU_LIST_OP = 1
  FU_LIST_OP_PREPEND FU_LIST_OP = 2
  FU_LIST_OP_INSERT FU_LIST_OP = 3
  FU_LIST_OP_OVERWRITE FU_LIST_OP = 4
  FU_LIST_OP_ERASE FU_LIST_OP = 5
  FU_LIST_OP_BY_UNIQUE FU_LIST_OP = 6
  FU_LIST_OP_BY_COND FU_LIST_OP = 7
  FU_LIST_OP_BY_INDEX FU_LIST_OP = 8
)

func (p FU_LIST_OP) String() string {
  switch p {
  case FU_LIST_OP_REPLACE: return "REPLACE"
  case FU_LIST_OP_APPEND: return "APPEND"
  case FU_LIST_OP_PREPEND: return "PREPEND"
  case FU_LIST_OP_INSERT: return "INSERT"
  case FU_LIST_OP_OVERWRITE: return "OVERWRITE"
  case FU_LIST_OP_ERASE: return "ERASE"
  case FU_LIST_OP_BY_UNIQUE: return "BY_UNIQUE"
  case FU_LIST_OP_BY_COND: return "BY_COND"
  case FU_LIST_OP_BY_INDEX: return "BY_INDEX"
  }
  return "<UNSET>"
}

func FU_LIST_OPFromString(s string) (FU_LIST_OP, error) {
  switch s {
  case "REPLACE": return FU_LIST_OP_REPLACE, nil 
  case "APPEND": return FU_LIST_OP_APPEND, nil 
  case "PREPEND": return FU_LIST_OP_PREPEND, nil 
  case "INSERT": return FU_LIST_OP_INSERT, nil 
  case "OVERWRITE": return FU_LIST_OP_OVERWRITE, nil 
  case "ERASE": return FU_LIST_OP_ERASE, nil 
  case "BY_UNIQUE": return FU_LIST_OP_BY_UNIQUE, nil 
  case "BY_COND": return FU_LIST_OP_BY_COND, nil 
  case "BY_INDEX": return FU_LIST_OP_BY_INDEX, nil 
  }
  return FU_LIST_OP(0), fmt.Errorf("not a valid FU_LIST_OP string")
}


func FU_LIST_OPPtr(v FU_LIST_OP) *FU_LIST_OP { return &v }

func (p FU_LIST_OP) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *FU_LIST_OP) UnmarshalText(text []byte) error {
q, err := FU_LIST_OPFromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *FU_LIST_OP) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = FU_LIST_OP(v)
return nil
}

func (p * FU_LIST_OP) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//The Cells Results types for using with CellsGroup requests
type CellsResult_ int64
const (
  CellsResult__IN_LIST CellsResult_ = 0
  CellsResult__ON_COLUMN CellsResult_ = 1
  CellsResult__ON_KEY CellsResult_ = 2
  CellsResult__ON_FRACTION CellsResult_ = 3
)

func (p CellsResult_) String() string {
  switch p {
  case CellsResult__IN_LIST: return "IN_LIST"
  case CellsResult__ON_COLUMN: return "ON_COLUMN"
  case CellsResult__ON_KEY: return "ON_KEY"
  case CellsResult__ON_FRACTION: return "ON_FRACTION"
  }
  return "<UNSET>"
}

func CellsResult_FromString(s string) (CellsResult_, error) {
  switch s {
  case "IN_LIST": return CellsResult__IN_LIST, nil 
  case "ON_COLUMN": return CellsResult__ON_COLUMN, nil 
  case "ON_KEY": return CellsResult__ON_KEY, nil 
  case "ON_FRACTION": return CellsResult__ON_FRACTION, nil 
  }
  return CellsResult_(0), fmt.Errorf("not a valid CellsResult_ string")
}


func CellsResult_Ptr(v CellsResult_) *CellsResult_ { return &v }

func (p CellsResult_) MarshalText() ([]byte, error) {
return []byte(p.String()), nil
}

func (p *CellsResult_) UnmarshalText(text []byte) error {
q, err := CellsResult_FromString(string(text))
if (err != nil) {
return err
}
*p = q
return nil
}

func (p *CellsResult_) Scan(value interface{}) error {
v, ok := value.(int64)
if !ok {
return errors.New("Scan value is not int64")
}
*p = CellsResult_(v)
return nil
}

func (p * CellsResult_) Value() (driver.Value, error) {
  if p == nil {
    return nil, nil
  }
return int64(*p), nil
}
//A list-container of Schemas
type Schemas []*Schema

func SchemasPtr(v Schemas) *Schemas { return &v }

//A Cell Key defined as binary(bytes) items in a list-container
type Key [][]byte

func KeyPtr(v Key) *Key { return &v }

//The Serial Cell Value Specifications defined as SpecValueSerialField items in a list-container
type SpecValueSerialFields []*SpecValueSerialField

func SpecValueSerialFieldsPtr(v SpecValueSerialFields) *SpecValueSerialFields { return &v }

//The Cell Value Specifications defined as SpecValuePlain items in a list-container
type SpecValuesPlain []*SpecValuePlain

func SpecValuesPlainPtr(v SpecValuesPlain) *SpecValuesPlain { return &v }

//The Cell Value Specifications defined as SpecValueCounter items in a list-container
type SpecValuesCounter []*SpecValueCounter

func SpecValuesCounterPtr(v SpecValuesCounter) *SpecValuesCounter { return &v }

//The Cell Value Specifications defined as SpecValueSerial items in a list-container
type SpecValuesSerial []*SpecValueSerial

func SpecValuesSerialPtr(v SpecValuesSerial) *SpecValuesSerial { return &v }

//The Key Specifications defined as SpecFraction items in a list-container
type SpecKey []*SpecFraction

func SpecKeyPtr(v SpecKey) *SpecKey { return &v }

//The Key Intervals Specifications defined as SpecKeyInterval items in a list-container
type SpecKeyIntervals []*SpecKeyInterval

func SpecKeyIntervalsPtr(v SpecKeyIntervals) *SpecKeyIntervals { return &v }

//The Cells for Update defined as UCellPlain items in a list-container
type UCellsPlain []*UCellPlain

func UCellsPlainPtr(v UCellsPlain) *UCellsPlain { return &v }

//The Cells for Update for a Column Id defined as UCellsPlain items in a map-container by CID
type UCCellsPlain map[int64]UCellsPlain

func UCCellsPlainPtr(v UCCellsPlain) *UCCellsPlain { return &v }

//The Cells for Update defined as UCellCounter items in a list-container
type UCellsCounter []*UCellCounter

func UCellsCounterPtr(v UCellsCounter) *UCellsCounter { return &v }

//The Cells for Update for a Column Id defined as UCellsCounter items in a map-container by CID
type UCCellsCounter map[int64]UCellsCounter

func UCCellsCounterPtr(v UCCellsCounter) *UCCellsCounter { return &v }

//The Serial Cell Value Fields defined as CellValueSerial items in a list-container
type CellValuesSerial []*CellValueSerial

func CellValuesSerialPtr(v CellValuesSerial) *CellValuesSerial { return &v }

//The Serial Cell Value Fields defined as CellValueSerialOp items in a list-container
type CellValuesSerialOp []*CellValueSerialOp

func CellValuesSerialOpPtr(v CellValuesSerialOp) *CellValuesSerialOp { return &v }

//The Cells for Update defined as UCellSerial items in a list-container
type UCellsSerial []*UCellSerial

func UCellsSerialPtr(v UCellsSerial) *UCellsSerial { return &v }

//The Cells for Update for a Column Id defined as UCellsSerial items in a map-container by CID
type UCCellsSerial map[int64]UCellsSerial

func UCCellsSerialPtr(v UCCellsSerial) *UCCellsSerial { return &v }

//A list-container of Plain Cells
type CellsPlain []*CellPlain

func CellsPlainPtr(v CellsPlain) *CellsPlain { return &v }

//A list-container of Counter Cells
type CellsCounter []*CellCounter

func CellsCounterPtr(v CellsCounter) *CellsCounter { return &v }

//A list-container of Serial Cells
type CellsSerial []*CellSerial

func CellsSerialPtr(v CellsSerial) *CellsSerial { return &v }

//The Columns Cells for results on Columns of scan, defined as cCells items in a map-container by Column Name
type CCells map[string]*CCells

func CCellsPtr(v CCells) *CCells { return &v }

//The Keys Cells for results on Key of scan, defined as kCells items in a list-container
type KCells []*KCells

func KCellsPtr(v KCells) *KCells { return &v }

//The Compact Results, defined as CompactResult items in a list-container
type CompactResults []*CompactResult_

func CompactResultsPtr(v CompactResults) *CompactResults { return &v }

// The SWC::Thrift::Exception a base for any Exceptions
// both for the Thrift-Protocol and SWC-DB Errors.
// 
// Attributes:
//  - Code: The corresponding Thrift-Procotol or SWC-DB Error Code
//  - Message: The message describing the error code
type Exception struct {
  Code int32 `thrift:"code,1" db:"code" json:"code"`
  Message string `thrift:"message,2" db:"message" json:"message"`
}

func NewException() *Exception {
  return &Exception{}
}


func (p *Exception) GetCode() int32 {
  return p.Code
}

func (p *Exception) GetMessage() string {
  return p.Message
}
func (p *Exception) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Exception)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Code = v
}
  return nil
}

func (p *Exception)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Message = v
}
  return nil
}

func (p *Exception) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Exception"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Exception) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "code", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Code)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.code (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err) }
  return err
}

func (p *Exception) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err) }
  return err
}

func (p *Exception) Equals(other *Exception) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Code != other.Code { return false }
  if p.Message != other.Message { return false }
  return true
}

func (p *Exception) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Exception(%+v)", *p)
}

func (p *Exception) Error() string {
  return p.String()
}

func (Exception) TExceptionType() thrift.TExceptionType {
  return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*Exception)(nil)

func (p *Exception) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.Exception",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Exception)(nil)

func (p *Exception) Validate() error {
  return nil
}
// The Schema Definition
// 
// Attributes:
//  - Cid: Column ID
//  - ColName: Column Name
//  - ColTags: Column Tags
//  - ColSeq: Column Key Sequence
//  - ColType: Column Type
//  - CellVersions: Cell Versions
//  - CellTTL: Cell Time to Live
//  - BlkEncoding: Block Encoding
//  - BlkSize: Block Size in Bytes
//  - BlkCells: Number of Cells in Block
//  - CsReplication: CellStore file Replication
//  - CsSize: CellStore Size in Bytes
//  - CsMax: Max CellStores in a Range
//  - LogRolloutRatio: Write Fragment File on ratio reached
//  - LogCompactCointervaling: Min. Cointervaling Fragments for Compaction
//  - LogFragmentPreload: Number of Fragment to Preload
//  - CompactPercent: Compact at percent reach
//  - Revision: Schema's revision/id
type Schema struct {
  Cid *int64 `thrift:"cid,1" db:"cid" json:"cid,omitempty"`
  ColName *string `thrift:"col_name,2" db:"col_name" json:"col_name,omitempty"`
  ColTags []string `thrift:"col_tags,3" db:"col_tags" json:"col_tags"`
  ColSeq *KeySeq `thrift:"col_seq,4" db:"col_seq" json:"col_seq,omitempty"`
  ColType *ColumnType `thrift:"col_type,5" db:"col_type" json:"col_type,omitempty"`
  CellVersions *int32 `thrift:"cell_versions,6" db:"cell_versions" json:"cell_versions,omitempty"`
  CellTTL *int32 `thrift:"cell_ttl,7" db:"cell_ttl" json:"cell_ttl,omitempty"`
  BlkEncoding *EncodingType `thrift:"blk_encoding,8" db:"blk_encoding" json:"blk_encoding,omitempty"`
  BlkSize *int32 `thrift:"blk_size,9" db:"blk_size" json:"blk_size,omitempty"`
  BlkCells *int32 `thrift:"blk_cells,10" db:"blk_cells" json:"blk_cells,omitempty"`
  CsReplication *int8 `thrift:"cs_replication,11" db:"cs_replication" json:"cs_replication,omitempty"`
  CsSize *int32 `thrift:"cs_size,12" db:"cs_size" json:"cs_size,omitempty"`
  CsMax *int8 `thrift:"cs_max,13" db:"cs_max" json:"cs_max,omitempty"`
  LogRolloutRatio *int8 `thrift:"log_rollout_ratio,14" db:"log_rollout_ratio" json:"log_rollout_ratio,omitempty"`
  LogCompactCointervaling *int8 `thrift:"log_compact_cointervaling,15" db:"log_compact_cointervaling" json:"log_compact_cointervaling,omitempty"`
  LogFragmentPreload *int8 `thrift:"log_fragment_preload,16" db:"log_fragment_preload" json:"log_fragment_preload,omitempty"`
  CompactPercent *int8 `thrift:"compact_percent,17" db:"compact_percent" json:"compact_percent,omitempty"`
  Revision *int64 `thrift:"revision,18" db:"revision" json:"revision,omitempty"`
}

func NewSchema() *Schema {
  return &Schema{}
}

var Schema_Cid_DEFAULT int64
func (p *Schema) GetCid() int64 {
  if !p.IsSetCid() {
    return Schema_Cid_DEFAULT
  }
  return *p.Cid
}
var Schema_ColName_DEFAULT string
func (p *Schema) GetColName() string {
  if !p.IsSetColName() {
    return Schema_ColName_DEFAULT
  }
  return *p.ColName
}

func (p *Schema) GetColTags() []string {
  return p.ColTags
}
var Schema_ColSeq_DEFAULT KeySeq
func (p *Schema) GetColSeq() KeySeq {
  if !p.IsSetColSeq() {
    return Schema_ColSeq_DEFAULT
  }
  return *p.ColSeq
}
var Schema_ColType_DEFAULT ColumnType
func (p *Schema) GetColType() ColumnType {
  if !p.IsSetColType() {
    return Schema_ColType_DEFAULT
  }
  return *p.ColType
}
var Schema_CellVersions_DEFAULT int32
func (p *Schema) GetCellVersions() int32 {
  if !p.IsSetCellVersions() {
    return Schema_CellVersions_DEFAULT
  }
  return *p.CellVersions
}
var Schema_CellTTL_DEFAULT int32
func (p *Schema) GetCellTTL() int32 {
  if !p.IsSetCellTTL() {
    return Schema_CellTTL_DEFAULT
  }
  return *p.CellTTL
}
var Schema_BlkEncoding_DEFAULT EncodingType
func (p *Schema) GetBlkEncoding() EncodingType {
  if !p.IsSetBlkEncoding() {
    return Schema_BlkEncoding_DEFAULT
  }
  return *p.BlkEncoding
}
var Schema_BlkSize_DEFAULT int32
func (p *Schema) GetBlkSize() int32 {
  if !p.IsSetBlkSize() {
    return Schema_BlkSize_DEFAULT
  }
  return *p.BlkSize
}
var Schema_BlkCells_DEFAULT int32
func (p *Schema) GetBlkCells() int32 {
  if !p.IsSetBlkCells() {
    return Schema_BlkCells_DEFAULT
  }
  return *p.BlkCells
}
var Schema_CsReplication_DEFAULT int8
func (p *Schema) GetCsReplication() int8 {
  if !p.IsSetCsReplication() {
    return Schema_CsReplication_DEFAULT
  }
  return *p.CsReplication
}
var Schema_CsSize_DEFAULT int32
func (p *Schema) GetCsSize() int32 {
  if !p.IsSetCsSize() {
    return Schema_CsSize_DEFAULT
  }
  return *p.CsSize
}
var Schema_CsMax_DEFAULT int8
func (p *Schema) GetCsMax() int8 {
  if !p.IsSetCsMax() {
    return Schema_CsMax_DEFAULT
  }
  return *p.CsMax
}
var Schema_LogRolloutRatio_DEFAULT int8
func (p *Schema) GetLogRolloutRatio() int8 {
  if !p.IsSetLogRolloutRatio() {
    return Schema_LogRolloutRatio_DEFAULT
  }
  return *p.LogRolloutRatio
}
var Schema_LogCompactCointervaling_DEFAULT int8
func (p *Schema) GetLogCompactCointervaling() int8 {
  if !p.IsSetLogCompactCointervaling() {
    return Schema_LogCompactCointervaling_DEFAULT
  }
  return *p.LogCompactCointervaling
}
var Schema_LogFragmentPreload_DEFAULT int8
func (p *Schema) GetLogFragmentPreload() int8 {
  if !p.IsSetLogFragmentPreload() {
    return Schema_LogFragmentPreload_DEFAULT
  }
  return *p.LogFragmentPreload
}
var Schema_CompactPercent_DEFAULT int8
func (p *Schema) GetCompactPercent() int8 {
  if !p.IsSetCompactPercent() {
    return Schema_CompactPercent_DEFAULT
  }
  return *p.CompactPercent
}
var Schema_Revision_DEFAULT int64
func (p *Schema) GetRevision() int64 {
  if !p.IsSetRevision() {
    return Schema_Revision_DEFAULT
  }
  return *p.Revision
}
func (p *Schema) IsSetCid() bool {
  return p.Cid != nil
}

func (p *Schema) IsSetColName() bool {
  return p.ColName != nil
}

func (p *Schema) IsSetColSeq() bool {
  return p.ColSeq != nil
}

func (p *Schema) IsSetColType() bool {
  return p.ColType != nil
}

func (p *Schema) IsSetCellVersions() bool {
  return p.CellVersions != nil
}

func (p *Schema) IsSetCellTTL() bool {
  return p.CellTTL != nil
}

func (p *Schema) IsSetBlkEncoding() bool {
  return p.BlkEncoding != nil
}

func (p *Schema) IsSetBlkSize() bool {
  return p.BlkSize != nil
}

func (p *Schema) IsSetBlkCells() bool {
  return p.BlkCells != nil
}

func (p *Schema) IsSetCsReplication() bool {
  return p.CsReplication != nil
}

func (p *Schema) IsSetCsSize() bool {
  return p.CsSize != nil
}

func (p *Schema) IsSetCsMax() bool {
  return p.CsMax != nil
}

func (p *Schema) IsSetLogRolloutRatio() bool {
  return p.LogRolloutRatio != nil
}

func (p *Schema) IsSetLogCompactCointervaling() bool {
  return p.LogCompactCointervaling != nil
}

func (p *Schema) IsSetLogFragmentPreload() bool {
  return p.LogFragmentPreload != nil
}

func (p *Schema) IsSetCompactPercent() bool {
  return p.CompactPercent != nil
}

func (p *Schema) IsSetRevision() bool {
  return p.Revision != nil
}

func (p *Schema) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 12:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField12(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 13:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField13(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 14:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField14(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 15:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField15(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 16:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField16(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 17:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField17(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 18:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField18(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Schema)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cid = &v
}
  return nil
}

func (p *Schema)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.ColName = &v
}
  return nil
}

func (p *Schema)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.ColTags =  tSlice
  for i := 0; i < size; i ++ {
var _elem0 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem0 = v
}
    p.ColTags = append(p.ColTags, _elem0)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Schema)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := KeySeq(v)
  p.ColSeq = &temp
}
  return nil
}

func (p *Schema)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := ColumnType(v)
  p.ColType = &temp
}
  return nil
}

func (p *Schema)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.CellVersions = &v
}
  return nil
}

func (p *Schema)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 7: ", err)
} else {
  p.CellTTL = &v
}
  return nil
}

func (p *Schema)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 8: ", err)
} else {
  temp := EncodingType(v)
  p.BlkEncoding = &temp
}
  return nil
}

func (p *Schema)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 9: ", err)
} else {
  p.BlkSize = &v
}
  return nil
}

func (p *Schema)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  p.BlkCells = &v
}
  return nil
}

func (p *Schema)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 11: ", err)
} else {
  temp := int8(v)
  p.CsReplication = &temp
}
  return nil
}

func (p *Schema)  ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 12: ", err)
} else {
  p.CsSize = &v
}
  return nil
}

func (p *Schema)  ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 13: ", err)
} else {
  temp := int8(v)
  p.CsMax = &temp
}
  return nil
}

func (p *Schema)  ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 14: ", err)
} else {
  temp := int8(v)
  p.LogRolloutRatio = &temp
}
  return nil
}

func (p *Schema)  ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 15: ", err)
} else {
  temp := int8(v)
  p.LogCompactCointervaling = &temp
}
  return nil
}

func (p *Schema)  ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 16: ", err)
} else {
  temp := int8(v)
  p.LogFragmentPreload = &temp
}
  return nil
}

func (p *Schema)  ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 17: ", err)
} else {
  temp := int8(v)
  p.CompactPercent = &temp
}
  return nil
}

func (p *Schema)  ReadField18(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 18: ", err)
} else {
  p.Revision = &v
}
  return nil
}

func (p *Schema) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Schema"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
    if err := p.writeField12(ctx, oprot); err != nil { return err }
    if err := p.writeField13(ctx, oprot); err != nil { return err }
    if err := p.writeField14(ctx, oprot); err != nil { return err }
    if err := p.writeField15(ctx, oprot); err != nil { return err }
    if err := p.writeField16(ctx, oprot); err != nil { return err }
    if err := p.writeField17(ctx, oprot); err != nil { return err }
    if err := p.writeField18(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Schema) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCid() {
    if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Cid)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err) }
  }
  return err
}

func (p *Schema) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetColName() {
    if err := oprot.WriteFieldBegin(ctx, "col_name", thrift.STRING, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:col_name: ", p), err) }
    if err := oprot.WriteString(ctx, string(*p.ColName)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.col_name (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:col_name: ", p), err) }
  }
  return err
}

func (p *Schema) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "col_tags", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:col_tags: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.ColTags)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ColTags {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:col_tags: ", p), err) }
  return err
}

func (p *Schema) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetColSeq() {
    if err := oprot.WriteFieldBegin(ctx, "col_seq", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:col_seq: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.ColSeq)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.col_seq (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:col_seq: ", p), err) }
  }
  return err
}

func (p *Schema) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetColType() {
    if err := oprot.WriteFieldBegin(ctx, "col_type", thrift.I32, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:col_type: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.ColType)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.col_type (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:col_type: ", p), err) }
  }
  return err
}

func (p *Schema) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCellVersions() {
    if err := oprot.WriteFieldBegin(ctx, "cell_versions", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:cell_versions: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.CellVersions)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cell_versions (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:cell_versions: ", p), err) }
  }
  return err
}

func (p *Schema) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCellTTL() {
    if err := oprot.WriteFieldBegin(ctx, "cell_ttl", thrift.I32, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:cell_ttl: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.CellTTL)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cell_ttl (7) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:cell_ttl: ", p), err) }
  }
  return err
}

func (p *Schema) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBlkEncoding() {
    if err := oprot.WriteFieldBegin(ctx, "blk_encoding", thrift.I32, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:blk_encoding: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BlkEncoding)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.blk_encoding (8) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:blk_encoding: ", p), err) }
  }
  return err
}

func (p *Schema) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBlkSize() {
    if err := oprot.WriteFieldBegin(ctx, "blk_size", thrift.I32, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:blk_size: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BlkSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.blk_size (9) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:blk_size: ", p), err) }
  }
  return err
}

func (p *Schema) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetBlkCells() {
    if err := oprot.WriteFieldBegin(ctx, "blk_cells", thrift.I32, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:blk_cells: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.BlkCells)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.blk_cells (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:blk_cells: ", p), err) }
  }
  return err
}

func (p *Schema) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCsReplication() {
    if err := oprot.WriteFieldBegin(ctx, "cs_replication", thrift.BYTE, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:cs_replication: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.CsReplication)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cs_replication (11) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:cs_replication: ", p), err) }
  }
  return err
}

func (p *Schema) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCsSize() {
    if err := oprot.WriteFieldBegin(ctx, "cs_size", thrift.I32, 12); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:cs_size: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.CsSize)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cs_size (12) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 12:cs_size: ", p), err) }
  }
  return err
}

func (p *Schema) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCsMax() {
    if err := oprot.WriteFieldBegin(ctx, "cs_max", thrift.BYTE, 13); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:cs_max: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.CsMax)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.cs_max (13) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 13:cs_max: ", p), err) }
  }
  return err
}

func (p *Schema) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLogRolloutRatio() {
    if err := oprot.WriteFieldBegin(ctx, "log_rollout_ratio", thrift.BYTE, 14); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:log_rollout_ratio: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.LogRolloutRatio)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.log_rollout_ratio (14) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 14:log_rollout_ratio: ", p), err) }
  }
  return err
}

func (p *Schema) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLogCompactCointervaling() {
    if err := oprot.WriteFieldBegin(ctx, "log_compact_cointervaling", thrift.BYTE, 15); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:log_compact_cointervaling: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.LogCompactCointervaling)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.log_compact_cointervaling (15) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 15:log_compact_cointervaling: ", p), err) }
  }
  return err
}

func (p *Schema) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLogFragmentPreload() {
    if err := oprot.WriteFieldBegin(ctx, "log_fragment_preload", thrift.BYTE, 16); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:log_fragment_preload: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.LogFragmentPreload)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.log_fragment_preload (16) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 16:log_fragment_preload: ", p), err) }
  }
  return err
}

func (p *Schema) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetCompactPercent() {
    if err := oprot.WriteFieldBegin(ctx, "compact_percent", thrift.BYTE, 17); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:compact_percent: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.CompactPercent)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.compact_percent (17) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 17:compact_percent: ", p), err) }
  }
  return err
}

func (p *Schema) writeField18(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetRevision() {
    if err := oprot.WriteFieldBegin(ctx, "revision", thrift.I64, 18); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:revision: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Revision)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.revision (18) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 18:revision: ", p), err) }
  }
  return err
}

func (p *Schema) Equals(other *Schema) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Cid != other.Cid {
    if p.Cid == nil || other.Cid == nil {
      return false
    }
    if (*p.Cid) != (*other.Cid) { return false }
  }
  if p.ColName != other.ColName {
    if p.ColName == nil || other.ColName == nil {
      return false
    }
    if (*p.ColName) != (*other.ColName) { return false }
  }
  if len(p.ColTags) != len(other.ColTags) { return false }
  for i, _tgt := range p.ColTags {
    _src1 := other.ColTags[i]
    if _tgt != _src1 { return false }
  }
  if p.ColSeq != other.ColSeq {
    if p.ColSeq == nil || other.ColSeq == nil {
      return false
    }
    if (*p.ColSeq) != (*other.ColSeq) { return false }
  }
  if p.ColType != other.ColType {
    if p.ColType == nil || other.ColType == nil {
      return false
    }
    if (*p.ColType) != (*other.ColType) { return false }
  }
  if p.CellVersions != other.CellVersions {
    if p.CellVersions == nil || other.CellVersions == nil {
      return false
    }
    if (*p.CellVersions) != (*other.CellVersions) { return false }
  }
  if p.CellTTL != other.CellTTL {
    if p.CellTTL == nil || other.CellTTL == nil {
      return false
    }
    if (*p.CellTTL) != (*other.CellTTL) { return false }
  }
  if p.BlkEncoding != other.BlkEncoding {
    if p.BlkEncoding == nil || other.BlkEncoding == nil {
      return false
    }
    if (*p.BlkEncoding) != (*other.BlkEncoding) { return false }
  }
  if p.BlkSize != other.BlkSize {
    if p.BlkSize == nil || other.BlkSize == nil {
      return false
    }
    if (*p.BlkSize) != (*other.BlkSize) { return false }
  }
  if p.BlkCells != other.BlkCells {
    if p.BlkCells == nil || other.BlkCells == nil {
      return false
    }
    if (*p.BlkCells) != (*other.BlkCells) { return false }
  }
  if p.CsReplication != other.CsReplication {
    if p.CsReplication == nil || other.CsReplication == nil {
      return false
    }
    if (*p.CsReplication) != (*other.CsReplication) { return false }
  }
  if p.CsSize != other.CsSize {
    if p.CsSize == nil || other.CsSize == nil {
      return false
    }
    if (*p.CsSize) != (*other.CsSize) { return false }
  }
  if p.CsMax != other.CsMax {
    if p.CsMax == nil || other.CsMax == nil {
      return false
    }
    if (*p.CsMax) != (*other.CsMax) { return false }
  }
  if p.LogRolloutRatio != other.LogRolloutRatio {
    if p.LogRolloutRatio == nil || other.LogRolloutRatio == nil {
      return false
    }
    if (*p.LogRolloutRatio) != (*other.LogRolloutRatio) { return false }
  }
  if p.LogCompactCointervaling != other.LogCompactCointervaling {
    if p.LogCompactCointervaling == nil || other.LogCompactCointervaling == nil {
      return false
    }
    if (*p.LogCompactCointervaling) != (*other.LogCompactCointervaling) { return false }
  }
  if p.LogFragmentPreload != other.LogFragmentPreload {
    if p.LogFragmentPreload == nil || other.LogFragmentPreload == nil {
      return false
    }
    if (*p.LogFragmentPreload) != (*other.LogFragmentPreload) { return false }
  }
  if p.CompactPercent != other.CompactPercent {
    if p.CompactPercent == nil || other.CompactPercent == nil {
      return false
    }
    if (*p.CompactPercent) != (*other.CompactPercent) { return false }
  }
  if p.Revision != other.Revision {
    if p.Revision == nil || other.Revision == nil {
      return false
    }
    if (*p.Revision) != (*other.Revision) { return false }
  }
  return true
}

func (p *Schema) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Schema(%+v)", *p)
}

func (p *Schema) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.Schema",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Schema)(nil)

func (p *Schema) Validate() error {
  return nil
}
// The Schema matching Pattern
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - Value: The patern value to match against
type SchemaPattern struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  Value string `thrift:"value,2" db:"value" json:"value"`
}

func NewSchemaPattern() *SchemaPattern {
  return &SchemaPattern{}
}


func (p *SchemaPattern) GetComp() Comp {
  return p.Comp
}

func (p *SchemaPattern) GetValue() string {
  return p.Value
}
func (p *SchemaPattern) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SchemaPattern)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SchemaPattern)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Value = v
}
  return nil
}

func (p *SchemaPattern) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SchemaPattern"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SchemaPattern) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SchemaPattern) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err) }
  return err
}

func (p *SchemaPattern) Equals(other *SchemaPattern) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if p.Value != other.Value { return false }
  return true
}

func (p *SchemaPattern) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SchemaPattern(%+v)", *p)
}

func (p *SchemaPattern) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SchemaPattern",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SchemaPattern)(nil)

func (p *SchemaPattern) Validate() error {
  return nil
}
// The Schema Tags patterns for the SchemaPatterns
// 
// Attributes:
//  - Comp: Logical comparator to Apply, unsupported PF, RE and Vol. kind
//  - Values: The tags patterns to match against schema's column tags
type SchemaTagsPatterns struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  Values []*SchemaPattern `thrift:"values,2" db:"values" json:"values"`
}

func NewSchemaTagsPatterns() *SchemaTagsPatterns {
  return &SchemaTagsPatterns{}
}


func (p *SchemaTagsPatterns) GetComp() Comp {
  return p.Comp
}

func (p *SchemaTagsPatterns) GetValues() []*SchemaPattern {
  return p.Values
}
func (p *SchemaTagsPatterns) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SchemaTagsPatterns)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SchemaTagsPatterns)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SchemaPattern, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
    _elem2 := &SchemaPattern{}
    if err := _elem2.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
    }
    p.Values = append(p.Values, _elem2)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SchemaTagsPatterns) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SchemaTagsPatterns"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SchemaTagsPatterns) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SchemaTagsPatterns) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:values: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:values: ", p), err) }
  return err
}

func (p *SchemaTagsPatterns) Equals(other *SchemaTagsPatterns) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src3 := other.Values[i]
    if !_tgt.Equals(_src3) { return false }
  }
  return true
}

func (p *SchemaTagsPatterns) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SchemaTagsPatterns(%+v)", *p)
}

func (p *SchemaTagsPatterns) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SchemaTagsPatterns",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SchemaTagsPatterns)(nil)

func (p *SchemaTagsPatterns) Validate() error {
  return nil
}
// The Schema Patterns for the SpecSchemas
// 
// Attributes:
//  - Names: The Schema patterns for selecting by Column Name
//  - Tags: The Schema patterns for selecting by Column Tags
type SchemaPatterns struct {
  Names []*SchemaPattern `thrift:"names,1" db:"names" json:"names"`
  Tags *SchemaTagsPatterns `thrift:"tags,2" db:"tags" json:"tags"`
}

func NewSchemaPatterns() *SchemaPatterns {
  return &SchemaPatterns{}
}


func (p *SchemaPatterns) GetNames() []*SchemaPattern {
  return p.Names
}
var SchemaPatterns_Tags_DEFAULT *SchemaTagsPatterns
func (p *SchemaPatterns) GetTags() *SchemaTagsPatterns {
  if !p.IsSetTags() {
    return SchemaPatterns_Tags_DEFAULT
  }
  return p.Tags
}
func (p *SchemaPatterns) IsSetTags() bool {
  return p.Tags != nil
}

func (p *SchemaPatterns) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SchemaPatterns)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SchemaPattern, 0, size)
  p.Names =  tSlice
  for i := 0; i < size; i ++ {
    _elem4 := &SchemaPattern{}
    if err := _elem4.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
    }
    p.Names = append(p.Names, _elem4)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SchemaPatterns)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Tags = &SchemaTagsPatterns{}
  if err := p.Tags.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Tags), err)
  }
  return nil
}

func (p *SchemaPatterns) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SchemaPatterns"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SchemaPatterns) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "names", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:names: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Names)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Names {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:names: ", p), err) }
  return err
}

func (p *SchemaPatterns) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "tags", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tags: ", p), err) }
  if err := p.Tags.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Tags), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tags: ", p), err) }
  return err
}

func (p *SchemaPatterns) Equals(other *SchemaPatterns) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Names) != len(other.Names) { return false }
  for i, _tgt := range p.Names {
    _src5 := other.Names[i]
    if !_tgt.Equals(_src5) { return false }
  }
  if !p.Tags.Equals(other.Tags) { return false }
  return true
}

func (p *SchemaPatterns) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SchemaPatterns(%+v)", *p)
}

func (p *SchemaPatterns) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SchemaPatterns",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SchemaPatterns)(nil)

func (p *SchemaPatterns) Validate() error {
  return nil
}
// The Specs for Schemas for using with list_columns or compact_columns
// 
// Attributes:
//  - Cids: The Column IDs
//  - Names: The Column Names
//  - Patterns: The Schema's selector patterns
type SpecSchemas struct {
  Cids []int64 `thrift:"cids,1" db:"cids" json:"cids"`
  Names []string `thrift:"names,2" db:"names" json:"names"`
  Patterns *SchemaPatterns `thrift:"patterns,3" db:"patterns" json:"patterns"`
}

func NewSpecSchemas() *SpecSchemas {
  return &SpecSchemas{}
}


func (p *SpecSchemas) GetCids() []int64 {
  return p.Cids
}

func (p *SpecSchemas) GetNames() []string {
  return p.Names
}
var SpecSchemas_Patterns_DEFAULT *SchemaPatterns
func (p *SpecSchemas) GetPatterns() *SchemaPatterns {
  if !p.IsSetPatterns() {
    return SpecSchemas_Patterns_DEFAULT
  }
  return p.Patterns
}
func (p *SpecSchemas) IsSetPatterns() bool {
  return p.Patterns != nil
}

func (p *SpecSchemas) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecSchemas)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int64, 0, size)
  p.Cids =  tSlice
  for i := 0; i < size; i ++ {
var _elem6 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem6 = v
}
    p.Cids = append(p.Cids, _elem6)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecSchemas)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]string, 0, size)
  p.Names =  tSlice
  for i := 0; i < size; i ++ {
var _elem7 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem7 = v
}
    p.Names = append(p.Names, _elem7)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecSchemas)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.Patterns = &SchemaPatterns{}
  if err := p.Patterns.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Patterns), err)
  }
  return nil
}

func (p *SpecSchemas) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecSchemas"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecSchemas) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cids", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cids: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.I64, len(p.Cids)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Cids {
    if err := oprot.WriteI64(ctx, int64(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cids: ", p), err) }
  return err
}

func (p *SpecSchemas) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "names", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:names: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Names)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Names {
    if err := oprot.WriteString(ctx, string(v)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:names: ", p), err) }
  return err
}

func (p *SpecSchemas) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "patterns", thrift.STRUCT, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:patterns: ", p), err) }
  if err := p.Patterns.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Patterns), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:patterns: ", p), err) }
  return err
}

func (p *SpecSchemas) Equals(other *SpecSchemas) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Cids) != len(other.Cids) { return false }
  for i, _tgt := range p.Cids {
    _src8 := other.Cids[i]
    if _tgt != _src8 { return false }
  }
  if len(p.Names) != len(other.Names) { return false }
  for i, _tgt := range p.Names {
    _src9 := other.Names[i]
    if _tgt != _src9 { return false }
  }
  if !p.Patterns.Equals(other.Patterns) { return false }
  return true
}

func (p *SpecSchemas) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecSchemas(%+v)", *p)
}

func (p *SpecSchemas) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecSchemas",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecSchemas)(nil)

func (p *SpecSchemas) Validate() error {
  return nil
}
// The Scan Specifications Flags
// 
// Attributes:
//  - Limit: Limit to this number of cells
//  - Offset: Scan from this number of cells Offset on matching Cell-Interval
//  - MaxVersions: Select only this number of Versions of a given Cell-Key
//  - MaxBuffer: return results with reach of this Buffer size in bytes
//  - Options: The options bit by SpecFlagsOpt
type SpecFlags struct {
  Limit *int64 `thrift:"limit,1" db:"limit" json:"limit,omitempty"`
  Offset *int64 `thrift:"offset,2" db:"offset" json:"offset,omitempty"`
  MaxVersions *int32 `thrift:"max_versions,3" db:"max_versions" json:"max_versions,omitempty"`
  MaxBuffer *int32 `thrift:"max_buffer,4" db:"max_buffer" json:"max_buffer,omitempty"`
  Options *int8 `thrift:"options,5" db:"options" json:"options,omitempty"`
}

func NewSpecFlags() *SpecFlags {
  return &SpecFlags{}
}

var SpecFlags_Limit_DEFAULT int64
func (p *SpecFlags) GetLimit() int64 {
  if !p.IsSetLimit() {
    return SpecFlags_Limit_DEFAULT
  }
  return *p.Limit
}
var SpecFlags_Offset_DEFAULT int64
func (p *SpecFlags) GetOffset() int64 {
  if !p.IsSetOffset() {
    return SpecFlags_Offset_DEFAULT
  }
  return *p.Offset
}
var SpecFlags_MaxVersions_DEFAULT int32
func (p *SpecFlags) GetMaxVersions() int32 {
  if !p.IsSetMaxVersions() {
    return SpecFlags_MaxVersions_DEFAULT
  }
  return *p.MaxVersions
}
var SpecFlags_MaxBuffer_DEFAULT int32
func (p *SpecFlags) GetMaxBuffer() int32 {
  if !p.IsSetMaxBuffer() {
    return SpecFlags_MaxBuffer_DEFAULT
  }
  return *p.MaxBuffer
}
var SpecFlags_Options_DEFAULT int8
func (p *SpecFlags) GetOptions() int8 {
  if !p.IsSetOptions() {
    return SpecFlags_Options_DEFAULT
  }
  return *p.Options
}
func (p *SpecFlags) IsSetLimit() bool {
  return p.Limit != nil
}

func (p *SpecFlags) IsSetOffset() bool {
  return p.Offset != nil
}

func (p *SpecFlags) IsSetMaxVersions() bool {
  return p.MaxVersions != nil
}

func (p *SpecFlags) IsSetMaxBuffer() bool {
  return p.MaxBuffer != nil
}

func (p *SpecFlags) IsSetOptions() bool {
  return p.Options != nil
}

func (p *SpecFlags) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecFlags)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Limit = &v
}
  return nil
}

func (p *SpecFlags)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Offset = &v
}
  return nil
}

func (p *SpecFlags)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.MaxVersions = &v
}
  return nil
}

func (p *SpecFlags)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.MaxBuffer = &v
}
  return nil
}

func (p *SpecFlags)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := int8(v)
  p.Options = &temp
}
  return nil
}

func (p *SpecFlags) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecFlags"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecFlags) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetLimit() {
    if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I64, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:limit: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Limit)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.limit (1) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:limit: ", p), err) }
  }
  return err
}

func (p *SpecFlags) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOffset() {
    if err := oprot.WriteFieldBegin(ctx, "offset", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:offset: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Offset)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.offset (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:offset: ", p), err) }
  }
  return err
}

func (p *SpecFlags) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxVersions() {
    if err := oprot.WriteFieldBegin(ctx, "max_versions", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:max_versions: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxVersions)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.max_versions (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:max_versions: ", p), err) }
  }
  return err
}

func (p *SpecFlags) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetMaxBuffer() {
    if err := oprot.WriteFieldBegin(ctx, "max_buffer", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:max_buffer: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.MaxBuffer)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.max_buffer (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:max_buffer: ", p), err) }
  }
  return err
}

func (p *SpecFlags) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOptions() {
    if err := oprot.WriteFieldBegin(ctx, "options", thrift.BYTE, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:options: ", p), err) }
    if err := oprot.WriteByte(ctx, int8(*p.Options)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.options (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:options: ", p), err) }
  }
  return err
}

func (p *SpecFlags) Equals(other *SpecFlags) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Limit != other.Limit {
    if p.Limit == nil || other.Limit == nil {
      return false
    }
    if (*p.Limit) != (*other.Limit) { return false }
  }
  if p.Offset != other.Offset {
    if p.Offset == nil || other.Offset == nil {
      return false
    }
    if (*p.Offset) != (*other.Offset) { return false }
  }
  if p.MaxVersions != other.MaxVersions {
    if p.MaxVersions == nil || other.MaxVersions == nil {
      return false
    }
    if (*p.MaxVersions) != (*other.MaxVersions) { return false }
  }
  if p.MaxBuffer != other.MaxBuffer {
    if p.MaxBuffer == nil || other.MaxBuffer == nil {
      return false
    }
    if (*p.MaxBuffer) != (*other.MaxBuffer) { return false }
  }
  if p.Options != other.Options {
    if p.Options == nil || other.Options == nil {
      return false
    }
    if (*p.Options) != (*other.Options) { return false }
  }
  return true
}

func (p *SpecFlags) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecFlags(%+v)", *p)
}

func (p *SpecFlags) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecFlags",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecFlags)(nil)

func (p *SpecFlags) Validate() error {
  return nil
}
// Attributes:
//  - Op: The Operation of update
//  - Pos: The position/index of INSERT and OVERWRITE update operations
type SpecUpdateOP struct {
  Op UpdateOP `thrift:"op,1" db:"op" json:"op"`
  Pos *int32 `thrift:"pos,2" db:"pos" json:"pos,omitempty"`
}

func NewSpecUpdateOP() *SpecUpdateOP {
  return &SpecUpdateOP{}
}


func (p *SpecUpdateOP) GetOp() UpdateOP {
  return p.Op
}
var SpecUpdateOP_Pos_DEFAULT int32
func (p *SpecUpdateOP) GetPos() int32 {
  if !p.IsSetPos() {
    return SpecUpdateOP_Pos_DEFAULT
  }
  return *p.Pos
}
func (p *SpecUpdateOP) IsSetPos() bool {
  return p.Pos != nil
}

func (p *SpecUpdateOP) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecUpdateOP)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := UpdateOP(v)
  p.Op = temp
}
  return nil
}

func (p *SpecUpdateOP)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Pos = &v
}
  return nil
}

func (p *SpecUpdateOP) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecUpdateOP"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecUpdateOP) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:op: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:op: ", p), err) }
  return err
}

func (p *SpecUpdateOP) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPos() {
    if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:pos: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Pos)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.pos (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:pos: ", p), err) }
  }
  return err
}

func (p *SpecUpdateOP) Equals(other *SpecUpdateOP) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Op != other.Op { return false }
  if p.Pos != other.Pos {
    if p.Pos == nil || other.Pos == nil {
      return false
    }
    if (*p.Pos) != (*other.Pos) { return false }
  }
  return true
}

func (p *SpecUpdateOP) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecUpdateOP(%+v)", *p)
}

func (p *SpecUpdateOP) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecUpdateOP",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecUpdateOP)(nil)

func (p *SpecUpdateOP) Validate() error {
  return nil
}
// The Value specs for an Updating Interval of 'updating' in SpecIntervalPlain
// 
// Attributes:
//  - V: The bytes value for the updated cell
//  - Ts: The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
//  - Encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
//  - UpdateOp: Optionally the operaton of value update
type SpecIntervalUpdatePlain struct {
  V []byte `thrift:"v,1" db:"v" json:"v"`
  Ts *int64 `thrift:"ts,2" db:"ts" json:"ts,omitempty"`
  Encoder *EncodingType `thrift:"encoder,3" db:"encoder" json:"encoder,omitempty"`
  UpdateOp *SpecUpdateOP `thrift:"update_op,4" db:"update_op" json:"update_op,omitempty"`
}

func NewSpecIntervalUpdatePlain() *SpecIntervalUpdatePlain {
  return &SpecIntervalUpdatePlain{}
}


func (p *SpecIntervalUpdatePlain) GetV() []byte {
  return p.V
}
var SpecIntervalUpdatePlain_Ts_DEFAULT int64
func (p *SpecIntervalUpdatePlain) GetTs() int64 {
  if !p.IsSetTs() {
    return SpecIntervalUpdatePlain_Ts_DEFAULT
  }
  return *p.Ts
}
var SpecIntervalUpdatePlain_Encoder_DEFAULT EncodingType
func (p *SpecIntervalUpdatePlain) GetEncoder() EncodingType {
  if !p.IsSetEncoder() {
    return SpecIntervalUpdatePlain_Encoder_DEFAULT
  }
  return *p.Encoder
}
var SpecIntervalUpdatePlain_UpdateOp_DEFAULT *SpecUpdateOP
func (p *SpecIntervalUpdatePlain) GetUpdateOp() *SpecUpdateOP {
  if !p.IsSetUpdateOp() {
    return SpecIntervalUpdatePlain_UpdateOp_DEFAULT
  }
  return p.UpdateOp
}
func (p *SpecIntervalUpdatePlain) IsSetTs() bool {
  return p.Ts != nil
}

func (p *SpecIntervalUpdatePlain) IsSetEncoder() bool {
  return p.Encoder != nil
}

func (p *SpecIntervalUpdatePlain) IsSetUpdateOp() bool {
  return p.UpdateOp != nil
}

func (p *SpecIntervalUpdatePlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecIntervalUpdatePlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *SpecIntervalUpdatePlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = &v
}
  return nil
}

func (p *SpecIntervalUpdatePlain)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  temp := EncodingType(v)
  p.Encoder = &temp
}
  return nil
}

func (p *SpecIntervalUpdatePlain)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.UpdateOp = &SpecUpdateOP{}
  if err := p.UpdateOp.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UpdateOp), err)
  }
  return nil
}

func (p *SpecIntervalUpdatePlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecIntervalUpdatePlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecIntervalUpdatePlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:v: ", p), err) }
  return err
}

func (p *SpecIntervalUpdatePlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTs() {
    if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Ts)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  }
  return err
}

func (p *SpecIntervalUpdatePlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEncoder() {
    if err := oprot.WriteFieldBegin(ctx, "encoder", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:encoder: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Encoder)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.encoder (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:encoder: ", p), err) }
  }
  return err
}

func (p *SpecIntervalUpdatePlain) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateOp() {
    if err := oprot.WriteFieldBegin(ctx, "update_op", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:update_op: ", p), err) }
    if err := p.UpdateOp.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UpdateOp), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:update_op: ", p), err) }
  }
  return err
}

func (p *SpecIntervalUpdatePlain) Equals(other *SpecIntervalUpdatePlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  if p.Ts != other.Ts {
    if p.Ts == nil || other.Ts == nil {
      return false
    }
    if (*p.Ts) != (*other.Ts) { return false }
  }
  if p.Encoder != other.Encoder {
    if p.Encoder == nil || other.Encoder == nil {
      return false
    }
    if (*p.Encoder) != (*other.Encoder) { return false }
  }
  if !p.UpdateOp.Equals(other.UpdateOp) { return false }
  return true
}

func (p *SpecIntervalUpdatePlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecIntervalUpdatePlain(%+v)", *p)
}

func (p *SpecIntervalUpdatePlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecIntervalUpdatePlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalUpdatePlain)(nil)

func (p *SpecIntervalUpdatePlain) Validate() error {
  return nil
}
// The Value specs for an Updating Interval of 'updating' in SpecIntervalCounter
// 
// Attributes:
//  - V: The int64 value for the updated cell
//  - Op: The Opration pf Counter, available: COUNTER_OP_EQUAL
//  - Ts: The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
//  - UpdateOp: Optionally the operaton of value update
type SpecIntervalUpdateCounter struct {
  V int64 `thrift:"v,1" db:"v" json:"v"`
  Op int64 `thrift:"op,2" db:"op" json:"op"`
  Ts *int64 `thrift:"ts,3" db:"ts" json:"ts,omitempty"`
  UpdateOp *SpecUpdateOP `thrift:"update_op,4" db:"update_op" json:"update_op,omitempty"`
}

func NewSpecIntervalUpdateCounter() *SpecIntervalUpdateCounter {
  return &SpecIntervalUpdateCounter{}
}


func (p *SpecIntervalUpdateCounter) GetV() int64 {
  return p.V
}

func (p *SpecIntervalUpdateCounter) GetOp() int64 {
  return p.Op
}
var SpecIntervalUpdateCounter_Ts_DEFAULT int64
func (p *SpecIntervalUpdateCounter) GetTs() int64 {
  if !p.IsSetTs() {
    return SpecIntervalUpdateCounter_Ts_DEFAULT
  }
  return *p.Ts
}
var SpecIntervalUpdateCounter_UpdateOp_DEFAULT *SpecUpdateOP
func (p *SpecIntervalUpdateCounter) GetUpdateOp() *SpecUpdateOP {
  if !p.IsSetUpdateOp() {
    return SpecIntervalUpdateCounter_UpdateOp_DEFAULT
  }
  return p.UpdateOp
}
func (p *SpecIntervalUpdateCounter) IsSetTs() bool {
  return p.Ts != nil
}

func (p *SpecIntervalUpdateCounter) IsSetUpdateOp() bool {
  return p.UpdateOp != nil
}

func (p *SpecIntervalUpdateCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecIntervalUpdateCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *SpecIntervalUpdateCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Op = v
}
  return nil
}

func (p *SpecIntervalUpdateCounter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Ts = &v
}
  return nil
}

func (p *SpecIntervalUpdateCounter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.UpdateOp = &SpecUpdateOP{}
  if err := p.UpdateOp.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UpdateOp), err)
  }
  return nil
}

func (p *SpecIntervalUpdateCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecIntervalUpdateCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecIntervalUpdateCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:v: ", p), err) }
  return err
}

func (p *SpecIntervalUpdateCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err) }
  return err
}

func (p *SpecIntervalUpdateCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTs() {
    if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Ts)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err) }
  }
  return err
}

func (p *SpecIntervalUpdateCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateOp() {
    if err := oprot.WriteFieldBegin(ctx, "update_op", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:update_op: ", p), err) }
    if err := p.UpdateOp.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UpdateOp), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:update_op: ", p), err) }
  }
  return err
}

func (p *SpecIntervalUpdateCounter) Equals(other *SpecIntervalUpdateCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.V != other.V { return false }
  if p.Op != other.Op { return false }
  if p.Ts != other.Ts {
    if p.Ts == nil || other.Ts == nil {
      return false
    }
    if (*p.Ts) != (*other.Ts) { return false }
  }
  if !p.UpdateOp.Equals(other.UpdateOp) { return false }
  return true
}

func (p *SpecIntervalUpdateCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecIntervalUpdateCounter(%+v)", *p)
}

func (p *SpecIntervalUpdateCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecIntervalUpdateCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalUpdateCounter)(nil)

func (p *SpecIntervalUpdateCounter) Validate() error {
  return nil
}
// The Value specs for an Updating Interval of 'updating' in SpecIntervalSerial
// 
// Attributes:
//  - Ts: The timestamp for the updated cell NULL: MIN_INT64-1, AUTO:MIN_INT64-1
//  - V: The values of serial-fields for the updated cell
//  - VOp: The values of serial-fields for the the SERIAL operation update
//  - Encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
//  - UpdateOp: Optionally the operaton of value update
type SpecIntervalUpdateSerial struct {
  Ts int64 `thrift:"ts,1" db:"ts" json:"ts"`
  V []*CellValueSerial `thrift:"v,2" db:"v" json:"v"`
  VOp []*CellValueSerialOp `thrift:"v_op,3" db:"v_op" json:"v_op"`
  Encoder *EncodingType `thrift:"encoder,4" db:"encoder" json:"encoder,omitempty"`
  UpdateOp *SpecUpdateOP `thrift:"update_op,5" db:"update_op" json:"update_op,omitempty"`
}

func NewSpecIntervalUpdateSerial() *SpecIntervalUpdateSerial {
  return &SpecIntervalUpdateSerial{}
}


func (p *SpecIntervalUpdateSerial) GetTs() int64 {
  return p.Ts
}

func (p *SpecIntervalUpdateSerial) GetV() []*CellValueSerial {
  return p.V
}

func (p *SpecIntervalUpdateSerial) GetVOp() []*CellValueSerialOp {
  return p.VOp
}
var SpecIntervalUpdateSerial_Encoder_DEFAULT EncodingType
func (p *SpecIntervalUpdateSerial) GetEncoder() EncodingType {
  if !p.IsSetEncoder() {
    return SpecIntervalUpdateSerial_Encoder_DEFAULT
  }
  return *p.Encoder
}
var SpecIntervalUpdateSerial_UpdateOp_DEFAULT *SpecUpdateOP
func (p *SpecIntervalUpdateSerial) GetUpdateOp() *SpecUpdateOP {
  if !p.IsSetUpdateOp() {
    return SpecIntervalUpdateSerial_UpdateOp_DEFAULT
  }
  return p.UpdateOp
}
func (p *SpecIntervalUpdateSerial) IsSetEncoder() bool {
  return p.Encoder != nil
}

func (p *SpecIntervalUpdateSerial) IsSetUpdateOp() bool {
  return p.UpdateOp != nil
}

func (p *SpecIntervalUpdateSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecIntervalUpdateSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *SpecIntervalUpdateSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CellValueSerial, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem10 := &CellValueSerial{}
    if err := _elem10.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem10), err)
    }
    p.V = append(p.V, _elem10)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalUpdateSerial)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CellValueSerialOp, 0, size)
  p.VOp =  tSlice
  for i := 0; i < size; i ++ {
    _elem11 := &CellValueSerialOp{}
    if err := _elem11.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem11), err)
    }
    p.VOp = append(p.VOp, _elem11)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalUpdateSerial)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := EncodingType(v)
  p.Encoder = &temp
}
  return nil
}

func (p *SpecIntervalUpdateSerial)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.UpdateOp = &SpecUpdateOP{}
  if err := p.UpdateOp.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UpdateOp), err)
  }
  return nil
}

func (p *SpecIntervalUpdateSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecIntervalUpdateSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecIntervalUpdateSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ts: ", p), err) }
  return err
}

func (p *SpecIntervalUpdateSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecIntervalUpdateSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v_op", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v_op: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.VOp)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.VOp {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v_op: ", p), err) }
  return err
}

func (p *SpecIntervalUpdateSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEncoder() {
    if err := oprot.WriteFieldBegin(ctx, "encoder", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:encoder: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Encoder)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.encoder (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:encoder: ", p), err) }
  }
  return err
}

func (p *SpecIntervalUpdateSerial) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdateOp() {
    if err := oprot.WriteFieldBegin(ctx, "update_op", thrift.STRUCT, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:update_op: ", p), err) }
    if err := p.UpdateOp.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UpdateOp), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:update_op: ", p), err) }
  }
  return err
}

func (p *SpecIntervalUpdateSerial) Equals(other *SpecIntervalUpdateSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Ts != other.Ts { return false }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src12 := other.V[i]
    if !_tgt.Equals(_src12) { return false }
  }
  if len(p.VOp) != len(other.VOp) { return false }
  for i, _tgt := range p.VOp {
    _src13 := other.VOp[i]
    if !_tgt.Equals(_src13) { return false }
  }
  if p.Encoder != other.Encoder {
    if p.Encoder == nil || other.Encoder == nil {
      return false
    }
    if (*p.Encoder) != (*other.Encoder) { return false }
  }
  if !p.UpdateOp.Equals(other.UpdateOp) { return false }
  return true
}

func (p *SpecIntervalUpdateSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecIntervalUpdateSerial(%+v)", *p)
}

func (p *SpecIntervalUpdateSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecIntervalUpdateSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalUpdateSerial)(nil)

func (p *SpecIntervalUpdateSerial) Validate() error {
  return nil
}
// The Specifications of INT64 Serial Value Field
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - V: The int64 to match against the value field
type SpecValueSerial_INT64 struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  V int64 `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_INT64() *SpecValueSerial_INT64 {
  return &SpecValueSerial_INT64{}
}


func (p *SpecValueSerial_INT64) GetComp() Comp {
  return p.Comp
}

func (p *SpecValueSerial_INT64) GetV() int64 {
  return p.V
}
func (p *SpecValueSerial_INT64) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueSerial_INT64)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecValueSerial_INT64)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *SpecValueSerial_INT64) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_INT64"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueSerial_INT64) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecValueSerial_INT64) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecValueSerial_INT64) Equals(other *SpecValueSerial_INT64) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if p.V != other.V { return false }
  return true
}

func (p *SpecValueSerial_INT64) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueSerial_INT64(%+v)", *p)
}

func (p *SpecValueSerial_INT64) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueSerial_INT64",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_INT64)(nil)

func (p *SpecValueSerial_INT64) Validate() error {
  return nil
}
// The Specifications of DOUBLE Serial Value Field
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - V: The double to match against the value field
type SpecValueSerial_DOUBLE struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  V float64 `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_DOUBLE() *SpecValueSerial_DOUBLE {
  return &SpecValueSerial_DOUBLE{}
}


func (p *SpecValueSerial_DOUBLE) GetComp() Comp {
  return p.Comp
}

func (p *SpecValueSerial_DOUBLE) GetV() float64 {
  return p.V
}
func (p *SpecValueSerial_DOUBLE) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueSerial_DOUBLE)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecValueSerial_DOUBLE)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *SpecValueSerial_DOUBLE) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_DOUBLE"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueSerial_DOUBLE) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecValueSerial_DOUBLE) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.DOUBLE, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteDouble(ctx, float64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecValueSerial_DOUBLE) Equals(other *SpecValueSerial_DOUBLE) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if p.V != other.V { return false }
  return true
}

func (p *SpecValueSerial_DOUBLE) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueSerial_DOUBLE(%+v)", *p)
}

func (p *SpecValueSerial_DOUBLE) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueSerial_DOUBLE",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_DOUBLE)(nil)

func (p *SpecValueSerial_DOUBLE) Validate() error {
  return nil
}
// The Specifications of BYTES Serial Value Field
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - V: The binary(bytes) to match against the value field
type SpecValueSerial_BYTES struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  V []byte `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_BYTES() *SpecValueSerial_BYTES {
  return &SpecValueSerial_BYTES{}
}


func (p *SpecValueSerial_BYTES) GetComp() Comp {
  return p.Comp
}

func (p *SpecValueSerial_BYTES) GetV() []byte {
  return p.V
}
func (p *SpecValueSerial_BYTES) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueSerial_BYTES)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecValueSerial_BYTES)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *SpecValueSerial_BYTES) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_BYTES"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueSerial_BYTES) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecValueSerial_BYTES) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecValueSerial_BYTES) Equals(other *SpecValueSerial_BYTES) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  return true
}

func (p *SpecValueSerial_BYTES) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueSerial_BYTES(%+v)", *p)
}

func (p *SpecValueSerial_BYTES) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueSerial_BYTES",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_BYTES)(nil)

func (p *SpecValueSerial_BYTES) Validate() error {
  return nil
}
// The Specifications of KEY Serial Value Field
// 
// Attributes:
//  - Seq: The Key Sequence to use
//  - V: The Specification of the Key to match against the value field
type SpecValueSerial_KEY struct {
  Seq KeySeq `thrift:"seq,1" db:"seq" json:"seq"`
  V []*SpecFraction `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_KEY() *SpecValueSerial_KEY {
  return &SpecValueSerial_KEY{}
}


func (p *SpecValueSerial_KEY) GetSeq() KeySeq {
  return p.Seq
}

func (p *SpecValueSerial_KEY) GetV() []*SpecFraction {
  return p.V
}
func (p *SpecValueSerial_KEY) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueSerial_KEY)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := KeySeq(v)
  p.Seq = temp
}
  return nil
}

func (p *SpecValueSerial_KEY)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecFraction, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem14 := &SpecFraction{}
    if err := _elem14.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem14), err)
    }
    p.V = append(p.V, _elem14)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecValueSerial_KEY) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_KEY"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueSerial_KEY) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "seq", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:seq: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Seq)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.seq (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:seq: ", p), err) }
  return err
}

func (p *SpecValueSerial_KEY) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecValueSerial_KEY) Equals(other *SpecValueSerial_KEY) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Seq != other.Seq { return false }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src15 := other.V[i]
    if !_tgt.Equals(_src15) { return false }
  }
  return true
}

func (p *SpecValueSerial_KEY) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueSerial_KEY(%+v)", *p)
}

func (p *SpecValueSerial_KEY) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueSerial_KEY",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_KEY)(nil)

func (p *SpecValueSerial_KEY) Validate() error {
  return nil
}
// The Specifications of LIST_INT64(LI) Serial Value Field
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - V: The List of Int64 to match against the value field
type SpecValueSerial_LI struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  V []*SpecValueSerial_INT64 `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_LI() *SpecValueSerial_LI {
  return &SpecValueSerial_LI{}
}


func (p *SpecValueSerial_LI) GetComp() Comp {
  return p.Comp
}

func (p *SpecValueSerial_LI) GetV() []*SpecValueSerial_INT64 {
  return p.V
}
func (p *SpecValueSerial_LI) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueSerial_LI)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecValueSerial_LI)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecValueSerial_INT64, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem16 := &SpecValueSerial_INT64{}
    if err := _elem16.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem16), err)
    }
    p.V = append(p.V, _elem16)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecValueSerial_LI) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_LI"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueSerial_LI) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecValueSerial_LI) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecValueSerial_LI) Equals(other *SpecValueSerial_LI) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src17 := other.V[i]
    if !_tgt.Equals(_src17) { return false }
  }
  return true
}

func (p *SpecValueSerial_LI) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueSerial_LI(%+v)", *p)
}

func (p *SpecValueSerial_LI) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueSerial_LI",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_LI)(nil)

func (p *SpecValueSerial_LI) Validate() error {
  return nil
}
// The Specifications of LIST_BYTES(LB) Serial Value Field
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - V: The List of Bytes to match against the value field
type SpecValueSerial_LB struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  V []*SpecValueSerial_BYTES `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_LB() *SpecValueSerial_LB {
  return &SpecValueSerial_LB{}
}


func (p *SpecValueSerial_LB) GetComp() Comp {
  return p.Comp
}

func (p *SpecValueSerial_LB) GetV() []*SpecValueSerial_BYTES {
  return p.V
}
func (p *SpecValueSerial_LB) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueSerial_LB)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecValueSerial_LB)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecValueSerial_BYTES, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem18 := &SpecValueSerial_BYTES{}
    if err := _elem18.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem18), err)
    }
    p.V = append(p.V, _elem18)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecValueSerial_LB) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_LB"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueSerial_LB) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecValueSerial_LB) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecValueSerial_LB) Equals(other *SpecValueSerial_LB) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src19 := other.V[i]
    if !_tgt.Equals(_src19) { return false }
  }
  return true
}

func (p *SpecValueSerial_LB) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueSerial_LB(%+v)", *p)
}

func (p *SpecValueSerial_LB) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueSerial_LB",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_LB)(nil)

func (p *SpecValueSerial_LB) Validate() error {
  return nil
}
// Attributes:
//  - FieldID: The Field Id of the Value Field
//  - SpecInt64: The specifications of Int64 for the field
//  - SpecDouble: The specifications of Double for the field
//  - SpecBytes: The specifications of Bytes for the field
//  - SpecKey: The specifications of Cell-Key for the field
//  - SpecLi: The specifications of List Int64 for the field
//  - SpecLb: The specifications of List Bytes for the field
type SpecValueSerialField struct {
  FieldID int32 `thrift:"field_id,1" db:"field_id" json:"field_id"`
  SpecInt64 *SpecValueSerial_INT64 `thrift:"spec_int64,2" db:"spec_int64" json:"spec_int64,omitempty"`
  SpecDouble *SpecValueSerial_DOUBLE `thrift:"spec_double,3" db:"spec_double" json:"spec_double,omitempty"`
  SpecBytes *SpecValueSerial_BYTES `thrift:"spec_bytes,4" db:"spec_bytes" json:"spec_bytes"`
  SpecKey *SpecValueSerial_KEY `thrift:"spec_key,5" db:"spec_key" json:"spec_key"`
  SpecLi *SpecValueSerial_LI `thrift:"spec_li,6" db:"spec_li" json:"spec_li"`
  SpecLb *SpecValueSerial_LB `thrift:"spec_lb,7" db:"spec_lb" json:"spec_lb"`
}

func NewSpecValueSerialField() *SpecValueSerialField {
  return &SpecValueSerialField{}
}


func (p *SpecValueSerialField) GetFieldID() int32 {
  return p.FieldID
}
var SpecValueSerialField_SpecInt64_DEFAULT *SpecValueSerial_INT64
func (p *SpecValueSerialField) GetSpecInt64() *SpecValueSerial_INT64 {
  if !p.IsSetSpecInt64() {
    return SpecValueSerialField_SpecInt64_DEFAULT
  }
  return p.SpecInt64
}
var SpecValueSerialField_SpecDouble_DEFAULT *SpecValueSerial_DOUBLE
func (p *SpecValueSerialField) GetSpecDouble() *SpecValueSerial_DOUBLE {
  if !p.IsSetSpecDouble() {
    return SpecValueSerialField_SpecDouble_DEFAULT
  }
  return p.SpecDouble
}
var SpecValueSerialField_SpecBytes_DEFAULT *SpecValueSerial_BYTES
func (p *SpecValueSerialField) GetSpecBytes() *SpecValueSerial_BYTES {
  if !p.IsSetSpecBytes() {
    return SpecValueSerialField_SpecBytes_DEFAULT
  }
  return p.SpecBytes
}
var SpecValueSerialField_SpecKey_DEFAULT *SpecValueSerial_KEY
func (p *SpecValueSerialField) GetSpecKey() *SpecValueSerial_KEY {
  if !p.IsSetSpecKey() {
    return SpecValueSerialField_SpecKey_DEFAULT
  }
  return p.SpecKey
}
var SpecValueSerialField_SpecLi_DEFAULT *SpecValueSerial_LI
func (p *SpecValueSerialField) GetSpecLi() *SpecValueSerial_LI {
  if !p.IsSetSpecLi() {
    return SpecValueSerialField_SpecLi_DEFAULT
  }
  return p.SpecLi
}
var SpecValueSerialField_SpecLb_DEFAULT *SpecValueSerial_LB
func (p *SpecValueSerialField) GetSpecLb() *SpecValueSerial_LB {
  if !p.IsSetSpecLb() {
    return SpecValueSerialField_SpecLb_DEFAULT
  }
  return p.SpecLb
}
func (p *SpecValueSerialField) IsSetSpecInt64() bool {
  return p.SpecInt64 != nil
}

func (p *SpecValueSerialField) IsSetSpecDouble() bool {
  return p.SpecDouble != nil
}

func (p *SpecValueSerialField) IsSetSpecBytes() bool {
  return p.SpecBytes != nil
}

func (p *SpecValueSerialField) IsSetSpecKey() bool {
  return p.SpecKey != nil
}

func (p *SpecValueSerialField) IsSetSpecLi() bool {
  return p.SpecLi != nil
}

func (p *SpecValueSerialField) IsSetSpecLb() bool {
  return p.SpecLb != nil
}

func (p *SpecValueSerialField) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueSerialField)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FieldID = v
}
  return nil
}

func (p *SpecValueSerialField)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.SpecInt64 = &SpecValueSerial_INT64{}
  if err := p.SpecInt64.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SpecInt64), err)
  }
  return nil
}

func (p *SpecValueSerialField)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.SpecDouble = &SpecValueSerial_DOUBLE{}
  if err := p.SpecDouble.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SpecDouble), err)
  }
  return nil
}

func (p *SpecValueSerialField)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.SpecBytes = &SpecValueSerial_BYTES{}
  if err := p.SpecBytes.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SpecBytes), err)
  }
  return nil
}

func (p *SpecValueSerialField)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  p.SpecKey = &SpecValueSerial_KEY{}
  if err := p.SpecKey.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SpecKey), err)
  }
  return nil
}

func (p *SpecValueSerialField)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.SpecLi = &SpecValueSerial_LI{}
  if err := p.SpecLi.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SpecLi), err)
  }
  return nil
}

func (p *SpecValueSerialField)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.SpecLb = &SpecValueSerial_LB{}
  if err := p.SpecLb.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SpecLb), err)
  }
  return nil
}

func (p *SpecValueSerialField) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueSerialField"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueSerialField) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "field_id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field_id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.FieldID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.field_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field_id: ", p), err) }
  return err
}

func (p *SpecValueSerialField) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSpecInt64() {
    if err := oprot.WriteFieldBegin(ctx, "spec_int64", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:spec_int64: ", p), err) }
    if err := p.SpecInt64.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SpecInt64), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:spec_int64: ", p), err) }
  }
  return err
}

func (p *SpecValueSerialField) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSpecDouble() {
    if err := oprot.WriteFieldBegin(ctx, "spec_double", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:spec_double: ", p), err) }
    if err := p.SpecDouble.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SpecDouble), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:spec_double: ", p), err) }
  }
  return err
}

func (p *SpecValueSerialField) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec_bytes", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:spec_bytes: ", p), err) }
  if err := p.SpecBytes.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SpecBytes), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:spec_bytes: ", p), err) }
  return err
}

func (p *SpecValueSerialField) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec_key", thrift.STRUCT, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:spec_key: ", p), err) }
  if err := p.SpecKey.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SpecKey), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:spec_key: ", p), err) }
  return err
}

func (p *SpecValueSerialField) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec_li", thrift.STRUCT, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:spec_li: ", p), err) }
  if err := p.SpecLi.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SpecLi), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:spec_li: ", p), err) }
  return err
}

func (p *SpecValueSerialField) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec_lb", thrift.STRUCT, 7); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:spec_lb: ", p), err) }
  if err := p.SpecLb.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SpecLb), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 7:spec_lb: ", p), err) }
  return err
}

func (p *SpecValueSerialField) Equals(other *SpecValueSerialField) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.FieldID != other.FieldID { return false }
  if !p.SpecInt64.Equals(other.SpecInt64) { return false }
  if !p.SpecDouble.Equals(other.SpecDouble) { return false }
  if !p.SpecBytes.Equals(other.SpecBytes) { return false }
  if !p.SpecKey.Equals(other.SpecKey) { return false }
  if !p.SpecLi.Equals(other.SpecLi) { return false }
  if !p.SpecLb.Equals(other.SpecLb) { return false }
  return true
}

func (p *SpecValueSerialField) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueSerialField(%+v)", *p)
}

func (p *SpecValueSerialField) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueSerialField",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerialField)(nil)

func (p *SpecValueSerialField) Validate() error {
  return nil
}
// The Plain Value Specifications, option to use with Extended Logical Comparators
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - V: The binary(bytes) to match against the Cell value
type SpecValuePlain struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  V []byte `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValuePlain() *SpecValuePlain {
  return &SpecValuePlain{}
}


func (p *SpecValuePlain) GetComp() Comp {
  return p.Comp
}

func (p *SpecValuePlain) GetV() []byte {
  return p.V
}
func (p *SpecValuePlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValuePlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecValuePlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *SpecValuePlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValuePlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValuePlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecValuePlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecValuePlain) Equals(other *SpecValuePlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  return true
}

func (p *SpecValuePlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValuePlain(%+v)", *p)
}

func (p *SpecValuePlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValuePlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValuePlain)(nil)

func (p *SpecValuePlain) Validate() error {
  return nil
}
// The Counter Value Specifications, option to use with Extended Logical Comparators
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - V: The int64 to match against the Cell value
type SpecValueCounter struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  V int64 `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueCounter() *SpecValueCounter {
  return &SpecValueCounter{}
}


func (p *SpecValueCounter) GetComp() Comp {
  return p.Comp
}

func (p *SpecValueCounter) GetV() int64 {
  return p.V
}
func (p *SpecValueCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecValueCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *SpecValueCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecValueCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err) }
  return err
}

func (p *SpecValueCounter) Equals(other *SpecValueCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if p.V != other.V { return false }
  return true
}

func (p *SpecValueCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueCounter(%+v)", *p)
}

func (p *SpecValueCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueCounter)(nil)

func (p *SpecValueCounter) Validate() error {
  return nil
}
// The Serial Value Specifications
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - Fields: The Serial Value Specifications to match against the SERIAL Cell value fields
type SpecValueSerial struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  Fields SpecValueSerialFields `thrift:"fields,2" db:"fields" json:"fields"`
}

func NewSpecValueSerial() *SpecValueSerial {
  return &SpecValueSerial{}
}


func (p *SpecValueSerial) GetComp() Comp {
  return p.Comp
}

func (p *SpecValueSerial) GetFields() SpecValueSerialFields {
  return p.Fields
}
func (p *SpecValueSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecValueSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecValueSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecValueSerialFields, 0, size)
  p.Fields =  tSlice
  for i := 0; i < size; i ++ {
    _elem20 := &SpecValueSerialField{}
    if err := _elem20.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem20), err)
    }
    p.Fields = append(p.Fields, _elem20)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecValueSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecValueSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecValueSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecValueSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "fields", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:fields: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Fields)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Fields {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:fields: ", p), err) }
  return err
}

func (p *SpecValueSerial) Equals(other *SpecValueSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if len(p.Fields) != len(other.Fields) { return false }
  for i, _tgt := range p.Fields {
    _src21 := other.Fields[i]
    if !_tgt.Equals(_src21) { return false }
  }
  return true
}

func (p *SpecValueSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecValueSerial(%+v)", *p)
}

func (p *SpecValueSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecValueSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial)(nil)

func (p *SpecValueSerial) Validate() error {
  return nil
}
// The Fraction Specifications
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - F: The binary(bytes) to match against a fraction of a Cell-Key
type SpecFraction struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  F []byte `thrift:"f,2" db:"f" json:"f"`
}

func NewSpecFraction() *SpecFraction {
  return &SpecFraction{}
}


func (p *SpecFraction) GetComp() Comp {
  return p.Comp
}

func (p *SpecFraction) GetF() []byte {
  return p.F
}
func (p *SpecFraction) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecFraction)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecFraction)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.F = v
}
  return nil
}

func (p *SpecFraction) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecFraction"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecFraction) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecFraction) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "f", thrift.STRING, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:f: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.F); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.f (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:f: ", p), err) }
  return err
}

func (p *SpecFraction) Equals(other *SpecFraction) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if bytes.Compare(p.F, other.F) != 0 { return false }
  return true
}

func (p *SpecFraction) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecFraction(%+v)", *p)
}

func (p *SpecFraction) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecFraction",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecFraction)(nil)

func (p *SpecFraction) Validate() error {
  return nil
}
// The Timestamp Specifications
// 
// Attributes:
//  - Comp: Logical comparator to Apply
//  - Ts: The timestamp in nanoseconds to match against the Cell timestamp/version (not the revision)
type SpecTimestamp struct {
  Comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
}

func NewSpecTimestamp() *SpecTimestamp {
  return &SpecTimestamp{}
}


func (p *SpecTimestamp) GetComp() Comp {
  return p.Comp
}

func (p *SpecTimestamp) GetTs() int64 {
  return p.Ts
}
func (p *SpecTimestamp) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecTimestamp)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Comp(v)
  p.Comp = temp
}
  return nil
}

func (p *SpecTimestamp)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *SpecTimestamp) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecTimestamp"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecTimestamp) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Comp)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err) }
  return err
}

func (p *SpecTimestamp) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *SpecTimestamp) Equals(other *SpecTimestamp) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Comp != other.Comp { return false }
  if p.Ts != other.Ts { return false }
  return true
}

func (p *SpecTimestamp) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecTimestamp(%+v)", *p)
}

func (p *SpecTimestamp) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecTimestamp",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecTimestamp)(nil)

func (p *SpecTimestamp) Validate() error {
  return nil
}
// The Key Interval Specifications
// 
// Attributes:
//  - Start: The Key Start Spec, the start of cells-interval key match
//  - Finish: The Key Finish Spec, the finish of cells-interval key match
type SpecKeyInterval struct {
  Start SpecKey `thrift:"start,1" db:"start" json:"start"`
  Finish SpecKey `thrift:"finish,2" db:"finish" json:"finish"`
}

func NewSpecKeyInterval() *SpecKeyInterval {
  return &SpecKeyInterval{}
}


func (p *SpecKeyInterval) GetStart() SpecKey {
  return p.Start
}

func (p *SpecKeyInterval) GetFinish() SpecKey {
  return p.Finish
}
func (p *SpecKeyInterval) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecKeyInterval)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecKey, 0, size)
  p.Start =  tSlice
  for i := 0; i < size; i ++ {
    _elem22 := &SpecFraction{}
    if err := _elem22.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem22), err)
    }
    p.Start = append(p.Start, _elem22)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecKeyInterval)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecKey, 0, size)
  p.Finish =  tSlice
  for i := 0; i < size; i ++ {
    _elem23 := &SpecFraction{}
    if err := _elem23.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem23), err)
    }
    p.Finish = append(p.Finish, _elem23)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecKeyInterval) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecKeyInterval"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecKeyInterval) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "start", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Start)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Start {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start: ", p), err) }
  return err
}

func (p *SpecKeyInterval) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "finish", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:finish: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Finish)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Finish {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:finish: ", p), err) }
  return err
}

func (p *SpecKeyInterval) Equals(other *SpecKeyInterval) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Start) != len(other.Start) { return false }
  for i, _tgt := range p.Start {
    _src24 := other.Start[i]
    if !_tgt.Equals(_src24) { return false }
  }
  if len(p.Finish) != len(other.Finish) { return false }
  for i, _tgt := range p.Finish {
    _src25 := other.Finish[i]
    if !_tgt.Equals(_src25) { return false }
  }
  return true
}

func (p *SpecKeyInterval) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecKeyInterval(%+v)", *p)
}

func (p *SpecKeyInterval) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecKeyInterval",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecKeyInterval)(nil)

func (p *SpecKeyInterval) Validate() error {
  return nil
}
// The Cells Interval Plain type Specifications with interval-scope Flags
// 
// Attributes:
//  - RangeBegin: Begin of Ranges evaluation with this Key inclusive
//  - RangeEnd: End of Ranges evaluation with this Key inclusive
//  - OffsetKey: Offset Cell Key of a Scan, select cells from this key inclusive
//  - OffsetRev: Offset Cell Timestamp of a Scan, select cells after this timestamp
//  - KeyIntervals: The Key Intervals
//  - Values: The Cell Value Specifications, cell-value match for plain type
//  - TsStart: The Timestamp Start Spec, the start of cells-interval timestamp match
//  - TsFinish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
//  - Flags: The Interval Flags Specification
//  - Options: The Interval Options Specification
//  - Updating: The Value spec of an Updating Interval
type SpecIntervalPlain struct {
  RangeBegin Key `thrift:"range_begin,1" db:"range_begin" json:"range_begin"`
  RangeEnd Key `thrift:"range_end,2" db:"range_end" json:"range_end"`
  OffsetKey Key `thrift:"offset_key,3" db:"offset_key" json:"offset_key"`
  OffsetRev *int64 `thrift:"offset_rev,4" db:"offset_rev" json:"offset_rev,omitempty"`
  KeyIntervals SpecKeyIntervals `thrift:"key_intervals,5" db:"key_intervals" json:"key_intervals"`
  Values SpecValuesPlain `thrift:"values,6" db:"values" json:"values"`
  TsStart *SpecTimestamp `thrift:"ts_start,7" db:"ts_start" json:"ts_start,omitempty"`
  TsFinish *SpecTimestamp `thrift:"ts_finish,8" db:"ts_finish" json:"ts_finish,omitempty"`
  Flags *SpecFlags `thrift:"flags,9" db:"flags" json:"flags,omitempty"`
  Options *SpecIntervalOptions `thrift:"options,10" db:"options" json:"options,omitempty"`
  Updating *SpecIntervalUpdatePlain `thrift:"updating,11" db:"updating" json:"updating,omitempty"`
}

func NewSpecIntervalPlain() *SpecIntervalPlain {
  return &SpecIntervalPlain{}
}


func (p *SpecIntervalPlain) GetRangeBegin() Key {
  return p.RangeBegin
}

func (p *SpecIntervalPlain) GetRangeEnd() Key {
  return p.RangeEnd
}

func (p *SpecIntervalPlain) GetOffsetKey() Key {
  return p.OffsetKey
}
var SpecIntervalPlain_OffsetRev_DEFAULT int64
func (p *SpecIntervalPlain) GetOffsetRev() int64 {
  if !p.IsSetOffsetRev() {
    return SpecIntervalPlain_OffsetRev_DEFAULT
  }
  return *p.OffsetRev
}

func (p *SpecIntervalPlain) GetKeyIntervals() SpecKeyIntervals {
  return p.KeyIntervals
}

func (p *SpecIntervalPlain) GetValues() SpecValuesPlain {
  return p.Values
}
var SpecIntervalPlain_TsStart_DEFAULT *SpecTimestamp
func (p *SpecIntervalPlain) GetTsStart() *SpecTimestamp {
  if !p.IsSetTsStart() {
    return SpecIntervalPlain_TsStart_DEFAULT
  }
  return p.TsStart
}
var SpecIntervalPlain_TsFinish_DEFAULT *SpecTimestamp
func (p *SpecIntervalPlain) GetTsFinish() *SpecTimestamp {
  if !p.IsSetTsFinish() {
    return SpecIntervalPlain_TsFinish_DEFAULT
  }
  return p.TsFinish
}
var SpecIntervalPlain_Flags_DEFAULT *SpecFlags
func (p *SpecIntervalPlain) GetFlags() *SpecFlags {
  if !p.IsSetFlags() {
    return SpecIntervalPlain_Flags_DEFAULT
  }
  return p.Flags
}
var SpecIntervalPlain_Options_DEFAULT SpecIntervalOptions
func (p *SpecIntervalPlain) GetOptions() SpecIntervalOptions {
  if !p.IsSetOptions() {
    return SpecIntervalPlain_Options_DEFAULT
  }
  return *p.Options
}
var SpecIntervalPlain_Updating_DEFAULT *SpecIntervalUpdatePlain
func (p *SpecIntervalPlain) GetUpdating() *SpecIntervalUpdatePlain {
  if !p.IsSetUpdating() {
    return SpecIntervalPlain_Updating_DEFAULT
  }
  return p.Updating
}
func (p *SpecIntervalPlain) IsSetOffsetRev() bool {
  return p.OffsetRev != nil
}

func (p *SpecIntervalPlain) IsSetTsStart() bool {
  return p.TsStart != nil
}

func (p *SpecIntervalPlain) IsSetTsFinish() bool {
  return p.TsFinish != nil
}

func (p *SpecIntervalPlain) IsSetFlags() bool {
  return p.Flags != nil
}

func (p *SpecIntervalPlain) IsSetOptions() bool {
  return p.Options != nil
}

func (p *SpecIntervalPlain) IsSetUpdating() bool {
  return p.Updating != nil
}

func (p *SpecIntervalPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.RangeBegin =  tSlice
  for i := 0; i < size; i ++ {
var _elem26 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem26 = v
}
    p.RangeBegin = append(p.RangeBegin, _elem26)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.RangeEnd =  tSlice
  for i := 0; i < size; i ++ {
var _elem27 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem27 = v
}
    p.RangeEnd = append(p.RangeEnd, _elem27)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.OffsetKey =  tSlice
  for i := 0; i < size; i ++ {
var _elem28 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem28 = v
}
    p.OffsetKey = append(p.OffsetKey, _elem28)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.OffsetRev = &v
}
  return nil
}

func (p *SpecIntervalPlain)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecKeyIntervals, 0, size)
  p.KeyIntervals =  tSlice
  for i := 0; i < size; i ++ {
    _elem29 := &SpecKeyInterval{}
    if err := _elem29.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem29), err)
    }
    p.KeyIntervals = append(p.KeyIntervals, _elem29)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecValuesPlain, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
    _elem30 := &SpecValuePlain{}
    if err := _elem30.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem30), err)
    }
    p.Values = append(p.Values, _elem30)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.TsStart = &SpecTimestamp{}
  if err := p.TsStart.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TsStart), err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  p.TsFinish = &SpecTimestamp{}
  if err := p.TsFinish.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TsFinish), err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  p.Flags = &SpecFlags{}
  if err := p.Flags.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Flags), err)
  }
  return nil
}

func (p *SpecIntervalPlain)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  temp := SpecIntervalOptions(v)
  p.Options = &temp
}
  return nil
}

func (p *SpecIntervalPlain)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  p.Updating = &SpecIntervalUpdatePlain{}
  if err := p.Updating.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Updating), err)
  }
  return nil
}

func (p *SpecIntervalPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecIntervalPlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecIntervalPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "range_begin", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:range_begin: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.RangeBegin)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.RangeBegin {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:range_begin: ", p), err) }
  return err
}

func (p *SpecIntervalPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "range_end", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:range_end: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.RangeEnd)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.RangeEnd {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:range_end: ", p), err) }
  return err
}

func (p *SpecIntervalPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "offset_key", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:offset_key: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.OffsetKey)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.OffsetKey {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:offset_key: ", p), err) }
  return err
}

func (p *SpecIntervalPlain) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOffsetRev() {
    if err := oprot.WriteFieldBegin(ctx, "offset_rev", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:offset_rev: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.OffsetRev)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.offset_rev (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:offset_rev: ", p), err) }
  }
  return err
}

func (p *SpecIntervalPlain) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key_intervals", thrift.LIST, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:key_intervals: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.KeyIntervals)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.KeyIntervals {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:key_intervals: ", p), err) }
  return err
}

func (p *SpecIntervalPlain) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:values: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:values: ", p), err) }
  return err
}

func (p *SpecIntervalPlain) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsStart() {
    if err := oprot.WriteFieldBegin(ctx, "ts_start", thrift.STRUCT, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:ts_start: ", p), err) }
    if err := p.TsStart.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TsStart), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:ts_start: ", p), err) }
  }
  return err
}

func (p *SpecIntervalPlain) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsFinish() {
    if err := oprot.WriteFieldBegin(ctx, "ts_finish", thrift.STRUCT, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:ts_finish: ", p), err) }
    if err := p.TsFinish.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TsFinish), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:ts_finish: ", p), err) }
  }
  return err
}

func (p *SpecIntervalPlain) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFlags() {
    if err := oprot.WriteFieldBegin(ctx, "flags", thrift.STRUCT, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:flags: ", p), err) }
    if err := p.Flags.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Flags), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:flags: ", p), err) }
  }
  return err
}

func (p *SpecIntervalPlain) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOptions() {
    if err := oprot.WriteFieldBegin(ctx, "options", thrift.I32, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:options: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Options)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.options (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:options: ", p), err) }
  }
  return err
}

func (p *SpecIntervalPlain) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdating() {
    if err := oprot.WriteFieldBegin(ctx, "updating", thrift.STRUCT, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:updating: ", p), err) }
    if err := p.Updating.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Updating), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:updating: ", p), err) }
  }
  return err
}

func (p *SpecIntervalPlain) Equals(other *SpecIntervalPlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.RangeBegin) != len(other.RangeBegin) { return false }
  for i, _tgt := range p.RangeBegin {
    _src31 := other.RangeBegin[i]
    if bytes.Compare(_tgt, _src31) != 0 { return false }
  }
  if len(p.RangeEnd) != len(other.RangeEnd) { return false }
  for i, _tgt := range p.RangeEnd {
    _src32 := other.RangeEnd[i]
    if bytes.Compare(_tgt, _src32) != 0 { return false }
  }
  if len(p.OffsetKey) != len(other.OffsetKey) { return false }
  for i, _tgt := range p.OffsetKey {
    _src33 := other.OffsetKey[i]
    if bytes.Compare(_tgt, _src33) != 0 { return false }
  }
  if p.OffsetRev != other.OffsetRev {
    if p.OffsetRev == nil || other.OffsetRev == nil {
      return false
    }
    if (*p.OffsetRev) != (*other.OffsetRev) { return false }
  }
  if len(p.KeyIntervals) != len(other.KeyIntervals) { return false }
  for i, _tgt := range p.KeyIntervals {
    _src34 := other.KeyIntervals[i]
    if !_tgt.Equals(_src34) { return false }
  }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src35 := other.Values[i]
    if !_tgt.Equals(_src35) { return false }
  }
  if !p.TsStart.Equals(other.TsStart) { return false }
  if !p.TsFinish.Equals(other.TsFinish) { return false }
  if !p.Flags.Equals(other.Flags) { return false }
  if p.Options != other.Options {
    if p.Options == nil || other.Options == nil {
      return false
    }
    if (*p.Options) != (*other.Options) { return false }
  }
  if !p.Updating.Equals(other.Updating) { return false }
  return true
}

func (p *SpecIntervalPlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecIntervalPlain(%+v)", *p)
}

func (p *SpecIntervalPlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecIntervalPlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalPlain)(nil)

func (p *SpecIntervalPlain) Validate() error {
  return nil
}
// The Cells Interval Counter type Specifications with interval-scope Flags
// 
// Attributes:
//  - RangeBegin: Begin of Ranges evaluation with this Key inclusive
//  - RangeEnd: End of Ranges evaluation with this Key inclusive
//  - OffsetKey: Offset Cell Key of a Scan, select cells from this key inclusive
//  - OffsetRev: Offset Cell Timestamp of a Scan, select cells after this timestamp
//  - KeyIntervals: The Key Intervals
//  - Values: The Cell Value Specifications, cell-value match for counter type
//  - TsStart: The Timestamp Start Spec, the start of cells-interval timestamp match
//  - TsFinish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
//  - Flags: The Interval Flags Specification
//  - Options: The Interval Options Specification
//  - Updating: The Value spec of an Updating Interval
type SpecIntervalCounter struct {
  RangeBegin Key `thrift:"range_begin,1" db:"range_begin" json:"range_begin"`
  RangeEnd Key `thrift:"range_end,2" db:"range_end" json:"range_end"`
  OffsetKey Key `thrift:"offset_key,3" db:"offset_key" json:"offset_key"`
  OffsetRev *int64 `thrift:"offset_rev,4" db:"offset_rev" json:"offset_rev,omitempty"`
  KeyIntervals SpecKeyIntervals `thrift:"key_intervals,5" db:"key_intervals" json:"key_intervals"`
  Values SpecValuesCounter `thrift:"values,6" db:"values" json:"values"`
  TsStart *SpecTimestamp `thrift:"ts_start,7" db:"ts_start" json:"ts_start,omitempty"`
  TsFinish *SpecTimestamp `thrift:"ts_finish,8" db:"ts_finish" json:"ts_finish,omitempty"`
  Flags *SpecFlags `thrift:"flags,9" db:"flags" json:"flags,omitempty"`
  Options *SpecIntervalOptions `thrift:"options,10" db:"options" json:"options,omitempty"`
  Updating *SpecIntervalUpdateCounter `thrift:"updating,11" db:"updating" json:"updating,omitempty"`
}

func NewSpecIntervalCounter() *SpecIntervalCounter {
  return &SpecIntervalCounter{}
}


func (p *SpecIntervalCounter) GetRangeBegin() Key {
  return p.RangeBegin
}

func (p *SpecIntervalCounter) GetRangeEnd() Key {
  return p.RangeEnd
}

func (p *SpecIntervalCounter) GetOffsetKey() Key {
  return p.OffsetKey
}
var SpecIntervalCounter_OffsetRev_DEFAULT int64
func (p *SpecIntervalCounter) GetOffsetRev() int64 {
  if !p.IsSetOffsetRev() {
    return SpecIntervalCounter_OffsetRev_DEFAULT
  }
  return *p.OffsetRev
}

func (p *SpecIntervalCounter) GetKeyIntervals() SpecKeyIntervals {
  return p.KeyIntervals
}

func (p *SpecIntervalCounter) GetValues() SpecValuesCounter {
  return p.Values
}
var SpecIntervalCounter_TsStart_DEFAULT *SpecTimestamp
func (p *SpecIntervalCounter) GetTsStart() *SpecTimestamp {
  if !p.IsSetTsStart() {
    return SpecIntervalCounter_TsStart_DEFAULT
  }
  return p.TsStart
}
var SpecIntervalCounter_TsFinish_DEFAULT *SpecTimestamp
func (p *SpecIntervalCounter) GetTsFinish() *SpecTimestamp {
  if !p.IsSetTsFinish() {
    return SpecIntervalCounter_TsFinish_DEFAULT
  }
  return p.TsFinish
}
var SpecIntervalCounter_Flags_DEFAULT *SpecFlags
func (p *SpecIntervalCounter) GetFlags() *SpecFlags {
  if !p.IsSetFlags() {
    return SpecIntervalCounter_Flags_DEFAULT
  }
  return p.Flags
}
var SpecIntervalCounter_Options_DEFAULT SpecIntervalOptions
func (p *SpecIntervalCounter) GetOptions() SpecIntervalOptions {
  if !p.IsSetOptions() {
    return SpecIntervalCounter_Options_DEFAULT
  }
  return *p.Options
}
var SpecIntervalCounter_Updating_DEFAULT *SpecIntervalUpdateCounter
func (p *SpecIntervalCounter) GetUpdating() *SpecIntervalUpdateCounter {
  if !p.IsSetUpdating() {
    return SpecIntervalCounter_Updating_DEFAULT
  }
  return p.Updating
}
func (p *SpecIntervalCounter) IsSetOffsetRev() bool {
  return p.OffsetRev != nil
}

func (p *SpecIntervalCounter) IsSetTsStart() bool {
  return p.TsStart != nil
}

func (p *SpecIntervalCounter) IsSetTsFinish() bool {
  return p.TsFinish != nil
}

func (p *SpecIntervalCounter) IsSetFlags() bool {
  return p.Flags != nil
}

func (p *SpecIntervalCounter) IsSetOptions() bool {
  return p.Options != nil
}

func (p *SpecIntervalCounter) IsSetUpdating() bool {
  return p.Updating != nil
}

func (p *SpecIntervalCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.RangeBegin =  tSlice
  for i := 0; i < size; i ++ {
var _elem36 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem36 = v
}
    p.RangeBegin = append(p.RangeBegin, _elem36)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.RangeEnd =  tSlice
  for i := 0; i < size; i ++ {
var _elem37 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem37 = v
}
    p.RangeEnd = append(p.RangeEnd, _elem37)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.OffsetKey =  tSlice
  for i := 0; i < size; i ++ {
var _elem38 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem38 = v
}
    p.OffsetKey = append(p.OffsetKey, _elem38)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.OffsetRev = &v
}
  return nil
}

func (p *SpecIntervalCounter)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecKeyIntervals, 0, size)
  p.KeyIntervals =  tSlice
  for i := 0; i < size; i ++ {
    _elem39 := &SpecKeyInterval{}
    if err := _elem39.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem39), err)
    }
    p.KeyIntervals = append(p.KeyIntervals, _elem39)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecValuesCounter, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
    _elem40 := &SpecValueCounter{}
    if err := _elem40.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem40), err)
    }
    p.Values = append(p.Values, _elem40)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.TsStart = &SpecTimestamp{}
  if err := p.TsStart.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TsStart), err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  p.TsFinish = &SpecTimestamp{}
  if err := p.TsFinish.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TsFinish), err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  p.Flags = &SpecFlags{}
  if err := p.Flags.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Flags), err)
  }
  return nil
}

func (p *SpecIntervalCounter)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  temp := SpecIntervalOptions(v)
  p.Options = &temp
}
  return nil
}

func (p *SpecIntervalCounter)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  p.Updating = &SpecIntervalUpdateCounter{}
  if err := p.Updating.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Updating), err)
  }
  return nil
}

func (p *SpecIntervalCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecIntervalCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecIntervalCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "range_begin", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:range_begin: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.RangeBegin)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.RangeBegin {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:range_begin: ", p), err) }
  return err
}

func (p *SpecIntervalCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "range_end", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:range_end: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.RangeEnd)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.RangeEnd {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:range_end: ", p), err) }
  return err
}

func (p *SpecIntervalCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "offset_key", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:offset_key: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.OffsetKey)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.OffsetKey {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:offset_key: ", p), err) }
  return err
}

func (p *SpecIntervalCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOffsetRev() {
    if err := oprot.WriteFieldBegin(ctx, "offset_rev", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:offset_rev: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.OffsetRev)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.offset_rev (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:offset_rev: ", p), err) }
  }
  return err
}

func (p *SpecIntervalCounter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key_intervals", thrift.LIST, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:key_intervals: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.KeyIntervals)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.KeyIntervals {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:key_intervals: ", p), err) }
  return err
}

func (p *SpecIntervalCounter) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:values: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:values: ", p), err) }
  return err
}

func (p *SpecIntervalCounter) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsStart() {
    if err := oprot.WriteFieldBegin(ctx, "ts_start", thrift.STRUCT, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:ts_start: ", p), err) }
    if err := p.TsStart.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TsStart), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:ts_start: ", p), err) }
  }
  return err
}

func (p *SpecIntervalCounter) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsFinish() {
    if err := oprot.WriteFieldBegin(ctx, "ts_finish", thrift.STRUCT, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:ts_finish: ", p), err) }
    if err := p.TsFinish.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TsFinish), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:ts_finish: ", p), err) }
  }
  return err
}

func (p *SpecIntervalCounter) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFlags() {
    if err := oprot.WriteFieldBegin(ctx, "flags", thrift.STRUCT, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:flags: ", p), err) }
    if err := p.Flags.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Flags), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:flags: ", p), err) }
  }
  return err
}

func (p *SpecIntervalCounter) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOptions() {
    if err := oprot.WriteFieldBegin(ctx, "options", thrift.I32, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:options: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Options)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.options (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:options: ", p), err) }
  }
  return err
}

func (p *SpecIntervalCounter) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdating() {
    if err := oprot.WriteFieldBegin(ctx, "updating", thrift.STRUCT, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:updating: ", p), err) }
    if err := p.Updating.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Updating), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:updating: ", p), err) }
  }
  return err
}

func (p *SpecIntervalCounter) Equals(other *SpecIntervalCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.RangeBegin) != len(other.RangeBegin) { return false }
  for i, _tgt := range p.RangeBegin {
    _src41 := other.RangeBegin[i]
    if bytes.Compare(_tgt, _src41) != 0 { return false }
  }
  if len(p.RangeEnd) != len(other.RangeEnd) { return false }
  for i, _tgt := range p.RangeEnd {
    _src42 := other.RangeEnd[i]
    if bytes.Compare(_tgt, _src42) != 0 { return false }
  }
  if len(p.OffsetKey) != len(other.OffsetKey) { return false }
  for i, _tgt := range p.OffsetKey {
    _src43 := other.OffsetKey[i]
    if bytes.Compare(_tgt, _src43) != 0 { return false }
  }
  if p.OffsetRev != other.OffsetRev {
    if p.OffsetRev == nil || other.OffsetRev == nil {
      return false
    }
    if (*p.OffsetRev) != (*other.OffsetRev) { return false }
  }
  if len(p.KeyIntervals) != len(other.KeyIntervals) { return false }
  for i, _tgt := range p.KeyIntervals {
    _src44 := other.KeyIntervals[i]
    if !_tgt.Equals(_src44) { return false }
  }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src45 := other.Values[i]
    if !_tgt.Equals(_src45) { return false }
  }
  if !p.TsStart.Equals(other.TsStart) { return false }
  if !p.TsFinish.Equals(other.TsFinish) { return false }
  if !p.Flags.Equals(other.Flags) { return false }
  if p.Options != other.Options {
    if p.Options == nil || other.Options == nil {
      return false
    }
    if (*p.Options) != (*other.Options) { return false }
  }
  if !p.Updating.Equals(other.Updating) { return false }
  return true
}

func (p *SpecIntervalCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecIntervalCounter(%+v)", *p)
}

func (p *SpecIntervalCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecIntervalCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalCounter)(nil)

func (p *SpecIntervalCounter) Validate() error {
  return nil
}
// The Cells Interval Serial type Specifications with interval-scope Flags
// 
// Attributes:
//  - RangeBegin: Begin of Ranges evaluation with this Key inclusive
//  - RangeEnd: End of Ranges evaluation with this Key inclusive
//  - OffsetKey: Offset Cell Key of a Scan, select cells from this key inclusive
//  - OffsetRev: Offset Cell Timestamp of a Scan, select cells after this timestamp
//  - KeyIntervals: The Key Intervals
//  - Values: The Serial Cell Value Specifications, cell-value fields match
//  - TsStart: The Timestamp Start Spec, the start of cells-interval timestamp match
//  - TsFinish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
//  - Flags: The Interval Flags Specification
//  - Options: The Interval Options Specification
//  - Updating: The Serial-Value spec of an Updating Interval
type SpecIntervalSerial struct {
  RangeBegin Key `thrift:"range_begin,1" db:"range_begin" json:"range_begin"`
  RangeEnd Key `thrift:"range_end,2" db:"range_end" json:"range_end"`
  OffsetKey Key `thrift:"offset_key,3" db:"offset_key" json:"offset_key"`
  OffsetRev *int64 `thrift:"offset_rev,4" db:"offset_rev" json:"offset_rev,omitempty"`
  KeyIntervals SpecKeyIntervals `thrift:"key_intervals,5" db:"key_intervals" json:"key_intervals"`
  Values SpecValuesSerial `thrift:"values,6" db:"values" json:"values"`
  TsStart *SpecTimestamp `thrift:"ts_start,7" db:"ts_start" json:"ts_start,omitempty"`
  TsFinish *SpecTimestamp `thrift:"ts_finish,8" db:"ts_finish" json:"ts_finish,omitempty"`
  Flags *SpecFlags `thrift:"flags,9" db:"flags" json:"flags,omitempty"`
  Options *SpecIntervalOptions `thrift:"options,10" db:"options" json:"options,omitempty"`
  Updating *SpecIntervalUpdateSerial `thrift:"updating,11" db:"updating" json:"updating,omitempty"`
}

func NewSpecIntervalSerial() *SpecIntervalSerial {
  return &SpecIntervalSerial{}
}


func (p *SpecIntervalSerial) GetRangeBegin() Key {
  return p.RangeBegin
}

func (p *SpecIntervalSerial) GetRangeEnd() Key {
  return p.RangeEnd
}

func (p *SpecIntervalSerial) GetOffsetKey() Key {
  return p.OffsetKey
}
var SpecIntervalSerial_OffsetRev_DEFAULT int64
func (p *SpecIntervalSerial) GetOffsetRev() int64 {
  if !p.IsSetOffsetRev() {
    return SpecIntervalSerial_OffsetRev_DEFAULT
  }
  return *p.OffsetRev
}

func (p *SpecIntervalSerial) GetKeyIntervals() SpecKeyIntervals {
  return p.KeyIntervals
}

func (p *SpecIntervalSerial) GetValues() SpecValuesSerial {
  return p.Values
}
var SpecIntervalSerial_TsStart_DEFAULT *SpecTimestamp
func (p *SpecIntervalSerial) GetTsStart() *SpecTimestamp {
  if !p.IsSetTsStart() {
    return SpecIntervalSerial_TsStart_DEFAULT
  }
  return p.TsStart
}
var SpecIntervalSerial_TsFinish_DEFAULT *SpecTimestamp
func (p *SpecIntervalSerial) GetTsFinish() *SpecTimestamp {
  if !p.IsSetTsFinish() {
    return SpecIntervalSerial_TsFinish_DEFAULT
  }
  return p.TsFinish
}
var SpecIntervalSerial_Flags_DEFAULT *SpecFlags
func (p *SpecIntervalSerial) GetFlags() *SpecFlags {
  if !p.IsSetFlags() {
    return SpecIntervalSerial_Flags_DEFAULT
  }
  return p.Flags
}
var SpecIntervalSerial_Options_DEFAULT SpecIntervalOptions
func (p *SpecIntervalSerial) GetOptions() SpecIntervalOptions {
  if !p.IsSetOptions() {
    return SpecIntervalSerial_Options_DEFAULT
  }
  return *p.Options
}
var SpecIntervalSerial_Updating_DEFAULT *SpecIntervalUpdateSerial
func (p *SpecIntervalSerial) GetUpdating() *SpecIntervalUpdateSerial {
  if !p.IsSetUpdating() {
    return SpecIntervalSerial_Updating_DEFAULT
  }
  return p.Updating
}
func (p *SpecIntervalSerial) IsSetOffsetRev() bool {
  return p.OffsetRev != nil
}

func (p *SpecIntervalSerial) IsSetTsStart() bool {
  return p.TsStart != nil
}

func (p *SpecIntervalSerial) IsSetTsFinish() bool {
  return p.TsFinish != nil
}

func (p *SpecIntervalSerial) IsSetFlags() bool {
  return p.Flags != nil
}

func (p *SpecIntervalSerial) IsSetOptions() bool {
  return p.Options != nil
}

func (p *SpecIntervalSerial) IsSetUpdating() bool {
  return p.Updating != nil
}

func (p *SpecIntervalSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 8:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField8(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 9:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField9(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 10:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField10(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 11:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField11(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.RangeBegin =  tSlice
  for i := 0; i < size; i ++ {
var _elem46 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem46 = v
}
    p.RangeBegin = append(p.RangeBegin, _elem46)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.RangeEnd =  tSlice
  for i := 0; i < size; i ++ {
var _elem47 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem47 = v
}
    p.RangeEnd = append(p.RangeEnd, _elem47)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.OffsetKey =  tSlice
  for i := 0; i < size; i ++ {
var _elem48 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem48 = v
}
    p.OffsetKey = append(p.OffsetKey, _elem48)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.OffsetRev = &v
}
  return nil
}

func (p *SpecIntervalSerial)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecKeyIntervals, 0, size)
  p.KeyIntervals =  tSlice
  for i := 0; i < size; i ++ {
    _elem49 := &SpecKeyInterval{}
    if err := _elem49.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem49), err)
    }
    p.KeyIntervals = append(p.KeyIntervals, _elem49)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(SpecValuesSerial, 0, size)
  p.Values =  tSlice
  for i := 0; i < size; i ++ {
    _elem50 := &SpecValueSerial{}
    if err := _elem50.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem50), err)
    }
    p.Values = append(p.Values, _elem50)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.TsStart = &SpecTimestamp{}
  if err := p.TsStart.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TsStart), err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
  p.TsFinish = &SpecTimestamp{}
  if err := p.TsFinish.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.TsFinish), err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
  p.Flags = &SpecFlags{}
  if err := p.Flags.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Flags), err)
  }
  return nil
}

func (p *SpecIntervalSerial)  ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 10: ", err)
} else {
  temp := SpecIntervalOptions(v)
  p.Options = &temp
}
  return nil
}

func (p *SpecIntervalSerial)  ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
  p.Updating = &SpecIntervalUpdateSerial{}
  if err := p.Updating.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Updating), err)
  }
  return nil
}

func (p *SpecIntervalSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecIntervalSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
    if err := p.writeField8(ctx, oprot); err != nil { return err }
    if err := p.writeField9(ctx, oprot); err != nil { return err }
    if err := p.writeField10(ctx, oprot); err != nil { return err }
    if err := p.writeField11(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecIntervalSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "range_begin", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:range_begin: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.RangeBegin)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.RangeBegin {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:range_begin: ", p), err) }
  return err
}

func (p *SpecIntervalSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "range_end", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:range_end: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.RangeEnd)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.RangeEnd {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:range_end: ", p), err) }
  return err
}

func (p *SpecIntervalSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "offset_key", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:offset_key: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.OffsetKey)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.OffsetKey {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:offset_key: ", p), err) }
  return err
}

func (p *SpecIntervalSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOffsetRev() {
    if err := oprot.WriteFieldBegin(ctx, "offset_rev", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:offset_rev: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.OffsetRev)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.offset_rev (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:offset_rev: ", p), err) }
  }
  return err
}

func (p *SpecIntervalSerial) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "key_intervals", thrift.LIST, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:key_intervals: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.KeyIntervals)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.KeyIntervals {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:key_intervals: ", p), err) }
  return err
}

func (p *SpecIntervalSerial) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:values: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Values)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Values {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:values: ", p), err) }
  return err
}

func (p *SpecIntervalSerial) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsStart() {
    if err := oprot.WriteFieldBegin(ctx, "ts_start", thrift.STRUCT, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:ts_start: ", p), err) }
    if err := p.TsStart.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TsStart), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:ts_start: ", p), err) }
  }
  return err
}

func (p *SpecIntervalSerial) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsFinish() {
    if err := oprot.WriteFieldBegin(ctx, "ts_finish", thrift.STRUCT, 8); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:ts_finish: ", p), err) }
    if err := p.TsFinish.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.TsFinish), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 8:ts_finish: ", p), err) }
  }
  return err
}

func (p *SpecIntervalSerial) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFlags() {
    if err := oprot.WriteFieldBegin(ctx, "flags", thrift.STRUCT, 9); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:flags: ", p), err) }
    if err := p.Flags.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Flags), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 9:flags: ", p), err) }
  }
  return err
}

func (p *SpecIntervalSerial) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetOptions() {
    if err := oprot.WriteFieldBegin(ctx, "options", thrift.I32, 10); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:options: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Options)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.options (10) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 10:options: ", p), err) }
  }
  return err
}

func (p *SpecIntervalSerial) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetUpdating() {
    if err := oprot.WriteFieldBegin(ctx, "updating", thrift.STRUCT, 11); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:updating: ", p), err) }
    if err := p.Updating.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Updating), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 11:updating: ", p), err) }
  }
  return err
}

func (p *SpecIntervalSerial) Equals(other *SpecIntervalSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.RangeBegin) != len(other.RangeBegin) { return false }
  for i, _tgt := range p.RangeBegin {
    _src51 := other.RangeBegin[i]
    if bytes.Compare(_tgt, _src51) != 0 { return false }
  }
  if len(p.RangeEnd) != len(other.RangeEnd) { return false }
  for i, _tgt := range p.RangeEnd {
    _src52 := other.RangeEnd[i]
    if bytes.Compare(_tgt, _src52) != 0 { return false }
  }
  if len(p.OffsetKey) != len(other.OffsetKey) { return false }
  for i, _tgt := range p.OffsetKey {
    _src53 := other.OffsetKey[i]
    if bytes.Compare(_tgt, _src53) != 0 { return false }
  }
  if p.OffsetRev != other.OffsetRev {
    if p.OffsetRev == nil || other.OffsetRev == nil {
      return false
    }
    if (*p.OffsetRev) != (*other.OffsetRev) { return false }
  }
  if len(p.KeyIntervals) != len(other.KeyIntervals) { return false }
  for i, _tgt := range p.KeyIntervals {
    _src54 := other.KeyIntervals[i]
    if !_tgt.Equals(_src54) { return false }
  }
  if len(p.Values) != len(other.Values) { return false }
  for i, _tgt := range p.Values {
    _src55 := other.Values[i]
    if !_tgt.Equals(_src55) { return false }
  }
  if !p.TsStart.Equals(other.TsStart) { return false }
  if !p.TsFinish.Equals(other.TsFinish) { return false }
  if !p.Flags.Equals(other.Flags) { return false }
  if p.Options != other.Options {
    if p.Options == nil || other.Options == nil {
      return false
    }
    if (*p.Options) != (*other.Options) { return false }
  }
  if !p.Updating.Equals(other.Updating) { return false }
  return true
}

func (p *SpecIntervalSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecIntervalSerial(%+v)", *p)
}

func (p *SpecIntervalSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecIntervalSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalSerial)(nil)

func (p *SpecIntervalSerial) Validate() error {
  return nil
}
// The Column Specifications, the Cells-Intervals(SpecIntervalPlain/s) specification for a PLAIN Type column
// 
// Attributes:
//  - Cid: The Column ID
//  - Intervals: The Cells Interval in a list-container
type SpecColumnPlain struct {
  Cid int64 `thrift:"cid,1" db:"cid" json:"cid"`
  Intervals []*SpecIntervalPlain `thrift:"intervals,2" db:"intervals" json:"intervals"`
}

func NewSpecColumnPlain() *SpecColumnPlain {
  return &SpecColumnPlain{}
}


func (p *SpecColumnPlain) GetCid() int64 {
  return p.Cid
}

func (p *SpecColumnPlain) GetIntervals() []*SpecIntervalPlain {
  return p.Intervals
}
func (p *SpecColumnPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecColumnPlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cid = v
}
  return nil
}

func (p *SpecColumnPlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecIntervalPlain, 0, size)
  p.Intervals =  tSlice
  for i := 0; i < size; i ++ {
    _elem56 := &SpecIntervalPlain{}
    if err := _elem56.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem56), err)
    }
    p.Intervals = append(p.Intervals, _elem56)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecColumnPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecColumnPlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecColumnPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Cid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err) }
  return err
}

func (p *SpecColumnPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "intervals", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:intervals: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Intervals)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Intervals {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:intervals: ", p), err) }
  return err
}

func (p *SpecColumnPlain) Equals(other *SpecColumnPlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Cid != other.Cid { return false }
  if len(p.Intervals) != len(other.Intervals) { return false }
  for i, _tgt := range p.Intervals {
    _src57 := other.Intervals[i]
    if !_tgt.Equals(_src57) { return false }
  }
  return true
}

func (p *SpecColumnPlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecColumnPlain(%+v)", *p)
}

func (p *SpecColumnPlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecColumnPlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecColumnPlain)(nil)

func (p *SpecColumnPlain) Validate() error {
  return nil
}
// The Column Specifications, the Cells-Intervals(SpecIntervalCounter/s) specification for a COUNTER Type column
// 
// Attributes:
//  - Cid: The Column ID
//  - Intervals: The Cells Interval in a list-container
type SpecColumnCounter struct {
  Cid int64 `thrift:"cid,1" db:"cid" json:"cid"`
  Intervals []*SpecIntervalCounter `thrift:"intervals,2" db:"intervals" json:"intervals"`
}

func NewSpecColumnCounter() *SpecColumnCounter {
  return &SpecColumnCounter{}
}


func (p *SpecColumnCounter) GetCid() int64 {
  return p.Cid
}

func (p *SpecColumnCounter) GetIntervals() []*SpecIntervalCounter {
  return p.Intervals
}
func (p *SpecColumnCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecColumnCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cid = v
}
  return nil
}

func (p *SpecColumnCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecIntervalCounter, 0, size)
  p.Intervals =  tSlice
  for i := 0; i < size; i ++ {
    _elem58 := &SpecIntervalCounter{}
    if err := _elem58.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem58), err)
    }
    p.Intervals = append(p.Intervals, _elem58)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecColumnCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecColumnCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecColumnCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Cid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err) }
  return err
}

func (p *SpecColumnCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "intervals", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:intervals: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Intervals)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Intervals {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:intervals: ", p), err) }
  return err
}

func (p *SpecColumnCounter) Equals(other *SpecColumnCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Cid != other.Cid { return false }
  if len(p.Intervals) != len(other.Intervals) { return false }
  for i, _tgt := range p.Intervals {
    _src59 := other.Intervals[i]
    if !_tgt.Equals(_src59) { return false }
  }
  return true
}

func (p *SpecColumnCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecColumnCounter(%+v)", *p)
}

func (p *SpecColumnCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecColumnCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecColumnCounter)(nil)

func (p *SpecColumnCounter) Validate() error {
  return nil
}
// The Column Specifications, the Cells-Intervals(SpecIntervalSerial/s) specification for a SERIAL Type Column
// 
// Attributes:
//  - Cid: The Column ID
//  - Intervals: The Serial Cells Interval in a list-container
type SpecColumnSerial struct {
  Cid int64 `thrift:"cid,1" db:"cid" json:"cid"`
  Intervals []*SpecIntervalSerial `thrift:"intervals,2" db:"intervals" json:"intervals"`
}

func NewSpecColumnSerial() *SpecColumnSerial {
  return &SpecColumnSerial{}
}


func (p *SpecColumnSerial) GetCid() int64 {
  return p.Cid
}

func (p *SpecColumnSerial) GetIntervals() []*SpecIntervalSerial {
  return p.Intervals
}
func (p *SpecColumnSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecColumnSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cid = v
}
  return nil
}

func (p *SpecColumnSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecIntervalSerial, 0, size)
  p.Intervals =  tSlice
  for i := 0; i < size; i ++ {
    _elem60 := &SpecIntervalSerial{}
    if err := _elem60.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem60), err)
    }
    p.Intervals = append(p.Intervals, _elem60)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecColumnSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecColumnSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecColumnSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Cid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err) }
  return err
}

func (p *SpecColumnSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "intervals", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:intervals: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Intervals)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Intervals {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:intervals: ", p), err) }
  return err
}

func (p *SpecColumnSerial) Equals(other *SpecColumnSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Cid != other.Cid { return false }
  if len(p.Intervals) != len(other.Intervals) { return false }
  for i, _tgt := range p.Intervals {
    _src61 := other.Intervals[i]
    if !_tgt.Equals(_src61) { return false }
  }
  return true
}

func (p *SpecColumnSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecColumnSerial(%+v)", *p)
}

func (p *SpecColumnSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecColumnSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecColumnSerial)(nil)

func (p *SpecColumnSerial) Validate() error {
  return nil
}
// The Scan Specifications, the Columns-Intervals(SpecColumn/s) with global-scope Flags
// 
// Attributes:
//  - ColumnsPlain: The Plain Column Intervals(SpecColumnPlain) in a list-container
//  - ColumnsCounter: The Counter Column Intervals(SpecColumnCounter) in a list-container
//  - ColumnsSerial: The Serial Column Intervals(SpecColumnSerial) in a list-container
//  - Flags: The Global Flags Specification
type SpecScan struct {
  ColumnsPlain []*SpecColumnPlain `thrift:"columns_plain,1" db:"columns_plain" json:"columns_plain"`
  ColumnsCounter []*SpecColumnCounter `thrift:"columns_counter,2" db:"columns_counter" json:"columns_counter"`
  ColumnsSerial []*SpecColumnSerial `thrift:"columns_serial,3" db:"columns_serial" json:"columns_serial"`
  Flags *SpecFlags `thrift:"flags,4" db:"flags" json:"flags,omitempty"`
}

func NewSpecScan() *SpecScan {
  return &SpecScan{}
}


func (p *SpecScan) GetColumnsPlain() []*SpecColumnPlain {
  return p.ColumnsPlain
}

func (p *SpecScan) GetColumnsCounter() []*SpecColumnCounter {
  return p.ColumnsCounter
}

func (p *SpecScan) GetColumnsSerial() []*SpecColumnSerial {
  return p.ColumnsSerial
}
var SpecScan_Flags_DEFAULT *SpecFlags
func (p *SpecScan) GetFlags() *SpecFlags {
  if !p.IsSetFlags() {
    return SpecScan_Flags_DEFAULT
  }
  return p.Flags
}
func (p *SpecScan) IsSetFlags() bool {
  return p.Flags != nil
}

func (p *SpecScan) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *SpecScan)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecColumnPlain, 0, size)
  p.ColumnsPlain =  tSlice
  for i := 0; i < size; i ++ {
    _elem62 := &SpecColumnPlain{}
    if err := _elem62.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem62), err)
    }
    p.ColumnsPlain = append(p.ColumnsPlain, _elem62)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecScan)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecColumnCounter, 0, size)
  p.ColumnsCounter =  tSlice
  for i := 0; i < size; i ++ {
    _elem63 := &SpecColumnCounter{}
    if err := _elem63.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem63), err)
    }
    p.ColumnsCounter = append(p.ColumnsCounter, _elem63)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecScan)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*SpecColumnSerial, 0, size)
  p.ColumnsSerial =  tSlice
  for i := 0; i < size; i ++ {
    _elem64 := &SpecColumnSerial{}
    if err := _elem64.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem64), err)
    }
    p.ColumnsSerial = append(p.ColumnsSerial, _elem64)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *SpecScan)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Flags = &SpecFlags{}
  if err := p.Flags.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Flags), err)
  }
  return nil
}

func (p *SpecScan) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "SpecScan"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *SpecScan) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "columns_plain", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:columns_plain: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ColumnsPlain)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ColumnsPlain {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:columns_plain: ", p), err) }
  return err
}

func (p *SpecScan) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "columns_counter", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns_counter: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ColumnsCounter)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ColumnsCounter {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns_counter: ", p), err) }
  return err
}

func (p *SpecScan) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "columns_serial", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:columns_serial: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.ColumnsSerial)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.ColumnsSerial {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:columns_serial: ", p), err) }
  return err
}

func (p *SpecScan) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetFlags() {
    if err := oprot.WriteFieldBegin(ctx, "flags", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:flags: ", p), err) }
    if err := p.Flags.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Flags), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:flags: ", p), err) }
  }
  return err
}

func (p *SpecScan) Equals(other *SpecScan) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.ColumnsPlain) != len(other.ColumnsPlain) { return false }
  for i, _tgt := range p.ColumnsPlain {
    _src65 := other.ColumnsPlain[i]
    if !_tgt.Equals(_src65) { return false }
  }
  if len(p.ColumnsCounter) != len(other.ColumnsCounter) { return false }
  for i, _tgt := range p.ColumnsCounter {
    _src66 := other.ColumnsCounter[i]
    if !_tgt.Equals(_src66) { return false }
  }
  if len(p.ColumnsSerial) != len(other.ColumnsSerial) { return false }
  for i, _tgt := range p.ColumnsSerial {
    _src67 := other.ColumnsSerial[i]
    if !_tgt.Equals(_src67) { return false }
  }
  if !p.Flags.Equals(other.Flags) { return false }
  return true
}

func (p *SpecScan) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("SpecScan(%+v)", *p)
}

func (p *SpecScan) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.SpecScan",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecScan)(nil)

func (p *SpecScan) Validate() error {
  return nil
}
// The Cell data for using with Update of PLAIN Column Type
// 
// Attributes:
//  - F: The Cell Flag
//  - K: The Cell Key
//  - Ts: The Cell Timestamp in nanoseconds
//  - TsDesc: The Cell Version is in timestamp descending
//  - V: The Cell Value
//  - Encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
type UCellPlain struct {
  F Flag `thrift:"f,1" db:"f" json:"f"`
  K Key `thrift:"k,2" db:"k" json:"k"`
  Ts *int64 `thrift:"ts,3" db:"ts" json:"ts,omitempty"`
  TsDesc *bool `thrift:"ts_desc,4" db:"ts_desc" json:"ts_desc,omitempty"`
  V []byte `thrift:"v,5" db:"v" json:"v"`
  Encoder *EncodingType `thrift:"encoder,6" db:"encoder" json:"encoder,omitempty"`
}

func NewUCellPlain() *UCellPlain {
  return &UCellPlain{}
}


func (p *UCellPlain) GetF() Flag {
  return p.F
}

func (p *UCellPlain) GetK() Key {
  return p.K
}
var UCellPlain_Ts_DEFAULT int64
func (p *UCellPlain) GetTs() int64 {
  if !p.IsSetTs() {
    return UCellPlain_Ts_DEFAULT
  }
  return *p.Ts
}
var UCellPlain_TsDesc_DEFAULT bool
func (p *UCellPlain) GetTsDesc() bool {
  if !p.IsSetTsDesc() {
    return UCellPlain_TsDesc_DEFAULT
  }
  return *p.TsDesc
}

func (p *UCellPlain) GetV() []byte {
  return p.V
}
var UCellPlain_Encoder_DEFAULT EncodingType
func (p *UCellPlain) GetEncoder() EncodingType {
  if !p.IsSetEncoder() {
    return UCellPlain_Encoder_DEFAULT
  }
  return *p.Encoder
}
func (p *UCellPlain) IsSetTs() bool {
  return p.Ts != nil
}

func (p *UCellPlain) IsSetTsDesc() bool {
  return p.TsDesc != nil
}

func (p *UCellPlain) IsSetEncoder() bool {
  return p.Encoder != nil
}

func (p *UCellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UCellPlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Flag(v)
  p.F = temp
}
  return nil
}

func (p *UCellPlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem68 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem68 = v
}
    p.K = append(p.K, _elem68)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *UCellPlain)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Ts = &v
}
  return nil
}

func (p *UCellPlain)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.TsDesc = &v
}
  return nil
}

func (p *UCellPlain)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *UCellPlain)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := EncodingType(v)
  p.Encoder = &temp
}
  return nil
}

func (p *UCellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "UCellPlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UCellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "f", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:f: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.F)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.f (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:f: ", p), err) }
  return err
}

func (p *UCellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err) }
  return err
}

func (p *UCellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTs() {
    if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Ts)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err) }
  }
  return err
}

func (p *UCellPlain) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsDesc() {
    if err := oprot.WriteFieldBegin(ctx, "ts_desc", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ts_desc: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.TsDesc)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ts_desc (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ts_desc: ", p), err) }
  }
  return err
}

func (p *UCellPlain) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err) }
  return err
}

func (p *UCellPlain) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEncoder() {
    if err := oprot.WriteFieldBegin(ctx, "encoder", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:encoder: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Encoder)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.encoder (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:encoder: ", p), err) }
  }
  return err
}

func (p *UCellPlain) Equals(other *UCellPlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.F != other.F { return false }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src69 := other.K[i]
    if bytes.Compare(_tgt, _src69) != 0 { return false }
  }
  if p.Ts != other.Ts {
    if p.Ts == nil || other.Ts == nil {
      return false
    }
    if (*p.Ts) != (*other.Ts) { return false }
  }
  if p.TsDesc != other.TsDesc {
    if p.TsDesc == nil || other.TsDesc == nil {
      return false
    }
    if (*p.TsDesc) != (*other.TsDesc) { return false }
  }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  if p.Encoder != other.Encoder {
    if p.Encoder == nil || other.Encoder == nil {
      return false
    }
    if (*p.Encoder) != (*other.Encoder) { return false }
  }
  return true
}

func (p *UCellPlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UCellPlain(%+v)", *p)
}

func (p *UCellPlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.UCellPlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*UCellPlain)(nil)

func (p *UCellPlain) Validate() error {
  return nil
}
// The Cell data for using with Update of COUNTER Column Type
// 
// Attributes:
//  - F: The Cell Flag
//  - K: The Cell Key
//  - Ts: The Cell Timestamp in nanoseconds
//  - TsDesc: The Cell Version is in timestamp descending
//  - Op: The Cell Counter Operation
//  - V: The Cell Counter Value
type UCellCounter struct {
  F Flag `thrift:"f,1" db:"f" json:"f"`
  K Key `thrift:"k,2" db:"k" json:"k"`
  Ts *int64 `thrift:"ts,3" db:"ts" json:"ts,omitempty"`
  TsDesc *bool `thrift:"ts_desc,4" db:"ts_desc" json:"ts_desc,omitempty"`
  Op int8 `thrift:"op,5" db:"op" json:"op"`
  V int64 `thrift:"v,6" db:"v" json:"v"`
}

func NewUCellCounter() *UCellCounter {
  return &UCellCounter{}
}


func (p *UCellCounter) GetF() Flag {
  return p.F
}

func (p *UCellCounter) GetK() Key {
  return p.K
}
var UCellCounter_Ts_DEFAULT int64
func (p *UCellCounter) GetTs() int64 {
  if !p.IsSetTs() {
    return UCellCounter_Ts_DEFAULT
  }
  return *p.Ts
}
var UCellCounter_TsDesc_DEFAULT bool
func (p *UCellCounter) GetTsDesc() bool {
  if !p.IsSetTsDesc() {
    return UCellCounter_TsDesc_DEFAULT
  }
  return *p.TsDesc
}

func (p *UCellCounter) GetOp() int8 {
  return p.Op
}

func (p *UCellCounter) GetV() int64 {
  return p.V
}
func (p *UCellCounter) IsSetTs() bool {
  return p.Ts != nil
}

func (p *UCellCounter) IsSetTsDesc() bool {
  return p.TsDesc != nil
}

func (p *UCellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UCellCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Flag(v)
  p.F = temp
}
  return nil
}

func (p *UCellCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem70 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem70 = v
}
    p.K = append(p.K, _elem70)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *UCellCounter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Ts = &v
}
  return nil
}

func (p *UCellCounter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.TsDesc = &v
}
  return nil
}

func (p *UCellCounter)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  temp := int8(v)
  p.Op = temp
}
  return nil
}

func (p *UCellCounter)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *UCellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "UCellCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UCellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "f", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:f: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.F)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.f (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:f: ", p), err) }
  return err
}

func (p *UCellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err) }
  return err
}

func (p *UCellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTs() {
    if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Ts)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err) }
  }
  return err
}

func (p *UCellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsDesc() {
    if err := oprot.WriteFieldBegin(ctx, "ts_desc", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ts_desc: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.TsDesc)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ts_desc (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ts_desc: ", p), err) }
  }
  return err
}

func (p *UCellCounter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op", thrift.BYTE, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:op: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:op: ", p), err) }
  return err
}

func (p *UCellCounter) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 6); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (6) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 6:v: ", p), err) }
  return err
}

func (p *UCellCounter) Equals(other *UCellCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.F != other.F { return false }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src71 := other.K[i]
    if bytes.Compare(_tgt, _src71) != 0 { return false }
  }
  if p.Ts != other.Ts {
    if p.Ts == nil || other.Ts == nil {
      return false
    }
    if (*p.Ts) != (*other.Ts) { return false }
  }
  if p.TsDesc != other.TsDesc {
    if p.TsDesc == nil || other.TsDesc == nil {
      return false
    }
    if (*p.TsDesc) != (*other.TsDesc) { return false }
  }
  if p.Op != other.Op { return false }
  if p.V != other.V { return false }
  return true
}

func (p *UCellCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UCellCounter(%+v)", *p)
}

func (p *UCellCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.UCellCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*UCellCounter)(nil)

func (p *UCellCounter) Validate() error {
  return nil
}
// The Serial Value Cell field
// 
// Attributes:
//  - FieldID: The Field ID, a single ID can have any/all the field types
//  - VInt64: The INT64 type field
//  - VDouble: The DOUBLE type field
//  - VBytes: The BYTES type field
//  - VKey: The Cell KEY type field
//  - VLi: The LIST INT64 type field
//  - VLb: The LIST BYTES type field
type CellValueSerial struct {
  FieldID int32 `thrift:"field_id,1" db:"field_id" json:"field_id"`
  VInt64 *int64 `thrift:"v_int64,2" db:"v_int64" json:"v_int64,omitempty"`
  VDouble *float64 `thrift:"v_double,3" db:"v_double" json:"v_double,omitempty"`
  VBytes []byte `thrift:"v_bytes,4" db:"v_bytes" json:"v_bytes,omitempty"`
  VKey Key `thrift:"v_key,5" db:"v_key" json:"v_key,omitempty"`
  VLi []int64 `thrift:"v_li,6" db:"v_li" json:"v_li,omitempty"`
  VLb [][]byte `thrift:"v_lb,7" db:"v_lb" json:"v_lb,omitempty"`
}

func NewCellValueSerial() *CellValueSerial {
  return &CellValueSerial{}
}


func (p *CellValueSerial) GetFieldID() int32 {
  return p.FieldID
}
var CellValueSerial_VInt64_DEFAULT int64
func (p *CellValueSerial) GetVInt64() int64 {
  if !p.IsSetVInt64() {
    return CellValueSerial_VInt64_DEFAULT
  }
  return *p.VInt64
}
var CellValueSerial_VDouble_DEFAULT float64
func (p *CellValueSerial) GetVDouble() float64 {
  if !p.IsSetVDouble() {
    return CellValueSerial_VDouble_DEFAULT
  }
  return *p.VDouble
}
var CellValueSerial_VBytes_DEFAULT []byte

func (p *CellValueSerial) GetVBytes() []byte {
  return p.VBytes
}
var CellValueSerial_VKey_DEFAULT Key

func (p *CellValueSerial) GetVKey() Key {
  return p.VKey
}
var CellValueSerial_VLi_DEFAULT []int64

func (p *CellValueSerial) GetVLi() []int64 {
  return p.VLi
}
var CellValueSerial_VLb_DEFAULT [][]byte

func (p *CellValueSerial) GetVLb() [][]byte {
  return p.VLb
}
func (p *CellValueSerial) IsSetVInt64() bool {
  return p.VInt64 != nil
}

func (p *CellValueSerial) IsSetVDouble() bool {
  return p.VDouble != nil
}

func (p *CellValueSerial) IsSetVBytes() bool {
  return p.VBytes != nil
}

func (p *CellValueSerial) IsSetVKey() bool {
  return p.VKey != nil
}

func (p *CellValueSerial) IsSetVLi() bool {
  return p.VLi != nil
}

func (p *CellValueSerial) IsSetVLb() bool {
  return p.VLb != nil
}

func (p *CellValueSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CellValueSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FieldID = v
}
  return nil
}

func (p *CellValueSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.VInt64 = &v
}
  return nil
}

func (p *CellValueSerial)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.VDouble = &v
}
  return nil
}

func (p *CellValueSerial)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.VBytes = v
}
  return nil
}

func (p *CellValueSerial)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.VKey =  tSlice
  for i := 0; i < size; i ++ {
var _elem72 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem72 = v
}
    p.VKey = append(p.VKey, _elem72)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellValueSerial)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]int64, 0, size)
  p.VLi =  tSlice
  for i := 0; i < size; i ++ {
var _elem73 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem73 = v
}
    p.VLi = append(p.VLi, _elem73)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellValueSerial)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([][]byte, 0, size)
  p.VLb =  tSlice
  for i := 0; i < size; i ++ {
var _elem74 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem74 = v
}
    p.VLb = append(p.VLb, _elem74)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellValueSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CellValueSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CellValueSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "field_id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field_id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.FieldID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.field_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field_id: ", p), err) }
  return err
}

func (p *CellValueSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVInt64() {
    if err := oprot.WriteFieldBegin(ctx, "v_int64", thrift.I64, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v_int64: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.VInt64)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.v_int64 (2) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v_int64: ", p), err) }
  }
  return err
}

func (p *CellValueSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVDouble() {
    if err := oprot.WriteFieldBegin(ctx, "v_double", thrift.DOUBLE, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v_double: ", p), err) }
    if err := oprot.WriteDouble(ctx, float64(*p.VDouble)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.v_double (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v_double: ", p), err) }
  }
  return err
}

func (p *CellValueSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVBytes() {
    if err := oprot.WriteFieldBegin(ctx, "v_bytes", thrift.STRING, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v_bytes: ", p), err) }
    if err := oprot.WriteBinary(ctx, p.VBytes); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.v_bytes (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v_bytes: ", p), err) }
  }
  return err
}

func (p *CellValueSerial) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVKey() {
    if err := oprot.WriteFieldBegin(ctx, "v_key", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v_key: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.VKey)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.VKey {
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v_key: ", p), err) }
  }
  return err
}

func (p *CellValueSerial) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVLi() {
    if err := oprot.WriteFieldBegin(ctx, "v_li", thrift.LIST, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:v_li: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.I64, len(p.VLi)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.VLi {
      if err := oprot.WriteI64(ctx, int64(v)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:v_li: ", p), err) }
  }
  return err
}

func (p *CellValueSerial) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVLb() {
    if err := oprot.WriteFieldBegin(ctx, "v_lb", thrift.LIST, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:v_lb: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.VLb)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.VLb {
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:v_lb: ", p), err) }
  }
  return err
}

func (p *CellValueSerial) Equals(other *CellValueSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.FieldID != other.FieldID { return false }
  if p.VInt64 != other.VInt64 {
    if p.VInt64 == nil || other.VInt64 == nil {
      return false
    }
    if (*p.VInt64) != (*other.VInt64) { return false }
  }
  if p.VDouble != other.VDouble {
    if p.VDouble == nil || other.VDouble == nil {
      return false
    }
    if (*p.VDouble) != (*other.VDouble) { return false }
  }
  if bytes.Compare(p.VBytes, other.VBytes) != 0 { return false }
  if len(p.VKey) != len(other.VKey) { return false }
  for i, _tgt := range p.VKey {
    _src75 := other.VKey[i]
    if bytes.Compare(_tgt, _src75) != 0 { return false }
  }
  if len(p.VLi) != len(other.VLi) { return false }
  for i, _tgt := range p.VLi {
    _src76 := other.VLi[i]
    if _tgt != _src76 { return false }
  }
  if len(p.VLb) != len(other.VLb) { return false }
  for i, _tgt := range p.VLb {
    _src77 := other.VLb[i]
    if bytes.Compare(_tgt, _src77) != 0 { return false }
  }
  return true
}

func (p *CellValueSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CellValueSerial(%+v)", *p)
}

func (p *CellValueSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CellValueSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellValueSerial)(nil)

func (p *CellValueSerial) Validate() error {
  return nil
}
// Serial INT64 Field Update
// 
// Attributes:
//  - Ctrl
//  - Op
//  - Pos
//  - Comp
//  - V
type FU_INT64 struct {
  Ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
  Op FU_MATH_OP `thrift:"op,2" db:"op" json:"op"`
  Pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
  Comp *Comp `thrift:"comp,4" db:"comp" json:"comp,omitempty"`
  V int64 `thrift:"v,5" db:"v" json:"v"`
}

func NewFU_INT64() *FU_INT64 {
  return &FU_INT64{
  Op: 0,
}
}


func (p *FU_INT64) GetCtrl() int8 {
  return p.Ctrl
}

func (p *FU_INT64) GetOp() FU_MATH_OP {
  return p.Op
}
var FU_INT64_Pos_DEFAULT int32
func (p *FU_INT64) GetPos() int32 {
  if !p.IsSetPos() {
    return FU_INT64_Pos_DEFAULT
  }
  return *p.Pos
}
var FU_INT64_Comp_DEFAULT Comp
func (p *FU_INT64) GetComp() Comp {
  if !p.IsSetComp() {
    return FU_INT64_Comp_DEFAULT
  }
  return *p.Comp
}

func (p *FU_INT64) GetV() int64 {
  return p.V
}
func (p *FU_INT64) IsSetPos() bool {
  return p.Pos != nil
}

func (p *FU_INT64) IsSetComp() bool {
  return p.Comp != nil
}

func (p *FU_INT64) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FU_INT64)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Ctrl = temp
}
  return nil
}

func (p *FU_INT64)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := FU_MATH_OP(v)
  p.Op = temp
}
  return nil
}

func (p *FU_INT64)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pos = &v
}
  return nil
}

func (p *FU_INT64)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := Comp(v)
  p.Comp = &temp
}
  return nil
}

func (p *FU_INT64)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *FU_INT64) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FU_INT64"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FU_INT64) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Ctrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err) }
  return err
}

func (p *FU_INT64) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err) }
  return err
}

func (p *FU_INT64) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPos() {
    if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Pos)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err) }
  }
  return err
}

func (p *FU_INT64) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetComp() {
    if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:comp: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Comp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.comp (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:comp: ", p), err) }
  }
  return err
}

func (p *FU_INT64) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err) }
  return err
}

func (p *FU_INT64) Equals(other *FU_INT64) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Ctrl != other.Ctrl { return false }
  if p.Op != other.Op { return false }
  if p.Pos != other.Pos {
    if p.Pos == nil || other.Pos == nil {
      return false
    }
    if (*p.Pos) != (*other.Pos) { return false }
  }
  if p.Comp != other.Comp {
    if p.Comp == nil || other.Comp == nil {
      return false
    }
    if (*p.Comp) != (*other.Comp) { return false }
  }
  if p.V != other.V { return false }
  return true
}

func (p *FU_INT64) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FU_INT64(%+v)", *p)
}

func (p *FU_INT64) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FU_INT64",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_INT64)(nil)

func (p *FU_INT64) Validate() error {
  return nil
}
// Serial DOUBLE Field Update
// 
// Attributes:
//  - Ctrl
//  - Op
//  - Pos
//  - Comp
//  - V
type FU_DOUBLE struct {
  Ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
  Op FU_MATH_OP `thrift:"op,2" db:"op" json:"op"`
  Pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
  Comp *Comp `thrift:"comp,4" db:"comp" json:"comp,omitempty"`
  V float64 `thrift:"v,5" db:"v" json:"v"`
}

func NewFU_DOUBLE() *FU_DOUBLE {
  return &FU_DOUBLE{
  Op: 0,
}
}


func (p *FU_DOUBLE) GetCtrl() int8 {
  return p.Ctrl
}

func (p *FU_DOUBLE) GetOp() FU_MATH_OP {
  return p.Op
}
var FU_DOUBLE_Pos_DEFAULT int32
func (p *FU_DOUBLE) GetPos() int32 {
  if !p.IsSetPos() {
    return FU_DOUBLE_Pos_DEFAULT
  }
  return *p.Pos
}
var FU_DOUBLE_Comp_DEFAULT Comp
func (p *FU_DOUBLE) GetComp() Comp {
  if !p.IsSetComp() {
    return FU_DOUBLE_Comp_DEFAULT
  }
  return *p.Comp
}

func (p *FU_DOUBLE) GetV() float64 {
  return p.V
}
func (p *FU_DOUBLE) IsSetPos() bool {
  return p.Pos != nil
}

func (p *FU_DOUBLE) IsSetComp() bool {
  return p.Comp != nil
}

func (p *FU_DOUBLE) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.DOUBLE {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FU_DOUBLE)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Ctrl = temp
}
  return nil
}

func (p *FU_DOUBLE)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := FU_MATH_OP(v)
  p.Op = temp
}
  return nil
}

func (p *FU_DOUBLE)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pos = &v
}
  return nil
}

func (p *FU_DOUBLE)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := Comp(v)
  p.Comp = &temp
}
  return nil
}

func (p *FU_DOUBLE)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadDouble(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *FU_DOUBLE) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FU_DOUBLE"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FU_DOUBLE) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Ctrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err) }
  return err
}

func (p *FU_DOUBLE) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err) }
  return err
}

func (p *FU_DOUBLE) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPos() {
    if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Pos)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err) }
  }
  return err
}

func (p *FU_DOUBLE) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetComp() {
    if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:comp: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Comp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.comp (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:comp: ", p), err) }
  }
  return err
}

func (p *FU_DOUBLE) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.DOUBLE, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err) }
  if err := oprot.WriteDouble(ctx, float64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err) }
  return err
}

func (p *FU_DOUBLE) Equals(other *FU_DOUBLE) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Ctrl != other.Ctrl { return false }
  if p.Op != other.Op { return false }
  if p.Pos != other.Pos {
    if p.Pos == nil || other.Pos == nil {
      return false
    }
    if (*p.Pos) != (*other.Pos) { return false }
  }
  if p.Comp != other.Comp {
    if p.Comp == nil || other.Comp == nil {
      return false
    }
    if (*p.Comp) != (*other.Comp) { return false }
  }
  if p.V != other.V { return false }
  return true
}

func (p *FU_DOUBLE) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FU_DOUBLE(%+v)", *p)
}

func (p *FU_DOUBLE) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FU_DOUBLE",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_DOUBLE)(nil)

func (p *FU_DOUBLE) Validate() error {
  return nil
}
// Serial BYTES Field Update
// 
// Attributes:
//  - Ctrl
//  - Op
//  - Pos
//  - Comp
//  - V
type FU_BYTES struct {
  Ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
  Op FU_LIST_OP `thrift:"op,2" db:"op" json:"op"`
  Pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
  Comp *Comp `thrift:"comp,4" db:"comp" json:"comp,omitempty"`
  V []byte `thrift:"v,5" db:"v" json:"v"`
}

func NewFU_BYTES() *FU_BYTES {
  return &FU_BYTES{
  Op: 0,
}
}


func (p *FU_BYTES) GetCtrl() int8 {
  return p.Ctrl
}

func (p *FU_BYTES) GetOp() FU_LIST_OP {
  return p.Op
}
var FU_BYTES_Pos_DEFAULT int32
func (p *FU_BYTES) GetPos() int32 {
  if !p.IsSetPos() {
    return FU_BYTES_Pos_DEFAULT
  }
  return *p.Pos
}
var FU_BYTES_Comp_DEFAULT Comp
func (p *FU_BYTES) GetComp() Comp {
  if !p.IsSetComp() {
    return FU_BYTES_Comp_DEFAULT
  }
  return *p.Comp
}

func (p *FU_BYTES) GetV() []byte {
  return p.V
}
func (p *FU_BYTES) IsSetPos() bool {
  return p.Pos != nil
}

func (p *FU_BYTES) IsSetComp() bool {
  return p.Comp != nil
}

func (p *FU_BYTES) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FU_BYTES)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Ctrl = temp
}
  return nil
}

func (p *FU_BYTES)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := FU_LIST_OP(v)
  p.Op = temp
}
  return nil
}

func (p *FU_BYTES)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pos = &v
}
  return nil
}

func (p *FU_BYTES)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  temp := Comp(v)
  p.Comp = &temp
}
  return nil
}

func (p *FU_BYTES)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *FU_BYTES) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FU_BYTES"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FU_BYTES) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Ctrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err) }
  return err
}

func (p *FU_BYTES) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err) }
  return err
}

func (p *FU_BYTES) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPos() {
    if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Pos)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err) }
  }
  return err
}

func (p *FU_BYTES) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetComp() {
    if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:comp: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Comp)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.comp (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:comp: ", p), err) }
  }
  return err
}

func (p *FU_BYTES) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (5) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err) }
  return err
}

func (p *FU_BYTES) Equals(other *FU_BYTES) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Ctrl != other.Ctrl { return false }
  if p.Op != other.Op { return false }
  if p.Pos != other.Pos {
    if p.Pos == nil || other.Pos == nil {
      return false
    }
    if (*p.Pos) != (*other.Pos) { return false }
  }
  if p.Comp != other.Comp {
    if p.Comp == nil || other.Comp == nil {
      return false
    }
    if (*p.Comp) != (*other.Comp) { return false }
  }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  return true
}

func (p *FU_BYTES) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FU_BYTES(%+v)", *p)
}

func (p *FU_BYTES) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FU_BYTES",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_BYTES)(nil)

func (p *FU_BYTES) Validate() error {
  return nil
}
// Serial LIST_INT64 Field Update
// 
// Attributes:
//  - Ctrl
//  - Op
//  - Pos
//  - V
type FU_LI struct {
  Ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
  Op FU_LIST_OP `thrift:"op,2" db:"op" json:"op"`
  Pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
  V []*FU_INT64 `thrift:"v,4" db:"v" json:"v"`
}

func NewFU_LI() *FU_LI {
  return &FU_LI{
  Op: 0,
}
}


func (p *FU_LI) GetCtrl() int8 {
  return p.Ctrl
}

func (p *FU_LI) GetOp() FU_LIST_OP {
  return p.Op
}
var FU_LI_Pos_DEFAULT int32
func (p *FU_LI) GetPos() int32 {
  if !p.IsSetPos() {
    return FU_LI_Pos_DEFAULT
  }
  return *p.Pos
}

func (p *FU_LI) GetV() []*FU_INT64 {
  return p.V
}
func (p *FU_LI) IsSetPos() bool {
  return p.Pos != nil
}

func (p *FU_LI) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FU_LI)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Ctrl = temp
}
  return nil
}

func (p *FU_LI)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := FU_LIST_OP(v)
  p.Op = temp
}
  return nil
}

func (p *FU_LI)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pos = &v
}
  return nil
}

func (p *FU_LI)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*FU_INT64, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem78 := &FU_INT64{
    Op: 0,
}
    if err := _elem78.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem78), err)
    }
    p.V = append(p.V, _elem78)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *FU_LI) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FU_LI"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FU_LI) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Ctrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err) }
  return err
}

func (p *FU_LI) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err) }
  return err
}

func (p *FU_LI) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPos() {
    if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Pos)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err) }
  }
  return err
}

func (p *FU_LI) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err) }
  return err
}

func (p *FU_LI) Equals(other *FU_LI) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Ctrl != other.Ctrl { return false }
  if p.Op != other.Op { return false }
  if p.Pos != other.Pos {
    if p.Pos == nil || other.Pos == nil {
      return false
    }
    if (*p.Pos) != (*other.Pos) { return false }
  }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src79 := other.V[i]
    if !_tgt.Equals(_src79) { return false }
  }
  return true
}

func (p *FU_LI) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FU_LI(%+v)", *p)
}

func (p *FU_LI) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FU_LI",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_LI)(nil)

func (p *FU_LI) Validate() error {
  return nil
}
// Serial LIST_BYTES Field Update
// 
// Attributes:
//  - Ctrl
//  - Op
//  - Pos
//  - V
type FU_LB struct {
  Ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
  Op FU_LIST_OP `thrift:"op,2" db:"op" json:"op"`
  Pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
  V []*FU_BYTES `thrift:"v,4" db:"v" json:"v"`
}

func NewFU_LB() *FU_LB {
  return &FU_LB{
  Op: 0,
}
}


func (p *FU_LB) GetCtrl() int8 {
  return p.Ctrl
}

func (p *FU_LB) GetOp() FU_LIST_OP {
  return p.Op
}
var FU_LB_Pos_DEFAULT int32
func (p *FU_LB) GetPos() int32 {
  if !p.IsSetPos() {
    return FU_LB_Pos_DEFAULT
  }
  return *p.Pos
}

func (p *FU_LB) GetV() []*FU_BYTES {
  return p.V
}
func (p *FU_LB) IsSetPos() bool {
  return p.Pos != nil
}

func (p *FU_LB) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.BYTE {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FU_LB)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadByte(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := int8(v)
  p.Ctrl = temp
}
  return nil
}

func (p *FU_LB)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := FU_LIST_OP(v)
  p.Op = temp
}
  return nil
}

func (p *FU_LB)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Pos = &v
}
  return nil
}

func (p *FU_LB)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*FU_BYTES, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem80 := &FU_BYTES{
    Op: 0,
}
    if err := _elem80.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem80), err)
    }
    p.V = append(p.V, _elem80)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *FU_LB) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FU_LB"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FU_LB) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err) }
  if err := oprot.WriteByte(ctx, int8(p.Ctrl)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err) }
  return err
}

func (p *FU_LB) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Op)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err) }
  return err
}

func (p *FU_LB) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetPos() {
    if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Pos)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err) }
  }
  return err
}

func (p *FU_LB) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err) }
  return err
}

func (p *FU_LB) Equals(other *FU_LB) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Ctrl != other.Ctrl { return false }
  if p.Op != other.Op { return false }
  if p.Pos != other.Pos {
    if p.Pos == nil || other.Pos == nil {
      return false
    }
    if (*p.Pos) != (*other.Pos) { return false }
  }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src81 := other.V[i]
    if !_tgt.Equals(_src81) { return false }
  }
  return true
}

func (p *FU_LB) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FU_LB(%+v)", *p)
}

func (p *FU_LB) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FU_LB",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_LB)(nil)

func (p *FU_LB) Validate() error {
  return nil
}
// The Serial Values Cell field with Update Operation
// 
// Attributes:
//  - FieldID: The Field ID, a single ID can have any/all the field types
//  - VInt64: The INT64 type update-field
//  - VDouble: The DOUBLE type update-field
//  - VBytes: The BYTES type update-field
//  - VKey: The Cell KEY type update-field
//  - VLi: The LIST INT64 type update-field
//  - VLb: The LIST BYTES type update-field
type CellValueSerialOp struct {
  FieldID int32 `thrift:"field_id,1" db:"field_id" json:"field_id"`
  VInt64 *FU_INT64 `thrift:"v_int64,2" db:"v_int64" json:"v_int64,omitempty"`
  VDouble *FU_DOUBLE `thrift:"v_double,3" db:"v_double" json:"v_double,omitempty"`
  VBytes *FU_BYTES `thrift:"v_bytes,4" db:"v_bytes" json:"v_bytes,omitempty"`
  VKey Key `thrift:"v_key,5" db:"v_key" json:"v_key,omitempty"`
  VLi *FU_LI `thrift:"v_li,6" db:"v_li" json:"v_li,omitempty"`
  VLb *FU_LB `thrift:"v_lb,7" db:"v_lb" json:"v_lb,omitempty"`
}

func NewCellValueSerialOp() *CellValueSerialOp {
  return &CellValueSerialOp{}
}


func (p *CellValueSerialOp) GetFieldID() int32 {
  return p.FieldID
}
var CellValueSerialOp_VInt64_DEFAULT *FU_INT64
func (p *CellValueSerialOp) GetVInt64() *FU_INT64 {
  if !p.IsSetVInt64() {
    return CellValueSerialOp_VInt64_DEFAULT
  }
  return p.VInt64
}
var CellValueSerialOp_VDouble_DEFAULT *FU_DOUBLE
func (p *CellValueSerialOp) GetVDouble() *FU_DOUBLE {
  if !p.IsSetVDouble() {
    return CellValueSerialOp_VDouble_DEFAULT
  }
  return p.VDouble
}
var CellValueSerialOp_VBytes_DEFAULT *FU_BYTES
func (p *CellValueSerialOp) GetVBytes() *FU_BYTES {
  if !p.IsSetVBytes() {
    return CellValueSerialOp_VBytes_DEFAULT
  }
  return p.VBytes
}
var CellValueSerialOp_VKey_DEFAULT Key

func (p *CellValueSerialOp) GetVKey() Key {
  return p.VKey
}
var CellValueSerialOp_VLi_DEFAULT *FU_LI
func (p *CellValueSerialOp) GetVLi() *FU_LI {
  if !p.IsSetVLi() {
    return CellValueSerialOp_VLi_DEFAULT
  }
  return p.VLi
}
var CellValueSerialOp_VLb_DEFAULT *FU_LB
func (p *CellValueSerialOp) GetVLb() *FU_LB {
  if !p.IsSetVLb() {
    return CellValueSerialOp_VLb_DEFAULT
  }
  return p.VLb
}
func (p *CellValueSerialOp) IsSetVInt64() bool {
  return p.VInt64 != nil
}

func (p *CellValueSerialOp) IsSetVDouble() bool {
  return p.VDouble != nil
}

func (p *CellValueSerialOp) IsSetVBytes() bool {
  return p.VBytes != nil
}

func (p *CellValueSerialOp) IsSetVKey() bool {
  return p.VKey != nil
}

func (p *CellValueSerialOp) IsSetVLi() bool {
  return p.VLi != nil
}

func (p *CellValueSerialOp) IsSetVLb() bool {
  return p.VLb != nil
}

func (p *CellValueSerialOp) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 7:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField7(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CellValueSerialOp)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.FieldID = v
}
  return nil
}

func (p *CellValueSerialOp)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.VInt64 = &FU_INT64{
  Op: 0,
}
  if err := p.VInt64.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.VInt64), err)
  }
  return nil
}

func (p *CellValueSerialOp)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  p.VDouble = &FU_DOUBLE{
  Op: 0,
}
  if err := p.VDouble.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.VDouble), err)
  }
  return nil
}

func (p *CellValueSerialOp)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.VBytes = &FU_BYTES{
  Op: 0,
}
  if err := p.VBytes.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.VBytes), err)
  }
  return nil
}

func (p *CellValueSerialOp)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.VKey =  tSlice
  for i := 0; i < size; i ++ {
var _elem82 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem82 = v
}
    p.VKey = append(p.VKey, _elem82)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellValueSerialOp)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  p.VLi = &FU_LI{
  Op: 0,
}
  if err := p.VLi.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.VLi), err)
  }
  return nil
}

func (p *CellValueSerialOp)  ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
  p.VLb = &FU_LB{
  Op: 0,
}
  if err := p.VLb.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.VLb), err)
  }
  return nil
}

func (p *CellValueSerialOp) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CellValueSerialOp"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
    if err := p.writeField7(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CellValueSerialOp) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "field_id", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field_id: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.FieldID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.field_id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field_id: ", p), err) }
  return err
}

func (p *CellValueSerialOp) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVInt64() {
    if err := oprot.WriteFieldBegin(ctx, "v_int64", thrift.STRUCT, 2); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v_int64: ", p), err) }
    if err := p.VInt64.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.VInt64), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v_int64: ", p), err) }
  }
  return err
}

func (p *CellValueSerialOp) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVDouble() {
    if err := oprot.WriteFieldBegin(ctx, "v_double", thrift.STRUCT, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v_double: ", p), err) }
    if err := p.VDouble.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.VDouble), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v_double: ", p), err) }
  }
  return err
}

func (p *CellValueSerialOp) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVBytes() {
    if err := oprot.WriteFieldBegin(ctx, "v_bytes", thrift.STRUCT, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v_bytes: ", p), err) }
    if err := p.VBytes.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.VBytes), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v_bytes: ", p), err) }
  }
  return err
}

func (p *CellValueSerialOp) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVKey() {
    if err := oprot.WriteFieldBegin(ctx, "v_key", thrift.LIST, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v_key: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.VKey)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.VKey {
      if err := oprot.WriteBinary(ctx, v); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v_key: ", p), err) }
  }
  return err
}

func (p *CellValueSerialOp) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVLi() {
    if err := oprot.WriteFieldBegin(ctx, "v_li", thrift.STRUCT, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:v_li: ", p), err) }
    if err := p.VLi.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.VLi), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:v_li: ", p), err) }
  }
  return err
}

func (p *CellValueSerialOp) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetVLb() {
    if err := oprot.WriteFieldBegin(ctx, "v_lb", thrift.STRUCT, 7); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:v_lb: ", p), err) }
    if err := p.VLb.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.VLb), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 7:v_lb: ", p), err) }
  }
  return err
}

func (p *CellValueSerialOp) Equals(other *CellValueSerialOp) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.FieldID != other.FieldID { return false }
  if !p.VInt64.Equals(other.VInt64) { return false }
  if !p.VDouble.Equals(other.VDouble) { return false }
  if !p.VBytes.Equals(other.VBytes) { return false }
  if len(p.VKey) != len(other.VKey) { return false }
  for i, _tgt := range p.VKey {
    _src83 := other.VKey[i]
    if bytes.Compare(_tgt, _src83) != 0 { return false }
  }
  if !p.VLi.Equals(other.VLi) { return false }
  if !p.VLb.Equals(other.VLb) { return false }
  return true
}

func (p *CellValueSerialOp) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CellValueSerialOp(%+v)", *p)
}

func (p *CellValueSerialOp) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CellValueSerialOp",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellValueSerialOp)(nil)

func (p *CellValueSerialOp) Validate() error {
  return nil
}
// The Cell data for using with Update of SERIAL Column Type
// 
// Attributes:
//  - F: The Cell Flag
//  - K: The Cell Key
//  - Ts: The Cell Timestamp in nanoseconds
//  - TsDesc: The Cell Version is in timestamp descending
//  - V: The Serial Cell Value fields
//  - Encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
type UCellSerial struct {
  F Flag `thrift:"f,1" db:"f" json:"f"`
  K Key `thrift:"k,2" db:"k" json:"k"`
  Ts *int64 `thrift:"ts,3" db:"ts" json:"ts,omitempty"`
  TsDesc *bool `thrift:"ts_desc,4" db:"ts_desc" json:"ts_desc,omitempty"`
  V CellValuesSerial `thrift:"v,5" db:"v" json:"v"`
  Encoder *EncodingType `thrift:"encoder,6" db:"encoder" json:"encoder,omitempty"`
}

func NewUCellSerial() *UCellSerial {
  return &UCellSerial{}
}


func (p *UCellSerial) GetF() Flag {
  return p.F
}

func (p *UCellSerial) GetK() Key {
  return p.K
}
var UCellSerial_Ts_DEFAULT int64
func (p *UCellSerial) GetTs() int64 {
  if !p.IsSetTs() {
    return UCellSerial_Ts_DEFAULT
  }
  return *p.Ts
}
var UCellSerial_TsDesc_DEFAULT bool
func (p *UCellSerial) GetTsDesc() bool {
  if !p.IsSetTsDesc() {
    return UCellSerial_TsDesc_DEFAULT
  }
  return *p.TsDesc
}

func (p *UCellSerial) GetV() CellValuesSerial {
  return p.V
}
var UCellSerial_Encoder_DEFAULT EncodingType
func (p *UCellSerial) GetEncoder() EncodingType {
  if !p.IsSetEncoder() {
    return UCellSerial_Encoder_DEFAULT
  }
  return *p.Encoder
}
func (p *UCellSerial) IsSetTs() bool {
  return p.Ts != nil
}

func (p *UCellSerial) IsSetTsDesc() bool {
  return p.TsDesc != nil
}

func (p *UCellSerial) IsSetEncoder() bool {
  return p.Encoder != nil
}

func (p *UCellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.BOOL {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 6:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField6(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *UCellSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := Flag(v)
  p.F = temp
}
  return nil
}

func (p *UCellSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem84 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem84 = v
}
    p.K = append(p.K, _elem84)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *UCellSerial)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Ts = &v
}
  return nil
}

func (p *UCellSerial)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBool(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.TsDesc = &v
}
  return nil
}

func (p *UCellSerial)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellValuesSerial, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem85 := &CellValueSerial{}
    if err := _elem85.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem85), err)
    }
    p.V = append(p.V, _elem85)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *UCellSerial)  ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 6: ", err)
} else {
  temp := EncodingType(v)
  p.Encoder = &temp
}
  return nil
}

func (p *UCellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "UCellSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
    if err := p.writeField6(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *UCellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "f", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:f: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.F)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.f (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:f: ", p), err) }
  return err
}

func (p *UCellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err) }
  return err
}

func (p *UCellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTs() {
    if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Ts)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err) }
  }
  return err
}

func (p *UCellSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetTsDesc() {
    if err := oprot.WriteFieldBegin(ctx, "ts_desc", thrift.BOOL, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ts_desc: ", p), err) }
    if err := oprot.WriteBool(ctx, bool(*p.TsDesc)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.ts_desc (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ts_desc: ", p), err) }
  }
  return err
}

func (p *UCellSerial) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 5); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err) }
  return err
}

func (p *UCellSerial) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEncoder() {
    if err := oprot.WriteFieldBegin(ctx, "encoder", thrift.I32, 6); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:encoder: ", p), err) }
    if err := oprot.WriteI32(ctx, int32(*p.Encoder)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.encoder (6) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 6:encoder: ", p), err) }
  }
  return err
}

func (p *UCellSerial) Equals(other *UCellSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.F != other.F { return false }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src86 := other.K[i]
    if bytes.Compare(_tgt, _src86) != 0 { return false }
  }
  if p.Ts != other.Ts {
    if p.Ts == nil || other.Ts == nil {
      return false
    }
    if (*p.Ts) != (*other.Ts) { return false }
  }
  if p.TsDesc != other.TsDesc {
    if p.TsDesc == nil || other.TsDesc == nil {
      return false
    }
    if (*p.TsDesc) != (*other.TsDesc) { return false }
  }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src87 := other.V[i]
    if !_tgt.Equals(_src87) { return false }
  }
  if p.Encoder != other.Encoder {
    if p.Encoder == nil || other.Encoder == nil {
      return false
    }
    if (*p.Encoder) != (*other.Encoder) { return false }
  }
  return true
}

func (p *UCellSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("UCellSerial(%+v)", *p)
}

func (p *UCellSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.UCellSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*UCellSerial)(nil)

func (p *UCellSerial) Validate() error {
  return nil
}
// The Cell for results list of scan
// 
// Attributes:
//  - C: The Column Name
//  - K: The Cell Key
//  - Ts: The Cell Timestamp
//  - V: The Cell Value
type CellPlain struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  K Key `thrift:"k,2" db:"k" json:"k"`
  Ts int64 `thrift:"ts,3" db:"ts" json:"ts"`
  V []byte `thrift:"v,4" db:"v" json:"v"`
}

func NewCellPlain() *CellPlain {
  return &CellPlain{}
}


func (p *CellPlain) GetC() string {
  return p.C
}

func (p *CellPlain) GetK() Key {
  return p.K
}

func (p *CellPlain) GetTs() int64 {
  return p.Ts
}

func (p *CellPlain) GetV() []byte {
  return p.V
}
func (p *CellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CellPlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *CellPlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem88 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem88 = v
}
    p.K = append(p.K, _elem88)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellPlain)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *CellPlain)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *CellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CellPlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *CellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err) }
  return err
}

func (p *CellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err) }
  return err
}

func (p *CellPlain) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err) }
  return err
}

func (p *CellPlain) Equals(other *CellPlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src89 := other.K[i]
    if bytes.Compare(_tgt, _src89) != 0 { return false }
  }
  if p.Ts != other.Ts { return false }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  return true
}

func (p *CellPlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CellPlain(%+v)", *p)
}

func (p *CellPlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CellPlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellPlain)(nil)

func (p *CellPlain) Validate() error {
  return nil
}
// The Counter Cell for results list of scan
// 
// Attributes:
//  - C: The Column Name
//  - K: The Cell Key
//  - Ts: The Cell Timestamp
//  - V: The Cell Counter Value
//  - Eq: The Counter EQ since ts
type CellCounter struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  K Key `thrift:"k,2" db:"k" json:"k"`
  Ts int64 `thrift:"ts,3" db:"ts" json:"ts"`
  V int64 `thrift:"v,4" db:"v" json:"v"`
  Eq *int64 `thrift:"eq,5" db:"eq" json:"eq,omitempty"`
}

func NewCellCounter() *CellCounter {
  return &CellCounter{}
}


func (p *CellCounter) GetC() string {
  return p.C
}

func (p *CellCounter) GetK() Key {
  return p.K
}

func (p *CellCounter) GetTs() int64 {
  return p.Ts
}

func (p *CellCounter) GetV() int64 {
  return p.V
}
var CellCounter_Eq_DEFAULT int64
func (p *CellCounter) GetEq() int64 {
  if !p.IsSetEq() {
    return CellCounter_Eq_DEFAULT
  }
  return *p.Eq
}
func (p *CellCounter) IsSetEq() bool {
  return p.Eq != nil
}

func (p *CellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 5:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField5(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CellCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *CellCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem90 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem90 = v
}
    p.K = append(p.K, _elem90)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellCounter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *CellCounter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *CellCounter)  ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 5: ", err)
} else {
  p.Eq = &v
}
  return nil
}

func (p *CellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CellCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
    if err := p.writeField5(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *CellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err) }
  return err
}

func (p *CellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err) }
  return err
}

func (p *CellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err) }
  return err
}

func (p *CellCounter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEq() {
    if err := oprot.WriteFieldBegin(ctx, "eq", thrift.I64, 5); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:eq: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Eq)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.eq (5) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 5:eq: ", p), err) }
  }
  return err
}

func (p *CellCounter) Equals(other *CellCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src91 := other.K[i]
    if bytes.Compare(_tgt, _src91) != 0 { return false }
  }
  if p.Ts != other.Ts { return false }
  if p.V != other.V { return false }
  if p.Eq != other.Eq {
    if p.Eq == nil || other.Eq == nil {
      return false
    }
    if (*p.Eq) != (*other.Eq) { return false }
  }
  return true
}

func (p *CellCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CellCounter(%+v)", *p)
}

func (p *CellCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CellCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellCounter)(nil)

func (p *CellCounter) Validate() error {
  return nil
}
// The Serial Cell for results list of scan
// 
// Attributes:
//  - C: The Column Name
//  - K: The Cell Key
//  - Ts: The Cell Timestamp
//  - V: The Cell Serial Value
type CellSerial struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  K Key `thrift:"k,2" db:"k" json:"k"`
  Ts int64 `thrift:"ts,3" db:"ts" json:"ts"`
  V CellValuesSerial `thrift:"v,4" db:"v" json:"v"`
}

func NewCellSerial() *CellSerial {
  return &CellSerial{}
}


func (p *CellSerial) GetC() string {
  return p.C
}

func (p *CellSerial) GetK() Key {
  return p.K
}

func (p *CellSerial) GetTs() int64 {
  return p.Ts
}

func (p *CellSerial) GetV() CellValuesSerial {
  return p.V
}
func (p *CellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CellSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *CellSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem92 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem92 = v
}
    p.K = append(p.K, _elem92)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellSerial)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *CellSerial)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellValuesSerial, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem93 := &CellValueSerial{}
    if err := _elem93.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem93), err)
    }
    p.V = append(p.V, _elem93)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CellSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *CellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err) }
  return err
}

func (p *CellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err) }
  return err
}

func (p *CellSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err) }
  return err
}

func (p *CellSerial) Equals(other *CellSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src94 := other.K[i]
    if bytes.Compare(_tgt, _src94) != 0 { return false }
  }
  if p.Ts != other.Ts { return false }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src95 := other.V[i]
    if !_tgt.Equals(_src95) { return false }
  }
  return true
}

func (p *CellSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CellSerial(%+v)", *p)
}

func (p *CellSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CellSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellSerial)(nil)

func (p *CellSerial) Validate() error {
  return nil
}
// The Cells for results list of scan
// 
// Attributes:
//  - PlainCells: The Cells, defined as Cell items in a list-container
//  - CounterCells: The Cells, defined as Cell items in a list-container
//  - SerialCells: The Serial Cells, defined as CellSerial items in a list-container
type Cells struct {
  PlainCells CellsPlain `thrift:"plain_cells,1" db:"plain_cells" json:"plain_cells"`
  CounterCells CellsCounter `thrift:"counter_cells,2" db:"counter_cells" json:"counter_cells"`
  SerialCells CellsSerial `thrift:"serial_cells,3" db:"serial_cells" json:"serial_cells"`
}

func NewCells() *Cells {
  return &Cells{}
}


func (p *Cells) GetPlainCells() CellsPlain {
  return p.PlainCells
}

func (p *Cells) GetCounterCells() CellsCounter {
  return p.CounterCells
}

func (p *Cells) GetSerialCells() CellsSerial {
  return p.SerialCells
}
func (p *Cells) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Cells)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellsPlain, 0, size)
  p.PlainCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem96 := &CellPlain{}
    if err := _elem96.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem96), err)
    }
    p.PlainCells = append(p.PlainCells, _elem96)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Cells)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellsCounter, 0, size)
  p.CounterCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem97 := &CellCounter{}
    if err := _elem97.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem97), err)
    }
    p.CounterCells = append(p.CounterCells, _elem97)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Cells)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellsSerial, 0, size)
  p.SerialCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem98 := &CellSerial{}
    if err := _elem98.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem98), err)
    }
    p.SerialCells = append(p.SerialCells, _elem98)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Cells) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Cells"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Cells) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "plain_cells", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:plain_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.PlainCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.PlainCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:plain_cells: ", p), err) }
  return err
}

func (p *Cells) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counter_cells", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:counter_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.CounterCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.CounterCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:counter_cells: ", p), err) }
  return err
}

func (p *Cells) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serial_cells", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serial_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.SerialCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.SerialCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serial_cells: ", p), err) }
  return err
}

func (p *Cells) Equals(other *Cells) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.PlainCells) != len(other.PlainCells) { return false }
  for i, _tgt := range p.PlainCells {
    _src99 := other.PlainCells[i]
    if !_tgt.Equals(_src99) { return false }
  }
  if len(p.CounterCells) != len(other.CounterCells) { return false }
  for i, _tgt := range p.CounterCells {
    _src100 := other.CounterCells[i]
    if !_tgt.Equals(_src100) { return false }
  }
  if len(p.SerialCells) != len(other.SerialCells) { return false }
  for i, _tgt := range p.SerialCells {
    _src101 := other.SerialCells[i]
    if !_tgt.Equals(_src101) { return false }
  }
  return true
}

func (p *Cells) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Cells(%+v)", *p)
}

func (p *Cells) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.Cells",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Cells)(nil)

func (p *Cells) Validate() error {
  return nil
}
// The Plain column type Cell for results on Columns of scan
// 
// Attributes:
//  - K: The Cell Key
//  - Ts: The Cell Timestamp
//  - V: The Cell Value
type CCellPlain struct {
  K Key `thrift:"k,1" db:"k" json:"k"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V []byte `thrift:"v,3" db:"v" json:"v"`
}

func NewCCellPlain() *CCellPlain {
  return &CCellPlain{}
}


func (p *CCellPlain) GetK() Key {
  return p.K
}

func (p *CCellPlain) GetTs() int64 {
  return p.Ts
}

func (p *CCellPlain) GetV() []byte {
  return p.V
}
func (p *CCellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CCellPlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem102 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem102 = v
}
    p.K = append(p.K, _elem102)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CCellPlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *CCellPlain)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *CCellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CCellPlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CCellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:k: ", p), err) }
  return err
}

func (p *CCellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *CCellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *CCellPlain) Equals(other *CCellPlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src103 := other.K[i]
    if bytes.Compare(_tgt, _src103) != 0 { return false }
  }
  if p.Ts != other.Ts { return false }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  return true
}

func (p *CCellPlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CCellPlain(%+v)", *p)
}

func (p *CCellPlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CCellPlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CCellPlain)(nil)

func (p *CCellPlain) Validate() error {
  return nil
}
// The Counter column type Cell for results on Columns of scan
// 
// Attributes:
//  - K: The Cell Key
//  - Ts: The Cell Timestamp
//  - V: The Cell Counter Value
//  - Eq: The Counter EQ since ts
type CCellCounter struct {
  K Key `thrift:"k,1" db:"k" json:"k"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V int64 `thrift:"v,3" db:"v" json:"v"`
  Eq *int64 `thrift:"eq,4" db:"eq" json:"eq,omitempty"`
}

func NewCCellCounter() *CCellCounter {
  return &CCellCounter{}
}


func (p *CCellCounter) GetK() Key {
  return p.K
}

func (p *CCellCounter) GetTs() int64 {
  return p.Ts
}

func (p *CCellCounter) GetV() int64 {
  return p.V
}
var CCellCounter_Eq_DEFAULT int64
func (p *CCellCounter) GetEq() int64 {
  if !p.IsSetEq() {
    return CCellCounter_Eq_DEFAULT
  }
  return *p.Eq
}
func (p *CCellCounter) IsSetEq() bool {
  return p.Eq != nil
}

func (p *CCellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CCellCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem104 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem104 = v
}
    p.K = append(p.K, _elem104)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CCellCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *CCellCounter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *CCellCounter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Eq = &v
}
  return nil
}

func (p *CCellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CCellCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CCellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:k: ", p), err) }
  return err
}

func (p *CCellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *CCellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *CCellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEq() {
    if err := oprot.WriteFieldBegin(ctx, "eq", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:eq: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Eq)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.eq (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:eq: ", p), err) }
  }
  return err
}

func (p *CCellCounter) Equals(other *CCellCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src105 := other.K[i]
    if bytes.Compare(_tgt, _src105) != 0 { return false }
  }
  if p.Ts != other.Ts { return false }
  if p.V != other.V { return false }
  if p.Eq != other.Eq {
    if p.Eq == nil || other.Eq == nil {
      return false
    }
    if (*p.Eq) != (*other.Eq) { return false }
  }
  return true
}

func (p *CCellCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CCellCounter(%+v)", *p)
}

func (p *CCellCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CCellCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CCellCounter)(nil)

func (p *CCellCounter) Validate() error {
  return nil
}
// The Serial column type Cell for results on Columns of scan
// 
// Attributes:
//  - K: The Cell Key
//  - Ts: The Cell Timestamp
//  - V: The Cell Serial Value
type CCellSerial struct {
  K Key `thrift:"k,1" db:"k" json:"k"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V CellValuesSerial `thrift:"v,3" db:"v" json:"v"`
}

func NewCCellSerial() *CCellSerial {
  return &CCellSerial{}
}


func (p *CCellSerial) GetK() Key {
  return p.K
}

func (p *CCellSerial) GetTs() int64 {
  return p.Ts
}

func (p *CCellSerial) GetV() CellValuesSerial {
  return p.V
}
func (p *CCellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CCellSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem106 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem106 = v
}
    p.K = append(p.K, _elem106)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CCellSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *CCellSerial)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellValuesSerial, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem107 := &CellValueSerial{}
    if err := _elem107.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem107), err)
    }
    p.V = append(p.V, _elem107)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CCellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CCellSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CCellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:k: ", p), err) }
  return err
}

func (p *CCellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *CCellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *CCellSerial) Equals(other *CCellSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src108 := other.K[i]
    if bytes.Compare(_tgt, _src108) != 0 { return false }
  }
  if p.Ts != other.Ts { return false }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src109 := other.V[i]
    if !_tgt.Equals(_src109) { return false }
  }
  return true
}

func (p *CCellSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CCellSerial(%+v)", *p)
}

func (p *CCellSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CCellSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CCellSerial)(nil)

func (p *CCellSerial) Validate() error {
  return nil
}
// The Column Cells for results on Columns of scan
// 
// Attributes:
//  - PlainCells: The Plain type Cells, defined as CCellPlain items in a list-container
//  - CounterCells: The Counter type Cells, defined as CCellCounter items in a list-container
//  - SerialCells: The Serial type Cells, defined as CCellSerial items in a list-container
type CCells struct {
  PlainCells []*CCellPlain `thrift:"plain_cells,1" db:"plain_cells" json:"plain_cells"`
  CounterCells []*CCellCounter `thrift:"counter_cells,2" db:"counter_cells" json:"counter_cells"`
  SerialCells []*CCellSerial `thrift:"serial_cells,3" db:"serial_cells" json:"serial_cells"`
}

func NewCCells() *CCells {
  return &CCells{}
}


func (p *CCells) GetPlainCells() []*CCellPlain {
  return p.PlainCells
}

func (p *CCells) GetCounterCells() []*CCellCounter {
  return p.CounterCells
}

func (p *CCells) GetSerialCells() []*CCellSerial {
  return p.SerialCells
}
func (p *CCells) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CCells)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CCellPlain, 0, size)
  p.PlainCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem110 := &CCellPlain{}
    if err := _elem110.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem110), err)
    }
    p.PlainCells = append(p.PlainCells, _elem110)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CCells)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CCellCounter, 0, size)
  p.CounterCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem111 := &CCellCounter{}
    if err := _elem111.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem111), err)
    }
    p.CounterCells = append(p.CounterCells, _elem111)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CCells)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*CCellSerial, 0, size)
  p.SerialCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem112 := &CCellSerial{}
    if err := _elem112.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem112), err)
    }
    p.SerialCells = append(p.SerialCells, _elem112)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CCells) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "cCells"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CCells) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "plain_cells", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:plain_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.PlainCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.PlainCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:plain_cells: ", p), err) }
  return err
}

func (p *CCells) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counter_cells", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:counter_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.CounterCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.CounterCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:counter_cells: ", p), err) }
  return err
}

func (p *CCells) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serial_cells", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serial_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.SerialCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.SerialCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serial_cells: ", p), err) }
  return err
}

func (p *CCells) Equals(other *CCells) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.PlainCells) != len(other.PlainCells) { return false }
  for i, _tgt := range p.PlainCells {
    _src113 := other.PlainCells[i]
    if !_tgt.Equals(_src113) { return false }
  }
  if len(p.CounterCells) != len(other.CounterCells) { return false }
  for i, _tgt := range p.CounterCells {
    _src114 := other.CounterCells[i]
    if !_tgt.Equals(_src114) { return false }
  }
  if len(p.SerialCells) != len(other.SerialCells) { return false }
  for i, _tgt := range p.SerialCells {
    _src115 := other.SerialCells[i]
    if !_tgt.Equals(_src115) { return false }
  }
  return true
}

func (p *CCells) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CCells(%+v)", *p)
}

func (p *CCells) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CCells",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CCells)(nil)

func (p *CCells) Validate() error {
  return nil
}
// The Plain column type Key Cell for results on Key of scan
// 
// Attributes:
//  - C: The Column Name
//  - Ts: The Cell Timestamp
//  - V: The Cell Value
type KCellPlain struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V []byte `thrift:"v,3" db:"v" json:"v"`
}

func NewKCellPlain() *KCellPlain {
  return &KCellPlain{}
}


func (p *KCellPlain) GetC() string {
  return p.C
}

func (p *KCellPlain) GetTs() int64 {
  return p.Ts
}

func (p *KCellPlain) GetV() []byte {
  return p.V
}
func (p *KCellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *KCellPlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *KCellPlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *KCellPlain)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *KCellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "KCellPlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KCellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *KCellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *KCellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *KCellPlain) Equals(other *KCellPlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if p.Ts != other.Ts { return false }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  return true
}

func (p *KCellPlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KCellPlain(%+v)", *p)
}

func (p *KCellPlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.KCellPlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*KCellPlain)(nil)

func (p *KCellPlain) Validate() error {
  return nil
}
// The Counter column type Key Cell for results on Key of scan
// 
// Attributes:
//  - C: The Column Name
//  - Ts: The Cell Timestamp
//  - V: The Cell Counter Value
//  - Eq: The Counter EQ since ts
type KCellCounter struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V int64 `thrift:"v,3" db:"v" json:"v"`
  Eq *int64 `thrift:"eq,4" db:"eq" json:"eq,omitempty"`
}

func NewKCellCounter() *KCellCounter {
  return &KCellCounter{}
}


func (p *KCellCounter) GetC() string {
  return p.C
}

func (p *KCellCounter) GetTs() int64 {
  return p.Ts
}

func (p *KCellCounter) GetV() int64 {
  return p.V
}
var KCellCounter_Eq_DEFAULT int64
func (p *KCellCounter) GetEq() int64 {
  if !p.IsSetEq() {
    return KCellCounter_Eq_DEFAULT
  }
  return *p.Eq
}
func (p *KCellCounter) IsSetEq() bool {
  return p.Eq != nil
}

func (p *KCellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *KCellCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *KCellCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *KCellCounter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *KCellCounter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Eq = &v
}
  return nil
}

func (p *KCellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "KCellCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KCellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *KCellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *KCellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *KCellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEq() {
    if err := oprot.WriteFieldBegin(ctx, "eq", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:eq: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Eq)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.eq (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:eq: ", p), err) }
  }
  return err
}

func (p *KCellCounter) Equals(other *KCellCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if p.Ts != other.Ts { return false }
  if p.V != other.V { return false }
  if p.Eq != other.Eq {
    if p.Eq == nil || other.Eq == nil {
      return false
    }
    if (*p.Eq) != (*other.Eq) { return false }
  }
  return true
}

func (p *KCellCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KCellCounter(%+v)", *p)
}

func (p *KCellCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.KCellCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*KCellCounter)(nil)

func (p *KCellCounter) Validate() error {
  return nil
}
// The Serial column type Key Cell for results on Key of scan
// 
// Attributes:
//  - C: The Column Name
//  - Ts: The Cell Timestamp
//  - V: The Cell Serial Value
type KCellSerial struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V CellValuesSerial `thrift:"v,3" db:"v" json:"v"`
}

func NewKCellSerial() *KCellSerial {
  return &KCellSerial{}
}


func (p *KCellSerial) GetC() string {
  return p.C
}

func (p *KCellSerial) GetTs() int64 {
  return p.Ts
}

func (p *KCellSerial) GetV() CellValuesSerial {
  return p.V
}
func (p *KCellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *KCellSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *KCellSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *KCellSerial)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellValuesSerial, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem116 := &CellValueSerial{}
    if err := _elem116.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem116), err)
    }
    p.V = append(p.V, _elem116)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *KCellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "KCellSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KCellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *KCellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *KCellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *KCellSerial) Equals(other *KCellSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if p.Ts != other.Ts { return false }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src117 := other.V[i]
    if !_tgt.Equals(_src117) { return false }
  }
  return true
}

func (p *KCellSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KCellSerial(%+v)", *p)
}

func (p *KCellSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.KCellSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*KCellSerial)(nil)

func (p *KCellSerial) Validate() error {
  return nil
}
// The Key Cells for results on Key of scan
// 
// Attributes:
//  - K: The Cell Key
//  - PlainCells: The Plain type Key Cells, defined as KCellPlain items in a list-container
//  - CounterCells: The Counter type Key Cells, defined as KCellCounter items in a list-container
//  - SerialCells: The Serial type Key Cells, defined as KCellSerial items in a list-container
type KCells struct {
  K Key `thrift:"k,1" db:"k" json:"k"`
  PlainCells []*KCellPlain `thrift:"plain_cells,2" db:"plain_cells" json:"plain_cells"`
  CounterCells []*KCellCounter `thrift:"counter_cells,3" db:"counter_cells" json:"counter_cells"`
  SerialCells []*KCellSerial `thrift:"serial_cells,4" db:"serial_cells" json:"serial_cells"`
}

func NewKCells() *KCells {
  return &KCells{}
}


func (p *KCells) GetK() Key {
  return p.K
}

func (p *KCells) GetPlainCells() []*KCellPlain {
  return p.PlainCells
}

func (p *KCells) GetCounterCells() []*KCellCounter {
  return p.CounterCells
}

func (p *KCells) GetSerialCells() []*KCellSerial {
  return p.SerialCells
}
func (p *KCells) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *KCells)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Key, 0, size)
  p.K =  tSlice
  for i := 0; i < size; i ++ {
var _elem118 []byte
    if v, err := iprot.ReadBinary(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _elem118 = v
}
    p.K = append(p.K, _elem118)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *KCells)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*KCellPlain, 0, size)
  p.PlainCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem119 := &KCellPlain{}
    if err := _elem119.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem119), err)
    }
    p.PlainCells = append(p.PlainCells, _elem119)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *KCells)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*KCellCounter, 0, size)
  p.CounterCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem120 := &KCellCounter{}
    if err := _elem120.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem120), err)
    }
    p.CounterCells = append(p.CounterCells, _elem120)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *KCells)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*KCellSerial, 0, size)
  p.SerialCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem121 := &KCellSerial{}
    if err := _elem121.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem121), err)
    }
    p.SerialCells = append(p.SerialCells, _elem121)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *KCells) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "kCells"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *KCells) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:k: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.K)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.K {
    if err := oprot.WriteBinary(ctx, v); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:k: ", p), err) }
  return err
}

func (p *KCells) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "plain_cells", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:plain_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.PlainCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.PlainCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:plain_cells: ", p), err) }
  return err
}

func (p *KCells) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counter_cells", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:counter_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.CounterCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.CounterCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:counter_cells: ", p), err) }
  return err
}

func (p *KCells) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serial_cells", thrift.LIST, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:serial_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.SerialCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.SerialCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:serial_cells: ", p), err) }
  return err
}

func (p *KCells) Equals(other *KCells) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.K) != len(other.K) { return false }
  for i, _tgt := range p.K {
    _src122 := other.K[i]
    if bytes.Compare(_tgt, _src122) != 0 { return false }
  }
  if len(p.PlainCells) != len(other.PlainCells) { return false }
  for i, _tgt := range p.PlainCells {
    _src123 := other.PlainCells[i]
    if !_tgt.Equals(_src123) { return false }
  }
  if len(p.CounterCells) != len(other.CounterCells) { return false }
  for i, _tgt := range p.CounterCells {
    _src124 := other.CounterCells[i]
    if !_tgt.Equals(_src124) { return false }
  }
  if len(p.SerialCells) != len(other.SerialCells) { return false }
  for i, _tgt := range p.SerialCells {
    _src125 := other.SerialCells[i]
    if !_tgt.Equals(_src125) { return false }
  }
  return true
}

func (p *KCells) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("KCells(%+v)", *p)
}

func (p *KCells) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.KCells",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*KCells)(nil)

func (p *KCells) Validate() error {
  return nil
}
// The Plain column type Fraction Cell for results on Fraction of scan
// 
// Attributes:
//  - C: The Column Name
//  - Ts: The Cell Timestamp
//  - V: The Cell Value
type FCellPlain struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V []byte `thrift:"v,3" db:"v" json:"v"`
}

func NewFCellPlain() *FCellPlain {
  return &FCellPlain{}
}


func (p *FCellPlain) GetC() string {
  return p.C
}

func (p *FCellPlain) GetTs() int64 {
  return p.Ts
}

func (p *FCellPlain) GetV() []byte {
  return p.V
}
func (p *FCellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FCellPlain)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *FCellPlain)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *FCellPlain)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadBinary(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *FCellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FCellPlain"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FCellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *FCellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *FCellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteBinary(ctx, p.V); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *FCellPlain) Equals(other *FCellPlain) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if p.Ts != other.Ts { return false }
  if bytes.Compare(p.V, other.V) != 0 { return false }
  return true
}

func (p *FCellPlain) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FCellPlain(%+v)", *p)
}

func (p *FCellPlain) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FCellPlain",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FCellPlain)(nil)

func (p *FCellPlain) Validate() error {
  return nil
}
// The Counter column type Fraction Cell for results on Fraction of scan
// 
// Attributes:
//  - C: The Column Name
//  - Ts: The Cell Timestamp
//  - V: The Cell Counter Value
//  - Eq: The Counter EQ since ts
type FCellCounter struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V int64 `thrift:"v,3" db:"v" json:"v"`
  Eq *int64 `thrift:"eq,4" db:"eq" json:"eq,omitempty"`
}

func NewFCellCounter() *FCellCounter {
  return &FCellCounter{}
}


func (p *FCellCounter) GetC() string {
  return p.C
}

func (p *FCellCounter) GetTs() int64 {
  return p.Ts
}

func (p *FCellCounter) GetV() int64 {
  return p.V
}
var FCellCounter_Eq_DEFAULT int64
func (p *FCellCounter) GetEq() int64 {
  if !p.IsSetEq() {
    return FCellCounter_Eq_DEFAULT
  }
  return *p.Eq
}
func (p *FCellCounter) IsSetEq() bool {
  return p.Eq != nil
}

func (p *FCellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FCellCounter)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *FCellCounter)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *FCellCounter)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 3: ", err)
} else {
  p.V = v
}
  return nil
}

func (p *FCellCounter)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.Eq = &v
}
  return nil
}

func (p *FCellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FCellCounter"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FCellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *FCellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *FCellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.V)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *FCellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetEq() {
    if err := oprot.WriteFieldBegin(ctx, "eq", thrift.I64, 4); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:eq: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Eq)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.eq (4) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 4:eq: ", p), err) }
  }
  return err
}

func (p *FCellCounter) Equals(other *FCellCounter) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if p.Ts != other.Ts { return false }
  if p.V != other.V { return false }
  if p.Eq != other.Eq {
    if p.Eq == nil || other.Eq == nil {
      return false
    }
    if (*p.Eq) != (*other.Eq) { return false }
  }
  return true
}

func (p *FCellCounter) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FCellCounter(%+v)", *p)
}

func (p *FCellCounter) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FCellCounter",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FCellCounter)(nil)

func (p *FCellCounter) Validate() error {
  return nil
}
// The Serial column type Fraction Cell for results on Fraction of scan
// 
// Attributes:
//  - C: The Column Name
//  - Ts: The Cell Timestamp
//  - V: The Cell Serial Value
type FCellSerial struct {
  C string `thrift:"c,1" db:"c" json:"c"`
  Ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
  V CellValuesSerial `thrift:"v,3" db:"v" json:"v"`
}

func NewFCellSerial() *FCellSerial {
  return &FCellSerial{}
}


func (p *FCellSerial) GetC() string {
  return p.C
}

func (p *FCellSerial) GetTs() int64 {
  return p.Ts
}

func (p *FCellSerial) GetV() CellValuesSerial {
  return p.V
}
func (p *FCellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FCellSerial)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.C = v
}
  return nil
}

func (p *FCellSerial)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Ts = v
}
  return nil
}

func (p *FCellSerial)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellValuesSerial, 0, size)
  p.V =  tSlice
  for i := 0; i < size; i ++ {
    _elem126 := &CellValueSerial{}
    if err := _elem126.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem126), err)
    }
    p.V = append(p.V, _elem126)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *FCellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FCellSerial"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FCellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.C)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err) }
  return err
}

func (p *FCellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Ts)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err) }
  return err
}

func (p *FCellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.V)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.V {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err) }
  return err
}

func (p *FCellSerial) Equals(other *FCellSerial) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.C != other.C { return false }
  if p.Ts != other.Ts { return false }
  if len(p.V) != len(other.V) { return false }
  for i, _tgt := range p.V {
    _src127 := other.V[i]
    if !_tgt.Equals(_src127) { return false }
  }
  return true
}

func (p *FCellSerial) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FCellSerial(%+v)", *p)
}

func (p *FCellSerial) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FCellSerial",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FCellSerial)(nil)

func (p *FCellSerial) Validate() error {
  return nil
}
// The Fraction Cells for results on Fraction of scan
// 
// Attributes:
//  - F: The Fraction Container for the Next Fractions Tree,  defined as FCells items in a map-container by current Fraction bytes
//  - PlainCells: The current Fraction's Cells, defined as FCellPlain items in a list-container
//  - CounterCells: The current Fraction's Cells, defined as FCellCounter items in a list-container
//  - SerialCells: The current Fraction's Serial Cells, defined as FCellSerial items in a list-container
type FCells struct {
  F map[string]*FCells `thrift:"f,1" db:"f" json:"f"`
  PlainCells []*FCellPlain `thrift:"plain_cells,2" db:"plain_cells" json:"plain_cells"`
  CounterCells []*FCellCounter `thrift:"counter_cells,3" db:"counter_cells" json:"counter_cells"`
  SerialCells []*FCellSerial `thrift:"serial_cells,4" db:"serial_cells" json:"serial_cells"`
}

func NewFCells() *FCells {
  return &FCells{}
}


func (p *FCells) GetF() map[string]*FCells {
  return p.F
}

func (p *FCells) GetPlainCells() []*FCellPlain {
  return p.PlainCells
}

func (p *FCells) GetCounterCells() []*FCellCounter {
  return p.CounterCells
}

func (p *FCells) GetSerialCells() []*FCellSerial {
  return p.SerialCells
}
func (p *FCells) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *FCells)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(map[string]*FCells, size)
  p.F =  tMap
  for i := 0; i < size; i ++ {
var _key128 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key128 = v
}
    _val129 := &FCells{}
    if err := _val129.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val129), err)
    }
    p.F[_key128] = _val129
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *FCells)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*FCellPlain, 0, size)
  p.PlainCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem130 := &FCellPlain{}
    if err := _elem130.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem130), err)
    }
    p.PlainCells = append(p.PlainCells, _elem130)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *FCells)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*FCellCounter, 0, size)
  p.CounterCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem131 := &FCellCounter{}
    if err := _elem131.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem131), err)
    }
    p.CounterCells = append(p.CounterCells, _elem131)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *FCells)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make([]*FCellSerial, 0, size)
  p.SerialCells =  tSlice
  for i := 0; i < size; i ++ {
    _elem132 := &FCellSerial{}
    if err := _elem132.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem132), err)
    }
    p.SerialCells = append(p.SerialCells, _elem132)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *FCells) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "FCells"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *FCells) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "f", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:f: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.F)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.F {
    if err := oprot.WriteString(ctx, string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:f: ", p), err) }
  return err
}

func (p *FCells) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "plain_cells", thrift.LIST, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:plain_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.PlainCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.PlainCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:plain_cells: ", p), err) }
  return err
}

func (p *FCells) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counter_cells", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:counter_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.CounterCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.CounterCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:counter_cells: ", p), err) }
  return err
}

func (p *FCells) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serial_cells", thrift.LIST, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:serial_cells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.SerialCells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.SerialCells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:serial_cells: ", p), err) }
  return err
}

func (p *FCells) Equals(other *FCells) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.F) != len(other.F) { return false }
  for k, _tgt := range p.F {
    _src133 := other.F[k]
    if !_tgt.Equals(_src133) { return false }
  }
  if len(p.PlainCells) != len(other.PlainCells) { return false }
  for i, _tgt := range p.PlainCells {
    _src134 := other.PlainCells[i]
    if !_tgt.Equals(_src134) { return false }
  }
  if len(p.CounterCells) != len(other.CounterCells) { return false }
  for i, _tgt := range p.CounterCells {
    _src135 := other.CounterCells[i]
    if !_tgt.Equals(_src135) { return false }
  }
  if len(p.SerialCells) != len(other.SerialCells) { return false }
  for i, _tgt := range p.SerialCells {
    _src136 := other.SerialCells[i]
    if !_tgt.Equals(_src136) { return false }
  }
  return true
}

func (p *FCells) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("FCells(%+v)", *p)
}

func (p *FCells) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.FCells",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FCells)(nil)

func (p *FCells) Validate() error {
  return nil
}
// A Grouped Cells result for results of scan, determined by the request's CellsResult enum
// 
// Attributes:
//  - Cells: The Cells in a list, defined as Cell items in a list-container
//  - Ccells: The Columns Cells in a map-container, defined as cCells items by Column Name
//  - Kcells: The Keys Cells in a list, defined as kCells items in a list-container
//  - Fcells: The Fraction Cells in struct FCells
type CellsGroup struct {
  Cells *Cells `thrift:"cells,1" db:"cells" json:"cells"`
  Ccells CCells `thrift:"ccells,2" db:"ccells" json:"ccells"`
  Kcells KCells `thrift:"kcells,3" db:"kcells" json:"kcells"`
  Fcells *FCells `thrift:"fcells,4" db:"fcells" json:"fcells"`
}

func NewCellsGroup() *CellsGroup {
  return &CellsGroup{}
}

var CellsGroup_Cells_DEFAULT *Cells
func (p *CellsGroup) GetCells() *Cells {
  if !p.IsSetCells() {
    return CellsGroup_Cells_DEFAULT
  }
  return p.Cells
}

func (p *CellsGroup) GetCcells() CCells {
  return p.Ccells
}

func (p *CellsGroup) GetKcells() KCells {
  return p.Kcells
}
var CellsGroup_Fcells_DEFAULT *FCells
func (p *CellsGroup) GetFcells() *FCells {
  if !p.IsSetFcells() {
    return CellsGroup_Fcells_DEFAULT
  }
  return p.Fcells
}
func (p *CellsGroup) IsSetCells() bool {
  return p.Cells != nil
}

func (p *CellsGroup) IsSetFcells() bool {
  return p.Fcells != nil
}

func (p *CellsGroup) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CellsGroup)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Cells = &Cells{}
  if err := p.Cells.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Cells), err)
  }
  return nil
}

func (p *CellsGroup)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(CCells, size)
  p.Ccells =  tMap
  for i := 0; i < size; i ++ {
var _key137 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key137 = v
}
    _val138 := &CCells{}
    if err := _val138.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val138), err)
    }
    p.Ccells[_key137] = _val138
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *CellsGroup)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(KCells, 0, size)
  p.Kcells =  tSlice
  for i := 0; i < size; i ++ {
    _elem139 := &KCells{}
    if err := _elem139.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem139), err)
    }
    p.Kcells = append(p.Kcells, _elem139)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *CellsGroup)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  p.Fcells = &FCells{}
  if err := p.Fcells.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Fcells), err)
  }
  return nil
}

func (p *CellsGroup) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CellsGroup"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CellsGroup) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cells", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cells: ", p), err) }
  if err := p.Cells.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Cells), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cells: ", p), err) }
  return err
}

func (p *CellsGroup) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "ccells", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ccells: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.Ccells)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Ccells {
    if err := oprot.WriteString(ctx, string(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ccells: ", p), err) }
  return err
}

func (p *CellsGroup) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "kcells", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:kcells: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Kcells)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Kcells {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:kcells: ", p), err) }
  return err
}

func (p *CellsGroup) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "fcells", thrift.STRUCT, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:fcells: ", p), err) }
  if err := p.Fcells.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Fcells), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:fcells: ", p), err) }
  return err
}

func (p *CellsGroup) Equals(other *CellsGroup) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if !p.Cells.Equals(other.Cells) { return false }
  if len(p.Ccells) != len(other.Ccells) { return false }
  for k, _tgt := range p.Ccells {
    _src140 := other.Ccells[k]
    if !_tgt.Equals(_src140) { return false }
  }
  if len(p.Kcells) != len(other.Kcells) { return false }
  for i, _tgt := range p.Kcells {
    _src141 := other.Kcells[i]
    if !_tgt.Equals(_src141) { return false }
  }
  if !p.Fcells.Equals(other.Fcells) { return false }
  return true
}

func (p *CellsGroup) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CellsGroup(%+v)", *p)
}

func (p *CellsGroup) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CellsGroup",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellsGroup)(nil)

func (p *CellsGroup) Validate() error {
  return nil
}
// The Compact Result
// 
// Attributes:
//  - Cid: Column ID
//  - Err: Error
type CompactResult_ struct {
  Cid int64 `thrift:"cid,1" db:"cid" json:"cid"`
  Err int32 `thrift:"err,2" db:"err" json:"err"`
}

func NewCompactResult_() *CompactResult_ {
  return &CompactResult_{}
}


func (p *CompactResult_) GetCid() int64 {
  return p.Cid
}

func (p *CompactResult_) GetErr() int32 {
  return p.Err
}
func (p *CompactResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *CompactResult_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Cid = v
}
  return nil
}

func (p *CompactResult_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.Err = v
}
  return nil
}

func (p *CompactResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "CompactResult"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *CompactResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.Cid)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err) }
  return err
}

func (p *CompactResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "err", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:err: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Err)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.err (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:err: ", p), err) }
  return err
}

func (p *CompactResult_) Equals(other *CompactResult_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if p.Cid != other.Cid { return false }
  if p.Err != other.Err { return false }
  return true
}

func (p *CompactResult_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("CompactResult_(%+v)", *p)
}

func (p *CompactResult_) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.CompactResult_",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CompactResult_)(nil)

func (p *CompactResult_) Validate() error {
  return nil
}
// The Result of 'exec_sql'
// 
// Attributes:
//  - Schemas: Set with result for 'list columns' query
//  - Cells: Set with result for 'select' query
//  - Compact: Set with result for 'compact columns' query
type Result_ struct {
  Schemas Schemas `thrift:"schemas,1" db:"schemas" json:"schemas"`
  Cells *Cells `thrift:"cells,2" db:"cells" json:"cells"`
  Compact CompactResults `thrift:"compact,3" db:"compact" json:"compact"`
}

func NewResult_() *Result_ {
  return &Result_{}
}


func (p *Result_) GetSchemas() Schemas {
  return p.Schemas
}
var Result__Cells_DEFAULT *Cells
func (p *Result_) GetCells() *Cells {
  if !p.IsSetCells() {
    return Result__Cells_DEFAULT
  }
  return p.Cells
}

func (p *Result_) GetCompact() CompactResults {
  return p.Compact
}
func (p *Result_) IsSetCells() bool {
  return p.Cells != nil
}

func (p *Result_) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *Result_)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Schemas, 0, size)
  p.Schemas =  tSlice
  for i := 0; i < size; i ++ {
    _elem142 := &Schema{}
    if err := _elem142.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem142), err)
    }
    p.Schemas = append(p.Schemas, _elem142)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Result_)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Cells = &Cells{}
  if err := p.Cells.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Cells), err)
  }
  return nil
}

func (p *Result_)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CompactResults, 0, size)
  p.Compact =  tSlice
  for i := 0; i < size; i ++ {
    _elem143 := &CompactResult_{}
    if err := _elem143.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem143), err)
    }
    p.Compact = append(p.Compact, _elem143)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *Result_) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "Result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *Result_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "schemas", thrift.LIST, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:schemas: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Schemas)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Schemas {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:schemas: ", p), err) }
  return err
}

func (p *Result_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cells", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:cells: ", p), err) }
  if err := p.Cells.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Cells), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:cells: ", p), err) }
  return err
}

func (p *Result_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "compact", thrift.LIST, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:compact: ", p), err) }
  if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Compact)); err != nil {
    return thrift.PrependError("error writing list begin: ", err)
  }
  for _, v := range p.Compact {
    if err := v.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
    }
  }
  if err := oprot.WriteListEnd(ctx); err != nil {
    return thrift.PrependError("error writing list end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:compact: ", p), err) }
  return err
}

func (p *Result_) Equals(other *Result_) bool {
  if p == other {
    return true
  } else if p == nil || other == nil {
    return false
  }
  if len(p.Schemas) != len(other.Schemas) { return false }
  for i, _tgt := range p.Schemas {
    _src144 := other.Schemas[i]
    if !_tgt.Equals(_src144) { return false }
  }
  if !p.Cells.Equals(other.Cells) { return false }
  if len(p.Compact) != len(other.Compact) { return false }
  for i, _tgt := range p.Compact {
    _src145 := other.Compact[i]
    if !_tgt.Equals(_src145) { return false }
  }
  return true
}

func (p *Result_) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("Result_(%+v)", *p)
}

func (p *Result_) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.Result_",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Result_)(nil)

func (p *Result_) Validate() error {
  return nil
}
type Service interface {  //The SWC-DB Thrift Service

  // The direct SQL method to Manage Column.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlMngColumn(ctx context.Context, sql string) (_err error)
  // The direct SQL method to List Columns
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlListColumns(ctx context.Context, sql string) (_r Schemas, _err error)
  // The direct SQL method to Compact Columns
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlCompactColumns(ctx context.Context, sql string) (_r CompactResults, _err error)
  // The direct SQL method to select cells with result in CellsPlain.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlSelectPlain(ctx context.Context, sql string) (_r CellsPlain, _err error)
  // The direct SQL method to select cells with result in CellsCounter.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlSelectCounter(ctx context.Context, sql string) (_r CellsCounter, _err error)
  // The direct SQL method to select cells with result in CellsSerial.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlSelectSerial(ctx context.Context, sql string) (_r CellsSerial, _err error)
  // The direct SQL method to select cells with result in Cells List.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlSelect(ctx context.Context, sql string) (_r *Cells, _err error)
  // The direct SQL method to select cells with result in Columns Cells map.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlSelectRsltOnColumn(ctx context.Context, sql string) (_r CCells, _err error)
  // The direct SQL method to select cells with result in Key Cells list.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlSelectRsltOnKey(ctx context.Context, sql string) (_r KCells, _err error)
  // The direct SQL method to select cells with result in Fractons Cells.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  SqlSelectRsltOnFraction(ctx context.Context, sql string) (_r *FCells, _err error)
  // The SQL method to select cells with result set by the request's type of CellsResult.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  //  - Rslt: The Type of Cells Result for the response
  SqlQuery(ctx context.Context, sql string, rslt CellsResult_) (_r *CellsGroup, _err error)
  // The direct SQL method to update cells optionally to work with updater-id.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  //  - UpdaterID: The Updater ID to work with
  SqlUpdate(ctx context.Context, sql string, updater_id int64) (_err error)
  // The SQL method to execute any query.
  // 
  // Parameters:
  //  - Sql: The SQL string to Execute
  ExecSql(ctx context.Context, sql string) (_r *Result_, _err error)
  // The method to Create an Updater ID with buffering size in bytes.
  // 
  // Parameters:
  //  - BufferSize: The buffer size of the Updater
  UpdaterCreate(ctx context.Context, buffer_size int32) (_r int64, _err error)
  // The method to Close an Updater ID.
  // 
  // Parameters:
  //  - ID: The Updater ID to close
  UpdaterClose(ctx context.Context, id int64) (_err error)
  // The direct method to update cells with cell in Update-Columns-Cells-Plain,
  // optionally to work with updater-id.
  // 
  // Parameters:
  //  - Cells: The Cells to update
  //  - UpdaterID: The Updater ID to use for write
  UpdatePlain(ctx context.Context, cells UCCellsPlain, updater_id int64) (_err error)
  // The direct method to update cells with cell in Update-Columns-Cells-Counter,
  // optionally to work with updater-id.
  // 
  // Parameters:
  //  - Cells: The Counter Cells to update
  //  - UpdaterID: The Updater ID to use for write
  UpdateCounter(ctx context.Context, cells UCCellsCounter, updater_id int64) (_err error)
  // The direct method to update cells with cell in Update-Columns-Cells-Serial,
  // optionally to work with updater-id.
  // 
  // Parameters:
  //  - Cells: The Serial Cells to update
  //  - UpdaterID: The Updater ID to use for write
  UpdateSerial(ctx context.Context, cells UCCellsSerial, updater_id int64) (_err error)
  // The method is to update cells by several Column-Types,
  // optionally to work with updater-id.
  // 
  // Parameters:
  //  - Plain: The PLAIN Cells to update
  //  - Counter: The COUNTER Cells to update
  //  - Serial: The SERIAL Cells to update
  //  - UpdaterID: The Updater ID to use for write
  UpdateByTypes(ctx context.Context, plain UCCellsPlain, counter UCCellsCounter, serial UCCellsSerial, updater_id int64) (_err error)
  // The direct method to Manage Column
  // 
  // Parameters:
  //  - Func: The Action Function to use
  //  - Schema: The Schema for the Action
  MngColumn(ctx context.Context, func_a1 SchemaFunc, schema *Schema) (_err error)
  // The direct method to List Columns
  // 
  // Parameters:
  //  - Spec: The Schemas Specifications to match Schema for response
  ListColumns(ctx context.Context, spec *SpecSchemas) (_r Schemas, _err error)
  // The direct method to Compact Columns
  // 
  // Parameters:
  //  - Spec: The Schemas Specifications to match columns to Compact
  CompactColumns(ctx context.Context, spec *SpecSchemas) (_r CompactResults, _err error)
  // The direct method to select cells with result in Cells List.
  // 
  // Parameters:
  //  - Spec: The Scan Specifications for the scan
  Scan(ctx context.Context, spec *SpecScan) (_r *Cells, _err error)
  // The direct method to select cells with result in Columns Cells map.
  // 
  // Parameters:
  //  - Spec: The Scan Specifications for the scan
  ScanRsltOnColumn(ctx context.Context, spec *SpecScan) (_r CCells, _err error)
  // The direct method to select cells with result in Key Cells list.
  // 
  // Parameters:
  //  - Spec: The Scan Specifications for the scan
  ScanRsltOnKey(ctx context.Context, spec *SpecScan) (_r KCells, _err error)
  // The direct method to select cells with result in Fractons Cells.
  // 
  // Parameters:
  //  - Spec: The Scan Specifications for the scan
  ScanRsltOnFraction(ctx context.Context, spec *SpecScan) (_r *FCells, _err error)
  // The method to select cells with result set by the request's type of CellsResult.
  // 
  // Parameters:
  //  - Spec: The Scan Specifications for the scan
  //  - Rslt: The Type of Cells Result for the response
  ScanRsltOn(ctx context.Context, spec *SpecScan, rslt CellsResult_) (_r *CellsGroup, _err error)
}

//The SWC-DB Thrift Service
type ServiceClient struct {
  c thrift.TClient
  meta thrift.ResponseMeta
}

func NewServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ServiceClient {
  return &ServiceClient{
    c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
  }
}

func NewServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ServiceClient {
  return &ServiceClient{
    c: thrift.NewTStandardClient(iprot, oprot),
  }
}

func NewServiceClient(c thrift.TClient) *ServiceClient {
  return &ServiceClient{
    c: c,
  }
}

func (p *ServiceClient) Client_() thrift.TClient {
  return p.c
}

func (p *ServiceClient) LastResponseMeta_() thrift.ResponseMeta {
  return p.meta
}

func (p *ServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
  p.meta = meta
}

// The direct SQL method to Manage Column.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlMngColumn(ctx context.Context, sql string) (_err error) {
  var _args146 ServiceSqlMngColumnArgs
  _args146.Sql = sql
  var _result148 ServiceSqlMngColumnResult
  var _meta147 thrift.ResponseMeta
  _meta147, _err = p.Client_().Call(ctx, "sql_mng_column", &_args146, &_result148)
  p.SetLastResponseMeta_(_meta147)
  if _err != nil {
    return
  }
  switch {
  case _result148.E!= nil:
    return _result148.E
  }

  return nil
}

// The direct SQL method to List Columns
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlListColumns(ctx context.Context, sql string) (_r Schemas, _err error) {
  var _args149 ServiceSqlListColumnsArgs
  _args149.Sql = sql
  var _result151 ServiceSqlListColumnsResult
  var _meta150 thrift.ResponseMeta
  _meta150, _err = p.Client_().Call(ctx, "sql_list_columns", &_args149, &_result151)
  p.SetLastResponseMeta_(_meta150)
  if _err != nil {
    return
  }
  switch {
  case _result151.E!= nil:
    return _r, _result151.E
  }

  return _result151.GetSuccess(), nil
}

// The direct SQL method to Compact Columns
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlCompactColumns(ctx context.Context, sql string) (_r CompactResults, _err error) {
  var _args152 ServiceSqlCompactColumnsArgs
  _args152.Sql = sql
  var _result154 ServiceSqlCompactColumnsResult
  var _meta153 thrift.ResponseMeta
  _meta153, _err = p.Client_().Call(ctx, "sql_compact_columns", &_args152, &_result154)
  p.SetLastResponseMeta_(_meta153)
  if _err != nil {
    return
  }
  switch {
  case _result154.E!= nil:
    return _r, _result154.E
  }

  return _result154.GetSuccess(), nil
}

// The direct SQL method to select cells with result in CellsPlain.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlSelectPlain(ctx context.Context, sql string) (_r CellsPlain, _err error) {
  var _args155 ServiceSqlSelectPlainArgs
  _args155.Sql = sql
  var _result157 ServiceSqlSelectPlainResult
  var _meta156 thrift.ResponseMeta
  _meta156, _err = p.Client_().Call(ctx, "sql_select_plain", &_args155, &_result157)
  p.SetLastResponseMeta_(_meta156)
  if _err != nil {
    return
  }
  switch {
  case _result157.E!= nil:
    return _r, _result157.E
  }

  return _result157.GetSuccess(), nil
}

// The direct SQL method to select cells with result in CellsCounter.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlSelectCounter(ctx context.Context, sql string) (_r CellsCounter, _err error) {
  var _args158 ServiceSqlSelectCounterArgs
  _args158.Sql = sql
  var _result160 ServiceSqlSelectCounterResult
  var _meta159 thrift.ResponseMeta
  _meta159, _err = p.Client_().Call(ctx, "sql_select_counter", &_args158, &_result160)
  p.SetLastResponseMeta_(_meta159)
  if _err != nil {
    return
  }
  switch {
  case _result160.E!= nil:
    return _r, _result160.E
  }

  return _result160.GetSuccess(), nil
}

// The direct SQL method to select cells with result in CellsSerial.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlSelectSerial(ctx context.Context, sql string) (_r CellsSerial, _err error) {
  var _args161 ServiceSqlSelectSerialArgs
  _args161.Sql = sql
  var _result163 ServiceSqlSelectSerialResult
  var _meta162 thrift.ResponseMeta
  _meta162, _err = p.Client_().Call(ctx, "sql_select_serial", &_args161, &_result163)
  p.SetLastResponseMeta_(_meta162)
  if _err != nil {
    return
  }
  switch {
  case _result163.E!= nil:
    return _r, _result163.E
  }

  return _result163.GetSuccess(), nil
}

// The direct SQL method to select cells with result in Cells List.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlSelect(ctx context.Context, sql string) (_r *Cells, _err error) {
  var _args164 ServiceSqlSelectArgs
  _args164.Sql = sql
  var _result166 ServiceSqlSelectResult
  var _meta165 thrift.ResponseMeta
  _meta165, _err = p.Client_().Call(ctx, "sql_select", &_args164, &_result166)
  p.SetLastResponseMeta_(_meta165)
  if _err != nil {
    return
  }
  switch {
  case _result166.E!= nil:
    return _r, _result166.E
  }

  if _ret167 := _result166.GetSuccess(); _ret167 != nil {
    return _ret167, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "sql_select failed: unknown result")
}

// The direct SQL method to select cells with result in Columns Cells map.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlSelectRsltOnColumn(ctx context.Context, sql string) (_r CCells, _err error) {
  var _args168 ServiceSqlSelectRsltOnColumnArgs
  _args168.Sql = sql
  var _result170 ServiceSqlSelectRsltOnColumnResult
  var _meta169 thrift.ResponseMeta
  _meta169, _err = p.Client_().Call(ctx, "sql_select_rslt_on_column", &_args168, &_result170)
  p.SetLastResponseMeta_(_meta169)
  if _err != nil {
    return
  }
  switch {
  case _result170.E!= nil:
    return _r, _result170.E
  }

  return _result170.GetSuccess(), nil
}

// The direct SQL method to select cells with result in Key Cells list.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlSelectRsltOnKey(ctx context.Context, sql string) (_r KCells, _err error) {
  var _args171 ServiceSqlSelectRsltOnKeyArgs
  _args171.Sql = sql
  var _result173 ServiceSqlSelectRsltOnKeyResult
  var _meta172 thrift.ResponseMeta
  _meta172, _err = p.Client_().Call(ctx, "sql_select_rslt_on_key", &_args171, &_result173)
  p.SetLastResponseMeta_(_meta172)
  if _err != nil {
    return
  }
  switch {
  case _result173.E!= nil:
    return _r, _result173.E
  }

  return _result173.GetSuccess(), nil
}

// The direct SQL method to select cells with result in Fractons Cells.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) SqlSelectRsltOnFraction(ctx context.Context, sql string) (_r *FCells, _err error) {
  var _args174 ServiceSqlSelectRsltOnFractionArgs
  _args174.Sql = sql
  var _result176 ServiceSqlSelectRsltOnFractionResult
  var _meta175 thrift.ResponseMeta
  _meta175, _err = p.Client_().Call(ctx, "sql_select_rslt_on_fraction", &_args174, &_result176)
  p.SetLastResponseMeta_(_meta175)
  if _err != nil {
    return
  }
  switch {
  case _result176.E!= nil:
    return _r, _result176.E
  }

  if _ret177 := _result176.GetSuccess(); _ret177 != nil {
    return _ret177, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "sql_select_rslt_on_fraction failed: unknown result")
}

// The SQL method to select cells with result set by the request's type of CellsResult.
// 
// Parameters:
//  - Sql: The SQL string to Execute
//  - Rslt: The Type of Cells Result for the response
func (p *ServiceClient) SqlQuery(ctx context.Context, sql string, rslt CellsResult_) (_r *CellsGroup, _err error) {
  var _args178 ServiceSqlQueryArgs
  _args178.Sql = sql
  _args178.Rslt = rslt
  var _result180 ServiceSqlQueryResult
  var _meta179 thrift.ResponseMeta
  _meta179, _err = p.Client_().Call(ctx, "sql_query", &_args178, &_result180)
  p.SetLastResponseMeta_(_meta179)
  if _err != nil {
    return
  }
  switch {
  case _result180.E!= nil:
    return _r, _result180.E
  }

  if _ret181 := _result180.GetSuccess(); _ret181 != nil {
    return _ret181, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "sql_query failed: unknown result")
}

// The direct SQL method to update cells optionally to work with updater-id.
// 
// Parameters:
//  - Sql: The SQL string to Execute
//  - UpdaterID: The Updater ID to work with
func (p *ServiceClient) SqlUpdate(ctx context.Context, sql string, updater_id int64) (_err error) {
  var _args182 ServiceSqlUpdateArgs
  _args182.Sql = sql
  _args182.UpdaterID = updater_id
  var _result184 ServiceSqlUpdateResult
  var _meta183 thrift.ResponseMeta
  _meta183, _err = p.Client_().Call(ctx, "sql_update", &_args182, &_result184)
  p.SetLastResponseMeta_(_meta183)
  if _err != nil {
    return
  }
  switch {
  case _result184.E!= nil:
    return _result184.E
  }

  return nil
}

// The SQL method to execute any query.
// 
// Parameters:
//  - Sql: The SQL string to Execute
func (p *ServiceClient) ExecSql(ctx context.Context, sql string) (_r *Result_, _err error) {
  var _args185 ServiceExecSqlArgs
  _args185.Sql = sql
  var _result187 ServiceExecSqlResult
  var _meta186 thrift.ResponseMeta
  _meta186, _err = p.Client_().Call(ctx, "exec_sql", &_args185, &_result187)
  p.SetLastResponseMeta_(_meta186)
  if _err != nil {
    return
  }
  switch {
  case _result187.E!= nil:
    return _r, _result187.E
  }

  if _ret188 := _result187.GetSuccess(); _ret188 != nil {
    return _ret188, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "exec_sql failed: unknown result")
}

// The method to Create an Updater ID with buffering size in bytes.
// 
// Parameters:
//  - BufferSize: The buffer size of the Updater
func (p *ServiceClient) UpdaterCreate(ctx context.Context, buffer_size int32) (_r int64, _err error) {
  var _args189 ServiceUpdaterCreateArgs
  _args189.BufferSize = buffer_size
  var _result191 ServiceUpdaterCreateResult
  var _meta190 thrift.ResponseMeta
  _meta190, _err = p.Client_().Call(ctx, "updater_create", &_args189, &_result191)
  p.SetLastResponseMeta_(_meta190)
  if _err != nil {
    return
  }
  switch {
  case _result191.E!= nil:
    return _r, _result191.E
  }

  return _result191.GetSuccess(), nil
}

// The method to Close an Updater ID.
// 
// Parameters:
//  - ID: The Updater ID to close
func (p *ServiceClient) UpdaterClose(ctx context.Context, id int64) (_err error) {
  var _args192 ServiceUpdaterCloseArgs
  _args192.ID = id
  var _result194 ServiceUpdaterCloseResult
  var _meta193 thrift.ResponseMeta
  _meta193, _err = p.Client_().Call(ctx, "updater_close", &_args192, &_result194)
  p.SetLastResponseMeta_(_meta193)
  if _err != nil {
    return
  }
  switch {
  case _result194.E!= nil:
    return _result194.E
  }

  return nil
}

// The direct method to update cells with cell in Update-Columns-Cells-Plain,
// optionally to work with updater-id.
// 
// Parameters:
//  - Cells: The Cells to update
//  - UpdaterID: The Updater ID to use for write
func (p *ServiceClient) UpdatePlain(ctx context.Context, cells UCCellsPlain, updater_id int64) (_err error) {
  var _args195 ServiceUpdatePlainArgs
  _args195.Cells = cells
  _args195.UpdaterID = updater_id
  var _result197 ServiceUpdatePlainResult
  var _meta196 thrift.ResponseMeta
  _meta196, _err = p.Client_().Call(ctx, "update_plain", &_args195, &_result197)
  p.SetLastResponseMeta_(_meta196)
  if _err != nil {
    return
  }
  switch {
  case _result197.E!= nil:
    return _result197.E
  }

  return nil
}

// The direct method to update cells with cell in Update-Columns-Cells-Counter,
// optionally to work with updater-id.
// 
// Parameters:
//  - Cells: The Counter Cells to update
//  - UpdaterID: The Updater ID to use for write
func (p *ServiceClient) UpdateCounter(ctx context.Context, cells UCCellsCounter, updater_id int64) (_err error) {
  var _args198 ServiceUpdateCounterArgs
  _args198.Cells = cells
  _args198.UpdaterID = updater_id
  var _result200 ServiceUpdateCounterResult
  var _meta199 thrift.ResponseMeta
  _meta199, _err = p.Client_().Call(ctx, "update_counter", &_args198, &_result200)
  p.SetLastResponseMeta_(_meta199)
  if _err != nil {
    return
  }
  switch {
  case _result200.E!= nil:
    return _result200.E
  }

  return nil
}

// The direct method to update cells with cell in Update-Columns-Cells-Serial,
// optionally to work with updater-id.
// 
// Parameters:
//  - Cells: The Serial Cells to update
//  - UpdaterID: The Updater ID to use for write
func (p *ServiceClient) UpdateSerial(ctx context.Context, cells UCCellsSerial, updater_id int64) (_err error) {
  var _args201 ServiceUpdateSerialArgs
  _args201.Cells = cells
  _args201.UpdaterID = updater_id
  var _result203 ServiceUpdateSerialResult
  var _meta202 thrift.ResponseMeta
  _meta202, _err = p.Client_().Call(ctx, "update_serial", &_args201, &_result203)
  p.SetLastResponseMeta_(_meta202)
  if _err != nil {
    return
  }
  switch {
  case _result203.E!= nil:
    return _result203.E
  }

  return nil
}

// The method is to update cells by several Column-Types,
// optionally to work with updater-id.
// 
// Parameters:
//  - Plain: The PLAIN Cells to update
//  - Counter: The COUNTER Cells to update
//  - Serial: The SERIAL Cells to update
//  - UpdaterID: The Updater ID to use for write
func (p *ServiceClient) UpdateByTypes(ctx context.Context, plain UCCellsPlain, counter UCCellsCounter, serial UCCellsSerial, updater_id int64) (_err error) {
  var _args204 ServiceUpdateByTypesArgs
  _args204.Plain = plain
  _args204.Counter = counter
  _args204.Serial = serial
  _args204.UpdaterID = updater_id
  var _result206 ServiceUpdateByTypesResult
  var _meta205 thrift.ResponseMeta
  _meta205, _err = p.Client_().Call(ctx, "update_by_types", &_args204, &_result206)
  p.SetLastResponseMeta_(_meta205)
  if _err != nil {
    return
  }
  switch {
  case _result206.E!= nil:
    return _result206.E
  }

  return nil
}

// The direct method to Manage Column
// 
// Parameters:
//  - Func: The Action Function to use
//  - Schema: The Schema for the Action
func (p *ServiceClient) MngColumn(ctx context.Context, func_a1 SchemaFunc, schema *Schema) (_err error) {
  var _args207 ServiceMngColumnArgs
  _args207.Func = func_a1
  _args207.Schema = schema
  var _result209 ServiceMngColumnResult
  var _meta208 thrift.ResponseMeta
  _meta208, _err = p.Client_().Call(ctx, "mng_column", &_args207, &_result209)
  p.SetLastResponseMeta_(_meta208)
  if _err != nil {
    return
  }
  switch {
  case _result209.E!= nil:
    return _result209.E
  }

  return nil
}

// The direct method to List Columns
// 
// Parameters:
//  - Spec: The Schemas Specifications to match Schema for response
func (p *ServiceClient) ListColumns(ctx context.Context, spec *SpecSchemas) (_r Schemas, _err error) {
  var _args210 ServiceListColumnsArgs
  _args210.Spec = spec
  var _result212 ServiceListColumnsResult
  var _meta211 thrift.ResponseMeta
  _meta211, _err = p.Client_().Call(ctx, "list_columns", &_args210, &_result212)
  p.SetLastResponseMeta_(_meta211)
  if _err != nil {
    return
  }
  switch {
  case _result212.E!= nil:
    return _r, _result212.E
  }

  return _result212.GetSuccess(), nil
}

// The direct method to Compact Columns
// 
// Parameters:
//  - Spec: The Schemas Specifications to match columns to Compact
func (p *ServiceClient) CompactColumns(ctx context.Context, spec *SpecSchemas) (_r CompactResults, _err error) {
  var _args213 ServiceCompactColumnsArgs
  _args213.Spec = spec
  var _result215 ServiceCompactColumnsResult
  var _meta214 thrift.ResponseMeta
  _meta214, _err = p.Client_().Call(ctx, "compact_columns", &_args213, &_result215)
  p.SetLastResponseMeta_(_meta214)
  if _err != nil {
    return
  }
  switch {
  case _result215.E!= nil:
    return _r, _result215.E
  }

  return _result215.GetSuccess(), nil
}

// The direct method to select cells with result in Cells List.
// 
// Parameters:
//  - Spec: The Scan Specifications for the scan
func (p *ServiceClient) Scan(ctx context.Context, spec *SpecScan) (_r *Cells, _err error) {
  var _args216 ServiceScanArgs
  _args216.Spec = spec
  var _result218 ServiceScanResult
  var _meta217 thrift.ResponseMeta
  _meta217, _err = p.Client_().Call(ctx, "scan", &_args216, &_result218)
  p.SetLastResponseMeta_(_meta217)
  if _err != nil {
    return
  }
  switch {
  case _result218.E!= nil:
    return _r, _result218.E
  }

  if _ret219 := _result218.GetSuccess(); _ret219 != nil {
    return _ret219, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "scan failed: unknown result")
}

// The direct method to select cells with result in Columns Cells map.
// 
// Parameters:
//  - Spec: The Scan Specifications for the scan
func (p *ServiceClient) ScanRsltOnColumn(ctx context.Context, spec *SpecScan) (_r CCells, _err error) {
  var _args220 ServiceScanRsltOnColumnArgs
  _args220.Spec = spec
  var _result222 ServiceScanRsltOnColumnResult
  var _meta221 thrift.ResponseMeta
  _meta221, _err = p.Client_().Call(ctx, "scan_rslt_on_column", &_args220, &_result222)
  p.SetLastResponseMeta_(_meta221)
  if _err != nil {
    return
  }
  switch {
  case _result222.E!= nil:
    return _r, _result222.E
  }

  return _result222.GetSuccess(), nil
}

// The direct method to select cells with result in Key Cells list.
// 
// Parameters:
//  - Spec: The Scan Specifications for the scan
func (p *ServiceClient) ScanRsltOnKey(ctx context.Context, spec *SpecScan) (_r KCells, _err error) {
  var _args223 ServiceScanRsltOnKeyArgs
  _args223.Spec = spec
  var _result225 ServiceScanRsltOnKeyResult
  var _meta224 thrift.ResponseMeta
  _meta224, _err = p.Client_().Call(ctx, "scan_rslt_on_key", &_args223, &_result225)
  p.SetLastResponseMeta_(_meta224)
  if _err != nil {
    return
  }
  switch {
  case _result225.E!= nil:
    return _r, _result225.E
  }

  return _result225.GetSuccess(), nil
}

// The direct method to select cells with result in Fractons Cells.
// 
// Parameters:
//  - Spec: The Scan Specifications for the scan
func (p *ServiceClient) ScanRsltOnFraction(ctx context.Context, spec *SpecScan) (_r *FCells, _err error) {
  var _args226 ServiceScanRsltOnFractionArgs
  _args226.Spec = spec
  var _result228 ServiceScanRsltOnFractionResult
  var _meta227 thrift.ResponseMeta
  _meta227, _err = p.Client_().Call(ctx, "scan_rslt_on_fraction", &_args226, &_result228)
  p.SetLastResponseMeta_(_meta227)
  if _err != nil {
    return
  }
  switch {
  case _result228.E!= nil:
    return _r, _result228.E
  }

  if _ret229 := _result228.GetSuccess(); _ret229 != nil {
    return _ret229, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "scan_rslt_on_fraction failed: unknown result")
}

// The method to select cells with result set by the request's type of CellsResult.
// 
// Parameters:
//  - Spec: The Scan Specifications for the scan
//  - Rslt: The Type of Cells Result for the response
func (p *ServiceClient) ScanRsltOn(ctx context.Context, spec *SpecScan, rslt CellsResult_) (_r *CellsGroup, _err error) {
  var _args230 ServiceScanRsltOnArgs
  _args230.Spec = spec
  _args230.Rslt = rslt
  var _result232 ServiceScanRsltOnResult
  var _meta231 thrift.ResponseMeta
  _meta231, _err = p.Client_().Call(ctx, "scan_rslt_on", &_args230, &_result232)
  p.SetLastResponseMeta_(_meta231)
  if _err != nil {
    return
  }
  switch {
  case _result232.E!= nil:
    return _r, _result232.E
  }

  if _ret233 := _result232.GetSuccess(); _ret233 != nil {
    return _ret233, nil
  }
  return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "scan_rslt_on failed: unknown result")
}

type ServiceProcessor struct {
  processorMap map[string]thrift.TProcessorFunction
  handler Service
}

func (p *ServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
  p.processorMap[key] = processor
}

func (p *ServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
  processor, ok = p.processorMap[key]
  return processor, ok
}

func (p *ServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
  return p.processorMap
}

func NewServiceProcessor(handler Service) *ServiceProcessor {

  self234 := &ServiceProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
  self234.processorMap["sql_mng_column"] = &serviceProcessorSqlMngColumn{handler:handler}
  self234.processorMap["sql_list_columns"] = &serviceProcessorSqlListColumns{handler:handler}
  self234.processorMap["sql_compact_columns"] = &serviceProcessorSqlCompactColumns{handler:handler}
  self234.processorMap["sql_select_plain"] = &serviceProcessorSqlSelectPlain{handler:handler}
  self234.processorMap["sql_select_counter"] = &serviceProcessorSqlSelectCounter{handler:handler}
  self234.processorMap["sql_select_serial"] = &serviceProcessorSqlSelectSerial{handler:handler}
  self234.processorMap["sql_select"] = &serviceProcessorSqlSelect{handler:handler}
  self234.processorMap["sql_select_rslt_on_column"] = &serviceProcessorSqlSelectRsltOnColumn{handler:handler}
  self234.processorMap["sql_select_rslt_on_key"] = &serviceProcessorSqlSelectRsltOnKey{handler:handler}
  self234.processorMap["sql_select_rslt_on_fraction"] = &serviceProcessorSqlSelectRsltOnFraction{handler:handler}
  self234.processorMap["sql_query"] = &serviceProcessorSqlQuery{handler:handler}
  self234.processorMap["sql_update"] = &serviceProcessorSqlUpdate{handler:handler}
  self234.processorMap["exec_sql"] = &serviceProcessorExecSql{handler:handler}
  self234.processorMap["updater_create"] = &serviceProcessorUpdaterCreate{handler:handler}
  self234.processorMap["updater_close"] = &serviceProcessorUpdaterClose{handler:handler}
  self234.processorMap["update_plain"] = &serviceProcessorUpdatePlain{handler:handler}
  self234.processorMap["update_counter"] = &serviceProcessorUpdateCounter{handler:handler}
  self234.processorMap["update_serial"] = &serviceProcessorUpdateSerial{handler:handler}
  self234.processorMap["update_by_types"] = &serviceProcessorUpdateByTypes{handler:handler}
  self234.processorMap["mng_column"] = &serviceProcessorMngColumn{handler:handler}
  self234.processorMap["list_columns"] = &serviceProcessorListColumns{handler:handler}
  self234.processorMap["compact_columns"] = &serviceProcessorCompactColumns{handler:handler}
  self234.processorMap["scan"] = &serviceProcessorScan{handler:handler}
  self234.processorMap["scan_rslt_on_column"] = &serviceProcessorScanRsltOnColumn{handler:handler}
  self234.processorMap["scan_rslt_on_key"] = &serviceProcessorScanRsltOnKey{handler:handler}
  self234.processorMap["scan_rslt_on_fraction"] = &serviceProcessorScanRsltOnFraction{handler:handler}
  self234.processorMap["scan_rslt_on"] = &serviceProcessorScanRsltOn{handler:handler}
return self234
}

func (p *ServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
  if err2 != nil { return false, thrift.WrapTException(err2) }
  if processor, ok := p.GetProcessorFunction(name); ok {
    return processor.Process(ctx, seqId, iprot, oprot)
  }
  iprot.Skip(ctx, thrift.STRUCT)
  iprot.ReadMessageEnd(ctx)
  x235 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
  oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
  x235.Write(ctx, oprot)
  oprot.WriteMessageEnd(ctx)
  oprot.Flush(ctx)
  return false, x235

}

type serviceProcessorSqlMngColumn struct {
  handler Service
}

func (p *serviceProcessorSqlMngColumn) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err236 error
  args := ServiceSqlMngColumnArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_mng_column", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlMngColumnResult{}
  if err2 := p.handler.SqlMngColumn(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc237 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_mng_column: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_mng_column", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err236 = thrift.WrapTException(err2)
      }
      if err2 := _exc237.Write(ctx, oprot); _write_err236 == nil && err2 != nil {
        _write_err236 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err236 == nil && err2 != nil {
        _write_err236 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err236 == nil && err2 != nil {
        _write_err236 = thrift.WrapTException(err2)
      }
      if _write_err236 != nil {
        return false, thrift.WrapTException(_write_err236)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_mng_column", thrift.REPLY, seqId); err2 != nil {
    _write_err236 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err236 == nil && err2 != nil {
    _write_err236 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err236 == nil && err2 != nil {
    _write_err236 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err236 == nil && err2 != nil {
    _write_err236 = thrift.WrapTException(err2)
  }
  if _write_err236 != nil {
    return false, thrift.WrapTException(_write_err236)
  }
  return true, err
}

type serviceProcessorSqlListColumns struct {
  handler Service
}

func (p *serviceProcessorSqlListColumns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err238 error
  args := ServiceSqlListColumnsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_list_columns", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlListColumnsResult{}
  if retval, err2 := p.handler.SqlListColumns(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc239 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_list_columns: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_list_columns", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err238 = thrift.WrapTException(err2)
      }
      if err2 := _exc239.Write(ctx, oprot); _write_err238 == nil && err2 != nil {
        _write_err238 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err238 == nil && err2 != nil {
        _write_err238 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err238 == nil && err2 != nil {
        _write_err238 = thrift.WrapTException(err2)
      }
      if _write_err238 != nil {
        return false, thrift.WrapTException(_write_err238)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_list_columns", thrift.REPLY, seqId); err2 != nil {
    _write_err238 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err238 == nil && err2 != nil {
    _write_err238 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err238 == nil && err2 != nil {
    _write_err238 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err238 == nil && err2 != nil {
    _write_err238 = thrift.WrapTException(err2)
  }
  if _write_err238 != nil {
    return false, thrift.WrapTException(_write_err238)
  }
  return true, err
}

type serviceProcessorSqlCompactColumns struct {
  handler Service
}

func (p *serviceProcessorSqlCompactColumns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err240 error
  args := ServiceSqlCompactColumnsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_compact_columns", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlCompactColumnsResult{}
  if retval, err2 := p.handler.SqlCompactColumns(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc241 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_compact_columns: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_compact_columns", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err240 = thrift.WrapTException(err2)
      }
      if err2 := _exc241.Write(ctx, oprot); _write_err240 == nil && err2 != nil {
        _write_err240 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err240 == nil && err2 != nil {
        _write_err240 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err240 == nil && err2 != nil {
        _write_err240 = thrift.WrapTException(err2)
      }
      if _write_err240 != nil {
        return false, thrift.WrapTException(_write_err240)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_compact_columns", thrift.REPLY, seqId); err2 != nil {
    _write_err240 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err240 == nil && err2 != nil {
    _write_err240 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err240 == nil && err2 != nil {
    _write_err240 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err240 == nil && err2 != nil {
    _write_err240 = thrift.WrapTException(err2)
  }
  if _write_err240 != nil {
    return false, thrift.WrapTException(_write_err240)
  }
  return true, err
}

type serviceProcessorSqlSelectPlain struct {
  handler Service
}

func (p *serviceProcessorSqlSelectPlain) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err242 error
  args := ServiceSqlSelectPlainArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_select_plain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlSelectPlainResult{}
  if retval, err2 := p.handler.SqlSelectPlain(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc243 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_plain: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_select_plain", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err242 = thrift.WrapTException(err2)
      }
      if err2 := _exc243.Write(ctx, oprot); _write_err242 == nil && err2 != nil {
        _write_err242 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err242 == nil && err2 != nil {
        _write_err242 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err242 == nil && err2 != nil {
        _write_err242 = thrift.WrapTException(err2)
      }
      if _write_err242 != nil {
        return false, thrift.WrapTException(_write_err242)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_select_plain", thrift.REPLY, seqId); err2 != nil {
    _write_err242 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err242 == nil && err2 != nil {
    _write_err242 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err242 == nil && err2 != nil {
    _write_err242 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err242 == nil && err2 != nil {
    _write_err242 = thrift.WrapTException(err2)
  }
  if _write_err242 != nil {
    return false, thrift.WrapTException(_write_err242)
  }
  return true, err
}

type serviceProcessorSqlSelectCounter struct {
  handler Service
}

func (p *serviceProcessorSqlSelectCounter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err244 error
  args := ServiceSqlSelectCounterArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_select_counter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlSelectCounterResult{}
  if retval, err2 := p.handler.SqlSelectCounter(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc245 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_counter: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_select_counter", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err244 = thrift.WrapTException(err2)
      }
      if err2 := _exc245.Write(ctx, oprot); _write_err244 == nil && err2 != nil {
        _write_err244 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err244 == nil && err2 != nil {
        _write_err244 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err244 == nil && err2 != nil {
        _write_err244 = thrift.WrapTException(err2)
      }
      if _write_err244 != nil {
        return false, thrift.WrapTException(_write_err244)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_select_counter", thrift.REPLY, seqId); err2 != nil {
    _write_err244 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err244 == nil && err2 != nil {
    _write_err244 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err244 == nil && err2 != nil {
    _write_err244 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err244 == nil && err2 != nil {
    _write_err244 = thrift.WrapTException(err2)
  }
  if _write_err244 != nil {
    return false, thrift.WrapTException(_write_err244)
  }
  return true, err
}

type serviceProcessorSqlSelectSerial struct {
  handler Service
}

func (p *serviceProcessorSqlSelectSerial) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err246 error
  args := ServiceSqlSelectSerialArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_select_serial", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlSelectSerialResult{}
  if retval, err2 := p.handler.SqlSelectSerial(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc247 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_serial: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_select_serial", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err246 = thrift.WrapTException(err2)
      }
      if err2 := _exc247.Write(ctx, oprot); _write_err246 == nil && err2 != nil {
        _write_err246 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err246 == nil && err2 != nil {
        _write_err246 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err246 == nil && err2 != nil {
        _write_err246 = thrift.WrapTException(err2)
      }
      if _write_err246 != nil {
        return false, thrift.WrapTException(_write_err246)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_select_serial", thrift.REPLY, seqId); err2 != nil {
    _write_err246 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err246 == nil && err2 != nil {
    _write_err246 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err246 == nil && err2 != nil {
    _write_err246 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err246 == nil && err2 != nil {
    _write_err246 = thrift.WrapTException(err2)
  }
  if _write_err246 != nil {
    return false, thrift.WrapTException(_write_err246)
  }
  return true, err
}

type serviceProcessorSqlSelect struct {
  handler Service
}

func (p *serviceProcessorSqlSelect) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err248 error
  args := ServiceSqlSelectArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_select", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlSelectResult{}
  if retval, err2 := p.handler.SqlSelect(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc249 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_select", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err248 = thrift.WrapTException(err2)
      }
      if err2 := _exc249.Write(ctx, oprot); _write_err248 == nil && err2 != nil {
        _write_err248 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err248 == nil && err2 != nil {
        _write_err248 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err248 == nil && err2 != nil {
        _write_err248 = thrift.WrapTException(err2)
      }
      if _write_err248 != nil {
        return false, thrift.WrapTException(_write_err248)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_select", thrift.REPLY, seqId); err2 != nil {
    _write_err248 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err248 == nil && err2 != nil {
    _write_err248 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err248 == nil && err2 != nil {
    _write_err248 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err248 == nil && err2 != nil {
    _write_err248 = thrift.WrapTException(err2)
  }
  if _write_err248 != nil {
    return false, thrift.WrapTException(_write_err248)
  }
  return true, err
}

type serviceProcessorSqlSelectRsltOnColumn struct {
  handler Service
}

func (p *serviceProcessorSqlSelectRsltOnColumn) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err250 error
  args := ServiceSqlSelectRsltOnColumnArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_column", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlSelectRsltOnColumnResult{}
  if retval, err2 := p.handler.SqlSelectRsltOnColumn(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc251 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_rslt_on_column: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_column", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err250 = thrift.WrapTException(err2)
      }
      if err2 := _exc251.Write(ctx, oprot); _write_err250 == nil && err2 != nil {
        _write_err250 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err250 == nil && err2 != nil {
        _write_err250 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err250 == nil && err2 != nil {
        _write_err250 = thrift.WrapTException(err2)
      }
      if _write_err250 != nil {
        return false, thrift.WrapTException(_write_err250)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_column", thrift.REPLY, seqId); err2 != nil {
    _write_err250 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err250 == nil && err2 != nil {
    _write_err250 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err250 == nil && err2 != nil {
    _write_err250 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err250 == nil && err2 != nil {
    _write_err250 = thrift.WrapTException(err2)
  }
  if _write_err250 != nil {
    return false, thrift.WrapTException(_write_err250)
  }
  return true, err
}

type serviceProcessorSqlSelectRsltOnKey struct {
  handler Service
}

func (p *serviceProcessorSqlSelectRsltOnKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err252 error
  args := ServiceSqlSelectRsltOnKeyArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlSelectRsltOnKeyResult{}
  if retval, err2 := p.handler.SqlSelectRsltOnKey(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc253 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_rslt_on_key: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_key", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err252 = thrift.WrapTException(err2)
      }
      if err2 := _exc253.Write(ctx, oprot); _write_err252 == nil && err2 != nil {
        _write_err252 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err252 == nil && err2 != nil {
        _write_err252 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err252 == nil && err2 != nil {
        _write_err252 = thrift.WrapTException(err2)
      }
      if _write_err252 != nil {
        return false, thrift.WrapTException(_write_err252)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_key", thrift.REPLY, seqId); err2 != nil {
    _write_err252 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err252 == nil && err2 != nil {
    _write_err252 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err252 == nil && err2 != nil {
    _write_err252 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err252 == nil && err2 != nil {
    _write_err252 = thrift.WrapTException(err2)
  }
  if _write_err252 != nil {
    return false, thrift.WrapTException(_write_err252)
  }
  return true, err
}

type serviceProcessorSqlSelectRsltOnFraction struct {
  handler Service
}

func (p *serviceProcessorSqlSelectRsltOnFraction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err254 error
  args := ServiceSqlSelectRsltOnFractionArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_fraction", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlSelectRsltOnFractionResult{}
  if retval, err2 := p.handler.SqlSelectRsltOnFraction(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc255 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_rslt_on_fraction: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_fraction", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err254 = thrift.WrapTException(err2)
      }
      if err2 := _exc255.Write(ctx, oprot); _write_err254 == nil && err2 != nil {
        _write_err254 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err254 == nil && err2 != nil {
        _write_err254 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err254 == nil && err2 != nil {
        _write_err254 = thrift.WrapTException(err2)
      }
      if _write_err254 != nil {
        return false, thrift.WrapTException(_write_err254)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_fraction", thrift.REPLY, seqId); err2 != nil {
    _write_err254 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err254 == nil && err2 != nil {
    _write_err254 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err254 == nil && err2 != nil {
    _write_err254 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err254 == nil && err2 != nil {
    _write_err254 = thrift.WrapTException(err2)
  }
  if _write_err254 != nil {
    return false, thrift.WrapTException(_write_err254)
  }
  return true, err
}

type serviceProcessorSqlQuery struct {
  handler Service
}

func (p *serviceProcessorSqlQuery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err256 error
  args := ServiceSqlQueryArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_query", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlQueryResult{}
  if retval, err2 := p.handler.SqlQuery(ctx, args.Sql, args.Rslt); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc257 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_query: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_query", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err256 = thrift.WrapTException(err2)
      }
      if err2 := _exc257.Write(ctx, oprot); _write_err256 == nil && err2 != nil {
        _write_err256 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err256 == nil && err2 != nil {
        _write_err256 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err256 == nil && err2 != nil {
        _write_err256 = thrift.WrapTException(err2)
      }
      if _write_err256 != nil {
        return false, thrift.WrapTException(_write_err256)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_query", thrift.REPLY, seqId); err2 != nil {
    _write_err256 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err256 == nil && err2 != nil {
    _write_err256 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err256 == nil && err2 != nil {
    _write_err256 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err256 == nil && err2 != nil {
    _write_err256 = thrift.WrapTException(err2)
  }
  if _write_err256 != nil {
    return false, thrift.WrapTException(_write_err256)
  }
  return true, err
}

type serviceProcessorSqlUpdate struct {
  handler Service
}

func (p *serviceProcessorSqlUpdate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err258 error
  args := ServiceSqlUpdateArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "sql_update", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceSqlUpdateResult{}
  if err2 := p.handler.SqlUpdate(ctx, args.Sql, args.UpdaterID); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc259 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_update: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "sql_update", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err258 = thrift.WrapTException(err2)
      }
      if err2 := _exc259.Write(ctx, oprot); _write_err258 == nil && err2 != nil {
        _write_err258 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err258 == nil && err2 != nil {
        _write_err258 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err258 == nil && err2 != nil {
        _write_err258 = thrift.WrapTException(err2)
      }
      if _write_err258 != nil {
        return false, thrift.WrapTException(_write_err258)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "sql_update", thrift.REPLY, seqId); err2 != nil {
    _write_err258 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err258 == nil && err2 != nil {
    _write_err258 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err258 == nil && err2 != nil {
    _write_err258 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err258 == nil && err2 != nil {
    _write_err258 = thrift.WrapTException(err2)
  }
  if _write_err258 != nil {
    return false, thrift.WrapTException(_write_err258)
  }
  return true, err
}

type serviceProcessorExecSql struct {
  handler Service
}

func (p *serviceProcessorExecSql) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err260 error
  args := ServiceExecSqlArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "exec_sql", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceExecSqlResult{}
  if retval, err2 := p.handler.ExecSql(ctx, args.Sql); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc261 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exec_sql: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "exec_sql", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err260 = thrift.WrapTException(err2)
      }
      if err2 := _exc261.Write(ctx, oprot); _write_err260 == nil && err2 != nil {
        _write_err260 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err260 == nil && err2 != nil {
        _write_err260 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err260 == nil && err2 != nil {
        _write_err260 = thrift.WrapTException(err2)
      }
      if _write_err260 != nil {
        return false, thrift.WrapTException(_write_err260)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "exec_sql", thrift.REPLY, seqId); err2 != nil {
    _write_err260 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err260 == nil && err2 != nil {
    _write_err260 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err260 == nil && err2 != nil {
    _write_err260 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err260 == nil && err2 != nil {
    _write_err260 = thrift.WrapTException(err2)
  }
  if _write_err260 != nil {
    return false, thrift.WrapTException(_write_err260)
  }
  return true, err
}

type serviceProcessorUpdaterCreate struct {
  handler Service
}

func (p *serviceProcessorUpdaterCreate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err262 error
  args := ServiceUpdaterCreateArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updater_create", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceUpdaterCreateResult{}
  if retval, err2 := p.handler.UpdaterCreate(ctx, args.BufferSize); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc263 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updater_create: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "updater_create", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err262 = thrift.WrapTException(err2)
      }
      if err2 := _exc263.Write(ctx, oprot); _write_err262 == nil && err2 != nil {
        _write_err262 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err262 == nil && err2 != nil {
        _write_err262 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err262 == nil && err2 != nil {
        _write_err262 = thrift.WrapTException(err2)
      }
      if _write_err262 != nil {
        return false, thrift.WrapTException(_write_err262)
      }
      return true, err
    }
  } else {
    result.Success = &retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "updater_create", thrift.REPLY, seqId); err2 != nil {
    _write_err262 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err262 == nil && err2 != nil {
    _write_err262 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err262 == nil && err2 != nil {
    _write_err262 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err262 == nil && err2 != nil {
    _write_err262 = thrift.WrapTException(err2)
  }
  if _write_err262 != nil {
    return false, thrift.WrapTException(_write_err262)
  }
  return true, err
}

type serviceProcessorUpdaterClose struct {
  handler Service
}

func (p *serviceProcessorUpdaterClose) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err264 error
  args := ServiceUpdaterCloseArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "updater_close", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceUpdaterCloseResult{}
  if err2 := p.handler.UpdaterClose(ctx, args.ID); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc265 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updater_close: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "updater_close", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err264 = thrift.WrapTException(err2)
      }
      if err2 := _exc265.Write(ctx, oprot); _write_err264 == nil && err2 != nil {
        _write_err264 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err264 == nil && err2 != nil {
        _write_err264 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err264 == nil && err2 != nil {
        _write_err264 = thrift.WrapTException(err2)
      }
      if _write_err264 != nil {
        return false, thrift.WrapTException(_write_err264)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "updater_close", thrift.REPLY, seqId); err2 != nil {
    _write_err264 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err264 == nil && err2 != nil {
    _write_err264 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err264 == nil && err2 != nil {
    _write_err264 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err264 == nil && err2 != nil {
    _write_err264 = thrift.WrapTException(err2)
  }
  if _write_err264 != nil {
    return false, thrift.WrapTException(_write_err264)
  }
  return true, err
}

type serviceProcessorUpdatePlain struct {
  handler Service
}

func (p *serviceProcessorUpdatePlain) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err266 error
  args := ServiceUpdatePlainArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "update_plain", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceUpdatePlainResult{}
  if err2 := p.handler.UpdatePlain(ctx, args.Cells, args.UpdaterID); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc267 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing update_plain: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "update_plain", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err266 = thrift.WrapTException(err2)
      }
      if err2 := _exc267.Write(ctx, oprot); _write_err266 == nil && err2 != nil {
        _write_err266 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err266 == nil && err2 != nil {
        _write_err266 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err266 == nil && err2 != nil {
        _write_err266 = thrift.WrapTException(err2)
      }
      if _write_err266 != nil {
        return false, thrift.WrapTException(_write_err266)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "update_plain", thrift.REPLY, seqId); err2 != nil {
    _write_err266 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err266 == nil && err2 != nil {
    _write_err266 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err266 == nil && err2 != nil {
    _write_err266 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err266 == nil && err2 != nil {
    _write_err266 = thrift.WrapTException(err2)
  }
  if _write_err266 != nil {
    return false, thrift.WrapTException(_write_err266)
  }
  return true, err
}

type serviceProcessorUpdateCounter struct {
  handler Service
}

func (p *serviceProcessorUpdateCounter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err268 error
  args := ServiceUpdateCounterArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "update_counter", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceUpdateCounterResult{}
  if err2 := p.handler.UpdateCounter(ctx, args.Cells, args.UpdaterID); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc269 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing update_counter: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "update_counter", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err268 = thrift.WrapTException(err2)
      }
      if err2 := _exc269.Write(ctx, oprot); _write_err268 == nil && err2 != nil {
        _write_err268 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err268 == nil && err2 != nil {
        _write_err268 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err268 == nil && err2 != nil {
        _write_err268 = thrift.WrapTException(err2)
      }
      if _write_err268 != nil {
        return false, thrift.WrapTException(_write_err268)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "update_counter", thrift.REPLY, seqId); err2 != nil {
    _write_err268 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err268 == nil && err2 != nil {
    _write_err268 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err268 == nil && err2 != nil {
    _write_err268 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err268 == nil && err2 != nil {
    _write_err268 = thrift.WrapTException(err2)
  }
  if _write_err268 != nil {
    return false, thrift.WrapTException(_write_err268)
  }
  return true, err
}

type serviceProcessorUpdateSerial struct {
  handler Service
}

func (p *serviceProcessorUpdateSerial) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err270 error
  args := ServiceUpdateSerialArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "update_serial", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceUpdateSerialResult{}
  if err2 := p.handler.UpdateSerial(ctx, args.Cells, args.UpdaterID); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc271 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing update_serial: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "update_serial", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err270 = thrift.WrapTException(err2)
      }
      if err2 := _exc271.Write(ctx, oprot); _write_err270 == nil && err2 != nil {
        _write_err270 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err270 == nil && err2 != nil {
        _write_err270 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err270 == nil && err2 != nil {
        _write_err270 = thrift.WrapTException(err2)
      }
      if _write_err270 != nil {
        return false, thrift.WrapTException(_write_err270)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "update_serial", thrift.REPLY, seqId); err2 != nil {
    _write_err270 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err270 == nil && err2 != nil {
    _write_err270 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err270 == nil && err2 != nil {
    _write_err270 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err270 == nil && err2 != nil {
    _write_err270 = thrift.WrapTException(err2)
  }
  if _write_err270 != nil {
    return false, thrift.WrapTException(_write_err270)
  }
  return true, err
}

type serviceProcessorUpdateByTypes struct {
  handler Service
}

func (p *serviceProcessorUpdateByTypes) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err272 error
  args := ServiceUpdateByTypesArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "update_by_types", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceUpdateByTypesResult{}
  if err2 := p.handler.UpdateByTypes(ctx, args.Plain, args.Counter, args.Serial, args.UpdaterID); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc273 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing update_by_types: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "update_by_types", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err272 = thrift.WrapTException(err2)
      }
      if err2 := _exc273.Write(ctx, oprot); _write_err272 == nil && err2 != nil {
        _write_err272 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err272 == nil && err2 != nil {
        _write_err272 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err272 == nil && err2 != nil {
        _write_err272 = thrift.WrapTException(err2)
      }
      if _write_err272 != nil {
        return false, thrift.WrapTException(_write_err272)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "update_by_types", thrift.REPLY, seqId); err2 != nil {
    _write_err272 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err272 == nil && err2 != nil {
    _write_err272 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err272 == nil && err2 != nil {
    _write_err272 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err272 == nil && err2 != nil {
    _write_err272 = thrift.WrapTException(err2)
  }
  if _write_err272 != nil {
    return false, thrift.WrapTException(_write_err272)
  }
  return true, err
}

type serviceProcessorMngColumn struct {
  handler Service
}

func (p *serviceProcessorMngColumn) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err274 error
  args := ServiceMngColumnArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "mng_column", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceMngColumnResult{}
  if err2 := p.handler.MngColumn(ctx, args.Func, args.Schema); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc275 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mng_column: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "mng_column", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err274 = thrift.WrapTException(err2)
      }
      if err2 := _exc275.Write(ctx, oprot); _write_err274 == nil && err2 != nil {
        _write_err274 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err274 == nil && err2 != nil {
        _write_err274 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err274 == nil && err2 != nil {
        _write_err274 = thrift.WrapTException(err2)
      }
      if _write_err274 != nil {
        return false, thrift.WrapTException(_write_err274)
      }
      return true, err
    }
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "mng_column", thrift.REPLY, seqId); err2 != nil {
    _write_err274 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err274 == nil && err2 != nil {
    _write_err274 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err274 == nil && err2 != nil {
    _write_err274 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err274 == nil && err2 != nil {
    _write_err274 = thrift.WrapTException(err2)
  }
  if _write_err274 != nil {
    return false, thrift.WrapTException(_write_err274)
  }
  return true, err
}

type serviceProcessorListColumns struct {
  handler Service
}

func (p *serviceProcessorListColumns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err276 error
  args := ServiceListColumnsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "list_columns", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceListColumnsResult{}
  if retval, err2 := p.handler.ListColumns(ctx, args.Spec); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc277 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing list_columns: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "list_columns", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err276 = thrift.WrapTException(err2)
      }
      if err2 := _exc277.Write(ctx, oprot); _write_err276 == nil && err2 != nil {
        _write_err276 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err276 == nil && err2 != nil {
        _write_err276 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err276 == nil && err2 != nil {
        _write_err276 = thrift.WrapTException(err2)
      }
      if _write_err276 != nil {
        return false, thrift.WrapTException(_write_err276)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "list_columns", thrift.REPLY, seqId); err2 != nil {
    _write_err276 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err276 == nil && err2 != nil {
    _write_err276 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err276 == nil && err2 != nil {
    _write_err276 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err276 == nil && err2 != nil {
    _write_err276 = thrift.WrapTException(err2)
  }
  if _write_err276 != nil {
    return false, thrift.WrapTException(_write_err276)
  }
  return true, err
}

type serviceProcessorCompactColumns struct {
  handler Service
}

func (p *serviceProcessorCompactColumns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err278 error
  args := ServiceCompactColumnsArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "compact_columns", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceCompactColumnsResult{}
  if retval, err2 := p.handler.CompactColumns(ctx, args.Spec); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc279 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing compact_columns: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "compact_columns", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err278 = thrift.WrapTException(err2)
      }
      if err2 := _exc279.Write(ctx, oprot); _write_err278 == nil && err2 != nil {
        _write_err278 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err278 == nil && err2 != nil {
        _write_err278 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err278 == nil && err2 != nil {
        _write_err278 = thrift.WrapTException(err2)
      }
      if _write_err278 != nil {
        return false, thrift.WrapTException(_write_err278)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "compact_columns", thrift.REPLY, seqId); err2 != nil {
    _write_err278 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err278 == nil && err2 != nil {
    _write_err278 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err278 == nil && err2 != nil {
    _write_err278 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err278 == nil && err2 != nil {
    _write_err278 = thrift.WrapTException(err2)
  }
  if _write_err278 != nil {
    return false, thrift.WrapTException(_write_err278)
  }
  return true, err
}

type serviceProcessorScan struct {
  handler Service
}

func (p *serviceProcessorScan) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err280 error
  args := ServiceScanArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "scan", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceScanResult{}
  if retval, err2 := p.handler.Scan(ctx, args.Spec); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc281 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "scan", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err280 = thrift.WrapTException(err2)
      }
      if err2 := _exc281.Write(ctx, oprot); _write_err280 == nil && err2 != nil {
        _write_err280 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err280 == nil && err2 != nil {
        _write_err280 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err280 == nil && err2 != nil {
        _write_err280 = thrift.WrapTException(err2)
      }
      if _write_err280 != nil {
        return false, thrift.WrapTException(_write_err280)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "scan", thrift.REPLY, seqId); err2 != nil {
    _write_err280 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err280 == nil && err2 != nil {
    _write_err280 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err280 == nil && err2 != nil {
    _write_err280 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err280 == nil && err2 != nil {
    _write_err280 = thrift.WrapTException(err2)
  }
  if _write_err280 != nil {
    return false, thrift.WrapTException(_write_err280)
  }
  return true, err
}

type serviceProcessorScanRsltOnColumn struct {
  handler Service
}

func (p *serviceProcessorScanRsltOnColumn) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err282 error
  args := ServiceScanRsltOnColumnArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "scan_rslt_on_column", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceScanRsltOnColumnResult{}
  if retval, err2 := p.handler.ScanRsltOnColumn(ctx, args.Spec); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc283 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan_rslt_on_column: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_column", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err282 = thrift.WrapTException(err2)
      }
      if err2 := _exc283.Write(ctx, oprot); _write_err282 == nil && err2 != nil {
        _write_err282 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err282 == nil && err2 != nil {
        _write_err282 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err282 == nil && err2 != nil {
        _write_err282 = thrift.WrapTException(err2)
      }
      if _write_err282 != nil {
        return false, thrift.WrapTException(_write_err282)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_column", thrift.REPLY, seqId); err2 != nil {
    _write_err282 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err282 == nil && err2 != nil {
    _write_err282 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err282 == nil && err2 != nil {
    _write_err282 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err282 == nil && err2 != nil {
    _write_err282 = thrift.WrapTException(err2)
  }
  if _write_err282 != nil {
    return false, thrift.WrapTException(_write_err282)
  }
  return true, err
}

type serviceProcessorScanRsltOnKey struct {
  handler Service
}

func (p *serviceProcessorScanRsltOnKey) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err284 error
  args := ServiceScanRsltOnKeyArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "scan_rslt_on_key", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceScanRsltOnKeyResult{}
  if retval, err2 := p.handler.ScanRsltOnKey(ctx, args.Spec); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc285 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan_rslt_on_key: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_key", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err284 = thrift.WrapTException(err2)
      }
      if err2 := _exc285.Write(ctx, oprot); _write_err284 == nil && err2 != nil {
        _write_err284 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err284 == nil && err2 != nil {
        _write_err284 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err284 == nil && err2 != nil {
        _write_err284 = thrift.WrapTException(err2)
      }
      if _write_err284 != nil {
        return false, thrift.WrapTException(_write_err284)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_key", thrift.REPLY, seqId); err2 != nil {
    _write_err284 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err284 == nil && err2 != nil {
    _write_err284 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err284 == nil && err2 != nil {
    _write_err284 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err284 == nil && err2 != nil {
    _write_err284 = thrift.WrapTException(err2)
  }
  if _write_err284 != nil {
    return false, thrift.WrapTException(_write_err284)
  }
  return true, err
}

type serviceProcessorScanRsltOnFraction struct {
  handler Service
}

func (p *serviceProcessorScanRsltOnFraction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err286 error
  args := ServiceScanRsltOnFractionArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "scan_rslt_on_fraction", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceScanRsltOnFractionResult{}
  if retval, err2 := p.handler.ScanRsltOnFraction(ctx, args.Spec); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc287 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan_rslt_on_fraction: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_fraction", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err286 = thrift.WrapTException(err2)
      }
      if err2 := _exc287.Write(ctx, oprot); _write_err286 == nil && err2 != nil {
        _write_err286 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err286 == nil && err2 != nil {
        _write_err286 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err286 == nil && err2 != nil {
        _write_err286 = thrift.WrapTException(err2)
      }
      if _write_err286 != nil {
        return false, thrift.WrapTException(_write_err286)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_fraction", thrift.REPLY, seqId); err2 != nil {
    _write_err286 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err286 == nil && err2 != nil {
    _write_err286 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err286 == nil && err2 != nil {
    _write_err286 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err286 == nil && err2 != nil {
    _write_err286 = thrift.WrapTException(err2)
  }
  if _write_err286 != nil {
    return false, thrift.WrapTException(_write_err286)
  }
  return true, err
}

type serviceProcessorScanRsltOn struct {
  handler Service
}

func (p *serviceProcessorScanRsltOn) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
  var _write_err288 error
  args := ServiceScanRsltOnArgs{}
  if err2 := args.Read(ctx, iprot); err2 != nil {
    iprot.ReadMessageEnd(ctx)
    x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
    oprot.WriteMessageBegin(ctx, "scan_rslt_on", thrift.EXCEPTION, seqId)
    x.Write(ctx, oprot)
    oprot.WriteMessageEnd(ctx)
    oprot.Flush(ctx)
    return false, thrift.WrapTException(err2)
  }
  iprot.ReadMessageEnd(ctx)

  tickerCancel := func() {}
  // Start a goroutine to do server side connectivity check.
  if thrift.ServerConnectivityCheckInterval > 0 {
    var cancel context.CancelCauseFunc
    ctx, cancel = context.WithCancelCause(ctx)
    defer cancel(nil)
    var tickerCtx context.Context
    tickerCtx, tickerCancel = context.WithCancel(context.Background())
    defer tickerCancel()
    go func(ctx context.Context, cancel context.CancelCauseFunc) {
      ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
      defer ticker.Stop()
      for {
        select {
        case <-ctx.Done():
          return
        case <-ticker.C:
          if !iprot.Transport().IsOpen() {
            cancel(thrift.ErrAbandonRequest)
            return
          }
        }
      }
    }(tickerCtx, cancel)
  }

  result := ServiceScanRsltOnResult{}
  if retval, err2 := p.handler.ScanRsltOn(ctx, args.Spec, args.Rslt); err2 != nil {
    tickerCancel()
    err = thrift.WrapTException(err2)
    switch v := err2.(type) {
    case *Exception:
      result.E = v
    default:
      if errors.Is(err2, thrift.ErrAbandonRequest) {
        return false, thrift.WrapTException(err2)
      }
      if errors.Is(err2, context.Canceled) {
        if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
          return false, thrift.WrapTException(err)
        }
      }
      _exc289 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan_rslt_on: " + err2.Error())
      if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on", thrift.EXCEPTION, seqId); err2 != nil {
        _write_err288 = thrift.WrapTException(err2)
      }
      if err2 := _exc289.Write(ctx, oprot); _write_err288 == nil && err2 != nil {
        _write_err288 = thrift.WrapTException(err2)
      }
      if err2 := oprot.WriteMessageEnd(ctx); _write_err288 == nil && err2 != nil {
        _write_err288 = thrift.WrapTException(err2)
      }
      if err2 := oprot.Flush(ctx); _write_err288 == nil && err2 != nil {
        _write_err288 = thrift.WrapTException(err2)
      }
      if _write_err288 != nil {
        return false, thrift.WrapTException(_write_err288)
      }
      return true, err
    }
  } else {
    result.Success = retval
  }
  tickerCancel()
  if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on", thrift.REPLY, seqId); err2 != nil {
    _write_err288 = thrift.WrapTException(err2)
  }
  if err2 := result.Write(ctx, oprot); _write_err288 == nil && err2 != nil {
    _write_err288 = thrift.WrapTException(err2)
  }
  if err2 := oprot.WriteMessageEnd(ctx); _write_err288 == nil && err2 != nil {
    _write_err288 = thrift.WrapTException(err2)
  }
  if err2 := oprot.Flush(ctx); _write_err288 == nil && err2 != nil {
    _write_err288 = thrift.WrapTException(err2)
  }
  if _write_err288 != nil {
    return false, thrift.WrapTException(_write_err288)
  }
  return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlMngColumnArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlMngColumnArgs() *ServiceSqlMngColumnArgs {
  return &ServiceSqlMngColumnArgs{}
}


func (p *ServiceSqlMngColumnArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlMngColumnArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlMngColumnArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlMngColumnArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_mng_column_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlMngColumnArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlMngColumnArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlMngColumnArgs(%+v)", *p)
}

func (p *ServiceSqlMngColumnArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlMngColumnArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlMngColumnArgs)(nil)

// Attributes:
//  - E
type ServiceSqlMngColumnResult struct {
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlMngColumnResult() *ServiceSqlMngColumnResult {
  return &ServiceSqlMngColumnResult{}
}

var ServiceSqlMngColumnResult_E_DEFAULT *Exception
func (p *ServiceSqlMngColumnResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlMngColumnResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlMngColumnResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlMngColumnResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlMngColumnResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlMngColumnResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_mng_column_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlMngColumnResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlMngColumnResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlMngColumnResult(%+v)", *p)
}

func (p *ServiceSqlMngColumnResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlMngColumnResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlMngColumnResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlListColumnsArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlListColumnsArgs() *ServiceSqlListColumnsArgs {
  return &ServiceSqlListColumnsArgs{}
}


func (p *ServiceSqlListColumnsArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlListColumnsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlListColumnsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlListColumnsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_list_columns_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlListColumnsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlListColumnsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlListColumnsArgs(%+v)", *p)
}

func (p *ServiceSqlListColumnsArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlListColumnsArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlListColumnsArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlListColumnsResult struct {
  Success Schemas `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlListColumnsResult() *ServiceSqlListColumnsResult {
  return &ServiceSqlListColumnsResult{}
}

var ServiceSqlListColumnsResult_Success_DEFAULT Schemas

func (p *ServiceSqlListColumnsResult) GetSuccess() Schemas {
  return p.Success
}
var ServiceSqlListColumnsResult_E_DEFAULT *Exception
func (p *ServiceSqlListColumnsResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlListColumnsResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlListColumnsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlListColumnsResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlListColumnsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlListColumnsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Schemas, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem290 := &Schema{}
    if err := _elem290.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem290), err)
    }
    p.Success = append(p.Success, _elem290)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceSqlListColumnsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlListColumnsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_list_columns_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlListColumnsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlListColumnsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlListColumnsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlListColumnsResult(%+v)", *p)
}

func (p *ServiceSqlListColumnsResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlListColumnsResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlListColumnsResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlCompactColumnsArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlCompactColumnsArgs() *ServiceSqlCompactColumnsArgs {
  return &ServiceSqlCompactColumnsArgs{}
}


func (p *ServiceSqlCompactColumnsArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlCompactColumnsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlCompactColumnsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlCompactColumnsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_compact_columns_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlCompactColumnsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlCompactColumnsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlCompactColumnsArgs(%+v)", *p)
}

func (p *ServiceSqlCompactColumnsArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlCompactColumnsArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlCompactColumnsArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlCompactColumnsResult struct {
  Success CompactResults `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlCompactColumnsResult() *ServiceSqlCompactColumnsResult {
  return &ServiceSqlCompactColumnsResult{}
}

var ServiceSqlCompactColumnsResult_Success_DEFAULT CompactResults

func (p *ServiceSqlCompactColumnsResult) GetSuccess() CompactResults {
  return p.Success
}
var ServiceSqlCompactColumnsResult_E_DEFAULT *Exception
func (p *ServiceSqlCompactColumnsResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlCompactColumnsResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlCompactColumnsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlCompactColumnsResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlCompactColumnsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlCompactColumnsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CompactResults, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem291 := &CompactResult_{}
    if err := _elem291.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem291), err)
    }
    p.Success = append(p.Success, _elem291)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceSqlCompactColumnsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlCompactColumnsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_compact_columns_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlCompactColumnsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlCompactColumnsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlCompactColumnsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlCompactColumnsResult(%+v)", *p)
}

func (p *ServiceSqlCompactColumnsResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlCompactColumnsResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlCompactColumnsResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlSelectPlainArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlSelectPlainArgs() *ServiceSqlSelectPlainArgs {
  return &ServiceSqlSelectPlainArgs{}
}


func (p *ServiceSqlSelectPlainArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlSelectPlainArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectPlainArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlSelectPlainArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_plain_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectPlainArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlSelectPlainArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectPlainArgs(%+v)", *p)
}

func (p *ServiceSqlSelectPlainArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectPlainArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectPlainArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlSelectPlainResult struct {
  Success CellsPlain `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlSelectPlainResult() *ServiceSqlSelectPlainResult {
  return &ServiceSqlSelectPlainResult{}
}

var ServiceSqlSelectPlainResult_Success_DEFAULT CellsPlain

func (p *ServiceSqlSelectPlainResult) GetSuccess() CellsPlain {
  return p.Success
}
var ServiceSqlSelectPlainResult_E_DEFAULT *Exception
func (p *ServiceSqlSelectPlainResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlSelectPlainResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlSelectPlainResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlSelectPlainResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlSelectPlainResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectPlainResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellsPlain, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem292 := &CellPlain{}
    if err := _elem292.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem292), err)
    }
    p.Success = append(p.Success, _elem292)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceSqlSelectPlainResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlSelectPlainResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_plain_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectPlainResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectPlainResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectPlainResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectPlainResult(%+v)", *p)
}

func (p *ServiceSqlSelectPlainResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectPlainResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectPlainResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlSelectCounterArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlSelectCounterArgs() *ServiceSqlSelectCounterArgs {
  return &ServiceSqlSelectCounterArgs{}
}


func (p *ServiceSqlSelectCounterArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlSelectCounterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectCounterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlSelectCounterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_counter_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectCounterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlSelectCounterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectCounterArgs(%+v)", *p)
}

func (p *ServiceSqlSelectCounterArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectCounterArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectCounterArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlSelectCounterResult struct {
  Success CellsCounter `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlSelectCounterResult() *ServiceSqlSelectCounterResult {
  return &ServiceSqlSelectCounterResult{}
}

var ServiceSqlSelectCounterResult_Success_DEFAULT CellsCounter

func (p *ServiceSqlSelectCounterResult) GetSuccess() CellsCounter {
  return p.Success
}
var ServiceSqlSelectCounterResult_E_DEFAULT *Exception
func (p *ServiceSqlSelectCounterResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlSelectCounterResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlSelectCounterResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlSelectCounterResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlSelectCounterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectCounterResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellsCounter, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem293 := &CellCounter{}
    if err := _elem293.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem293), err)
    }
    p.Success = append(p.Success, _elem293)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceSqlSelectCounterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlSelectCounterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_counter_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectCounterResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectCounterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectCounterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectCounterResult(%+v)", *p)
}

func (p *ServiceSqlSelectCounterResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectCounterResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectCounterResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlSelectSerialArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlSelectSerialArgs() *ServiceSqlSelectSerialArgs {
  return &ServiceSqlSelectSerialArgs{}
}


func (p *ServiceSqlSelectSerialArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlSelectSerialArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectSerialArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlSelectSerialArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_serial_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectSerialArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlSelectSerialArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectSerialArgs(%+v)", *p)
}

func (p *ServiceSqlSelectSerialArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectSerialArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectSerialArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlSelectSerialResult struct {
  Success CellsSerial `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlSelectSerialResult() *ServiceSqlSelectSerialResult {
  return &ServiceSqlSelectSerialResult{}
}

var ServiceSqlSelectSerialResult_Success_DEFAULT CellsSerial

func (p *ServiceSqlSelectSerialResult) GetSuccess() CellsSerial {
  return p.Success
}
var ServiceSqlSelectSerialResult_E_DEFAULT *Exception
func (p *ServiceSqlSelectSerialResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlSelectSerialResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlSelectSerialResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlSelectSerialResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlSelectSerialResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectSerialResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CellsSerial, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem294 := &CellSerial{}
    if err := _elem294.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem294), err)
    }
    p.Success = append(p.Success, _elem294)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceSqlSelectSerialResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlSelectSerialResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_serial_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectSerialResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectSerialResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectSerialResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectSerialResult(%+v)", *p)
}

func (p *ServiceSqlSelectSerialResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectSerialResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectSerialResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlSelectArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlSelectArgs() *ServiceSqlSelectArgs {
  return &ServiceSqlSelectArgs{}
}


func (p *ServiceSqlSelectArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlSelectArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlSelectArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlSelectArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectArgs(%+v)", *p)
}

func (p *ServiceSqlSelectArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlSelectResult struct {
  Success *Cells `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlSelectResult() *ServiceSqlSelectResult {
  return &ServiceSqlSelectResult{}
}

var ServiceSqlSelectResult_Success_DEFAULT *Cells
func (p *ServiceSqlSelectResult) GetSuccess() *Cells {
  if !p.IsSetSuccess() {
    return ServiceSqlSelectResult_Success_DEFAULT
  }
  return p.Success
}
var ServiceSqlSelectResult_E_DEFAULT *Exception
func (p *ServiceSqlSelectResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlSelectResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlSelectResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlSelectResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlSelectResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Cells{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ServiceSqlSelectResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlSelectResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectResult(%+v)", *p)
}

func (p *ServiceSqlSelectResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlSelectRsltOnColumnArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlSelectRsltOnColumnArgs() *ServiceSqlSelectRsltOnColumnArgs {
  return &ServiceSqlSelectRsltOnColumnArgs{}
}


func (p *ServiceSqlSelectRsltOnColumnArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlSelectRsltOnColumnArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnColumnArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlSelectRsltOnColumnArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_column_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectRsltOnColumnArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlSelectRsltOnColumnArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectRsltOnColumnArgs(%+v)", *p)
}

func (p *ServiceSqlSelectRsltOnColumnArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectRsltOnColumnArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectRsltOnColumnArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlSelectRsltOnColumnResult struct {
  Success CCells `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlSelectRsltOnColumnResult() *ServiceSqlSelectRsltOnColumnResult {
  return &ServiceSqlSelectRsltOnColumnResult{}
}

var ServiceSqlSelectRsltOnColumnResult_Success_DEFAULT CCells

func (p *ServiceSqlSelectRsltOnColumnResult) GetSuccess() CCells {
  return p.Success
}
var ServiceSqlSelectRsltOnColumnResult_E_DEFAULT *Exception
func (p *ServiceSqlSelectRsltOnColumnResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlSelectRsltOnColumnResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlSelectRsltOnColumnResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlSelectRsltOnColumnResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlSelectRsltOnColumnResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnColumnResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(CCells, size)
  p.Success =  tMap
  for i := 0; i < size; i ++ {
var _key295 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key295 = v
}
    _val296 := &CCells{}
    if err := _val296.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val296), err)
    }
    p.Success[_key295] = _val296
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnColumnResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnColumnResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_column_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectRsltOnColumnResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.MAP, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Success {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectRsltOnColumnResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectRsltOnColumnResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectRsltOnColumnResult(%+v)", *p)
}

func (p *ServiceSqlSelectRsltOnColumnResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectRsltOnColumnResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectRsltOnColumnResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlSelectRsltOnKeyArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlSelectRsltOnKeyArgs() *ServiceSqlSelectRsltOnKeyArgs {
  return &ServiceSqlSelectRsltOnKeyArgs{}
}


func (p *ServiceSqlSelectRsltOnKeyArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlSelectRsltOnKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlSelectRsltOnKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectRsltOnKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlSelectRsltOnKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectRsltOnKeyArgs(%+v)", *p)
}

func (p *ServiceSqlSelectRsltOnKeyArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectRsltOnKeyArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectRsltOnKeyArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlSelectRsltOnKeyResult struct {
  Success KCells `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlSelectRsltOnKeyResult() *ServiceSqlSelectRsltOnKeyResult {
  return &ServiceSqlSelectRsltOnKeyResult{}
}

var ServiceSqlSelectRsltOnKeyResult_Success_DEFAULT KCells

func (p *ServiceSqlSelectRsltOnKeyResult) GetSuccess() KCells {
  return p.Success
}
var ServiceSqlSelectRsltOnKeyResult_E_DEFAULT *Exception
func (p *ServiceSqlSelectRsltOnKeyResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlSelectRsltOnKeyResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlSelectRsltOnKeyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlSelectRsltOnKeyResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlSelectRsltOnKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnKeyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(KCells, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem297 := &KCells{}
    if err := _elem297.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem297), err)
    }
    p.Success = append(p.Success, _elem297)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnKeyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectRsltOnKeyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectRsltOnKeyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectRsltOnKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectRsltOnKeyResult(%+v)", *p)
}

func (p *ServiceSqlSelectRsltOnKeyResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectRsltOnKeyResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectRsltOnKeyResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceSqlSelectRsltOnFractionArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceSqlSelectRsltOnFractionArgs() *ServiceSqlSelectRsltOnFractionArgs {
  return &ServiceSqlSelectRsltOnFractionArgs{}
}


func (p *ServiceSqlSelectRsltOnFractionArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceSqlSelectRsltOnFractionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnFractionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlSelectRsltOnFractionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_fraction_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectRsltOnFractionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlSelectRsltOnFractionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectRsltOnFractionArgs(%+v)", *p)
}

func (p *ServiceSqlSelectRsltOnFractionArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectRsltOnFractionArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectRsltOnFractionArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlSelectRsltOnFractionResult struct {
  Success *FCells `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlSelectRsltOnFractionResult() *ServiceSqlSelectRsltOnFractionResult {
  return &ServiceSqlSelectRsltOnFractionResult{}
}

var ServiceSqlSelectRsltOnFractionResult_Success_DEFAULT *FCells
func (p *ServiceSqlSelectRsltOnFractionResult) GetSuccess() *FCells {
  if !p.IsSetSuccess() {
    return ServiceSqlSelectRsltOnFractionResult_Success_DEFAULT
  }
  return p.Success
}
var ServiceSqlSelectRsltOnFractionResult_E_DEFAULT *Exception
func (p *ServiceSqlSelectRsltOnFractionResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlSelectRsltOnFractionResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlSelectRsltOnFractionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlSelectRsltOnFractionResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlSelectRsltOnFractionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnFractionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FCells{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnFractionResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlSelectRsltOnFractionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_fraction_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlSelectRsltOnFractionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectRsltOnFractionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlSelectRsltOnFractionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlSelectRsltOnFractionResult(%+v)", *p)
}

func (p *ServiceSqlSelectRsltOnFractionResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlSelectRsltOnFractionResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlSelectRsltOnFractionResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
//  - Rslt: The Type of Cells Result for the response
type ServiceSqlQueryArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
  Rslt CellsResult_ `thrift:"rslt,2" db:"rslt" json:"rslt"`
}

func NewServiceSqlQueryArgs() *ServiceSqlQueryArgs {
  return &ServiceSqlQueryArgs{}
}


func (p *ServiceSqlQueryArgs) GetSql() string {
  return p.Sql
}

func (p *ServiceSqlQueryArgs) GetRslt() CellsResult_ {
  return p.Rslt
}
func (p *ServiceSqlQueryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlQueryArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlQueryArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := CellsResult_(v)
  p.Rslt = temp
}
  return nil
}

func (p *ServiceSqlQueryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_query_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlQueryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlQueryArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rslt", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rslt: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Rslt)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.rslt (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rslt: ", p), err) }
  return err
}

func (p *ServiceSqlQueryArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlQueryArgs(%+v)", *p)
}

func (p *ServiceSqlQueryArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlQueryArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlQueryArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceSqlQueryResult struct {
  Success *CellsGroup `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlQueryResult() *ServiceSqlQueryResult {
  return &ServiceSqlQueryResult{}
}

var ServiceSqlQueryResult_Success_DEFAULT *CellsGroup
func (p *ServiceSqlQueryResult) GetSuccess() *CellsGroup {
  if !p.IsSetSuccess() {
    return ServiceSqlQueryResult_Success_DEFAULT
  }
  return p.Success
}
var ServiceSqlQueryResult_E_DEFAULT *Exception
func (p *ServiceSqlQueryResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlQueryResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlQueryResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceSqlQueryResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlQueryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlQueryResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CellsGroup{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ServiceSqlQueryResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlQueryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_query_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlQueryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceSqlQueryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlQueryResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlQueryResult(%+v)", *p)
}

func (p *ServiceSqlQueryResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlQueryResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlQueryResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
//  - UpdaterID: The Updater ID to work with
type ServiceSqlUpdateArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
  UpdaterID int64 `thrift:"updater_id,2" db:"updater_id" json:"updater_id"`
}

func NewServiceSqlUpdateArgs() *ServiceSqlUpdateArgs {
  return &ServiceSqlUpdateArgs{}
}


func (p *ServiceSqlUpdateArgs) GetSql() string {
  return p.Sql
}

func (p *ServiceSqlUpdateArgs) GetUpdaterID() int64 {
  return p.UpdaterID
}
func (p *ServiceSqlUpdateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlUpdateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceSqlUpdateArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.UpdaterID = v
}
  return nil
}

func (p *ServiceSqlUpdateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_update_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlUpdateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceSqlUpdateArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updater_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.UpdaterID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updater_id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updater_id: ", p), err) }
  return err
}

func (p *ServiceSqlUpdateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlUpdateArgs(%+v)", *p)
}

func (p *ServiceSqlUpdateArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlUpdateArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlUpdateArgs)(nil)

// Attributes:
//  - E
type ServiceSqlUpdateResult struct {
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceSqlUpdateResult() *ServiceSqlUpdateResult {
  return &ServiceSqlUpdateResult{}
}

var ServiceSqlUpdateResult_E_DEFAULT *Exception
func (p *ServiceSqlUpdateResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceSqlUpdateResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceSqlUpdateResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceSqlUpdateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceSqlUpdateResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceSqlUpdateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "sql_update_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceSqlUpdateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceSqlUpdateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceSqlUpdateResult(%+v)", *p)
}

func (p *ServiceSqlUpdateResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceSqlUpdateResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceSqlUpdateResult)(nil)

// Attributes:
//  - Sql: The SQL string to Execute
type ServiceExecSqlArgs struct {
  Sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceExecSqlArgs() *ServiceExecSqlArgs {
  return &ServiceExecSqlArgs{}
}


func (p *ServiceExecSqlArgs) GetSql() string {
  return p.Sql
}
func (p *ServiceExecSqlArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRING {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceExecSqlArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadString(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.Sql = v
}
  return nil
}

func (p *ServiceExecSqlArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "exec_sql_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceExecSqlArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err) }
  if err := oprot.WriteString(ctx, string(p.Sql)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err) }
  return err
}

func (p *ServiceExecSqlArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceExecSqlArgs(%+v)", *p)
}

func (p *ServiceExecSqlArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceExecSqlArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceExecSqlArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceExecSqlResult struct {
  Success *Result_ `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceExecSqlResult() *ServiceExecSqlResult {
  return &ServiceExecSqlResult{}
}

var ServiceExecSqlResult_Success_DEFAULT *Result_
func (p *ServiceExecSqlResult) GetSuccess() *Result_ {
  if !p.IsSetSuccess() {
    return ServiceExecSqlResult_Success_DEFAULT
  }
  return p.Success
}
var ServiceExecSqlResult_E_DEFAULT *Exception
func (p *ServiceExecSqlResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceExecSqlResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceExecSqlResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceExecSqlResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceExecSqlResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceExecSqlResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Result_{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ServiceExecSqlResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceExecSqlResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "exec_sql_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceExecSqlResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceExecSqlResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceExecSqlResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceExecSqlResult(%+v)", *p)
}

func (p *ServiceExecSqlResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceExecSqlResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceExecSqlResult)(nil)

// Attributes:
//  - BufferSize: The buffer size of the Updater
type ServiceUpdaterCreateArgs struct {
  BufferSize int32 `thrift:"buffer_size,1" db:"buffer_size" json:"buffer_size"`
}

func NewServiceUpdaterCreateArgs() *ServiceUpdaterCreateArgs {
  return &ServiceUpdaterCreateArgs{}
}


func (p *ServiceUpdaterCreateArgs) GetBufferSize() int32 {
  return p.BufferSize
}
func (p *ServiceUpdaterCreateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdaterCreateArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.BufferSize = v
}
  return nil
}

func (p *ServiceUpdaterCreateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updater_create_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdaterCreateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "buffer_size", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:buffer_size: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.BufferSize)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.buffer_size (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:buffer_size: ", p), err) }
  return err
}

func (p *ServiceUpdaterCreateArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdaterCreateArgs(%+v)", *p)
}

func (p *ServiceUpdaterCreateArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdaterCreateArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdaterCreateArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceUpdaterCreateResult struct {
  Success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceUpdaterCreateResult() *ServiceUpdaterCreateResult {
  return &ServiceUpdaterCreateResult{}
}

var ServiceUpdaterCreateResult_Success_DEFAULT int64
func (p *ServiceUpdaterCreateResult) GetSuccess() int64 {
  if !p.IsSetSuccess() {
    return ServiceUpdaterCreateResult_Success_DEFAULT
  }
  return *p.Success
}
var ServiceUpdaterCreateResult_E_DEFAULT *Exception
func (p *ServiceUpdaterCreateResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceUpdaterCreateResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceUpdaterCreateResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceUpdaterCreateResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceUpdaterCreateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdaterCreateResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 0: ", err)
} else {
  p.Success = &v
}
  return nil
}

func (p *ServiceUpdaterCreateResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceUpdaterCreateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updater_create_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdaterCreateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteI64(ctx, int64(*p.Success)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err) }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceUpdaterCreateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceUpdaterCreateResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdaterCreateResult(%+v)", *p)
}

func (p *ServiceUpdaterCreateResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdaterCreateResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdaterCreateResult)(nil)

// Attributes:
//  - ID: The Updater ID to close
type ServiceUpdaterCloseArgs struct {
  ID int64 `thrift:"id,1" db:"id" json:"id"`
}

func NewServiceUpdaterCloseArgs() *ServiceUpdaterCloseArgs {
  return &ServiceUpdaterCloseArgs{}
}


func (p *ServiceUpdaterCloseArgs) GetID() int64 {
  return p.ID
}
func (p *ServiceUpdaterCloseArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdaterCloseArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  p.ID = v
}
  return nil
}

func (p *ServiceUpdaterCloseArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updater_close_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdaterCloseArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "id", thrift.I64, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.ID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err) }
  return err
}

func (p *ServiceUpdaterCloseArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdaterCloseArgs(%+v)", *p)
}

func (p *ServiceUpdaterCloseArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdaterCloseArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdaterCloseArgs)(nil)

// Attributes:
//  - E
type ServiceUpdaterCloseResult struct {
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceUpdaterCloseResult() *ServiceUpdaterCloseResult {
  return &ServiceUpdaterCloseResult{}
}

var ServiceUpdaterCloseResult_E_DEFAULT *Exception
func (p *ServiceUpdaterCloseResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceUpdaterCloseResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceUpdaterCloseResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceUpdaterCloseResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdaterCloseResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceUpdaterCloseResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "updater_close_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdaterCloseResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceUpdaterCloseResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdaterCloseResult(%+v)", *p)
}

func (p *ServiceUpdaterCloseResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdaterCloseResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdaterCloseResult)(nil)

// Attributes:
//  - Cells: The Cells to update
//  - UpdaterID: The Updater ID to use for write
type ServiceUpdatePlainArgs struct {
  Cells UCCellsPlain `thrift:"cells,1" db:"cells" json:"cells"`
  UpdaterID int64 `thrift:"updater_id,2" db:"updater_id" json:"updater_id"`
}

func NewServiceUpdatePlainArgs() *ServiceUpdatePlainArgs {
  return &ServiceUpdatePlainArgs{}
}


func (p *ServiceUpdatePlainArgs) GetCells() UCCellsPlain {
  return p.Cells
}

func (p *ServiceUpdatePlainArgs) GetUpdaterID() int64 {
  return p.UpdaterID
}
func (p *ServiceUpdatePlainArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdatePlainArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(UCCellsPlain, size)
  p.Cells =  tMap
  for i := 0; i < size; i ++ {
var _key298 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key298 = v
}
    _, size, err := iprot.ReadListBegin(ctx)
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make(UCellsPlain, 0, size)
    _val299 :=  tSlice
    for i := 0; i < size; i ++ {
      _elem300 := &UCellPlain{}
      if err := _elem300.Read(ctx, iprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem300), err)
      }
      _val299 = append(_val299, _elem300)
    }
    if err := iprot.ReadListEnd(ctx); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Cells[_key298] = _val299
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ServiceUpdatePlainArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.UpdaterID = v
}
  return nil
}

func (p *ServiceUpdatePlainArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "update_plain_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdatePlainArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cells", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cells: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.Cells)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Cells {
    if err := oprot.WriteI64(ctx, int64(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cells: ", p), err) }
  return err
}

func (p *ServiceUpdatePlainArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updater_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.UpdaterID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updater_id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updater_id: ", p), err) }
  return err
}

func (p *ServiceUpdatePlainArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdatePlainArgs(%+v)", *p)
}

func (p *ServiceUpdatePlainArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdatePlainArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdatePlainArgs)(nil)

// Attributes:
//  - E
type ServiceUpdatePlainResult struct {
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceUpdatePlainResult() *ServiceUpdatePlainResult {
  return &ServiceUpdatePlainResult{}
}

var ServiceUpdatePlainResult_E_DEFAULT *Exception
func (p *ServiceUpdatePlainResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceUpdatePlainResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceUpdatePlainResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceUpdatePlainResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdatePlainResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceUpdatePlainResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "update_plain_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdatePlainResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceUpdatePlainResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdatePlainResult(%+v)", *p)
}

func (p *ServiceUpdatePlainResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdatePlainResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdatePlainResult)(nil)

// Attributes:
//  - Cells: The Counter Cells to update
//  - UpdaterID: The Updater ID to use for write
type ServiceUpdateCounterArgs struct {
  Cells UCCellsCounter `thrift:"cells,1" db:"cells" json:"cells"`
  UpdaterID int64 `thrift:"updater_id,2" db:"updater_id" json:"updater_id"`
}

func NewServiceUpdateCounterArgs() *ServiceUpdateCounterArgs {
  return &ServiceUpdateCounterArgs{}
}


func (p *ServiceUpdateCounterArgs) GetCells() UCCellsCounter {
  return p.Cells
}

func (p *ServiceUpdateCounterArgs) GetUpdaterID() int64 {
  return p.UpdaterID
}
func (p *ServiceUpdateCounterArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdateCounterArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(UCCellsCounter, size)
  p.Cells =  tMap
  for i := 0; i < size; i ++ {
var _key301 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key301 = v
}
    _, size, err := iprot.ReadListBegin(ctx)
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make(UCellsCounter, 0, size)
    _val302 :=  tSlice
    for i := 0; i < size; i ++ {
      _elem303 := &UCellCounter{}
      if err := _elem303.Read(ctx, iprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem303), err)
      }
      _val302 = append(_val302, _elem303)
    }
    if err := iprot.ReadListEnd(ctx); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Cells[_key301] = _val302
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ServiceUpdateCounterArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.UpdaterID = v
}
  return nil
}

func (p *ServiceUpdateCounterArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "update_counter_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdateCounterArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cells", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cells: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.Cells)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Cells {
    if err := oprot.WriteI64(ctx, int64(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cells: ", p), err) }
  return err
}

func (p *ServiceUpdateCounterArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updater_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.UpdaterID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updater_id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updater_id: ", p), err) }
  return err
}

func (p *ServiceUpdateCounterArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdateCounterArgs(%+v)", *p)
}

func (p *ServiceUpdateCounterArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdateCounterArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdateCounterArgs)(nil)

// Attributes:
//  - E
type ServiceUpdateCounterResult struct {
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceUpdateCounterResult() *ServiceUpdateCounterResult {
  return &ServiceUpdateCounterResult{}
}

var ServiceUpdateCounterResult_E_DEFAULT *Exception
func (p *ServiceUpdateCounterResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceUpdateCounterResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceUpdateCounterResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceUpdateCounterResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdateCounterResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceUpdateCounterResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "update_counter_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdateCounterResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceUpdateCounterResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdateCounterResult(%+v)", *p)
}

func (p *ServiceUpdateCounterResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdateCounterResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdateCounterResult)(nil)

// Attributes:
//  - Cells: The Serial Cells to update
//  - UpdaterID: The Updater ID to use for write
type ServiceUpdateSerialArgs struct {
  Cells UCCellsSerial `thrift:"cells,1" db:"cells" json:"cells"`
  UpdaterID int64 `thrift:"updater_id,2" db:"updater_id" json:"updater_id"`
}

func NewServiceUpdateSerialArgs() *ServiceUpdateSerialArgs {
  return &ServiceUpdateSerialArgs{}
}


func (p *ServiceUpdateSerialArgs) GetCells() UCCellsSerial {
  return p.Cells
}

func (p *ServiceUpdateSerialArgs) GetUpdaterID() int64 {
  return p.UpdaterID
}
func (p *ServiceUpdateSerialArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdateSerialArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(UCCellsSerial, size)
  p.Cells =  tMap
  for i := 0; i < size; i ++ {
var _key304 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key304 = v
}
    _, size, err := iprot.ReadListBegin(ctx)
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make(UCellsSerial, 0, size)
    _val305 :=  tSlice
    for i := 0; i < size; i ++ {
      _elem306 := &UCellSerial{}
      if err := _elem306.Read(ctx, iprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem306), err)
      }
      _val305 = append(_val305, _elem306)
    }
    if err := iprot.ReadListEnd(ctx); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Cells[_key304] = _val305
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ServiceUpdateSerialArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  p.UpdaterID = v
}
  return nil
}

func (p *ServiceUpdateSerialArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "update_serial_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdateSerialArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "cells", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cells: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.Cells)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Cells {
    if err := oprot.WriteI64(ctx, int64(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cells: ", p), err) }
  return err
}

func (p *ServiceUpdateSerialArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updater_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.UpdaterID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updater_id (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updater_id: ", p), err) }
  return err
}

func (p *ServiceUpdateSerialArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdateSerialArgs(%+v)", *p)
}

func (p *ServiceUpdateSerialArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdateSerialArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdateSerialArgs)(nil)

// Attributes:
//  - E
type ServiceUpdateSerialResult struct {
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceUpdateSerialResult() *ServiceUpdateSerialResult {
  return &ServiceUpdateSerialResult{}
}

var ServiceUpdateSerialResult_E_DEFAULT *Exception
func (p *ServiceUpdateSerialResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceUpdateSerialResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceUpdateSerialResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceUpdateSerialResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdateSerialResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceUpdateSerialResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "update_serial_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdateSerialResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceUpdateSerialResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdateSerialResult(%+v)", *p)
}

func (p *ServiceUpdateSerialResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdateSerialResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdateSerialResult)(nil)

// Attributes:
//  - Plain: The PLAIN Cells to update
//  - Counter: The COUNTER Cells to update
//  - Serial: The SERIAL Cells to update
//  - UpdaterID: The Updater ID to use for write
type ServiceUpdateByTypesArgs struct {
  Plain UCCellsPlain `thrift:"plain,1" db:"plain" json:"plain"`
  Counter UCCellsCounter `thrift:"counter,2" db:"counter" json:"counter"`
  Serial UCCellsSerial `thrift:"serial,3" db:"serial" json:"serial"`
  UpdaterID int64 `thrift:"updater_id,4" db:"updater_id" json:"updater_id"`
}

func NewServiceUpdateByTypesArgs() *ServiceUpdateByTypesArgs {
  return &ServiceUpdateByTypesArgs{}
}


func (p *ServiceUpdateByTypesArgs) GetPlain() UCCellsPlain {
  return p.Plain
}

func (p *ServiceUpdateByTypesArgs) GetCounter() UCCellsCounter {
  return p.Counter
}

func (p *ServiceUpdateByTypesArgs) GetSerial() UCCellsSerial {
  return p.Serial
}

func (p *ServiceUpdateByTypesArgs) GetUpdaterID() int64 {
  return p.UpdaterID
}
func (p *ServiceUpdateByTypesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 3:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField3(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 4:
      if fieldTypeId == thrift.I64 {
        if err := p.ReadField4(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdateByTypesArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(UCCellsPlain, size)
  p.Plain =  tMap
  for i := 0; i < size; i ++ {
var _key307 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key307 = v
}
    _, size, err := iprot.ReadListBegin(ctx)
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make(UCellsPlain, 0, size)
    _val308 :=  tSlice
    for i := 0; i < size; i ++ {
      _elem309 := &UCellPlain{}
      if err := _elem309.Read(ctx, iprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem309), err)
      }
      _val308 = append(_val308, _elem309)
    }
    if err := iprot.ReadListEnd(ctx); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Plain[_key307] = _val308
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ServiceUpdateByTypesArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(UCCellsCounter, size)
  p.Counter =  tMap
  for i := 0; i < size; i ++ {
var _key310 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key310 = v
}
    _, size, err := iprot.ReadListBegin(ctx)
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make(UCellsCounter, 0, size)
    _val311 :=  tSlice
    for i := 0; i < size; i ++ {
      _elem312 := &UCellCounter{}
      if err := _elem312.Read(ctx, iprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem312), err)
      }
      _val311 = append(_val311, _elem312)
    }
    if err := iprot.ReadListEnd(ctx); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Counter[_key310] = _val311
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ServiceUpdateByTypesArgs)  ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(UCCellsSerial, size)
  p.Serial =  tMap
  for i := 0; i < size; i ++ {
var _key313 int64
    if v, err := iprot.ReadI64(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key313 = v
}
    _, size, err := iprot.ReadListBegin(ctx)
    if err != nil {
      return thrift.PrependError("error reading list begin: ", err)
    }
    tSlice := make(UCellsSerial, 0, size)
    _val314 :=  tSlice
    for i := 0; i < size; i ++ {
      _elem315 := &UCellSerial{}
      if err := _elem315.Read(ctx, iprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem315), err)
      }
      _val314 = append(_val314, _elem315)
    }
    if err := iprot.ReadListEnd(ctx); err != nil {
      return thrift.PrependError("error reading list end: ", err)
    }
    p.Serial[_key313] = _val314
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ServiceUpdateByTypesArgs)  ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI64(ctx); err != nil {
  return thrift.PrependError("error reading field 4: ", err)
} else {
  p.UpdaterID = v
}
  return nil
}

func (p *ServiceUpdateByTypesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "update_by_types_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
    if err := p.writeField3(ctx, oprot); err != nil { return err }
    if err := p.writeField4(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdateByTypesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "plain", thrift.MAP, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:plain: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.Plain)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Plain {
    if err := oprot.WriteI64(ctx, int64(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:plain: ", p), err) }
  return err
}

func (p *ServiceUpdateByTypesArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "counter", thrift.MAP, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:counter: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.Counter)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Counter {
    if err := oprot.WriteI64(ctx, int64(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:counter: ", p), err) }
  return err
}

func (p *ServiceUpdateByTypesArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "serial", thrift.MAP, 3); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serial: ", p), err) }
  if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.Serial)); err != nil {
    return thrift.PrependError("error writing map begin: ", err)
  }
  for k, v := range p.Serial {
    if err := oprot.WriteI64(ctx, int64(k)); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range v {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
  }
  if err := oprot.WriteMapEnd(ctx); err != nil {
    return thrift.PrependError("error writing map end: ", err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serial: ", p), err) }
  return err
}

func (p *ServiceUpdateByTypesArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 4); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:updater_id: ", p), err) }
  if err := oprot.WriteI64(ctx, int64(p.UpdaterID)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.updater_id (4) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 4:updater_id: ", p), err) }
  return err
}

func (p *ServiceUpdateByTypesArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdateByTypesArgs(%+v)", *p)
}

func (p *ServiceUpdateByTypesArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdateByTypesArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdateByTypesArgs)(nil)

// Attributes:
//  - E
type ServiceUpdateByTypesResult struct {
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceUpdateByTypesResult() *ServiceUpdateByTypesResult {
  return &ServiceUpdateByTypesResult{}
}

var ServiceUpdateByTypesResult_E_DEFAULT *Exception
func (p *ServiceUpdateByTypesResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceUpdateByTypesResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceUpdateByTypesResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceUpdateByTypesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceUpdateByTypesResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceUpdateByTypesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "update_by_types_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceUpdateByTypesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceUpdateByTypesResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceUpdateByTypesResult(%+v)", *p)
}

func (p *ServiceUpdateByTypesResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceUpdateByTypesResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceUpdateByTypesResult)(nil)

// Attributes:
//  - Func: The Action Function to use
//  - Schema: The Schema for the Action
type ServiceMngColumnArgs struct {
  Func SchemaFunc `thrift:"func,1" db:"func" json:"func"`
  Schema *Schema `thrift:"schema,2" db:"schema" json:"schema"`
}

func NewServiceMngColumnArgs() *ServiceMngColumnArgs {
  return &ServiceMngColumnArgs{}
}


func (p *ServiceMngColumnArgs) GetFunc() SchemaFunc {
  return p.Func
}
var ServiceMngColumnArgs_Schema_DEFAULT *Schema
func (p *ServiceMngColumnArgs) GetSchema() *Schema {
  if !p.IsSetSchema() {
    return ServiceMngColumnArgs_Schema_DEFAULT
  }
  return p.Schema
}
func (p *ServiceMngColumnArgs) IsSetSchema() bool {
  return p.Schema != nil
}

func (p *ServiceMngColumnArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceMngColumnArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 1: ", err)
} else {
  temp := SchemaFunc(v)
  p.Func = temp
}
  return nil
}

func (p *ServiceMngColumnArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  p.Schema = &Schema{}
  if err := p.Schema.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Schema), err)
  }
  return nil
}

func (p *ServiceMngColumnArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mng_column_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceMngColumnArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "func", thrift.I32, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:func: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Func)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.func (1) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:func: ", p), err) }
  return err
}

func (p *ServiceMngColumnArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "schema", thrift.STRUCT, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:schema: ", p), err) }
  if err := p.Schema.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Schema), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:schema: ", p), err) }
  return err
}

func (p *ServiceMngColumnArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceMngColumnArgs(%+v)", *p)
}

func (p *ServiceMngColumnArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceMngColumnArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceMngColumnArgs)(nil)

// Attributes:
//  - E
type ServiceMngColumnResult struct {
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceMngColumnResult() *ServiceMngColumnResult {
  return &ServiceMngColumnResult{}
}

var ServiceMngColumnResult_E_DEFAULT *Exception
func (p *ServiceMngColumnResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceMngColumnResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceMngColumnResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceMngColumnResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceMngColumnResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceMngColumnResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "mng_column_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceMngColumnResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceMngColumnResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceMngColumnResult(%+v)", *p)
}

func (p *ServiceMngColumnResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceMngColumnResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceMngColumnResult)(nil)

// Attributes:
//  - Spec: The Schemas Specifications to match Schema for response
type ServiceListColumnsArgs struct {
  Spec *SpecSchemas `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServiceListColumnsArgs() *ServiceListColumnsArgs {
  return &ServiceListColumnsArgs{}
}

var ServiceListColumnsArgs_Spec_DEFAULT *SpecSchemas
func (p *ServiceListColumnsArgs) GetSpec() *SpecSchemas {
  if !p.IsSetSpec() {
    return ServiceListColumnsArgs_Spec_DEFAULT
  }
  return p.Spec
}
func (p *ServiceListColumnsArgs) IsSetSpec() bool {
  return p.Spec != nil
}

func (p *ServiceListColumnsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceListColumnsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Spec = &SpecSchemas{}
  if err := p.Spec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Spec), err)
  }
  return nil
}

func (p *ServiceListColumnsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "list_columns_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceListColumnsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err) }
  if err := p.Spec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Spec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err) }
  return err
}

func (p *ServiceListColumnsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceListColumnsArgs(%+v)", *p)
}

func (p *ServiceListColumnsArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceListColumnsArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceListColumnsArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceListColumnsResult struct {
  Success Schemas `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceListColumnsResult() *ServiceListColumnsResult {
  return &ServiceListColumnsResult{}
}

var ServiceListColumnsResult_Success_DEFAULT Schemas

func (p *ServiceListColumnsResult) GetSuccess() Schemas {
  return p.Success
}
var ServiceListColumnsResult_E_DEFAULT *Exception
func (p *ServiceListColumnsResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceListColumnsResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceListColumnsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceListColumnsResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceListColumnsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceListColumnsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(Schemas, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem316 := &Schema{}
    if err := _elem316.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem316), err)
    }
    p.Success = append(p.Success, _elem316)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceListColumnsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceListColumnsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "list_columns_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceListColumnsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceListColumnsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceListColumnsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceListColumnsResult(%+v)", *p)
}

func (p *ServiceListColumnsResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceListColumnsResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceListColumnsResult)(nil)

// Attributes:
//  - Spec: The Schemas Specifications to match columns to Compact
type ServiceCompactColumnsArgs struct {
  Spec *SpecSchemas `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServiceCompactColumnsArgs() *ServiceCompactColumnsArgs {
  return &ServiceCompactColumnsArgs{}
}

var ServiceCompactColumnsArgs_Spec_DEFAULT *SpecSchemas
func (p *ServiceCompactColumnsArgs) GetSpec() *SpecSchemas {
  if !p.IsSetSpec() {
    return ServiceCompactColumnsArgs_Spec_DEFAULT
  }
  return p.Spec
}
func (p *ServiceCompactColumnsArgs) IsSetSpec() bool {
  return p.Spec != nil
}

func (p *ServiceCompactColumnsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceCompactColumnsArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Spec = &SpecSchemas{}
  if err := p.Spec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Spec), err)
  }
  return nil
}

func (p *ServiceCompactColumnsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "compact_columns_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceCompactColumnsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err) }
  if err := p.Spec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Spec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err) }
  return err
}

func (p *ServiceCompactColumnsArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceCompactColumnsArgs(%+v)", *p)
}

func (p *ServiceCompactColumnsArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceCompactColumnsArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceCompactColumnsArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceCompactColumnsResult struct {
  Success CompactResults `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceCompactColumnsResult() *ServiceCompactColumnsResult {
  return &ServiceCompactColumnsResult{}
}

var ServiceCompactColumnsResult_Success_DEFAULT CompactResults

func (p *ServiceCompactColumnsResult) GetSuccess() CompactResults {
  return p.Success
}
var ServiceCompactColumnsResult_E_DEFAULT *Exception
func (p *ServiceCompactColumnsResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceCompactColumnsResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceCompactColumnsResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceCompactColumnsResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceCompactColumnsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceCompactColumnsResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(CompactResults, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem317 := &CompactResult_{}
    if err := _elem317.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem317), err)
    }
    p.Success = append(p.Success, _elem317)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceCompactColumnsResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceCompactColumnsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "compact_columns_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceCompactColumnsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceCompactColumnsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceCompactColumnsResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceCompactColumnsResult(%+v)", *p)
}

func (p *ServiceCompactColumnsResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceCompactColumnsResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceCompactColumnsResult)(nil)

// Attributes:
//  - Spec: The Scan Specifications for the scan
type ServiceScanArgs struct {
  Spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServiceScanArgs() *ServiceScanArgs {
  return &ServiceScanArgs{}
}

var ServiceScanArgs_Spec_DEFAULT *SpecScan
func (p *ServiceScanArgs) GetSpec() *SpecScan {
  if !p.IsSetSpec() {
    return ServiceScanArgs_Spec_DEFAULT
  }
  return p.Spec
}
func (p *ServiceScanArgs) IsSetSpec() bool {
  return p.Spec != nil
}

func (p *ServiceScanArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Spec = &SpecScan{}
  if err := p.Spec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Spec), err)
  }
  return nil
}

func (p *ServiceScanArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err) }
  if err := p.Spec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Spec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err) }
  return err
}

func (p *ServiceScanArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanArgs(%+v)", *p)
}

func (p *ServiceScanArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceScanResult struct {
  Success *Cells `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceScanResult() *ServiceScanResult {
  return &ServiceScanResult{}
}

var ServiceScanResult_Success_DEFAULT *Cells
func (p *ServiceScanResult) GetSuccess() *Cells {
  if !p.IsSetSuccess() {
    return ServiceScanResult_Success_DEFAULT
  }
  return p.Success
}
var ServiceScanResult_E_DEFAULT *Exception
func (p *ServiceScanResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceScanResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceScanResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceScanResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceScanResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &Cells{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ServiceScanResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceScanResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceScanResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceScanResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanResult(%+v)", *p)
}

func (p *ServiceScanResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanResult)(nil)

// Attributes:
//  - Spec: The Scan Specifications for the scan
type ServiceScanRsltOnColumnArgs struct {
  Spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServiceScanRsltOnColumnArgs() *ServiceScanRsltOnColumnArgs {
  return &ServiceScanRsltOnColumnArgs{}
}

var ServiceScanRsltOnColumnArgs_Spec_DEFAULT *SpecScan
func (p *ServiceScanRsltOnColumnArgs) GetSpec() *SpecScan {
  if !p.IsSetSpec() {
    return ServiceScanRsltOnColumnArgs_Spec_DEFAULT
  }
  return p.Spec
}
func (p *ServiceScanRsltOnColumnArgs) IsSetSpec() bool {
  return p.Spec != nil
}

func (p *ServiceScanRsltOnColumnArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanRsltOnColumnArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Spec = &SpecScan{}
  if err := p.Spec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Spec), err)
  }
  return nil
}

func (p *ServiceScanRsltOnColumnArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_column_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanRsltOnColumnArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err) }
  if err := p.Spec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Spec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err) }
  return err
}

func (p *ServiceScanRsltOnColumnArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanRsltOnColumnArgs(%+v)", *p)
}

func (p *ServiceScanRsltOnColumnArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanRsltOnColumnArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanRsltOnColumnArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceScanRsltOnColumnResult struct {
  Success CCells `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceScanRsltOnColumnResult() *ServiceScanRsltOnColumnResult {
  return &ServiceScanRsltOnColumnResult{}
}

var ServiceScanRsltOnColumnResult_Success_DEFAULT CCells

func (p *ServiceScanRsltOnColumnResult) GetSuccess() CCells {
  return p.Success
}
var ServiceScanRsltOnColumnResult_E_DEFAULT *Exception
func (p *ServiceScanRsltOnColumnResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceScanRsltOnColumnResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceScanRsltOnColumnResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceScanRsltOnColumnResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceScanRsltOnColumnResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.MAP {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanRsltOnColumnResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, _, size, err := iprot.ReadMapBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading map begin: ", err)
  }
  tMap := make(CCells, size)
  p.Success =  tMap
  for i := 0; i < size; i ++ {
var _key318 string
    if v, err := iprot.ReadString(ctx); err != nil {
    return thrift.PrependError("error reading field 0: ", err)
} else {
    _key318 = v
}
    _val319 := &CCells{}
    if err := _val319.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val319), err)
    }
    p.Success[_key318] = _val319
  }
  if err := iprot.ReadMapEnd(ctx); err != nil {
    return thrift.PrependError("error reading map end: ", err)
  }
  return nil
}

func (p *ServiceScanRsltOnColumnResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceScanRsltOnColumnResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_column_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanRsltOnColumnResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.MAP, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing map begin: ", err)
    }
    for k, v := range p.Success {
      if err := oprot.WriteString(ctx, string(k)); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err) }
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteMapEnd(ctx); err != nil {
      return thrift.PrependError("error writing map end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceScanRsltOnColumnResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceScanRsltOnColumnResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanRsltOnColumnResult(%+v)", *p)
}

func (p *ServiceScanRsltOnColumnResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanRsltOnColumnResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanRsltOnColumnResult)(nil)

// Attributes:
//  - Spec: The Scan Specifications for the scan
type ServiceScanRsltOnKeyArgs struct {
  Spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServiceScanRsltOnKeyArgs() *ServiceScanRsltOnKeyArgs {
  return &ServiceScanRsltOnKeyArgs{}
}

var ServiceScanRsltOnKeyArgs_Spec_DEFAULT *SpecScan
func (p *ServiceScanRsltOnKeyArgs) GetSpec() *SpecScan {
  if !p.IsSetSpec() {
    return ServiceScanRsltOnKeyArgs_Spec_DEFAULT
  }
  return p.Spec
}
func (p *ServiceScanRsltOnKeyArgs) IsSetSpec() bool {
  return p.Spec != nil
}

func (p *ServiceScanRsltOnKeyArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanRsltOnKeyArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Spec = &SpecScan{}
  if err := p.Spec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Spec), err)
  }
  return nil
}

func (p *ServiceScanRsltOnKeyArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_key_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanRsltOnKeyArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err) }
  if err := p.Spec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Spec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err) }
  return err
}

func (p *ServiceScanRsltOnKeyArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanRsltOnKeyArgs(%+v)", *p)
}

func (p *ServiceScanRsltOnKeyArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanRsltOnKeyArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanRsltOnKeyArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceScanRsltOnKeyResult struct {
  Success KCells `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceScanRsltOnKeyResult() *ServiceScanRsltOnKeyResult {
  return &ServiceScanRsltOnKeyResult{}
}

var ServiceScanRsltOnKeyResult_Success_DEFAULT KCells

func (p *ServiceScanRsltOnKeyResult) GetSuccess() KCells {
  return p.Success
}
var ServiceScanRsltOnKeyResult_E_DEFAULT *Exception
func (p *ServiceScanRsltOnKeyResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceScanRsltOnKeyResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceScanRsltOnKeyResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceScanRsltOnKeyResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceScanRsltOnKeyResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.LIST {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanRsltOnKeyResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  _, size, err := iprot.ReadListBegin(ctx)
  if err != nil {
    return thrift.PrependError("error reading list begin: ", err)
  }
  tSlice := make(KCells, 0, size)
  p.Success =  tSlice
  for i := 0; i < size; i ++ {
    _elem320 := &KCells{}
    if err := _elem320.Read(ctx, iprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem320), err)
    }
    p.Success = append(p.Success, _elem320)
  }
  if err := iprot.ReadListEnd(ctx); err != nil {
    return thrift.PrependError("error reading list end: ", err)
  }
  return nil
}

func (p *ServiceScanRsltOnKeyResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceScanRsltOnKeyResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_key_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanRsltOnKeyResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
      return thrift.PrependError("error writing list begin: ", err)
    }
    for _, v := range p.Success {
      if err := v.Write(ctx, oprot); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
      }
    }
    if err := oprot.WriteListEnd(ctx); err != nil {
      return thrift.PrependError("error writing list end: ", err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceScanRsltOnKeyResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceScanRsltOnKeyResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanRsltOnKeyResult(%+v)", *p)
}

func (p *ServiceScanRsltOnKeyResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanRsltOnKeyResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanRsltOnKeyResult)(nil)

// Attributes:
//  - Spec: The Scan Specifications for the scan
type ServiceScanRsltOnFractionArgs struct {
  Spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServiceScanRsltOnFractionArgs() *ServiceScanRsltOnFractionArgs {
  return &ServiceScanRsltOnFractionArgs{}
}

var ServiceScanRsltOnFractionArgs_Spec_DEFAULT *SpecScan
func (p *ServiceScanRsltOnFractionArgs) GetSpec() *SpecScan {
  if !p.IsSetSpec() {
    return ServiceScanRsltOnFractionArgs_Spec_DEFAULT
  }
  return p.Spec
}
func (p *ServiceScanRsltOnFractionArgs) IsSetSpec() bool {
  return p.Spec != nil
}

func (p *ServiceScanRsltOnFractionArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanRsltOnFractionArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Spec = &SpecScan{}
  if err := p.Spec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Spec), err)
  }
  return nil
}

func (p *ServiceScanRsltOnFractionArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_fraction_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanRsltOnFractionArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err) }
  if err := p.Spec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Spec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err) }
  return err
}

func (p *ServiceScanRsltOnFractionArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanRsltOnFractionArgs(%+v)", *p)
}

func (p *ServiceScanRsltOnFractionArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanRsltOnFractionArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanRsltOnFractionArgs)(nil)

// Attributes:
//  - Success
//  - E
type ServiceScanRsltOnFractionResult struct {
  Success *FCells `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceScanRsltOnFractionResult() *ServiceScanRsltOnFractionResult {
  return &ServiceScanRsltOnFractionResult{}
}

var ServiceScanRsltOnFractionResult_Success_DEFAULT *FCells
func (p *ServiceScanRsltOnFractionResult) GetSuccess() *FCells {
  if !p.IsSetSuccess() {
    return ServiceScanRsltOnFractionResult_Success_DEFAULT
  }
  return p.Success
}
var ServiceScanRsltOnFractionResult_E_DEFAULT *Exception
func (p *ServiceScanRsltOnFractionResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceScanRsltOnFractionResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceScanRsltOnFractionResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceScanRsltOnFractionResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceScanRsltOnFractionResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanRsltOnFractionResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &FCells{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ServiceScanRsltOnFractionResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceScanRsltOnFractionResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_fraction_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanRsltOnFractionResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceScanRsltOnFractionResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceScanRsltOnFractionResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanRsltOnFractionResult(%+v)", *p)
}

func (p *ServiceScanRsltOnFractionResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanRsltOnFractionResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanRsltOnFractionResult)(nil)

// Attributes:
//  - Spec: The Scan Specifications for the scan
//  - Rslt: The Type of Cells Result for the response
type ServiceScanRsltOnArgs struct {
  Spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
  Rslt CellsResult_ `thrift:"rslt,2" db:"rslt" json:"rslt"`
}

func NewServiceScanRsltOnArgs() *ServiceScanRsltOnArgs {
  return &ServiceScanRsltOnArgs{}
}

var ServiceScanRsltOnArgs_Spec_DEFAULT *SpecScan
func (p *ServiceScanRsltOnArgs) GetSpec() *SpecScan {
  if !p.IsSetSpec() {
    return ServiceScanRsltOnArgs_Spec_DEFAULT
  }
  return p.Spec
}

func (p *ServiceScanRsltOnArgs) GetRslt() CellsResult_ {
  return p.Rslt
}
func (p *ServiceScanRsltOnArgs) IsSetSpec() bool {
  return p.Spec != nil
}

func (p *ServiceScanRsltOnArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 2:
      if fieldTypeId == thrift.I32 {
        if err := p.ReadField2(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanRsltOnArgs)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.Spec = &SpecScan{}
  if err := p.Spec.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Spec), err)
  }
  return nil
}

func (p *ServiceScanRsltOnArgs)  ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
  if v, err := iprot.ReadI32(ctx); err != nil {
  return thrift.PrependError("error reading field 2: ", err)
} else {
  temp := CellsResult_(v)
  p.Rslt = temp
}
  return nil
}

func (p *ServiceScanRsltOnArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_args"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField1(ctx, oprot); err != nil { return err }
    if err := p.writeField2(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanRsltOnArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err) }
  if err := p.Spec.Write(ctx, oprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Spec), err)
  }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err) }
  return err
}

func (p *ServiceScanRsltOnArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if err := oprot.WriteFieldBegin(ctx, "rslt", thrift.I32, 2); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rslt: ", p), err) }
  if err := oprot.WriteI32(ctx, int32(p.Rslt)); err != nil {
  return thrift.PrependError(fmt.Sprintf("%T.rslt (2) field write error: ", p), err) }
  if err := oprot.WriteFieldEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rslt: ", p), err) }
  return err
}

func (p *ServiceScanRsltOnArgs) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanRsltOnArgs(%+v)", *p)
}

func (p *ServiceScanRsltOnArgs) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanRsltOnArgs",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanRsltOnArgs)(nil)

// Attributes:
//  - Success
//  - E: The Base Exception
type ServiceScanRsltOnResult struct {
  Success *CellsGroup `thrift:"success,0" db:"success" json:"success,omitempty"`
  E *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceScanRsltOnResult() *ServiceScanRsltOnResult {
  return &ServiceScanRsltOnResult{}
}

var ServiceScanRsltOnResult_Success_DEFAULT *CellsGroup
func (p *ServiceScanRsltOnResult) GetSuccess() *CellsGroup {
  if !p.IsSetSuccess() {
    return ServiceScanRsltOnResult_Success_DEFAULT
  }
  return p.Success
}
var ServiceScanRsltOnResult_E_DEFAULT *Exception
func (p *ServiceScanRsltOnResult) GetE() *Exception {
  if !p.IsSetE() {
    return ServiceScanRsltOnResult_E_DEFAULT
  }
  return p.E
}
func (p *ServiceScanRsltOnResult) IsSetSuccess() bool {
  return p.Success != nil
}

func (p *ServiceScanRsltOnResult) IsSetE() bool {
  return p.E != nil
}

func (p *ServiceScanRsltOnResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
  if _, err := iprot.ReadStructBegin(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
  }


  for {
    _, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
    if err != nil {
      return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
    }
    if fieldTypeId == thrift.STOP { break; }
    switch fieldId {
    case 0:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField0(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    case 1:
      if fieldTypeId == thrift.STRUCT {
        if err := p.ReadField1(ctx, iprot); err != nil {
          return err
        }
      } else {
        if err := iprot.Skip(ctx, fieldTypeId); err != nil {
          return err
        }
      }
    default:
      if err := iprot.Skip(ctx, fieldTypeId); err != nil {
        return err
      }
    }
    if err := iprot.ReadFieldEnd(ctx); err != nil {
      return err
    }
  }
  if err := iprot.ReadStructEnd(ctx); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
  }
  return nil
}

func (p *ServiceScanRsltOnResult)  ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
  p.Success = &CellsGroup{}
  if err := p.Success.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
  }
  return nil
}

func (p *ServiceScanRsltOnResult)  ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
  p.E = &Exception{}
  if err := p.E.Read(ctx, iprot); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.E), err)
  }
  return nil
}

func (p *ServiceScanRsltOnResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
  if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_result"); err != nil {
    return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err) }
  if p != nil {
    if err := p.writeField0(ctx, oprot); err != nil { return err }
    if err := p.writeField1(ctx, oprot); err != nil { return err }
  }
  if err := oprot.WriteFieldStop(ctx); err != nil {
    return thrift.PrependError("write field stop error: ", err) }
  if err := oprot.WriteStructEnd(ctx); err != nil {
    return thrift.PrependError("write struct stop error: ", err) }
  return nil
}

func (p *ServiceScanRsltOnResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetSuccess() {
    if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err) }
    if err := p.Success.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err) }
  }
  return err
}

func (p *ServiceScanRsltOnResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
  if p.IsSetE() {
    if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err) }
    if err := p.E.Write(ctx, oprot); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.E), err)
    }
    if err := oprot.WriteFieldEnd(ctx); err != nil {
      return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err) }
  }
  return err
}

func (p *ServiceScanRsltOnResult) String() string {
  if p == nil {
    return "<nil>"
  }
  return fmt.Sprintf("ServiceScanRsltOnResult(%+v)", *p)
}

func (p *ServiceScanRsltOnResult) LogValue() slog.Value {
  if p == nil {
    return slog.AnyValue(nil)
  }
  v := thrift.SlogTStructWrapper{
    Type: "*swcdb_thrift.ServiceScanRsltOnResult",
    Value: p,
  }
  return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ServiceScanRsltOnResult)(nil)


