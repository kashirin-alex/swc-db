// Code generated by Thrift Compiler (0.21.0). DO NOT EDIT.

package swcdb_thrift

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"log/slog"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"strings"
	"regexp"
)

// (needed to ensure safety because of naive import list construction.)
var _ = bytes.Equal
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = slog.Log
var _ = time.Now
var _ = thrift.ZERO
// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

//Column Key Sequences
type KeySeq int64
const (
	KeySeq_UNKNOWN KeySeq = 0
	KeySeq_LEXIC KeySeq = 1
	KeySeq_VOLUME KeySeq = 2
	KeySeq_FC_LEXIC KeySeq = 3
	KeySeq_FC_VOLUME KeySeq = 4
)

func (p KeySeq) String() string {
	switch p {
	case KeySeq_UNKNOWN: return "UNKNOWN"
	case KeySeq_LEXIC: return "LEXIC"
	case KeySeq_VOLUME: return "VOLUME"
	case KeySeq_FC_LEXIC: return "FC_LEXIC"
	case KeySeq_FC_VOLUME: return "FC_VOLUME"
	}
	return "<UNSET>"
}

func KeySeqFromString(s string) (KeySeq, error) {
	switch s {
	case "UNKNOWN": return KeySeq_UNKNOWN, nil
	case "LEXIC": return KeySeq_LEXIC, nil
	case "VOLUME": return KeySeq_VOLUME, nil
	case "FC_LEXIC": return KeySeq_FC_LEXIC, nil
	case "FC_VOLUME": return KeySeq_FC_VOLUME, nil
	}
	return KeySeq(0), fmt.Errorf("not a valid KeySeq string")
}


func KeySeqPtr(v KeySeq) *KeySeq { return &v }

func (p KeySeq) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *KeySeq) UnmarshalText(text []byte) error {
	q, err := KeySeqFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *KeySeq) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = KeySeq(v)
	return nil
}

func (p *KeySeq) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//Column Value Types
type ColumnType int64
const (
	ColumnType_UNKNOWN ColumnType = 0
	ColumnType_PLAIN ColumnType = 1
	ColumnType_COUNTER_I64 ColumnType = 2
	ColumnType_COUNTER_I32 ColumnType = 3
	ColumnType_COUNTER_I16 ColumnType = 4
	ColumnType_COUNTER_I8 ColumnType = 5
	ColumnType_SERIAL ColumnType = 6
	ColumnType_CELL_DEFINED ColumnType = 15
)

func (p ColumnType) String() string {
	switch p {
	case ColumnType_UNKNOWN: return "UNKNOWN"
	case ColumnType_PLAIN: return "PLAIN"
	case ColumnType_COUNTER_I64: return "COUNTER_I64"
	case ColumnType_COUNTER_I32: return "COUNTER_I32"
	case ColumnType_COUNTER_I16: return "COUNTER_I16"
	case ColumnType_COUNTER_I8: return "COUNTER_I8"
	case ColumnType_SERIAL: return "SERIAL"
	case ColumnType_CELL_DEFINED: return "CELL_DEFINED"
	}
	return "<UNSET>"
}

func ColumnTypeFromString(s string) (ColumnType, error) {
	switch s {
	case "UNKNOWN": return ColumnType_UNKNOWN, nil
	case "PLAIN": return ColumnType_PLAIN, nil
	case "COUNTER_I64": return ColumnType_COUNTER_I64, nil
	case "COUNTER_I32": return ColumnType_COUNTER_I32, nil
	case "COUNTER_I16": return ColumnType_COUNTER_I16, nil
	case "COUNTER_I8": return ColumnType_COUNTER_I8, nil
	case "SERIAL": return ColumnType_SERIAL, nil
	case "CELL_DEFINED": return ColumnType_CELL_DEFINED, nil
	}
	return ColumnType(0), fmt.Errorf("not a valid ColumnType string")
}


func ColumnTypePtr(v ColumnType) *ColumnType { return &v }

func (p ColumnType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *ColumnType) UnmarshalText(text []byte) error {
	q, err := ColumnTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *ColumnType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = ColumnType(v)
	return nil
}

func (p *ColumnType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//Data Encoding Types
type EncodingType int64
const (
	EncodingType_DEFAULT EncodingType = 0
	EncodingType_PLAIN EncodingType = 1
	EncodingType_ZLIB EncodingType = 2
	EncodingType_SNAPPY EncodingType = 3
	EncodingType_ZSTD EncodingType = 4
	EncodingType_UNKNOWN EncodingType = 255
)

func (p EncodingType) String() string {
	switch p {
	case EncodingType_DEFAULT: return "DEFAULT"
	case EncodingType_PLAIN: return "PLAIN"
	case EncodingType_ZLIB: return "ZLIB"
	case EncodingType_SNAPPY: return "SNAPPY"
	case EncodingType_ZSTD: return "ZSTD"
	case EncodingType_UNKNOWN: return "UNKNOWN"
	}
	return "<UNSET>"
}

func EncodingTypeFromString(s string) (EncodingType, error) {
	switch s {
	case "DEFAULT": return EncodingType_DEFAULT, nil
	case "PLAIN": return EncodingType_PLAIN, nil
	case "ZLIB": return EncodingType_ZLIB, nil
	case "SNAPPY": return EncodingType_SNAPPY, nil
	case "ZSTD": return EncodingType_ZSTD, nil
	case "UNKNOWN": return EncodingType_UNKNOWN, nil
	}
	return EncodingType(0), fmt.Errorf("not a valid EncodingType string")
}


func EncodingTypePtr(v EncodingType) *EncodingType { return &v }

func (p EncodingType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *EncodingType) UnmarshalText(text []byte) error {
	q, err := EncodingTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *EncodingType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = EncodingType(v)
	return nil
}

func (p *EncodingType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//Manage Columns schema function Flags
type SchemaFunc int64
const (
	SchemaFunc_CREATE SchemaFunc = 3
	SchemaFunc_REMOVE SchemaFunc = 5
	SchemaFunc_MODIFY SchemaFunc = 7
)

func (p SchemaFunc) String() string {
	switch p {
	case SchemaFunc_CREATE: return "CREATE"
	case SchemaFunc_REMOVE: return "REMOVE"
	case SchemaFunc_MODIFY: return "MODIFY"
	}
	return "<UNSET>"
}

func SchemaFuncFromString(s string) (SchemaFunc, error) {
	switch s {
	case "CREATE": return SchemaFunc_CREATE, nil
	case "REMOVE": return SchemaFunc_REMOVE, nil
	case "MODIFY": return SchemaFunc_MODIFY, nil
	}
	return SchemaFunc(0), fmt.Errorf("not a valid SchemaFunc string")
}


func SchemaFuncPtr(v SchemaFunc) *SchemaFunc { return &v }

func (p SchemaFunc) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *SchemaFunc) UnmarshalText(text []byte) error {
	q, err := SchemaFuncFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *SchemaFunc) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = SchemaFunc(v)
	return nil
}

func (p *SchemaFunc) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//The available logical Comparators, plus extended logic options applied with 'v' for VOLUME
type Comp int64
const (
	Comp_NONE Comp = 0
	Comp_PF Comp = 1
	Comp_GT Comp = 2
	Comp_GE Comp = 3
	Comp_EQ Comp = 4
	Comp_LE Comp = 5
	Comp_LT Comp = 6
	Comp_NE Comp = 7
	Comp_RE Comp = 8
	Comp_VGT Comp = 9
	Comp_VGE Comp = 10
	Comp_VLE Comp = 11
	Comp_VLT Comp = 12
	Comp_SBS Comp = 13
	Comp_SPS Comp = 14
	Comp_POSBS Comp = 15
	Comp_POSPS Comp = 16
	Comp_FOSBS Comp = 17
	Comp_FOSPS Comp = 18
	Comp_FIP Comp = 19
	Comp_FI Comp = 20
	Comp_OR Comp = 21
)

func (p Comp) String() string {
	switch p {
	case Comp_NONE: return "NONE"
	case Comp_PF: return "PF"
	case Comp_GT: return "GT"
	case Comp_GE: return "GE"
	case Comp_EQ: return "EQ"
	case Comp_LE: return "LE"
	case Comp_LT: return "LT"
	case Comp_NE: return "NE"
	case Comp_RE: return "RE"
	case Comp_VGT: return "VGT"
	case Comp_VGE: return "VGE"
	case Comp_VLE: return "VLE"
	case Comp_VLT: return "VLT"
	case Comp_SBS: return "SBS"
	case Comp_SPS: return "SPS"
	case Comp_POSBS: return "POSBS"
	case Comp_POSPS: return "POSPS"
	case Comp_FOSBS: return "FOSBS"
	case Comp_FOSPS: return "FOSPS"
	case Comp_FIP: return "FIP"
	case Comp_FI: return "FI"
	case Comp_OR: return "OR"
	}
	return "<UNSET>"
}

func CompFromString(s string) (Comp, error) {
	switch s {
	case "NONE": return Comp_NONE, nil
	case "PF": return Comp_PF, nil
	case "GT": return Comp_GT, nil
	case "GE": return Comp_GE, nil
	case "EQ": return Comp_EQ, nil
	case "LE": return Comp_LE, nil
	case "LT": return Comp_LT, nil
	case "NE": return Comp_NE, nil
	case "RE": return Comp_RE, nil
	case "VGT": return Comp_VGT, nil
	case "VGE": return Comp_VGE, nil
	case "VLE": return Comp_VLE, nil
	case "VLT": return Comp_VLT, nil
	case "SBS": return Comp_SBS, nil
	case "SPS": return Comp_SPS, nil
	case "POSBS": return Comp_POSBS, nil
	case "POSPS": return Comp_POSPS, nil
	case "FOSBS": return Comp_FOSBS, nil
	case "FOSPS": return Comp_FOSPS, nil
	case "FIP": return Comp_FIP, nil
	case "FI": return Comp_FI, nil
	case "OR": return Comp_OR, nil
	}
	return Comp(0), fmt.Errorf("not a valid Comp string")
}


func CompPtr(v Comp) *Comp { return &v }

func (p Comp) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *Comp) UnmarshalText(text []byte) error {
	q, err := CompFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *Comp) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = Comp(v)
	return nil
}

func (p *Comp) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//The Scan options Flags Specifications for the SpecFlags 'options' bit
type SpecFlagsOpt int64
const (
	SpecFlagsOpt_NONE SpecFlagsOpt = 0
	SpecFlagsOpt_LIMIT_BY_KEYS SpecFlagsOpt = 1
	SpecFlagsOpt_OFFSET_BY_KEYS SpecFlagsOpt = 4
	SpecFlagsOpt_ONLY_KEYS SpecFlagsOpt = 8
	SpecFlagsOpt_ONLY_DELETES SpecFlagsOpt = 10
)

func (p SpecFlagsOpt) String() string {
	switch p {
	case SpecFlagsOpt_NONE: return "NONE"
	case SpecFlagsOpt_LIMIT_BY_KEYS: return "LIMIT_BY_KEYS"
	case SpecFlagsOpt_OFFSET_BY_KEYS: return "OFFSET_BY_KEYS"
	case SpecFlagsOpt_ONLY_KEYS: return "ONLY_KEYS"
	case SpecFlagsOpt_ONLY_DELETES: return "ONLY_DELETES"
	}
	return "<UNSET>"
}

func SpecFlagsOptFromString(s string) (SpecFlagsOpt, error) {
	switch s {
	case "NONE": return SpecFlagsOpt_NONE, nil
	case "LIMIT_BY_KEYS": return SpecFlagsOpt_LIMIT_BY_KEYS, nil
	case "OFFSET_BY_KEYS": return SpecFlagsOpt_OFFSET_BY_KEYS, nil
	case "ONLY_KEYS": return SpecFlagsOpt_ONLY_KEYS, nil
	case "ONLY_DELETES": return SpecFlagsOpt_ONLY_DELETES, nil
	}
	return SpecFlagsOpt(0), fmt.Errorf("not a valid SpecFlagsOpt string")
}


func SpecFlagsOptPtr(v SpecFlagsOpt) *SpecFlagsOpt { return &v }

func (p SpecFlagsOpt) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *SpecFlagsOpt) UnmarshalText(text []byte) error {
	q, err := SpecFlagsOptFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *SpecFlagsOpt) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = SpecFlagsOpt(v)
	return nil
}

func (p *SpecFlagsOpt) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type UpdateOP int64
const (
	UpdateOP_REPLACE UpdateOP = 0
	UpdateOP_APPEND UpdateOP = 1
	UpdateOP_PREPEND UpdateOP = 2
	UpdateOP_INSERT UpdateOP = 3
	UpdateOP_OVERWRITE UpdateOP = 4
	UpdateOP_SERIAL UpdateOP = 5
)

func (p UpdateOP) String() string {
	switch p {
	case UpdateOP_REPLACE: return "REPLACE"
	case UpdateOP_APPEND: return "APPEND"
	case UpdateOP_PREPEND: return "PREPEND"
	case UpdateOP_INSERT: return "INSERT"
	case UpdateOP_OVERWRITE: return "OVERWRITE"
	case UpdateOP_SERIAL: return "SERIAL"
	}
	return "<UNSET>"
}

func UpdateOPFromString(s string) (UpdateOP, error) {
	switch s {
	case "REPLACE": return UpdateOP_REPLACE, nil
	case "APPEND": return UpdateOP_APPEND, nil
	case "PREPEND": return UpdateOP_PREPEND, nil
	case "INSERT": return UpdateOP_INSERT, nil
	case "OVERWRITE": return UpdateOP_OVERWRITE, nil
	case "SERIAL": return UpdateOP_SERIAL, nil
	}
	return UpdateOP(0), fmt.Errorf("not a valid UpdateOP string")
}


func UpdateOPPtr(v UpdateOP) *UpdateOP { return &v }

func (p UpdateOP) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *UpdateOP) UnmarshalText(text []byte) error {
	q, err := UpdateOPFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *UpdateOP) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = UpdateOP(v)
	return nil
}

func (p *UpdateOP) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//The Scan Interval Specs Options for the SpecIntervalPlain, SpecIntervalCounter and SpecIntervalSerial 'options' bit
type SpecIntervalOptions int64
const (
	SpecIntervalOptions_UPDATING SpecIntervalOptions = 4
	SpecIntervalOptions_DELETING SpecIntervalOptions = 8
)

func (p SpecIntervalOptions) String() string {
	switch p {
	case SpecIntervalOptions_UPDATING: return "UPDATING"
	case SpecIntervalOptions_DELETING: return "DELETING"
	}
	return "<UNSET>"
}

func SpecIntervalOptionsFromString(s string) (SpecIntervalOptions, error) {
	switch s {
	case "UPDATING": return SpecIntervalOptions_UPDATING, nil
	case "DELETING": return SpecIntervalOptions_DELETING, nil
	}
	return SpecIntervalOptions(0), fmt.Errorf("not a valid SpecIntervalOptions string")
}


func SpecIntervalOptionsPtr(v SpecIntervalOptions) *SpecIntervalOptions { return &v }

func (p SpecIntervalOptions) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *SpecIntervalOptions) UnmarshalText(text []byte) error {
	q, err := SpecIntervalOptionsFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *SpecIntervalOptions) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = SpecIntervalOptions(v)
	return nil
}

func (p *SpecIntervalOptions) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//The Cell Flag
type Flag int64
const (
	Flag_NONE Flag = 0
	Flag_INSERT Flag = 1
	Flag_DELETE_LE Flag = 2
	Flag_DELETE_EQ Flag = 3
)

func (p Flag) String() string {
	switch p {
	case Flag_NONE: return "NONE"
	case Flag_INSERT: return "INSERT"
	case Flag_DELETE_LE: return "DELETE_LE"
	case Flag_DELETE_EQ: return "DELETE_EQ"
	}
	return "<UNSET>"
}

func FlagFromString(s string) (Flag, error) {
	switch s {
	case "NONE": return Flag_NONE, nil
	case "INSERT": return Flag_INSERT, nil
	case "DELETE_LE": return Flag_DELETE_LE, nil
	case "DELETE_EQ": return Flag_DELETE_EQ, nil
	}
	return Flag(0), fmt.Errorf("not a valid Flag string")
}


func FlagPtr(v Flag) *Flag { return &v }

func (p Flag) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *Flag) UnmarshalText(text []byte) error {
	q, err := FlagFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *Flag) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = Flag(v)
	return nil
}

func (p *Flag) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//MATH Operations for Serial Field Update of types INT64 and DOUBLE
type FU_MATH_OP int64
const (
	FU_MATH_OP_EQUAL FU_MATH_OP = 0
	FU_MATH_OP_PLUS FU_MATH_OP = 1
	FU_MATH_OP_MULTIPLY FU_MATH_OP = 2
	FU_MATH_OP_DIVIDE FU_MATH_OP = 3
)

func (p FU_MATH_OP) String() string {
	switch p {
	case FU_MATH_OP_EQUAL: return "EQUAL"
	case FU_MATH_OP_PLUS: return "PLUS"
	case FU_MATH_OP_MULTIPLY: return "MULTIPLY"
	case FU_MATH_OP_DIVIDE: return "DIVIDE"
	}
	return "<UNSET>"
}

func FU_MATH_OPFromString(s string) (FU_MATH_OP, error) {
	switch s {
	case "EQUAL": return FU_MATH_OP_EQUAL, nil
	case "PLUS": return FU_MATH_OP_PLUS, nil
	case "MULTIPLY": return FU_MATH_OP_MULTIPLY, nil
	case "DIVIDE": return FU_MATH_OP_DIVIDE, nil
	}
	return FU_MATH_OP(0), fmt.Errorf("not a valid FU_MATH_OP string")
}


func FU_MATH_OPPtr(v FU_MATH_OP) *FU_MATH_OP { return &v }

func (p FU_MATH_OP) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *FU_MATH_OP) UnmarshalText(text []byte) error {
	q, err := FU_MATH_OPFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *FU_MATH_OP) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = FU_MATH_OP(v)
	return nil
}

func (p *FU_MATH_OP) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//LIST Operations for Serial Field Update of array/list/bytes with LIST-op in the inner SERIAL fields
type FU_LIST_OP int64
const (
	FU_LIST_OP_REPLACE FU_LIST_OP = 0
	FU_LIST_OP_APPEND FU_LIST_OP = 1
	FU_LIST_OP_PREPEND FU_LIST_OP = 2
	FU_LIST_OP_INSERT FU_LIST_OP = 3
	FU_LIST_OP_OVERWRITE FU_LIST_OP = 4
	FU_LIST_OP_ERASE FU_LIST_OP = 5
	FU_LIST_OP_BY_UNIQUE FU_LIST_OP = 6
	FU_LIST_OP_BY_COND FU_LIST_OP = 7
	FU_LIST_OP_BY_INDEX FU_LIST_OP = 8
)

func (p FU_LIST_OP) String() string {
	switch p {
	case FU_LIST_OP_REPLACE: return "REPLACE"
	case FU_LIST_OP_APPEND: return "APPEND"
	case FU_LIST_OP_PREPEND: return "PREPEND"
	case FU_LIST_OP_INSERT: return "INSERT"
	case FU_LIST_OP_OVERWRITE: return "OVERWRITE"
	case FU_LIST_OP_ERASE: return "ERASE"
	case FU_LIST_OP_BY_UNIQUE: return "BY_UNIQUE"
	case FU_LIST_OP_BY_COND: return "BY_COND"
	case FU_LIST_OP_BY_INDEX: return "BY_INDEX"
	}
	return "<UNSET>"
}

func FU_LIST_OPFromString(s string) (FU_LIST_OP, error) {
	switch s {
	case "REPLACE": return FU_LIST_OP_REPLACE, nil
	case "APPEND": return FU_LIST_OP_APPEND, nil
	case "PREPEND": return FU_LIST_OP_PREPEND, nil
	case "INSERT": return FU_LIST_OP_INSERT, nil
	case "OVERWRITE": return FU_LIST_OP_OVERWRITE, nil
	case "ERASE": return FU_LIST_OP_ERASE, nil
	case "BY_UNIQUE": return FU_LIST_OP_BY_UNIQUE, nil
	case "BY_COND": return FU_LIST_OP_BY_COND, nil
	case "BY_INDEX": return FU_LIST_OP_BY_INDEX, nil
	}
	return FU_LIST_OP(0), fmt.Errorf("not a valid FU_LIST_OP string")
}


func FU_LIST_OPPtr(v FU_LIST_OP) *FU_LIST_OP { return &v }

func (p FU_LIST_OP) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *FU_LIST_OP) UnmarshalText(text []byte) error {
	q, err := FU_LIST_OPFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *FU_LIST_OP) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = FU_LIST_OP(v)
	return nil
}

func (p *FU_LIST_OP) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//The Cells Results types for using with CellsGroup requests
type CellsResult_ int64
const (
	CellsResult__IN_LIST CellsResult_ = 0
	CellsResult__ON_COLUMN CellsResult_ = 1
	CellsResult__ON_KEY CellsResult_ = 2
	CellsResult__ON_FRACTION CellsResult_ = 3
)

func (p CellsResult_) String() string {
	switch p {
	case CellsResult__IN_LIST: return "IN_LIST"
	case CellsResult__ON_COLUMN: return "ON_COLUMN"
	case CellsResult__ON_KEY: return "ON_KEY"
	case CellsResult__ON_FRACTION: return "ON_FRACTION"
	}
	return "<UNSET>"
}

func CellsResult_FromString(s string) (CellsResult_, error) {
	switch s {
	case "IN_LIST": return CellsResult__IN_LIST, nil
	case "ON_COLUMN": return CellsResult__ON_COLUMN, nil
	case "ON_KEY": return CellsResult__ON_KEY, nil
	case "ON_FRACTION": return CellsResult__ON_FRACTION, nil
	}
	return CellsResult_(0), fmt.Errorf("not a valid CellsResult_ string")
}


func CellsResult_Ptr(v CellsResult_) *CellsResult_ { return &v }

func (p CellsResult_) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *CellsResult_) UnmarshalText(text []byte) error {
	q, err := CellsResult_FromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *CellsResult_) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = CellsResult_(v)
	return nil
}

func (p *CellsResult_) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

//A list-container of Schemas
type Schemas []*Schema

func SchemasPtr(v Schemas) *Schemas { return &v }

//A Cell Key defined as binary(bytes) items in a list-container
type Key [][]byte

func KeyPtr(v Key) *Key { return &v }

//The Serial Cell Value Specifications defined as SpecValueSerialField items in a list-container
type SpecValueSerialFields []*SpecValueSerialField

func SpecValueSerialFieldsPtr(v SpecValueSerialFields) *SpecValueSerialFields { return &v }

//The Cell Value Specifications defined as SpecValuePlain items in a list-container
type SpecValuesPlain []*SpecValuePlain

func SpecValuesPlainPtr(v SpecValuesPlain) *SpecValuesPlain { return &v }

//The Cell Value Specifications defined as SpecValueCounter items in a list-container
type SpecValuesCounter []*SpecValueCounter

func SpecValuesCounterPtr(v SpecValuesCounter) *SpecValuesCounter { return &v }

//The Cell Value Specifications defined as SpecValueSerial items in a list-container
type SpecValuesSerial []*SpecValueSerial

func SpecValuesSerialPtr(v SpecValuesSerial) *SpecValuesSerial { return &v }

//The Key Specifications defined as SpecFraction items in a list-container
type SpecKey []*SpecFraction

func SpecKeyPtr(v SpecKey) *SpecKey { return &v }

//The Key Intervals Specifications defined as SpecKeyInterval items in a list-container
type SpecKeyIntervals []*SpecKeyInterval

func SpecKeyIntervalsPtr(v SpecKeyIntervals) *SpecKeyIntervals { return &v }

//The Cells for Update defined as UCellPlain items in a list-container
type UCellsPlain []*UCellPlain

func UCellsPlainPtr(v UCellsPlain) *UCellsPlain { return &v }

//The Cells for Update for a Column Id defined as UCellsPlain items in a map-container by CID
type UCCellsPlain map[int64]UCellsPlain

func UCCellsPlainPtr(v UCCellsPlain) *UCCellsPlain { return &v }

//The Cells for Update defined as UCellCounter items in a list-container
type UCellsCounter []*UCellCounter

func UCellsCounterPtr(v UCellsCounter) *UCellsCounter { return &v }

//The Cells for Update for a Column Id defined as UCellsCounter items in a map-container by CID
type UCCellsCounter map[int64]UCellsCounter

func UCCellsCounterPtr(v UCCellsCounter) *UCCellsCounter { return &v }

//The Serial Cell Value Fields defined as CellValueSerial items in a list-container
type CellValuesSerial []*CellValueSerial

func CellValuesSerialPtr(v CellValuesSerial) *CellValuesSerial { return &v }

//The Serial Cell Value Fields defined as CellValueSerialOp items in a list-container
type CellValuesSerialOp []*CellValueSerialOp

func CellValuesSerialOpPtr(v CellValuesSerialOp) *CellValuesSerialOp { return &v }

//The Cells for Update defined as UCellSerial items in a list-container
type UCellsSerial []*UCellSerial

func UCellsSerialPtr(v UCellsSerial) *UCellsSerial { return &v }

//The Cells for Update for a Column Id defined as UCellsSerial items in a map-container by CID
type UCCellsSerial map[int64]UCellsSerial

func UCCellsSerialPtr(v UCCellsSerial) *UCCellsSerial { return &v }

//A list-container of Plain Cells
type CellsPlain []*CellPlain

func CellsPlainPtr(v CellsPlain) *CellsPlain { return &v }

//A list-container of Counter Cells
type CellsCounter []*CellCounter

func CellsCounterPtr(v CellsCounter) *CellsCounter { return &v }

//A list-container of Serial Cells
type CellsSerial []*CellSerial

func CellsSerialPtr(v CellsSerial) *CellsSerial { return &v }

//The Columns Cells for results on Columns of scan, defined as cCells items in a map-container by Column Name
type CCells map[string]*cCells

func CCellsPtr(v CCells) *CCells { return &v }

//The Keys Cells for results on Key of scan, defined as kCells items in a list-container
type KCells []*kCells

func KCellsPtr(v KCells) *KCells { return &v }

//The Compact Results, defined as CompactResult items in a list-container
type CompactResults []*CompactResult_

func CompactResultsPtr(v CompactResults) *CompactResults { return &v }

// The SWC::Thrift::Exception a base for any Exceptions
// both for the Thrift-Protocol and SWC-DB Errors.
// 
// Attributes:
//  - code: The corresponding Thrift-Procotol or SWC-DB Error Code
//  - message: The message describing the error code
// 
type Exception struct {
	code int32 `thrift:"code,1" db:"code" json:"code"`
	message string `thrift:"message,2" db:"message" json:"message"`
}

func NewException() *Exception {
	return &Exception{}
}



func (p *Exception) Getcode() int32 {
	return p.code
}



func (p *Exception) Getmessage() string {
	return p.message
}

func (p *Exception) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Exception) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.code = v
	}
	return nil
}

func (p *Exception) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.message = v
	}
	return nil
}

func (p *Exception) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Exception"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Exception) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "code", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:code: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.code)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.code (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:code: ", p), err)
	}
	return err
}

func (p *Exception) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err)
	}
	return err
}

func (p *Exception) Equals(other *Exception) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.code != other.code { return false }
	if p.message != other.message { return false }
	return true
}

func (p *Exception) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Exception(%+v)", *p)
}

func (p *Exception) Error() string {
	return p.String()
}

func (Exception) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*Exception)(nil)

func (p *Exception) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Exception",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Exception)(nil)

func (p *Exception) Validate() error {
	return nil
}

// The Schema Definition
// 
// Attributes:
//  - cid: Column ID
//  - col_name: Column Name
//  - col_tags: Column Tags
//  - col_seq: Column Key Sequence
//  - col_type: Column Type
//  - cell_versions: Cell Versions
//  - cell_ttl: Cell Time to Live
//  - blk_encoding: Block Encoding
//  - blk_size: Block Size in Bytes
//  - blk_cells: Number of Cells in Block
//  - cs_replication: CellStore file Replication
//  - cs_size: CellStore Size in Bytes
//  - cs_max: Max CellStores in a Range
//  - log_rollout_ratio: Write Fragment File on ratio reached
//  - log_compact_cointervaling: Min. Cointervaling Fragments for Compaction
//  - log_fragment_preload: Number of Fragment to Preload
//  - compact_percent: Compact at percent reach
//  - revision: Schema's revision/id
// 
type Schema struct {
	cid *int64 `thrift:"cid,1" db:"cid" json:"cid,omitempty"`
	col_name *string `thrift:"col_name,2" db:"col_name" json:"col_name,omitempty"`
	col_tags []string `thrift:"col_tags,3" db:"col_tags" json:"col_tags"`
	col_seq *KeySeq `thrift:"col_seq,4" db:"col_seq" json:"col_seq,omitempty"`
	col_type *ColumnType `thrift:"col_type,5" db:"col_type" json:"col_type,omitempty"`
	cell_versions *int32 `thrift:"cell_versions,6" db:"cell_versions" json:"cell_versions,omitempty"`
	cell_ttl *int32 `thrift:"cell_ttl,7" db:"cell_ttl" json:"cell_ttl,omitempty"`
	blk_encoding *EncodingType `thrift:"blk_encoding,8" db:"blk_encoding" json:"blk_encoding,omitempty"`
	blk_size *int32 `thrift:"blk_size,9" db:"blk_size" json:"blk_size,omitempty"`
	blk_cells *int32 `thrift:"blk_cells,10" db:"blk_cells" json:"blk_cells,omitempty"`
	cs_replication *int8 `thrift:"cs_replication,11" db:"cs_replication" json:"cs_replication,omitempty"`
	cs_size *int32 `thrift:"cs_size,12" db:"cs_size" json:"cs_size,omitempty"`
	cs_max *int8 `thrift:"cs_max,13" db:"cs_max" json:"cs_max,omitempty"`
	log_rollout_ratio *int8 `thrift:"log_rollout_ratio,14" db:"log_rollout_ratio" json:"log_rollout_ratio,omitempty"`
	log_compact_cointervaling *int8 `thrift:"log_compact_cointervaling,15" db:"log_compact_cointervaling" json:"log_compact_cointervaling,omitempty"`
	log_fragment_preload *int8 `thrift:"log_fragment_preload,16" db:"log_fragment_preload" json:"log_fragment_preload,omitempty"`
	compact_percent *int8 `thrift:"compact_percent,17" db:"compact_percent" json:"compact_percent,omitempty"`
	revision *int64 `thrift:"revision,18" db:"revision" json:"revision,omitempty"`
}

func NewSchema() *Schema {
	return &Schema{}
}

var Schema_cid_DEFAULT int64

func (p *Schema) Getcid() int64 {
	if !p.IsSetcid() {
		return Schema_cid_DEFAULT
	}
	return *p.cid
}

var Schema_col_name_DEFAULT string

func (p *Schema) Getcol_name() string {
	if !p.IsSetcol_name() {
		return Schema_col_name_DEFAULT
	}
	return *p.col_name
}



func (p *Schema) Getcol_tags() []string {
	return p.col_tags
}

var Schema_col_seq_DEFAULT KeySeq

func (p *Schema) Getcol_seq() KeySeq {
	if !p.IsSetcol_seq() {
		return Schema_col_seq_DEFAULT
	}
	return *p.col_seq
}

var Schema_col_type_DEFAULT ColumnType

func (p *Schema) Getcol_type() ColumnType {
	if !p.IsSetcol_type() {
		return Schema_col_type_DEFAULT
	}
	return *p.col_type
}

var Schema_cell_versions_DEFAULT int32

func (p *Schema) Getcell_versions() int32 {
	if !p.IsSetcell_versions() {
		return Schema_cell_versions_DEFAULT
	}
	return *p.cell_versions
}

var Schema_cell_ttl_DEFAULT int32

func (p *Schema) Getcell_ttl() int32 {
	if !p.IsSetcell_ttl() {
		return Schema_cell_ttl_DEFAULT
	}
	return *p.cell_ttl
}

var Schema_blk_encoding_DEFAULT EncodingType

func (p *Schema) Getblk_encoding() EncodingType {
	if !p.IsSetblk_encoding() {
		return Schema_blk_encoding_DEFAULT
	}
	return *p.blk_encoding
}

var Schema_blk_size_DEFAULT int32

func (p *Schema) Getblk_size() int32 {
	if !p.IsSetblk_size() {
		return Schema_blk_size_DEFAULT
	}
	return *p.blk_size
}

var Schema_blk_cells_DEFAULT int32

func (p *Schema) Getblk_cells() int32 {
	if !p.IsSetblk_cells() {
		return Schema_blk_cells_DEFAULT
	}
	return *p.blk_cells
}

var Schema_cs_replication_DEFAULT int8

func (p *Schema) Getcs_replication() int8 {
	if !p.IsSetcs_replication() {
		return Schema_cs_replication_DEFAULT
	}
	return *p.cs_replication
}

var Schema_cs_size_DEFAULT int32

func (p *Schema) Getcs_size() int32 {
	if !p.IsSetcs_size() {
		return Schema_cs_size_DEFAULT
	}
	return *p.cs_size
}

var Schema_cs_max_DEFAULT int8

func (p *Schema) Getcs_max() int8 {
	if !p.IsSetcs_max() {
		return Schema_cs_max_DEFAULT
	}
	return *p.cs_max
}

var Schema_log_rollout_ratio_DEFAULT int8

func (p *Schema) Getlog_rollout_ratio() int8 {
	if !p.IsSetlog_rollout_ratio() {
		return Schema_log_rollout_ratio_DEFAULT
	}
	return *p.log_rollout_ratio
}

var Schema_log_compact_cointervaling_DEFAULT int8

func (p *Schema) Getlog_compact_cointervaling() int8 {
	if !p.IsSetlog_compact_cointervaling() {
		return Schema_log_compact_cointervaling_DEFAULT
	}
	return *p.log_compact_cointervaling
}

var Schema_log_fragment_preload_DEFAULT int8

func (p *Schema) Getlog_fragment_preload() int8 {
	if !p.IsSetlog_fragment_preload() {
		return Schema_log_fragment_preload_DEFAULT
	}
	return *p.log_fragment_preload
}

var Schema_compact_percent_DEFAULT int8

func (p *Schema) Getcompact_percent() int8 {
	if !p.IsSetcompact_percent() {
		return Schema_compact_percent_DEFAULT
	}
	return *p.compact_percent
}

var Schema_revision_DEFAULT int64

func (p *Schema) Getrevision() int64 {
	if !p.IsSetrevision() {
		return Schema_revision_DEFAULT
	}
	return *p.revision
}

func (p *Schema) IsSetcid() bool {
	return p.cid != nil
}

func (p *Schema) IsSetcol_name() bool {
	return p.col_name != nil
}

func (p *Schema) IsSetcol_seq() bool {
	return p.col_seq != nil
}

func (p *Schema) IsSetcol_type() bool {
	return p.col_type != nil
}

func (p *Schema) IsSetcell_versions() bool {
	return p.cell_versions != nil
}

func (p *Schema) IsSetcell_ttl() bool {
	return p.cell_ttl != nil
}

func (p *Schema) IsSetblk_encoding() bool {
	return p.blk_encoding != nil
}

func (p *Schema) IsSetblk_size() bool {
	return p.blk_size != nil
}

func (p *Schema) IsSetblk_cells() bool {
	return p.blk_cells != nil
}

func (p *Schema) IsSetcs_replication() bool {
	return p.cs_replication != nil
}

func (p *Schema) IsSetcs_size() bool {
	return p.cs_size != nil
}

func (p *Schema) IsSetcs_max() bool {
	return p.cs_max != nil
}

func (p *Schema) IsSetlog_rollout_ratio() bool {
	return p.log_rollout_ratio != nil
}

func (p *Schema) IsSetlog_compact_cointervaling() bool {
	return p.log_compact_cointervaling != nil
}

func (p *Schema) IsSetlog_fragment_preload() bool {
	return p.log_fragment_preload != nil
}

func (p *Schema) IsSetcompact_percent() bool {
	return p.compact_percent != nil
}

func (p *Schema) IsSetrevision() bool {
	return p.revision != nil
}

func (p *Schema) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 12:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField12(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 13:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField13(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 14:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField14(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 15:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField15(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 16:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField16(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 17:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField17(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 18:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField18(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Schema) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.cid = &v
	}
	return nil
}

func (p *Schema) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.col_name = &v
	}
	return nil
}

func (p *Schema) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.col_tags = tSlice
	for i := 0; i < size; i++ {
		var _elem0 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem0 = v
		}
		p.col_tags = append(p.col_tags, _elem0)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Schema) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := KeySeq(v)
		p.col_seq = &temp
	}
	return nil
}

func (p *Schema) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := ColumnType(v)
		p.col_type = &temp
	}
	return nil
}

func (p *Schema) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.cell_versions = &v
	}
	return nil
}

func (p *Schema) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.cell_ttl = &v
	}
	return nil
}

func (p *Schema) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		temp := EncodingType(v)
		p.blk_encoding = &temp
	}
	return nil
}

func (p *Schema) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		p.blk_size = &v
	}
	return nil
}

func (p *Schema) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		p.blk_cells = &v
	}
	return nil
}

func (p *Schema) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		temp := int8(v)
		p.cs_replication = &temp
	}
	return nil
}

func (p *Schema) ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 12: ", err)
	} else {
		p.cs_size = &v
	}
	return nil
}

func (p *Schema) ReadField13(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 13: ", err)
	} else {
		temp := int8(v)
		p.cs_max = &temp
	}
	return nil
}

func (p *Schema) ReadField14(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 14: ", err)
	} else {
		temp := int8(v)
		p.log_rollout_ratio = &temp
	}
	return nil
}

func (p *Schema) ReadField15(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 15: ", err)
	} else {
		temp := int8(v)
		p.log_compact_cointervaling = &temp
	}
	return nil
}

func (p *Schema) ReadField16(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 16: ", err)
	} else {
		temp := int8(v)
		p.log_fragment_preload = &temp
	}
	return nil
}

func (p *Schema) ReadField17(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 17: ", err)
	} else {
		temp := int8(v)
		p.compact_percent = &temp
	}
	return nil
}

func (p *Schema) ReadField18(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 18: ", err)
	} else {
		p.revision = &v
	}
	return nil
}

func (p *Schema) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Schema"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
		if err := p.writeField11(ctx, oprot); err != nil { return err }
		if err := p.writeField12(ctx, oprot); err != nil { return err }
		if err := p.writeField13(ctx, oprot); err != nil { return err }
		if err := p.writeField14(ctx, oprot); err != nil { return err }
		if err := p.writeField15(ctx, oprot); err != nil { return err }
		if err := p.writeField16(ctx, oprot); err != nil { return err }
		if err := p.writeField17(ctx, oprot); err != nil { return err }
		if err := p.writeField18(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Schema) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcid() {
		if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.cid)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcol_name() {
		if err := oprot.WriteFieldBegin(ctx, "col_name", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:col_name: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.col_name)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.col_name (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:col_name: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "col_tags", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:col_tags: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.col_tags)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.col_tags {
		if err := oprot.WriteString(ctx, string(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:col_tags: ", p), err)
	}
	return err
}

func (p *Schema) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcol_seq() {
		if err := oprot.WriteFieldBegin(ctx, "col_seq", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:col_seq: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.col_seq)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.col_seq (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:col_seq: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcol_type() {
		if err := oprot.WriteFieldBegin(ctx, "col_type", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:col_type: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.col_type)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.col_type (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:col_type: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcell_versions() {
		if err := oprot.WriteFieldBegin(ctx, "cell_versions", thrift.I32, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:cell_versions: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.cell_versions)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cell_versions (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:cell_versions: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcell_ttl() {
		if err := oprot.WriteFieldBegin(ctx, "cell_ttl", thrift.I32, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:cell_ttl: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.cell_ttl)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cell_ttl (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:cell_ttl: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetblk_encoding() {
		if err := oprot.WriteFieldBegin(ctx, "blk_encoding", thrift.I32, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:blk_encoding: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.blk_encoding)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.blk_encoding (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:blk_encoding: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetblk_size() {
		if err := oprot.WriteFieldBegin(ctx, "blk_size", thrift.I32, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:blk_size: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.blk_size)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.blk_size (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:blk_size: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetblk_cells() {
		if err := oprot.WriteFieldBegin(ctx, "blk_cells", thrift.I32, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:blk_cells: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.blk_cells)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.blk_cells (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:blk_cells: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcs_replication() {
		if err := oprot.WriteFieldBegin(ctx, "cs_replication", thrift.BYTE, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:cs_replication: ", p), err)
		}
		if err := oprot.WriteByte(ctx, int8(*p.cs_replication)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cs_replication (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:cs_replication: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcs_size() {
		if err := oprot.WriteFieldBegin(ctx, "cs_size", thrift.I32, 12); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:cs_size: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.cs_size)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cs_size (12) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 12:cs_size: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField13(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcs_max() {
		if err := oprot.WriteFieldBegin(ctx, "cs_max", thrift.BYTE, 13); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 13:cs_max: ", p), err)
		}
		if err := oprot.WriteByte(ctx, int8(*p.cs_max)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.cs_max (13) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 13:cs_max: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField14(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetlog_rollout_ratio() {
		if err := oprot.WriteFieldBegin(ctx, "log_rollout_ratio", thrift.BYTE, 14); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 14:log_rollout_ratio: ", p), err)
		}
		if err := oprot.WriteByte(ctx, int8(*p.log_rollout_ratio)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.log_rollout_ratio (14) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 14:log_rollout_ratio: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField15(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetlog_compact_cointervaling() {
		if err := oprot.WriteFieldBegin(ctx, "log_compact_cointervaling", thrift.BYTE, 15); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 15:log_compact_cointervaling: ", p), err)
		}
		if err := oprot.WriteByte(ctx, int8(*p.log_compact_cointervaling)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.log_compact_cointervaling (15) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 15:log_compact_cointervaling: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField16(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetlog_fragment_preload() {
		if err := oprot.WriteFieldBegin(ctx, "log_fragment_preload", thrift.BYTE, 16); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 16:log_fragment_preload: ", p), err)
		}
		if err := oprot.WriteByte(ctx, int8(*p.log_fragment_preload)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.log_fragment_preload (16) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 16:log_fragment_preload: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField17(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcompact_percent() {
		if err := oprot.WriteFieldBegin(ctx, "compact_percent", thrift.BYTE, 17); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 17:compact_percent: ", p), err)
		}
		if err := oprot.WriteByte(ctx, int8(*p.compact_percent)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.compact_percent (17) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 17:compact_percent: ", p), err)
		}
	}
	return err
}

func (p *Schema) writeField18(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetrevision() {
		if err := oprot.WriteFieldBegin(ctx, "revision", thrift.I64, 18); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 18:revision: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.revision)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.revision (18) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 18:revision: ", p), err)
		}
	}
	return err
}

func (p *Schema) Equals(other *Schema) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.cid != other.cid {
		if p.cid == nil || other.cid == nil {
			return false
		}
		if (*p.cid) != (*other.cid) { return false }
	}
	if p.col_name != other.col_name {
		if p.col_name == nil || other.col_name == nil {
			return false
		}
		if (*p.col_name) != (*other.col_name) { return false }
	}
	if len(p.col_tags) != len(other.col_tags) { return false }
	for i, _tgt := range p.col_tags {
		_src1 := other.col_tags[i]
		if _tgt != _src1 { return false }
	}
	if p.col_seq != other.col_seq {
		if p.col_seq == nil || other.col_seq == nil {
			return false
		}
		if (*p.col_seq) != (*other.col_seq) { return false }
	}
	if p.col_type != other.col_type {
		if p.col_type == nil || other.col_type == nil {
			return false
		}
		if (*p.col_type) != (*other.col_type) { return false }
	}
	if p.cell_versions != other.cell_versions {
		if p.cell_versions == nil || other.cell_versions == nil {
			return false
		}
		if (*p.cell_versions) != (*other.cell_versions) { return false }
	}
	if p.cell_ttl != other.cell_ttl {
		if p.cell_ttl == nil || other.cell_ttl == nil {
			return false
		}
		if (*p.cell_ttl) != (*other.cell_ttl) { return false }
	}
	if p.blk_encoding != other.blk_encoding {
		if p.blk_encoding == nil || other.blk_encoding == nil {
			return false
		}
		if (*p.blk_encoding) != (*other.blk_encoding) { return false }
	}
	if p.blk_size != other.blk_size {
		if p.blk_size == nil || other.blk_size == nil {
			return false
		}
		if (*p.blk_size) != (*other.blk_size) { return false }
	}
	if p.blk_cells != other.blk_cells {
		if p.blk_cells == nil || other.blk_cells == nil {
			return false
		}
		if (*p.blk_cells) != (*other.blk_cells) { return false }
	}
	if p.cs_replication != other.cs_replication {
		if p.cs_replication == nil || other.cs_replication == nil {
			return false
		}
		if (*p.cs_replication) != (*other.cs_replication) { return false }
	}
	if p.cs_size != other.cs_size {
		if p.cs_size == nil || other.cs_size == nil {
			return false
		}
		if (*p.cs_size) != (*other.cs_size) { return false }
	}
	if p.cs_max != other.cs_max {
		if p.cs_max == nil || other.cs_max == nil {
			return false
		}
		if (*p.cs_max) != (*other.cs_max) { return false }
	}
	if p.log_rollout_ratio != other.log_rollout_ratio {
		if p.log_rollout_ratio == nil || other.log_rollout_ratio == nil {
			return false
		}
		if (*p.log_rollout_ratio) != (*other.log_rollout_ratio) { return false }
	}
	if p.log_compact_cointervaling != other.log_compact_cointervaling {
		if p.log_compact_cointervaling == nil || other.log_compact_cointervaling == nil {
			return false
		}
		if (*p.log_compact_cointervaling) != (*other.log_compact_cointervaling) { return false }
	}
	if p.log_fragment_preload != other.log_fragment_preload {
		if p.log_fragment_preload == nil || other.log_fragment_preload == nil {
			return false
		}
		if (*p.log_fragment_preload) != (*other.log_fragment_preload) { return false }
	}
	if p.compact_percent != other.compact_percent {
		if p.compact_percent == nil || other.compact_percent == nil {
			return false
		}
		if (*p.compact_percent) != (*other.compact_percent) { return false }
	}
	if p.revision != other.revision {
		if p.revision == nil || other.revision == nil {
			return false
		}
		if (*p.revision) != (*other.revision) { return false }
	}
	return true
}

func (p *Schema) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Schema(%+v)", *p)
}

func (p *Schema) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Schema",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Schema)(nil)

func (p *Schema) Validate() error {
	return nil
}

// The Schema matching Pattern
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - value: The patern value to match against
// 
type SchemaPattern struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	value string `thrift:"value,2" db:"value" json:"value"`
}

func NewSchemaPattern() *SchemaPattern {
	return &SchemaPattern{}
}



func (p *SchemaPattern) Getcomp() Comp {
	return p.comp
}



func (p *SchemaPattern) Getvalue() string {
	return p.value
}

func (p *SchemaPattern) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SchemaPattern) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SchemaPattern) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.value = v
	}
	return nil
}

func (p *SchemaPattern) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SchemaPattern"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SchemaPattern) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SchemaPattern) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.value)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err)
	}
	return err
}

func (p *SchemaPattern) Equals(other *SchemaPattern) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if p.value != other.value { return false }
	return true
}

func (p *SchemaPattern) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SchemaPattern(%+v)", *p)
}

func (p *SchemaPattern) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SchemaPattern",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SchemaPattern)(nil)

func (p *SchemaPattern) Validate() error {
	return nil
}

// The Schema Tags patterns for the SchemaPatterns
// 
// Attributes:
//  - comp: Logical comparator to Apply, unsupported PF, RE and Vol. kind
//  - values: The tags patterns to match against schema's column tags
// 
type SchemaTagsPatterns struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	values []*SchemaPattern `thrift:"values,2" db:"values" json:"values"`
}

func NewSchemaTagsPatterns() *SchemaTagsPatterns {
	return &SchemaTagsPatterns{}
}



func (p *SchemaTagsPatterns) Getcomp() Comp {
	return p.comp
}



func (p *SchemaTagsPatterns) Getvalues() []*SchemaPattern {
	return p.values
}

func (p *SchemaTagsPatterns) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SchemaTagsPatterns) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SchemaTagsPatterns) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SchemaPattern, 0, size)
	p.values = tSlice
	for i := 0; i < size; i++ {
		_elem2 := &SchemaPattern{}
		if err := _elem2.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
		}
		p.values = append(p.values, _elem2)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SchemaTagsPatterns) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SchemaTagsPatterns"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SchemaTagsPatterns) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SchemaTagsPatterns) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:values: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.values)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.values {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:values: ", p), err)
	}
	return err
}

func (p *SchemaTagsPatterns) Equals(other *SchemaTagsPatterns) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if len(p.values) != len(other.values) { return false }
	for i, _tgt := range p.values {
		_src3 := other.values[i]
		if !_tgt.Equals(_src3) { return false }
	}
	return true
}

func (p *SchemaTagsPatterns) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SchemaTagsPatterns(%+v)", *p)
}

func (p *SchemaTagsPatterns) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SchemaTagsPatterns",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SchemaTagsPatterns)(nil)

func (p *SchemaTagsPatterns) Validate() error {
	return nil
}

// The Schema Patterns for the SpecSchemas
// 
// Attributes:
//  - names: The Schema patterns for selecting by Column Name
//  - tags: The Schema patterns for selecting by Column Tags
// 
type SchemaPatterns struct {
	names []*SchemaPattern `thrift:"names,1" db:"names" json:"names"`
	tags *SchemaTagsPatterns `thrift:"tags,2" db:"tags" json:"tags"`
}

func NewSchemaPatterns() *SchemaPatterns {
	return &SchemaPatterns{}
}



func (p *SchemaPatterns) Getnames() []*SchemaPattern {
	return p.names
}

var SchemaPatterns_tags_DEFAULT *SchemaTagsPatterns

func (p *SchemaPatterns) Gettags() *SchemaTagsPatterns {
	if !p.IsSettags() {
		return SchemaPatterns_tags_DEFAULT
	}
	return p.tags
}

func (p *SchemaPatterns) IsSettags() bool {
	return p.tags != nil
}

func (p *SchemaPatterns) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SchemaPatterns) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SchemaPattern, 0, size)
	p.names = tSlice
	for i := 0; i < size; i++ {
		_elem4 := &SchemaPattern{}
		if err := _elem4.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
		}
		p.names = append(p.names, _elem4)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SchemaPatterns) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.tags = &SchemaTagsPatterns{}
	if err := p.tags.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.tags), err)
	}
	return nil
}

func (p *SchemaPatterns) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SchemaPatterns"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SchemaPatterns) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "names", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:names: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.names)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.names {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:names: ", p), err)
	}
	return err
}

func (p *SchemaPatterns) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tags", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tags: ", p), err)
	}
	if err := p.tags.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.tags), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tags: ", p), err)
	}
	return err
}

func (p *SchemaPatterns) Equals(other *SchemaPatterns) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.names) != len(other.names) { return false }
	for i, _tgt := range p.names {
		_src5 := other.names[i]
		if !_tgt.Equals(_src5) { return false }
	}
	if !p.tags.Equals(other.tags) { return false }
	return true
}

func (p *SchemaPatterns) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SchemaPatterns(%+v)", *p)
}

func (p *SchemaPatterns) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SchemaPatterns",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SchemaPatterns)(nil)

func (p *SchemaPatterns) Validate() error {
	return nil
}

// The Specs for Schemas for using with list_columns or compact_columns
// 
// Attributes:
//  - cids: The Column IDs
//  - names: The Column Names
//  - patterns: The Schema's selector patterns
// 
type SpecSchemas struct {
	cids []int64 `thrift:"cids,1" db:"cids" json:"cids"`
	names []string `thrift:"names,2" db:"names" json:"names"`
	patterns *SchemaPatterns `thrift:"patterns,3" db:"patterns" json:"patterns"`
}

func NewSpecSchemas() *SpecSchemas {
	return &SpecSchemas{}
}



func (p *SpecSchemas) Getcids() []int64 {
	return p.cids
}



func (p *SpecSchemas) Getnames() []string {
	return p.names
}

var SpecSchemas_patterns_DEFAULT *SchemaPatterns

func (p *SpecSchemas) Getpatterns() *SchemaPatterns {
	if !p.IsSetpatterns() {
		return SpecSchemas_patterns_DEFAULT
	}
	return p.patterns
}

func (p *SpecSchemas) IsSetpatterns() bool {
	return p.patterns != nil
}

func (p *SpecSchemas) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecSchemas) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]int64, 0, size)
	p.cids = tSlice
	for i := 0; i < size; i++ {
		var _elem6 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem6 = v
		}
		p.cids = append(p.cids, _elem6)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecSchemas) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.names = tSlice
	for i := 0; i < size; i++ {
		var _elem7 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem7 = v
		}
		p.names = append(p.names, _elem7)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecSchemas) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.patterns = &SchemaPatterns{}
	if err := p.patterns.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.patterns), err)
	}
	return nil
}

func (p *SpecSchemas) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecSchemas"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecSchemas) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cids", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cids: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.I64, len(p.cids)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.cids {
		if err := oprot.WriteI64(ctx, int64(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cids: ", p), err)
	}
	return err
}

func (p *SpecSchemas) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "names", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:names: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.names)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.names {
		if err := oprot.WriteString(ctx, string(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:names: ", p), err)
	}
	return err
}

func (p *SpecSchemas) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "patterns", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:patterns: ", p), err)
	}
	if err := p.patterns.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.patterns), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:patterns: ", p), err)
	}
	return err
}

func (p *SpecSchemas) Equals(other *SpecSchemas) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.cids) != len(other.cids) { return false }
	for i, _tgt := range p.cids {
		_src8 := other.cids[i]
		if _tgt != _src8 { return false }
	}
	if len(p.names) != len(other.names) { return false }
	for i, _tgt := range p.names {
		_src9 := other.names[i]
		if _tgt != _src9 { return false }
	}
	if !p.patterns.Equals(other.patterns) { return false }
	return true
}

func (p *SpecSchemas) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecSchemas(%+v)", *p)
}

func (p *SpecSchemas) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecSchemas",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecSchemas)(nil)

func (p *SpecSchemas) Validate() error {
	return nil
}

// The Scan Specifications Flags
// 
// Attributes:
//  - limit: Limit to this number of cells
//  - offset: Scan from this number of cells Offset on matching Cell-Interval
//  - max_versions: Select only this number of Versions of a given Cell-Key
//  - max_buffer: return results with reach of this Buffer size in bytes
//  - options: The options bit by SpecFlagsOpt
// 
type SpecFlags struct {
	limit *int64 `thrift:"limit,1" db:"limit" json:"limit,omitempty"`
	offset *int64 `thrift:"offset,2" db:"offset" json:"offset,omitempty"`
	max_versions *int32 `thrift:"max_versions,3" db:"max_versions" json:"max_versions,omitempty"`
	max_buffer *int32 `thrift:"max_buffer,4" db:"max_buffer" json:"max_buffer,omitempty"`
	options *int8 `thrift:"options,5" db:"options" json:"options,omitempty"`
}

func NewSpecFlags() *SpecFlags {
	return &SpecFlags{}
}

var SpecFlags_limit_DEFAULT int64

func (p *SpecFlags) Getlimit() int64 {
	if !p.IsSetlimit() {
		return SpecFlags_limit_DEFAULT
	}
	return *p.limit
}

var SpecFlags_offset_DEFAULT int64

func (p *SpecFlags) Getoffset() int64 {
	if !p.IsSetoffset() {
		return SpecFlags_offset_DEFAULT
	}
	return *p.offset
}

var SpecFlags_max_versions_DEFAULT int32

func (p *SpecFlags) Getmax_versions() int32 {
	if !p.IsSetmax_versions() {
		return SpecFlags_max_versions_DEFAULT
	}
	return *p.max_versions
}

var SpecFlags_max_buffer_DEFAULT int32

func (p *SpecFlags) Getmax_buffer() int32 {
	if !p.IsSetmax_buffer() {
		return SpecFlags_max_buffer_DEFAULT
	}
	return *p.max_buffer
}

var SpecFlags_options_DEFAULT int8

func (p *SpecFlags) Getoptions() int8 {
	if !p.IsSetoptions() {
		return SpecFlags_options_DEFAULT
	}
	return *p.options
}

func (p *SpecFlags) IsSetlimit() bool {
	return p.limit != nil
}

func (p *SpecFlags) IsSetoffset() bool {
	return p.offset != nil
}

func (p *SpecFlags) IsSetmax_versions() bool {
	return p.max_versions != nil
}

func (p *SpecFlags) IsSetmax_buffer() bool {
	return p.max_buffer != nil
}

func (p *SpecFlags) IsSetoptions() bool {
	return p.options != nil
}

func (p *SpecFlags) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecFlags) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.limit = &v
	}
	return nil
}

func (p *SpecFlags) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.offset = &v
	}
	return nil
}

func (p *SpecFlags) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.max_versions = &v
	}
	return nil
}

func (p *SpecFlags) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.max_buffer = &v
	}
	return nil
}

func (p *SpecFlags) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := int8(v)
		p.options = &temp
	}
	return nil
}

func (p *SpecFlags) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecFlags"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecFlags) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetlimit() {
		if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I64, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:limit: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.limit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.limit (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:limit: ", p), err)
		}
	}
	return err
}

func (p *SpecFlags) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetoffset() {
		if err := oprot.WriteFieldBegin(ctx, "offset", thrift.I64, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:offset: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.offset)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.offset (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:offset: ", p), err)
		}
	}
	return err
}

func (p *SpecFlags) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetmax_versions() {
		if err := oprot.WriteFieldBegin(ctx, "max_versions", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:max_versions: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.max_versions)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.max_versions (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:max_versions: ", p), err)
		}
	}
	return err
}

func (p *SpecFlags) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetmax_buffer() {
		if err := oprot.WriteFieldBegin(ctx, "max_buffer", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:max_buffer: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.max_buffer)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.max_buffer (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:max_buffer: ", p), err)
		}
	}
	return err
}

func (p *SpecFlags) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetoptions() {
		if err := oprot.WriteFieldBegin(ctx, "options", thrift.BYTE, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:options: ", p), err)
		}
		if err := oprot.WriteByte(ctx, int8(*p.options)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.options (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:options: ", p), err)
		}
	}
	return err
}

func (p *SpecFlags) Equals(other *SpecFlags) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.limit != other.limit {
		if p.limit == nil || other.limit == nil {
			return false
		}
		if (*p.limit) != (*other.limit) { return false }
	}
	if p.offset != other.offset {
		if p.offset == nil || other.offset == nil {
			return false
		}
		if (*p.offset) != (*other.offset) { return false }
	}
	if p.max_versions != other.max_versions {
		if p.max_versions == nil || other.max_versions == nil {
			return false
		}
		if (*p.max_versions) != (*other.max_versions) { return false }
	}
	if p.max_buffer != other.max_buffer {
		if p.max_buffer == nil || other.max_buffer == nil {
			return false
		}
		if (*p.max_buffer) != (*other.max_buffer) { return false }
	}
	if p.options != other.options {
		if p.options == nil || other.options == nil {
			return false
		}
		if (*p.options) != (*other.options) { return false }
	}
	return true
}

func (p *SpecFlags) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecFlags(%+v)", *p)
}

func (p *SpecFlags) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecFlags",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecFlags)(nil)

func (p *SpecFlags) Validate() error {
	return nil
}

// Attributes:
//  - op: The Operation of update
//  - pos: The position/index of INSERT and OVERWRITE update operations
// 
type SpecUpdateOP struct {
	op UpdateOP `thrift:"op,1" db:"op" json:"op"`
	pos *int32 `thrift:"pos,2" db:"pos" json:"pos,omitempty"`
}

func NewSpecUpdateOP() *SpecUpdateOP {
	return &SpecUpdateOP{}
}



func (p *SpecUpdateOP) Getop() UpdateOP {
	return p.op
}

var SpecUpdateOP_pos_DEFAULT int32

func (p *SpecUpdateOP) Getpos() int32 {
	if !p.IsSetpos() {
		return SpecUpdateOP_pos_DEFAULT
	}
	return *p.pos
}

func (p *SpecUpdateOP) IsSetpos() bool {
	return p.pos != nil
}

func (p *SpecUpdateOP) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecUpdateOP) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := UpdateOP(v)
		p.op = temp
	}
	return nil
}

func (p *SpecUpdateOP) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.pos = &v
	}
	return nil
}

func (p *SpecUpdateOP) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecUpdateOP"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecUpdateOP) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:op: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:op: ", p), err)
	}
	return err
}

func (p *SpecUpdateOP) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetpos() {
		if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:pos: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.pos)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.pos (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:pos: ", p), err)
		}
	}
	return err
}

func (p *SpecUpdateOP) Equals(other *SpecUpdateOP) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.op != other.op { return false }
	if p.pos != other.pos {
		if p.pos == nil || other.pos == nil {
			return false
		}
		if (*p.pos) != (*other.pos) { return false }
	}
	return true
}

func (p *SpecUpdateOP) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecUpdateOP(%+v)", *p)
}

func (p *SpecUpdateOP) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecUpdateOP",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecUpdateOP)(nil)

func (p *SpecUpdateOP) Validate() error {
	return nil
}

// The Value specs for an Updating Interval of 'updating' in SpecIntervalPlain
// 
// Attributes:
//  - v: The bytes value for the updated cell
//  - ts: The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
//  - encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
//  - update_op: Optionally the operaton of value update
// 
type SpecIntervalUpdatePlain struct {
	v []byte `thrift:"v,1" db:"v" json:"v"`
	ts *int64 `thrift:"ts,2" db:"ts" json:"ts,omitempty"`
	encoder *EncodingType `thrift:"encoder,3" db:"encoder" json:"encoder,omitempty"`
	update_op *SpecUpdateOP `thrift:"update_op,4" db:"update_op" json:"update_op,omitempty"`
}

func NewSpecIntervalUpdatePlain() *SpecIntervalUpdatePlain {
	return &SpecIntervalUpdatePlain{}
}



func (p *SpecIntervalUpdatePlain) Getv() []byte {
	return p.v
}

var SpecIntervalUpdatePlain_ts_DEFAULT int64

func (p *SpecIntervalUpdatePlain) Getts() int64 {
	if !p.IsSetts() {
		return SpecIntervalUpdatePlain_ts_DEFAULT
	}
	return *p.ts
}

var SpecIntervalUpdatePlain_encoder_DEFAULT EncodingType

func (p *SpecIntervalUpdatePlain) Getencoder() EncodingType {
	if !p.IsSetencoder() {
		return SpecIntervalUpdatePlain_encoder_DEFAULT
	}
	return *p.encoder
}

var SpecIntervalUpdatePlain_update_op_DEFAULT *SpecUpdateOP

func (p *SpecIntervalUpdatePlain) Getupdate_op() *SpecUpdateOP {
	if !p.IsSetupdate_op() {
		return SpecIntervalUpdatePlain_update_op_DEFAULT
	}
	return p.update_op
}

func (p *SpecIntervalUpdatePlain) IsSetts() bool {
	return p.ts != nil
}

func (p *SpecIntervalUpdatePlain) IsSetencoder() bool {
	return p.encoder != nil
}

func (p *SpecIntervalUpdatePlain) IsSetupdate_op() bool {
	return p.update_op != nil
}

func (p *SpecIntervalUpdatePlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecIntervalUpdatePlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *SpecIntervalUpdatePlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = &v
	}
	return nil
}

func (p *SpecIntervalUpdatePlain) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		temp := EncodingType(v)
		p.encoder = &temp
	}
	return nil
}

func (p *SpecIntervalUpdatePlain) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.update_op = &SpecUpdateOP{}
	if err := p.update_op.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.update_op), err)
	}
	return nil
}

func (p *SpecIntervalUpdatePlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecIntervalUpdatePlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecIntervalUpdatePlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:v: ", p), err)
	}
	return err
}

func (p *SpecIntervalUpdatePlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts() {
		if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.ts)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalUpdatePlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetencoder() {
		if err := oprot.WriteFieldBegin(ctx, "encoder", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:encoder: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.encoder)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.encoder (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:encoder: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalUpdatePlain) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetupdate_op() {
		if err := oprot.WriteFieldBegin(ctx, "update_op", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:update_op: ", p), err)
		}
		if err := p.update_op.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.update_op), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:update_op: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalUpdatePlain) Equals(other *SpecIntervalUpdatePlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.v, other.v) != 0 { return false }
	if p.ts != other.ts {
		if p.ts == nil || other.ts == nil {
			return false
		}
		if (*p.ts) != (*other.ts) { return false }
	}
	if p.encoder != other.encoder {
		if p.encoder == nil || other.encoder == nil {
			return false
		}
		if (*p.encoder) != (*other.encoder) { return false }
	}
	if !p.update_op.Equals(other.update_op) { return false }
	return true
}

func (p *SpecIntervalUpdatePlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecIntervalUpdatePlain(%+v)", *p)
}

func (p *SpecIntervalUpdatePlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecIntervalUpdatePlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalUpdatePlain)(nil)

func (p *SpecIntervalUpdatePlain) Validate() error {
	return nil
}

// The Value specs for an Updating Interval of 'updating' in SpecIntervalCounter
// 
// Attributes:
//  - v: The int64 value for the updated cell
//  - op: The Opration pf Counter, available: COUNTER_OP_EQUAL
//  - ts: The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
//  - update_op: Optionally the operaton of value update
// 
type SpecIntervalUpdateCounter struct {
	v int64 `thrift:"v,1" db:"v" json:"v"`
	op int64 `thrift:"op,2" db:"op" json:"op"`
	ts *int64 `thrift:"ts,3" db:"ts" json:"ts,omitempty"`
	update_op *SpecUpdateOP `thrift:"update_op,4" db:"update_op" json:"update_op,omitempty"`
}

func NewSpecIntervalUpdateCounter() *SpecIntervalUpdateCounter {
	return &SpecIntervalUpdateCounter{}
}



func (p *SpecIntervalUpdateCounter) Getv() int64 {
	return p.v
}



func (p *SpecIntervalUpdateCounter) Getop() int64 {
	return p.op
}

var SpecIntervalUpdateCounter_ts_DEFAULT int64

func (p *SpecIntervalUpdateCounter) Getts() int64 {
	if !p.IsSetts() {
		return SpecIntervalUpdateCounter_ts_DEFAULT
	}
	return *p.ts
}

var SpecIntervalUpdateCounter_update_op_DEFAULT *SpecUpdateOP

func (p *SpecIntervalUpdateCounter) Getupdate_op() *SpecUpdateOP {
	if !p.IsSetupdate_op() {
		return SpecIntervalUpdateCounter_update_op_DEFAULT
	}
	return p.update_op
}

func (p *SpecIntervalUpdateCounter) IsSetts() bool {
	return p.ts != nil
}

func (p *SpecIntervalUpdateCounter) IsSetupdate_op() bool {
	return p.update_op != nil
}

func (p *SpecIntervalUpdateCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecIntervalUpdateCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *SpecIntervalUpdateCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.op = v
	}
	return nil
}

func (p *SpecIntervalUpdateCounter) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ts = &v
	}
	return nil
}

func (p *SpecIntervalUpdateCounter) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.update_op = &SpecUpdateOP{}
	if err := p.update_op.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.update_op), err)
	}
	return nil
}

func (p *SpecIntervalUpdateCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecIntervalUpdateCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecIntervalUpdateCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:v: ", p), err)
	}
	return err
}

func (p *SpecIntervalUpdateCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "op", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err)
	}
	return err
}

func (p *SpecIntervalUpdateCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts() {
		if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.ts)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalUpdateCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetupdate_op() {
		if err := oprot.WriteFieldBegin(ctx, "update_op", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:update_op: ", p), err)
		}
		if err := p.update_op.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.update_op), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:update_op: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalUpdateCounter) Equals(other *SpecIntervalUpdateCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.v != other.v { return false }
	if p.op != other.op { return false }
	if p.ts != other.ts {
		if p.ts == nil || other.ts == nil {
			return false
		}
		if (*p.ts) != (*other.ts) { return false }
	}
	if !p.update_op.Equals(other.update_op) { return false }
	return true
}

func (p *SpecIntervalUpdateCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecIntervalUpdateCounter(%+v)", *p)
}

func (p *SpecIntervalUpdateCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecIntervalUpdateCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalUpdateCounter)(nil)

func (p *SpecIntervalUpdateCounter) Validate() error {
	return nil
}

// The Value specs for an Updating Interval of 'updating' in SpecIntervalSerial
// 
// Attributes:
//  - ts: The timestamp for the updated cell NULL: MIN_INT64-1, AUTO:MIN_INT64-1
//  - v: The values of serial-fields for the updated cell
//  - v_op: The values of serial-fields for the the SERIAL operation update
//  - encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
//  - update_op: Optionally the operaton of value update
// 
type SpecIntervalUpdateSerial struct {
	ts int64 `thrift:"ts,1" db:"ts" json:"ts"`
	v []*CellValueSerial `thrift:"v,2" db:"v" json:"v"`
	v_op []*CellValueSerialOp `thrift:"v_op,3" db:"v_op" json:"v_op"`
	encoder *EncodingType `thrift:"encoder,4" db:"encoder" json:"encoder,omitempty"`
	update_op *SpecUpdateOP `thrift:"update_op,5" db:"update_op" json:"update_op,omitempty"`
}

func NewSpecIntervalUpdateSerial() *SpecIntervalUpdateSerial {
	return &SpecIntervalUpdateSerial{}
}



func (p *SpecIntervalUpdateSerial) Getts() int64 {
	return p.ts
}



func (p *SpecIntervalUpdateSerial) Getv() []*CellValueSerial {
	return p.v
}



func (p *SpecIntervalUpdateSerial) Getv_op() []*CellValueSerialOp {
	return p.v_op
}

var SpecIntervalUpdateSerial_encoder_DEFAULT EncodingType

func (p *SpecIntervalUpdateSerial) Getencoder() EncodingType {
	if !p.IsSetencoder() {
		return SpecIntervalUpdateSerial_encoder_DEFAULT
	}
	return *p.encoder
}

var SpecIntervalUpdateSerial_update_op_DEFAULT *SpecUpdateOP

func (p *SpecIntervalUpdateSerial) Getupdate_op() *SpecUpdateOP {
	if !p.IsSetupdate_op() {
		return SpecIntervalUpdateSerial_update_op_DEFAULT
	}
	return p.update_op
}

func (p *SpecIntervalUpdateSerial) IsSetencoder() bool {
	return p.encoder != nil
}

func (p *SpecIntervalUpdateSerial) IsSetupdate_op() bool {
	return p.update_op != nil
}

func (p *SpecIntervalUpdateSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecIntervalUpdateSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *SpecIntervalUpdateSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CellValueSerial, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem10 := &CellValueSerial{}
		if err := _elem10.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem10), err)
		}
		p.v = append(p.v, _elem10)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalUpdateSerial) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CellValueSerialOp, 0, size)
	p.v_op = tSlice
	for i := 0; i < size; i++ {
		_elem11 := &CellValueSerialOp{}
		if err := _elem11.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem11), err)
		}
		p.v_op = append(p.v_op, _elem11)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalUpdateSerial) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := EncodingType(v)
		p.encoder = &temp
	}
	return nil
}

func (p *SpecIntervalUpdateSerial) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	p.update_op = &SpecUpdateOP{}
	if err := p.update_op.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.update_op), err)
	}
	return nil
}

func (p *SpecIntervalUpdateSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecIntervalUpdateSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecIntervalUpdateSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ts: ", p), err)
	}
	return err
}

func (p *SpecIntervalUpdateSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecIntervalUpdateSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v_op", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v_op: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v_op)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v_op {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v_op: ", p), err)
	}
	return err
}

func (p *SpecIntervalUpdateSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetencoder() {
		if err := oprot.WriteFieldBegin(ctx, "encoder", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:encoder: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.encoder)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.encoder (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:encoder: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalUpdateSerial) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetupdate_op() {
		if err := oprot.WriteFieldBegin(ctx, "update_op", thrift.STRUCT, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:update_op: ", p), err)
		}
		if err := p.update_op.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.update_op), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:update_op: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalUpdateSerial) Equals(other *SpecIntervalUpdateSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ts != other.ts { return false }
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src12 := other.v[i]
		if !_tgt.Equals(_src12) { return false }
	}
	if len(p.v_op) != len(other.v_op) { return false }
	for i, _tgt := range p.v_op {
		_src13 := other.v_op[i]
		if !_tgt.Equals(_src13) { return false }
	}
	if p.encoder != other.encoder {
		if p.encoder == nil || other.encoder == nil {
			return false
		}
		if (*p.encoder) != (*other.encoder) { return false }
	}
	if !p.update_op.Equals(other.update_op) { return false }
	return true
}

func (p *SpecIntervalUpdateSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecIntervalUpdateSerial(%+v)", *p)
}

func (p *SpecIntervalUpdateSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecIntervalUpdateSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalUpdateSerial)(nil)

func (p *SpecIntervalUpdateSerial) Validate() error {
	return nil
}

// The Specifications of INT64 Serial Value Field
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - v: The int64 to match against the value field
// 
type SpecValueSerial_INT64 struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	v int64 `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_INT64() *SpecValueSerial_INT64 {
	return &SpecValueSerial_INT64{}
}



func (p *SpecValueSerial_INT64) Getcomp() Comp {
	return p.comp
}



func (p *SpecValueSerial_INT64) Getv() int64 {
	return p.v
}

func (p *SpecValueSerial_INT64) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueSerial_INT64) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecValueSerial_INT64) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *SpecValueSerial_INT64) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_INT64"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueSerial_INT64) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_INT64) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_INT64) Equals(other *SpecValueSerial_INT64) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if p.v != other.v { return false }
	return true
}

func (p *SpecValueSerial_INT64) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueSerial_INT64(%+v)", *p)
}

func (p *SpecValueSerial_INT64) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueSerial_INT64",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_INT64)(nil)

func (p *SpecValueSerial_INT64) Validate() error {
	return nil
}

// The Specifications of DOUBLE Serial Value Field
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - v: The double to match against the value field
// 
type SpecValueSerial_DOUBLE struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	v float64 `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_DOUBLE() *SpecValueSerial_DOUBLE {
	return &SpecValueSerial_DOUBLE{}
}



func (p *SpecValueSerial_DOUBLE) Getcomp() Comp {
	return p.comp
}



func (p *SpecValueSerial_DOUBLE) Getv() float64 {
	return p.v
}

func (p *SpecValueSerial_DOUBLE) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueSerial_DOUBLE) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecValueSerial_DOUBLE) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *SpecValueSerial_DOUBLE) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_DOUBLE"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueSerial_DOUBLE) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_DOUBLE) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.DOUBLE, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_DOUBLE) Equals(other *SpecValueSerial_DOUBLE) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if p.v != other.v { return false }
	return true
}

func (p *SpecValueSerial_DOUBLE) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueSerial_DOUBLE(%+v)", *p)
}

func (p *SpecValueSerial_DOUBLE) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueSerial_DOUBLE",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_DOUBLE)(nil)

func (p *SpecValueSerial_DOUBLE) Validate() error {
	return nil
}

// The Specifications of BYTES Serial Value Field
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - v: The binary(bytes) to match against the value field
// 
type SpecValueSerial_BYTES struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	v []byte `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_BYTES() *SpecValueSerial_BYTES {
	return &SpecValueSerial_BYTES{}
}



func (p *SpecValueSerial_BYTES) Getcomp() Comp {
	return p.comp
}



func (p *SpecValueSerial_BYTES) Getv() []byte {
	return p.v
}

func (p *SpecValueSerial_BYTES) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueSerial_BYTES) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecValueSerial_BYTES) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *SpecValueSerial_BYTES) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_BYTES"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueSerial_BYTES) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_BYTES) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_BYTES) Equals(other *SpecValueSerial_BYTES) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if bytes.Compare(p.v, other.v) != 0 { return false }
	return true
}

func (p *SpecValueSerial_BYTES) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueSerial_BYTES(%+v)", *p)
}

func (p *SpecValueSerial_BYTES) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueSerial_BYTES",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_BYTES)(nil)

func (p *SpecValueSerial_BYTES) Validate() error {
	return nil
}

// The Specifications of KEY Serial Value Field
// 
// Attributes:
//  - seq: The Key Sequence to use
//  - v: The Specification of the Key to match against the value field
// 
type SpecValueSerial_KEY struct {
	seq KeySeq `thrift:"seq,1" db:"seq" json:"seq"`
	v []*SpecFraction `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_KEY() *SpecValueSerial_KEY {
	return &SpecValueSerial_KEY{}
}



func (p *SpecValueSerial_KEY) Getseq() KeySeq {
	return p.seq
}



func (p *SpecValueSerial_KEY) Getv() []*SpecFraction {
	return p.v
}

func (p *SpecValueSerial_KEY) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueSerial_KEY) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := KeySeq(v)
		p.seq = temp
	}
	return nil
}

func (p *SpecValueSerial_KEY) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecFraction, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem14 := &SpecFraction{}
		if err := _elem14.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem14), err)
		}
		p.v = append(p.v, _elem14)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecValueSerial_KEY) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_KEY"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueSerial_KEY) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "seq", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:seq: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.seq)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.seq (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:seq: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_KEY) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_KEY) Equals(other *SpecValueSerial_KEY) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.seq != other.seq { return false }
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src15 := other.v[i]
		if !_tgt.Equals(_src15) { return false }
	}
	return true
}

func (p *SpecValueSerial_KEY) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueSerial_KEY(%+v)", *p)
}

func (p *SpecValueSerial_KEY) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueSerial_KEY",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_KEY)(nil)

func (p *SpecValueSerial_KEY) Validate() error {
	return nil
}

// The Specifications of LIST_INT64(LI) Serial Value Field
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - v: The List of Int64 to match against the value field
// 
type SpecValueSerial_LI struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	v []*SpecValueSerial_INT64 `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_LI() *SpecValueSerial_LI {
	return &SpecValueSerial_LI{}
}



func (p *SpecValueSerial_LI) Getcomp() Comp {
	return p.comp
}



func (p *SpecValueSerial_LI) Getv() []*SpecValueSerial_INT64 {
	return p.v
}

func (p *SpecValueSerial_LI) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueSerial_LI) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecValueSerial_LI) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecValueSerial_INT64, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem16 := &SpecValueSerial_INT64{}
		if err := _elem16.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem16), err)
		}
		p.v = append(p.v, _elem16)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecValueSerial_LI) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_LI"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueSerial_LI) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_LI) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_LI) Equals(other *SpecValueSerial_LI) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src17 := other.v[i]
		if !_tgt.Equals(_src17) { return false }
	}
	return true
}

func (p *SpecValueSerial_LI) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueSerial_LI(%+v)", *p)
}

func (p *SpecValueSerial_LI) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueSerial_LI",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_LI)(nil)

func (p *SpecValueSerial_LI) Validate() error {
	return nil
}

// The Specifications of LIST_BYTES(LB) Serial Value Field
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - v: The List of Bytes to match against the value field
// 
type SpecValueSerial_LB struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	v []*SpecValueSerial_BYTES `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueSerial_LB() *SpecValueSerial_LB {
	return &SpecValueSerial_LB{}
}



func (p *SpecValueSerial_LB) Getcomp() Comp {
	return p.comp
}



func (p *SpecValueSerial_LB) Getv() []*SpecValueSerial_BYTES {
	return p.v
}

func (p *SpecValueSerial_LB) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueSerial_LB) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecValueSerial_LB) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecValueSerial_BYTES, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem18 := &SpecValueSerial_BYTES{}
		if err := _elem18.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem18), err)
		}
		p.v = append(p.v, _elem18)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecValueSerial_LB) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueSerial_LB"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueSerial_LB) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_LB) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecValueSerial_LB) Equals(other *SpecValueSerial_LB) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src19 := other.v[i]
		if !_tgt.Equals(_src19) { return false }
	}
	return true
}

func (p *SpecValueSerial_LB) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueSerial_LB(%+v)", *p)
}

func (p *SpecValueSerial_LB) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueSerial_LB",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial_LB)(nil)

func (p *SpecValueSerial_LB) Validate() error {
	return nil
}

// Attributes:
//  - field_id: The Field Id of the Value Field
//  - spec_int64: The specifications of Int64 for the field
//  - spec_double: The specifications of Double for the field
//  - spec_bytes: The specifications of Bytes for the field
//  - spec_key: The specifications of Cell-Key for the field
//  - spec_li: The specifications of List Int64 for the field
//  - spec_lb: The specifications of List Bytes for the field
// 
type SpecValueSerialField struct {
	field_id int32 `thrift:"field_id,1" db:"field_id" json:"field_id"`
	spec_int64 *SpecValueSerial_INT64 `thrift:"spec_int64,2" db:"spec_int64" json:"spec_int64,omitempty"`
	spec_double *SpecValueSerial_DOUBLE `thrift:"spec_double,3" db:"spec_double" json:"spec_double,omitempty"`
	spec_bytes *SpecValueSerial_BYTES `thrift:"spec_bytes,4" db:"spec_bytes" json:"spec_bytes"`
	spec_key *SpecValueSerial_KEY `thrift:"spec_key,5" db:"spec_key" json:"spec_key"`
	spec_li *SpecValueSerial_LI `thrift:"spec_li,6" db:"spec_li" json:"spec_li"`
	spec_lb *SpecValueSerial_LB `thrift:"spec_lb,7" db:"spec_lb" json:"spec_lb"`
}

func NewSpecValueSerialField() *SpecValueSerialField {
	return &SpecValueSerialField{}
}



func (p *SpecValueSerialField) Getfield_id() int32 {
	return p.field_id
}

var SpecValueSerialField_spec_int64_DEFAULT *SpecValueSerial_INT64

func (p *SpecValueSerialField) Getspec_int64() *SpecValueSerial_INT64 {
	if !p.IsSetspec_int64() {
		return SpecValueSerialField_spec_int64_DEFAULT
	}
	return p.spec_int64
}

var SpecValueSerialField_spec_double_DEFAULT *SpecValueSerial_DOUBLE

func (p *SpecValueSerialField) Getspec_double() *SpecValueSerial_DOUBLE {
	if !p.IsSetspec_double() {
		return SpecValueSerialField_spec_double_DEFAULT
	}
	return p.spec_double
}

var SpecValueSerialField_spec_bytes_DEFAULT *SpecValueSerial_BYTES

func (p *SpecValueSerialField) Getspec_bytes() *SpecValueSerial_BYTES {
	if !p.IsSetspec_bytes() {
		return SpecValueSerialField_spec_bytes_DEFAULT
	}
	return p.spec_bytes
}

var SpecValueSerialField_spec_key_DEFAULT *SpecValueSerial_KEY

func (p *SpecValueSerialField) Getspec_key() *SpecValueSerial_KEY {
	if !p.IsSetspec_key() {
		return SpecValueSerialField_spec_key_DEFAULT
	}
	return p.spec_key
}

var SpecValueSerialField_spec_li_DEFAULT *SpecValueSerial_LI

func (p *SpecValueSerialField) Getspec_li() *SpecValueSerial_LI {
	if !p.IsSetspec_li() {
		return SpecValueSerialField_spec_li_DEFAULT
	}
	return p.spec_li
}

var SpecValueSerialField_spec_lb_DEFAULT *SpecValueSerial_LB

func (p *SpecValueSerialField) Getspec_lb() *SpecValueSerial_LB {
	if !p.IsSetspec_lb() {
		return SpecValueSerialField_spec_lb_DEFAULT
	}
	return p.spec_lb
}

func (p *SpecValueSerialField) IsSetspec_int64() bool {
	return p.spec_int64 != nil
}

func (p *SpecValueSerialField) IsSetspec_double() bool {
	return p.spec_double != nil
}

func (p *SpecValueSerialField) IsSetspec_bytes() bool {
	return p.spec_bytes != nil
}

func (p *SpecValueSerialField) IsSetspec_key() bool {
	return p.spec_key != nil
}

func (p *SpecValueSerialField) IsSetspec_li() bool {
	return p.spec_li != nil
}

func (p *SpecValueSerialField) IsSetspec_lb() bool {
	return p.spec_lb != nil
}

func (p *SpecValueSerialField) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueSerialField) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.field_id = v
	}
	return nil
}

func (p *SpecValueSerialField) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec_int64 = &SpecValueSerial_INT64{}
	if err := p.spec_int64.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec_int64), err)
	}
	return nil
}

func (p *SpecValueSerialField) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec_double = &SpecValueSerial_DOUBLE{}
	if err := p.spec_double.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec_double), err)
	}
	return nil
}

func (p *SpecValueSerialField) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec_bytes = &SpecValueSerial_BYTES{}
	if err := p.spec_bytes.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec_bytes), err)
	}
	return nil
}

func (p *SpecValueSerialField) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec_key = &SpecValueSerial_KEY{}
	if err := p.spec_key.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec_key), err)
	}
	return nil
}

func (p *SpecValueSerialField) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec_li = &SpecValueSerial_LI{}
	if err := p.spec_li.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec_li), err)
	}
	return nil
}

func (p *SpecValueSerialField) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec_lb = &SpecValueSerial_LB{}
	if err := p.spec_lb.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec_lb), err)
	}
	return nil
}

func (p *SpecValueSerialField) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueSerialField"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueSerialField) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "field_id", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field_id: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.field_id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.field_id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field_id: ", p), err)
	}
	return err
}

func (p *SpecValueSerialField) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetspec_int64() {
		if err := oprot.WriteFieldBegin(ctx, "spec_int64", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:spec_int64: ", p), err)
		}
		if err := p.spec_int64.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec_int64), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:spec_int64: ", p), err)
		}
	}
	return err
}

func (p *SpecValueSerialField) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetspec_double() {
		if err := oprot.WriteFieldBegin(ctx, "spec_double", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:spec_double: ", p), err)
		}
		if err := p.spec_double.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec_double), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:spec_double: ", p), err)
		}
	}
	return err
}

func (p *SpecValueSerialField) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec_bytes", thrift.STRUCT, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:spec_bytes: ", p), err)
	}
	if err := p.spec_bytes.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec_bytes), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:spec_bytes: ", p), err)
	}
	return err
}

func (p *SpecValueSerialField) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec_key", thrift.STRUCT, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:spec_key: ", p), err)
	}
	if err := p.spec_key.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec_key), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:spec_key: ", p), err)
	}
	return err
}

func (p *SpecValueSerialField) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec_li", thrift.STRUCT, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:spec_li: ", p), err)
	}
	if err := p.spec_li.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec_li), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:spec_li: ", p), err)
	}
	return err
}

func (p *SpecValueSerialField) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec_lb", thrift.STRUCT, 7); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:spec_lb: ", p), err)
	}
	if err := p.spec_lb.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec_lb), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 7:spec_lb: ", p), err)
	}
	return err
}

func (p *SpecValueSerialField) Equals(other *SpecValueSerialField) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.field_id != other.field_id { return false }
	if !p.spec_int64.Equals(other.spec_int64) { return false }
	if !p.spec_double.Equals(other.spec_double) { return false }
	if !p.spec_bytes.Equals(other.spec_bytes) { return false }
	if !p.spec_key.Equals(other.spec_key) { return false }
	if !p.spec_li.Equals(other.spec_li) { return false }
	if !p.spec_lb.Equals(other.spec_lb) { return false }
	return true
}

func (p *SpecValueSerialField) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueSerialField(%+v)", *p)
}

func (p *SpecValueSerialField) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueSerialField",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerialField)(nil)

func (p *SpecValueSerialField) Validate() error {
	return nil
}

// The Plain Value Specifications, option to use with Extended Logical Comparators
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - v: The binary(bytes) to match against the Cell value
// 
type SpecValuePlain struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	v []byte `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValuePlain() *SpecValuePlain {
	return &SpecValuePlain{}
}



func (p *SpecValuePlain) Getcomp() Comp {
	return p.comp
}



func (p *SpecValuePlain) Getv() []byte {
	return p.v
}

func (p *SpecValuePlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValuePlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecValuePlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *SpecValuePlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValuePlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValuePlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecValuePlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecValuePlain) Equals(other *SpecValuePlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if bytes.Compare(p.v, other.v) != 0 { return false }
	return true
}

func (p *SpecValuePlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValuePlain(%+v)", *p)
}

func (p *SpecValuePlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValuePlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValuePlain)(nil)

func (p *SpecValuePlain) Validate() error {
	return nil
}

// The Counter Value Specifications, option to use with Extended Logical Comparators
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - v: The int64 to match against the Cell value
// 
type SpecValueCounter struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	v int64 `thrift:"v,2" db:"v" json:"v"`
}

func NewSpecValueCounter() *SpecValueCounter {
	return &SpecValueCounter{}
}



func (p *SpecValueCounter) Getcomp() Comp {
	return p.comp
}



func (p *SpecValueCounter) Getv() int64 {
	return p.v
}

func (p *SpecValueCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecValueCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *SpecValueCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecValueCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v: ", p), err)
	}
	return err
}

func (p *SpecValueCounter) Equals(other *SpecValueCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if p.v != other.v { return false }
	return true
}

func (p *SpecValueCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueCounter(%+v)", *p)
}

func (p *SpecValueCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueCounter)(nil)

func (p *SpecValueCounter) Validate() error {
	return nil
}

// The Serial Value Specifications
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - fields: The Serial Value Specifications to match against the SERIAL Cell value fields
// 
type SpecValueSerial struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	fields SpecValueSerialFields `thrift:"fields,2" db:"fields" json:"fields"`
}

func NewSpecValueSerial() *SpecValueSerial {
	return &SpecValueSerial{}
}



func (p *SpecValueSerial) Getcomp() Comp {
	return p.comp
}



func (p *SpecValueSerial) Getfields() SpecValueSerialFields {
	return p.fields
}

func (p *SpecValueSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecValueSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecValueSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecValueSerialFields, 0, size)
	p.fields = tSlice
	for i := 0; i < size; i++ {
		_elem20 := &SpecValueSerialField{}
		if err := _elem20.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem20), err)
		}
		p.fields = append(p.fields, _elem20)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecValueSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecValueSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecValueSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecValueSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "fields", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:fields: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.fields)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.fields {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:fields: ", p), err)
	}
	return err
}

func (p *SpecValueSerial) Equals(other *SpecValueSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if len(p.fields) != len(other.fields) { return false }
	for i, _tgt := range p.fields {
		_src21 := other.fields[i]
		if !_tgt.Equals(_src21) { return false }
	}
	return true
}

func (p *SpecValueSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecValueSerial(%+v)", *p)
}

func (p *SpecValueSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecValueSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecValueSerial)(nil)

func (p *SpecValueSerial) Validate() error {
	return nil
}

// The Fraction Specifications
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - f: The binary(bytes) to match against a fraction of a Cell-Key
// 
type SpecFraction struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	f []byte `thrift:"f,2" db:"f" json:"f"`
}

func NewSpecFraction() *SpecFraction {
	return &SpecFraction{}
}



func (p *SpecFraction) Getcomp() Comp {
	return p.comp
}



func (p *SpecFraction) Getf() []byte {
	return p.f
}

func (p *SpecFraction) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecFraction) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecFraction) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.f = v
	}
	return nil
}

func (p *SpecFraction) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecFraction"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecFraction) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecFraction) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "f", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:f: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.f); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.f (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:f: ", p), err)
	}
	return err
}

func (p *SpecFraction) Equals(other *SpecFraction) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if bytes.Compare(p.f, other.f) != 0 { return false }
	return true
}

func (p *SpecFraction) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecFraction(%+v)", *p)
}

func (p *SpecFraction) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecFraction",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecFraction)(nil)

func (p *SpecFraction) Validate() error {
	return nil
}

// The Timestamp Specifications
// 
// Attributes:
//  - comp: Logical comparator to Apply
//  - ts: The timestamp in nanoseconds to match against the Cell timestamp/version (not the revision)
// 
type SpecTimestamp struct {
	comp Comp `thrift:"comp,1" db:"comp" json:"comp"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
}

func NewSpecTimestamp() *SpecTimestamp {
	return &SpecTimestamp{}
}



func (p *SpecTimestamp) Getcomp() Comp {
	return p.comp
}



func (p *SpecTimestamp) Getts() int64 {
	return p.ts
}

func (p *SpecTimestamp) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecTimestamp) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Comp(v)
		p.comp = temp
	}
	return nil
}

func (p *SpecTimestamp) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *SpecTimestamp) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecTimestamp"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecTimestamp) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:comp: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.comp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.comp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:comp: ", p), err)
	}
	return err
}

func (p *SpecTimestamp) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *SpecTimestamp) Equals(other *SpecTimestamp) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.comp != other.comp { return false }
	if p.ts != other.ts { return false }
	return true
}

func (p *SpecTimestamp) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecTimestamp(%+v)", *p)
}

func (p *SpecTimestamp) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecTimestamp",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecTimestamp)(nil)

func (p *SpecTimestamp) Validate() error {
	return nil
}

// The Key Interval Specifications
// 
// Attributes:
//  - start: The Key Start Spec, the start of cells-interval key match
//  - finish: The Key Finish Spec, the finish of cells-interval key match
// 
type SpecKeyInterval struct {
	start SpecKey `thrift:"start,1" db:"start" json:"start"`
	finish SpecKey `thrift:"finish,2" db:"finish" json:"finish"`
}

func NewSpecKeyInterval() *SpecKeyInterval {
	return &SpecKeyInterval{}
}



func (p *SpecKeyInterval) Getstart() SpecKey {
	return p.start
}



func (p *SpecKeyInterval) Getfinish() SpecKey {
	return p.finish
}

func (p *SpecKeyInterval) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecKeyInterval) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecKey, 0, size)
	p.start = tSlice
	for i := 0; i < size; i++ {
		_elem22 := &SpecFraction{}
		if err := _elem22.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem22), err)
		}
		p.start = append(p.start, _elem22)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecKeyInterval) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecKey, 0, size)
	p.finish = tSlice
	for i := 0; i < size; i++ {
		_elem23 := &SpecFraction{}
		if err := _elem23.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem23), err)
		}
		p.finish = append(p.finish, _elem23)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecKeyInterval) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecKeyInterval"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecKeyInterval) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "start", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.start)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.start {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start: ", p), err)
	}
	return err
}

func (p *SpecKeyInterval) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "finish", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:finish: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.finish)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.finish {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:finish: ", p), err)
	}
	return err
}

func (p *SpecKeyInterval) Equals(other *SpecKeyInterval) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.start) != len(other.start) { return false }
	for i, _tgt := range p.start {
		_src24 := other.start[i]
		if !_tgt.Equals(_src24) { return false }
	}
	if len(p.finish) != len(other.finish) { return false }
	for i, _tgt := range p.finish {
		_src25 := other.finish[i]
		if !_tgt.Equals(_src25) { return false }
	}
	return true
}

func (p *SpecKeyInterval) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecKeyInterval(%+v)", *p)
}

func (p *SpecKeyInterval) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecKeyInterval",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecKeyInterval)(nil)

func (p *SpecKeyInterval) Validate() error {
	return nil
}

// The Cells Interval Plain type Specifications with interval-scope Flags
// 
// Attributes:
//  - range_begin: Begin of Ranges evaluation with this Key inclusive
//  - range_end: End of Ranges evaluation with this Key inclusive
//  - offset_key: Offset Cell Key of a Scan, select cells from this key inclusive
//  - offset_rev: Offset Cell Timestamp of a Scan, select cells after this timestamp
//  - key_intervals: The Key Intervals
//  - values: The Cell Value Specifications, cell-value match for plain type
//  - ts_start: The Timestamp Start Spec, the start of cells-interval timestamp match
//  - ts_finish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
//  - flags: The Interval Flags Specification
//  - options: The Interval Options Specification
//  - updating: The Value spec of an Updating Interval
// 
type SpecIntervalPlain struct {
	range_begin Key `thrift:"range_begin,1" db:"range_begin" json:"range_begin"`
	range_end Key `thrift:"range_end,2" db:"range_end" json:"range_end"`
	offset_key Key `thrift:"offset_key,3" db:"offset_key" json:"offset_key"`
	offset_rev *int64 `thrift:"offset_rev,4" db:"offset_rev" json:"offset_rev,omitempty"`
	key_intervals SpecKeyIntervals `thrift:"key_intervals,5" db:"key_intervals" json:"key_intervals"`
	values SpecValuesPlain `thrift:"values,6" db:"values" json:"values"`
	ts_start *SpecTimestamp `thrift:"ts_start,7" db:"ts_start" json:"ts_start,omitempty"`
	ts_finish *SpecTimestamp `thrift:"ts_finish,8" db:"ts_finish" json:"ts_finish,omitempty"`
	flags *SpecFlags `thrift:"flags,9" db:"flags" json:"flags,omitempty"`
	options *SpecIntervalOptions `thrift:"options,10" db:"options" json:"options,omitempty"`
	updating *SpecIntervalUpdatePlain `thrift:"updating,11" db:"updating" json:"updating,omitempty"`
}

func NewSpecIntervalPlain() *SpecIntervalPlain {
	return &SpecIntervalPlain{}
}



func (p *SpecIntervalPlain) Getrange_begin() Key {
	return p.range_begin
}



func (p *SpecIntervalPlain) Getrange_end() Key {
	return p.range_end
}



func (p *SpecIntervalPlain) Getoffset_key() Key {
	return p.offset_key
}

var SpecIntervalPlain_offset_rev_DEFAULT int64

func (p *SpecIntervalPlain) Getoffset_rev() int64 {
	if !p.IsSetoffset_rev() {
		return SpecIntervalPlain_offset_rev_DEFAULT
	}
	return *p.offset_rev
}



func (p *SpecIntervalPlain) Getkey_intervals() SpecKeyIntervals {
	return p.key_intervals
}



func (p *SpecIntervalPlain) Getvalues() SpecValuesPlain {
	return p.values
}

var SpecIntervalPlain_ts_start_DEFAULT *SpecTimestamp

func (p *SpecIntervalPlain) Getts_start() *SpecTimestamp {
	if !p.IsSetts_start() {
		return SpecIntervalPlain_ts_start_DEFAULT
	}
	return p.ts_start
}

var SpecIntervalPlain_ts_finish_DEFAULT *SpecTimestamp

func (p *SpecIntervalPlain) Getts_finish() *SpecTimestamp {
	if !p.IsSetts_finish() {
		return SpecIntervalPlain_ts_finish_DEFAULT
	}
	return p.ts_finish
}

var SpecIntervalPlain_flags_DEFAULT *SpecFlags

func (p *SpecIntervalPlain) Getflags() *SpecFlags {
	if !p.IsSetflags() {
		return SpecIntervalPlain_flags_DEFAULT
	}
	return p.flags
}

var SpecIntervalPlain_options_DEFAULT SpecIntervalOptions

func (p *SpecIntervalPlain) Getoptions() SpecIntervalOptions {
	if !p.IsSetoptions() {
		return SpecIntervalPlain_options_DEFAULT
	}
	return *p.options
}

var SpecIntervalPlain_updating_DEFAULT *SpecIntervalUpdatePlain

func (p *SpecIntervalPlain) Getupdating() *SpecIntervalUpdatePlain {
	if !p.IsSetupdating() {
		return SpecIntervalPlain_updating_DEFAULT
	}
	return p.updating
}

func (p *SpecIntervalPlain) IsSetoffset_rev() bool {
	return p.offset_rev != nil
}

func (p *SpecIntervalPlain) IsSetts_start() bool {
	return p.ts_start != nil
}

func (p *SpecIntervalPlain) IsSetts_finish() bool {
	return p.ts_finish != nil
}

func (p *SpecIntervalPlain) IsSetflags() bool {
	return p.flags != nil
}

func (p *SpecIntervalPlain) IsSetoptions() bool {
	return p.options != nil
}

func (p *SpecIntervalPlain) IsSetupdating() bool {
	return p.updating != nil
}

func (p *SpecIntervalPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.range_begin = tSlice
	for i := 0; i < size; i++ {
		var _elem26 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem26 = v
		}
		p.range_begin = append(p.range_begin, _elem26)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.range_end = tSlice
	for i := 0; i < size; i++ {
		var _elem27 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem27 = v
		}
		p.range_end = append(p.range_end, _elem27)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.offset_key = tSlice
	for i := 0; i < size; i++ {
		var _elem28 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem28 = v
		}
		p.offset_key = append(p.offset_key, _elem28)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.offset_rev = &v
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecKeyIntervals, 0, size)
	p.key_intervals = tSlice
	for i := 0; i < size; i++ {
		_elem29 := &SpecKeyInterval{}
		if err := _elem29.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem29), err)
		}
		p.key_intervals = append(p.key_intervals, _elem29)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecValuesPlain, 0, size)
	p.values = tSlice
	for i := 0; i < size; i++ {
		_elem30 := &SpecValuePlain{}
		if err := _elem30.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem30), err)
		}
		p.values = append(p.values, _elem30)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	p.ts_start = &SpecTimestamp{}
	if err := p.ts_start.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ts_start), err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	p.ts_finish = &SpecTimestamp{}
	if err := p.ts_finish.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ts_finish), err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	p.flags = &SpecFlags{}
	if err := p.flags.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.flags), err)
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		temp := SpecIntervalOptions(v)
		p.options = &temp
	}
	return nil
}

func (p *SpecIntervalPlain) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	p.updating = &SpecIntervalUpdatePlain{}
	if err := p.updating.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.updating), err)
	}
	return nil
}

func (p *SpecIntervalPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecIntervalPlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
		if err := p.writeField11(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecIntervalPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "range_begin", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:range_begin: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.range_begin)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.range_begin {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:range_begin: ", p), err)
	}
	return err
}

func (p *SpecIntervalPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "range_end", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:range_end: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.range_end)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.range_end {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:range_end: ", p), err)
	}
	return err
}

func (p *SpecIntervalPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "offset_key", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:offset_key: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.offset_key)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.offset_key {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:offset_key: ", p), err)
	}
	return err
}

func (p *SpecIntervalPlain) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetoffset_rev() {
		if err := oprot.WriteFieldBegin(ctx, "offset_rev", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:offset_rev: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.offset_rev)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.offset_rev (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:offset_rev: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalPlain) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key_intervals", thrift.LIST, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:key_intervals: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.key_intervals)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.key_intervals {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:key_intervals: ", p), err)
	}
	return err
}

func (p *SpecIntervalPlain) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:values: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.values)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.values {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:values: ", p), err)
	}
	return err
}

func (p *SpecIntervalPlain) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_start() {
		if err := oprot.WriteFieldBegin(ctx, "ts_start", thrift.STRUCT, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:ts_start: ", p), err)
		}
		if err := p.ts_start.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ts_start), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:ts_start: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalPlain) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_finish() {
		if err := oprot.WriteFieldBegin(ctx, "ts_finish", thrift.STRUCT, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:ts_finish: ", p), err)
		}
		if err := p.ts_finish.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ts_finish), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:ts_finish: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalPlain) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetflags() {
		if err := oprot.WriteFieldBegin(ctx, "flags", thrift.STRUCT, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:flags: ", p), err)
		}
		if err := p.flags.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.flags), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:flags: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalPlain) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetoptions() {
		if err := oprot.WriteFieldBegin(ctx, "options", thrift.I32, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:options: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.options)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.options (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:options: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalPlain) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetupdating() {
		if err := oprot.WriteFieldBegin(ctx, "updating", thrift.STRUCT, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:updating: ", p), err)
		}
		if err := p.updating.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.updating), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:updating: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalPlain) Equals(other *SpecIntervalPlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.range_begin) != len(other.range_begin) { return false }
	for i, _tgt := range p.range_begin {
		_src31 := other.range_begin[i]
		if bytes.Compare(_tgt, _src31) != 0 { return false }
	}
	if len(p.range_end) != len(other.range_end) { return false }
	for i, _tgt := range p.range_end {
		_src32 := other.range_end[i]
		if bytes.Compare(_tgt, _src32) != 0 { return false }
	}
	if len(p.offset_key) != len(other.offset_key) { return false }
	for i, _tgt := range p.offset_key {
		_src33 := other.offset_key[i]
		if bytes.Compare(_tgt, _src33) != 0 { return false }
	}
	if p.offset_rev != other.offset_rev {
		if p.offset_rev == nil || other.offset_rev == nil {
			return false
		}
		if (*p.offset_rev) != (*other.offset_rev) { return false }
	}
	if len(p.key_intervals) != len(other.key_intervals) { return false }
	for i, _tgt := range p.key_intervals {
		_src34 := other.key_intervals[i]
		if !_tgt.Equals(_src34) { return false }
	}
	if len(p.values) != len(other.values) { return false }
	for i, _tgt := range p.values {
		_src35 := other.values[i]
		if !_tgt.Equals(_src35) { return false }
	}
	if !p.ts_start.Equals(other.ts_start) { return false }
	if !p.ts_finish.Equals(other.ts_finish) { return false }
	if !p.flags.Equals(other.flags) { return false }
	if p.options != other.options {
		if p.options == nil || other.options == nil {
			return false
		}
		if (*p.options) != (*other.options) { return false }
	}
	if !p.updating.Equals(other.updating) { return false }
	return true
}

func (p *SpecIntervalPlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecIntervalPlain(%+v)", *p)
}

func (p *SpecIntervalPlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecIntervalPlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalPlain)(nil)

func (p *SpecIntervalPlain) Validate() error {
	return nil
}

// The Cells Interval Counter type Specifications with interval-scope Flags
// 
// Attributes:
//  - range_begin: Begin of Ranges evaluation with this Key inclusive
//  - range_end: End of Ranges evaluation with this Key inclusive
//  - offset_key: Offset Cell Key of a Scan, select cells from this key inclusive
//  - offset_rev: Offset Cell Timestamp of a Scan, select cells after this timestamp
//  - key_intervals: The Key Intervals
//  - values: The Cell Value Specifications, cell-value match for counter type
//  - ts_start: The Timestamp Start Spec, the start of cells-interval timestamp match
//  - ts_finish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
//  - flags: The Interval Flags Specification
//  - options: The Interval Options Specification
//  - updating: The Value spec of an Updating Interval
// 
type SpecIntervalCounter struct {
	range_begin Key `thrift:"range_begin,1" db:"range_begin" json:"range_begin"`
	range_end Key `thrift:"range_end,2" db:"range_end" json:"range_end"`
	offset_key Key `thrift:"offset_key,3" db:"offset_key" json:"offset_key"`
	offset_rev *int64 `thrift:"offset_rev,4" db:"offset_rev" json:"offset_rev,omitempty"`
	key_intervals SpecKeyIntervals `thrift:"key_intervals,5" db:"key_intervals" json:"key_intervals"`
	values SpecValuesCounter `thrift:"values,6" db:"values" json:"values"`
	ts_start *SpecTimestamp `thrift:"ts_start,7" db:"ts_start" json:"ts_start,omitempty"`
	ts_finish *SpecTimestamp `thrift:"ts_finish,8" db:"ts_finish" json:"ts_finish,omitempty"`
	flags *SpecFlags `thrift:"flags,9" db:"flags" json:"flags,omitempty"`
	options *SpecIntervalOptions `thrift:"options,10" db:"options" json:"options,omitempty"`
	updating *SpecIntervalUpdateCounter `thrift:"updating,11" db:"updating" json:"updating,omitempty"`
}

func NewSpecIntervalCounter() *SpecIntervalCounter {
	return &SpecIntervalCounter{}
}



func (p *SpecIntervalCounter) Getrange_begin() Key {
	return p.range_begin
}



func (p *SpecIntervalCounter) Getrange_end() Key {
	return p.range_end
}



func (p *SpecIntervalCounter) Getoffset_key() Key {
	return p.offset_key
}

var SpecIntervalCounter_offset_rev_DEFAULT int64

func (p *SpecIntervalCounter) Getoffset_rev() int64 {
	if !p.IsSetoffset_rev() {
		return SpecIntervalCounter_offset_rev_DEFAULT
	}
	return *p.offset_rev
}



func (p *SpecIntervalCounter) Getkey_intervals() SpecKeyIntervals {
	return p.key_intervals
}



func (p *SpecIntervalCounter) Getvalues() SpecValuesCounter {
	return p.values
}

var SpecIntervalCounter_ts_start_DEFAULT *SpecTimestamp

func (p *SpecIntervalCounter) Getts_start() *SpecTimestamp {
	if !p.IsSetts_start() {
		return SpecIntervalCounter_ts_start_DEFAULT
	}
	return p.ts_start
}

var SpecIntervalCounter_ts_finish_DEFAULT *SpecTimestamp

func (p *SpecIntervalCounter) Getts_finish() *SpecTimestamp {
	if !p.IsSetts_finish() {
		return SpecIntervalCounter_ts_finish_DEFAULT
	}
	return p.ts_finish
}

var SpecIntervalCounter_flags_DEFAULT *SpecFlags

func (p *SpecIntervalCounter) Getflags() *SpecFlags {
	if !p.IsSetflags() {
		return SpecIntervalCounter_flags_DEFAULT
	}
	return p.flags
}

var SpecIntervalCounter_options_DEFAULT SpecIntervalOptions

func (p *SpecIntervalCounter) Getoptions() SpecIntervalOptions {
	if !p.IsSetoptions() {
		return SpecIntervalCounter_options_DEFAULT
	}
	return *p.options
}

var SpecIntervalCounter_updating_DEFAULT *SpecIntervalUpdateCounter

func (p *SpecIntervalCounter) Getupdating() *SpecIntervalUpdateCounter {
	if !p.IsSetupdating() {
		return SpecIntervalCounter_updating_DEFAULT
	}
	return p.updating
}

func (p *SpecIntervalCounter) IsSetoffset_rev() bool {
	return p.offset_rev != nil
}

func (p *SpecIntervalCounter) IsSetts_start() bool {
	return p.ts_start != nil
}

func (p *SpecIntervalCounter) IsSetts_finish() bool {
	return p.ts_finish != nil
}

func (p *SpecIntervalCounter) IsSetflags() bool {
	return p.flags != nil
}

func (p *SpecIntervalCounter) IsSetoptions() bool {
	return p.options != nil
}

func (p *SpecIntervalCounter) IsSetupdating() bool {
	return p.updating != nil
}

func (p *SpecIntervalCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.range_begin = tSlice
	for i := 0; i < size; i++ {
		var _elem36 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem36 = v
		}
		p.range_begin = append(p.range_begin, _elem36)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.range_end = tSlice
	for i := 0; i < size; i++ {
		var _elem37 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem37 = v
		}
		p.range_end = append(p.range_end, _elem37)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.offset_key = tSlice
	for i := 0; i < size; i++ {
		var _elem38 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem38 = v
		}
		p.offset_key = append(p.offset_key, _elem38)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.offset_rev = &v
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecKeyIntervals, 0, size)
	p.key_intervals = tSlice
	for i := 0; i < size; i++ {
		_elem39 := &SpecKeyInterval{}
		if err := _elem39.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem39), err)
		}
		p.key_intervals = append(p.key_intervals, _elem39)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecValuesCounter, 0, size)
	p.values = tSlice
	for i := 0; i < size; i++ {
		_elem40 := &SpecValueCounter{}
		if err := _elem40.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem40), err)
		}
		p.values = append(p.values, _elem40)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	p.ts_start = &SpecTimestamp{}
	if err := p.ts_start.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ts_start), err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	p.ts_finish = &SpecTimestamp{}
	if err := p.ts_finish.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ts_finish), err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	p.flags = &SpecFlags{}
	if err := p.flags.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.flags), err)
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		temp := SpecIntervalOptions(v)
		p.options = &temp
	}
	return nil
}

func (p *SpecIntervalCounter) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	p.updating = &SpecIntervalUpdateCounter{}
	if err := p.updating.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.updating), err)
	}
	return nil
}

func (p *SpecIntervalCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecIntervalCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
		if err := p.writeField11(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecIntervalCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "range_begin", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:range_begin: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.range_begin)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.range_begin {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:range_begin: ", p), err)
	}
	return err
}

func (p *SpecIntervalCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "range_end", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:range_end: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.range_end)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.range_end {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:range_end: ", p), err)
	}
	return err
}

func (p *SpecIntervalCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "offset_key", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:offset_key: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.offset_key)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.offset_key {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:offset_key: ", p), err)
	}
	return err
}

func (p *SpecIntervalCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetoffset_rev() {
		if err := oprot.WriteFieldBegin(ctx, "offset_rev", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:offset_rev: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.offset_rev)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.offset_rev (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:offset_rev: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalCounter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key_intervals", thrift.LIST, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:key_intervals: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.key_intervals)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.key_intervals {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:key_intervals: ", p), err)
	}
	return err
}

func (p *SpecIntervalCounter) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:values: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.values)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.values {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:values: ", p), err)
	}
	return err
}

func (p *SpecIntervalCounter) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_start() {
		if err := oprot.WriteFieldBegin(ctx, "ts_start", thrift.STRUCT, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:ts_start: ", p), err)
		}
		if err := p.ts_start.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ts_start), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:ts_start: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalCounter) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_finish() {
		if err := oprot.WriteFieldBegin(ctx, "ts_finish", thrift.STRUCT, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:ts_finish: ", p), err)
		}
		if err := p.ts_finish.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ts_finish), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:ts_finish: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalCounter) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetflags() {
		if err := oprot.WriteFieldBegin(ctx, "flags", thrift.STRUCT, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:flags: ", p), err)
		}
		if err := p.flags.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.flags), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:flags: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalCounter) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetoptions() {
		if err := oprot.WriteFieldBegin(ctx, "options", thrift.I32, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:options: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.options)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.options (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:options: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalCounter) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetupdating() {
		if err := oprot.WriteFieldBegin(ctx, "updating", thrift.STRUCT, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:updating: ", p), err)
		}
		if err := p.updating.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.updating), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:updating: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalCounter) Equals(other *SpecIntervalCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.range_begin) != len(other.range_begin) { return false }
	for i, _tgt := range p.range_begin {
		_src41 := other.range_begin[i]
		if bytes.Compare(_tgt, _src41) != 0 { return false }
	}
	if len(p.range_end) != len(other.range_end) { return false }
	for i, _tgt := range p.range_end {
		_src42 := other.range_end[i]
		if bytes.Compare(_tgt, _src42) != 0 { return false }
	}
	if len(p.offset_key) != len(other.offset_key) { return false }
	for i, _tgt := range p.offset_key {
		_src43 := other.offset_key[i]
		if bytes.Compare(_tgt, _src43) != 0 { return false }
	}
	if p.offset_rev != other.offset_rev {
		if p.offset_rev == nil || other.offset_rev == nil {
			return false
		}
		if (*p.offset_rev) != (*other.offset_rev) { return false }
	}
	if len(p.key_intervals) != len(other.key_intervals) { return false }
	for i, _tgt := range p.key_intervals {
		_src44 := other.key_intervals[i]
		if !_tgt.Equals(_src44) { return false }
	}
	if len(p.values) != len(other.values) { return false }
	for i, _tgt := range p.values {
		_src45 := other.values[i]
		if !_tgt.Equals(_src45) { return false }
	}
	if !p.ts_start.Equals(other.ts_start) { return false }
	if !p.ts_finish.Equals(other.ts_finish) { return false }
	if !p.flags.Equals(other.flags) { return false }
	if p.options != other.options {
		if p.options == nil || other.options == nil {
			return false
		}
		if (*p.options) != (*other.options) { return false }
	}
	if !p.updating.Equals(other.updating) { return false }
	return true
}

func (p *SpecIntervalCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecIntervalCounter(%+v)", *p)
}

func (p *SpecIntervalCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecIntervalCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalCounter)(nil)

func (p *SpecIntervalCounter) Validate() error {
	return nil
}

// The Cells Interval Serial type Specifications with interval-scope Flags
// 
// Attributes:
//  - range_begin: Begin of Ranges evaluation with this Key inclusive
//  - range_end: End of Ranges evaluation with this Key inclusive
//  - offset_key: Offset Cell Key of a Scan, select cells from this key inclusive
//  - offset_rev: Offset Cell Timestamp of a Scan, select cells after this timestamp
//  - key_intervals: The Key Intervals
//  - values: The Serial Cell Value Specifications, cell-value fields match
//  - ts_start: The Timestamp Start Spec, the start of cells-interval timestamp match
//  - ts_finish: The Timestamp Finish Spec, the finish of cells-interval timestamp match
//  - flags: The Interval Flags Specification
//  - options: The Interval Options Specification
//  - updating: The Serial-Value spec of an Updating Interval
// 
type SpecIntervalSerial struct {
	range_begin Key `thrift:"range_begin,1" db:"range_begin" json:"range_begin"`
	range_end Key `thrift:"range_end,2" db:"range_end" json:"range_end"`
	offset_key Key `thrift:"offset_key,3" db:"offset_key" json:"offset_key"`
	offset_rev *int64 `thrift:"offset_rev,4" db:"offset_rev" json:"offset_rev,omitempty"`
	key_intervals SpecKeyIntervals `thrift:"key_intervals,5" db:"key_intervals" json:"key_intervals"`
	values SpecValuesSerial `thrift:"values,6" db:"values" json:"values"`
	ts_start *SpecTimestamp `thrift:"ts_start,7" db:"ts_start" json:"ts_start,omitempty"`
	ts_finish *SpecTimestamp `thrift:"ts_finish,8" db:"ts_finish" json:"ts_finish,omitempty"`
	flags *SpecFlags `thrift:"flags,9" db:"flags" json:"flags,omitempty"`
	options *SpecIntervalOptions `thrift:"options,10" db:"options" json:"options,omitempty"`
	updating *SpecIntervalUpdateSerial `thrift:"updating,11" db:"updating" json:"updating,omitempty"`
}

func NewSpecIntervalSerial() *SpecIntervalSerial {
	return &SpecIntervalSerial{}
}



func (p *SpecIntervalSerial) Getrange_begin() Key {
	return p.range_begin
}



func (p *SpecIntervalSerial) Getrange_end() Key {
	return p.range_end
}



func (p *SpecIntervalSerial) Getoffset_key() Key {
	return p.offset_key
}

var SpecIntervalSerial_offset_rev_DEFAULT int64

func (p *SpecIntervalSerial) Getoffset_rev() int64 {
	if !p.IsSetoffset_rev() {
		return SpecIntervalSerial_offset_rev_DEFAULT
	}
	return *p.offset_rev
}



func (p *SpecIntervalSerial) Getkey_intervals() SpecKeyIntervals {
	return p.key_intervals
}



func (p *SpecIntervalSerial) Getvalues() SpecValuesSerial {
	return p.values
}

var SpecIntervalSerial_ts_start_DEFAULT *SpecTimestamp

func (p *SpecIntervalSerial) Getts_start() *SpecTimestamp {
	if !p.IsSetts_start() {
		return SpecIntervalSerial_ts_start_DEFAULT
	}
	return p.ts_start
}

var SpecIntervalSerial_ts_finish_DEFAULT *SpecTimestamp

func (p *SpecIntervalSerial) Getts_finish() *SpecTimestamp {
	if !p.IsSetts_finish() {
		return SpecIntervalSerial_ts_finish_DEFAULT
	}
	return p.ts_finish
}

var SpecIntervalSerial_flags_DEFAULT *SpecFlags

func (p *SpecIntervalSerial) Getflags() *SpecFlags {
	if !p.IsSetflags() {
		return SpecIntervalSerial_flags_DEFAULT
	}
	return p.flags
}

var SpecIntervalSerial_options_DEFAULT SpecIntervalOptions

func (p *SpecIntervalSerial) Getoptions() SpecIntervalOptions {
	if !p.IsSetoptions() {
		return SpecIntervalSerial_options_DEFAULT
	}
	return *p.options
}

var SpecIntervalSerial_updating_DEFAULT *SpecIntervalUpdateSerial

func (p *SpecIntervalSerial) Getupdating() *SpecIntervalUpdateSerial {
	if !p.IsSetupdating() {
		return SpecIntervalSerial_updating_DEFAULT
	}
	return p.updating
}

func (p *SpecIntervalSerial) IsSetoffset_rev() bool {
	return p.offset_rev != nil
}

func (p *SpecIntervalSerial) IsSetts_start() bool {
	return p.ts_start != nil
}

func (p *SpecIntervalSerial) IsSetts_finish() bool {
	return p.ts_finish != nil
}

func (p *SpecIntervalSerial) IsSetflags() bool {
	return p.flags != nil
}

func (p *SpecIntervalSerial) IsSetoptions() bool {
	return p.options != nil
}

func (p *SpecIntervalSerial) IsSetupdating() bool {
	return p.updating != nil
}

func (p *SpecIntervalSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.range_begin = tSlice
	for i := 0; i < size; i++ {
		var _elem46 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem46 = v
		}
		p.range_begin = append(p.range_begin, _elem46)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.range_end = tSlice
	for i := 0; i < size; i++ {
		var _elem47 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem47 = v
		}
		p.range_end = append(p.range_end, _elem47)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.offset_key = tSlice
	for i := 0; i < size; i++ {
		var _elem48 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem48 = v
		}
		p.offset_key = append(p.offset_key, _elem48)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.offset_rev = &v
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecKeyIntervals, 0, size)
	p.key_intervals = tSlice
	for i := 0; i < size; i++ {
		_elem49 := &SpecKeyInterval{}
		if err := _elem49.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem49), err)
		}
		p.key_intervals = append(p.key_intervals, _elem49)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(SpecValuesSerial, 0, size)
	p.values = tSlice
	for i := 0; i < size; i++ {
		_elem50 := &SpecValueSerial{}
		if err := _elem50.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem50), err)
		}
		p.values = append(p.values, _elem50)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	p.ts_start = &SpecTimestamp{}
	if err := p.ts_start.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ts_start), err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	p.ts_finish = &SpecTimestamp{}
	if err := p.ts_finish.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ts_finish), err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	p.flags = &SpecFlags{}
	if err := p.flags.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.flags), err)
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		temp := SpecIntervalOptions(v)
		p.options = &temp
	}
	return nil
}

func (p *SpecIntervalSerial) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	p.updating = &SpecIntervalUpdateSerial{}
	if err := p.updating.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.updating), err)
	}
	return nil
}

func (p *SpecIntervalSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecIntervalSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
		if err := p.writeField11(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecIntervalSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "range_begin", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:range_begin: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.range_begin)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.range_begin {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:range_begin: ", p), err)
	}
	return err
}

func (p *SpecIntervalSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "range_end", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:range_end: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.range_end)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.range_end {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:range_end: ", p), err)
	}
	return err
}

func (p *SpecIntervalSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "offset_key", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:offset_key: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.offset_key)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.offset_key {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:offset_key: ", p), err)
	}
	return err
}

func (p *SpecIntervalSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetoffset_rev() {
		if err := oprot.WriteFieldBegin(ctx, "offset_rev", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:offset_rev: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.offset_rev)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.offset_rev (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:offset_rev: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalSerial) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "key_intervals", thrift.LIST, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:key_intervals: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.key_intervals)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.key_intervals {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:key_intervals: ", p), err)
	}
	return err
}

func (p *SpecIntervalSerial) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:values: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.values)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.values {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:values: ", p), err)
	}
	return err
}

func (p *SpecIntervalSerial) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_start() {
		if err := oprot.WriteFieldBegin(ctx, "ts_start", thrift.STRUCT, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:ts_start: ", p), err)
		}
		if err := p.ts_start.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ts_start), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:ts_start: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalSerial) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_finish() {
		if err := oprot.WriteFieldBegin(ctx, "ts_finish", thrift.STRUCT, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:ts_finish: ", p), err)
		}
		if err := p.ts_finish.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ts_finish), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:ts_finish: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalSerial) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetflags() {
		if err := oprot.WriteFieldBegin(ctx, "flags", thrift.STRUCT, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:flags: ", p), err)
		}
		if err := p.flags.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.flags), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:flags: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalSerial) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetoptions() {
		if err := oprot.WriteFieldBegin(ctx, "options", thrift.I32, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:options: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.options)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.options (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:options: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalSerial) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetupdating() {
		if err := oprot.WriteFieldBegin(ctx, "updating", thrift.STRUCT, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:updating: ", p), err)
		}
		if err := p.updating.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.updating), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:updating: ", p), err)
		}
	}
	return err
}

func (p *SpecIntervalSerial) Equals(other *SpecIntervalSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.range_begin) != len(other.range_begin) { return false }
	for i, _tgt := range p.range_begin {
		_src51 := other.range_begin[i]
		if bytes.Compare(_tgt, _src51) != 0 { return false }
	}
	if len(p.range_end) != len(other.range_end) { return false }
	for i, _tgt := range p.range_end {
		_src52 := other.range_end[i]
		if bytes.Compare(_tgt, _src52) != 0 { return false }
	}
	if len(p.offset_key) != len(other.offset_key) { return false }
	for i, _tgt := range p.offset_key {
		_src53 := other.offset_key[i]
		if bytes.Compare(_tgt, _src53) != 0 { return false }
	}
	if p.offset_rev != other.offset_rev {
		if p.offset_rev == nil || other.offset_rev == nil {
			return false
		}
		if (*p.offset_rev) != (*other.offset_rev) { return false }
	}
	if len(p.key_intervals) != len(other.key_intervals) { return false }
	for i, _tgt := range p.key_intervals {
		_src54 := other.key_intervals[i]
		if !_tgt.Equals(_src54) { return false }
	}
	if len(p.values) != len(other.values) { return false }
	for i, _tgt := range p.values {
		_src55 := other.values[i]
		if !_tgt.Equals(_src55) { return false }
	}
	if !p.ts_start.Equals(other.ts_start) { return false }
	if !p.ts_finish.Equals(other.ts_finish) { return false }
	if !p.flags.Equals(other.flags) { return false }
	if p.options != other.options {
		if p.options == nil || other.options == nil {
			return false
		}
		if (*p.options) != (*other.options) { return false }
	}
	if !p.updating.Equals(other.updating) { return false }
	return true
}

func (p *SpecIntervalSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecIntervalSerial(%+v)", *p)
}

func (p *SpecIntervalSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecIntervalSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecIntervalSerial)(nil)

func (p *SpecIntervalSerial) Validate() error {
	return nil
}

// The Column Specifications, the Cells-Intervals(SpecIntervalPlain/s) specification for a PLAIN Type column
// 
// Attributes:
//  - cid: The Column ID
//  - intervals: The Cells Interval in a list-container
// 
type SpecColumnPlain struct {
	cid int64 `thrift:"cid,1" db:"cid" json:"cid"`
	intervals []*SpecIntervalPlain `thrift:"intervals,2" db:"intervals" json:"intervals"`
}

func NewSpecColumnPlain() *SpecColumnPlain {
	return &SpecColumnPlain{}
}



func (p *SpecColumnPlain) Getcid() int64 {
	return p.cid
}



func (p *SpecColumnPlain) Getintervals() []*SpecIntervalPlain {
	return p.intervals
}

func (p *SpecColumnPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecColumnPlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.cid = v
	}
	return nil
}

func (p *SpecColumnPlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecIntervalPlain, 0, size)
	p.intervals = tSlice
	for i := 0; i < size; i++ {
		_elem56 := &SpecIntervalPlain{}
		if err := _elem56.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem56), err)
		}
		p.intervals = append(p.intervals, _elem56)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecColumnPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecColumnPlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecColumnPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.cid)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err)
	}
	return err
}

func (p *SpecColumnPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "intervals", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:intervals: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.intervals)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.intervals {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:intervals: ", p), err)
	}
	return err
}

func (p *SpecColumnPlain) Equals(other *SpecColumnPlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.cid != other.cid { return false }
	if len(p.intervals) != len(other.intervals) { return false }
	for i, _tgt := range p.intervals {
		_src57 := other.intervals[i]
		if !_tgt.Equals(_src57) { return false }
	}
	return true
}

func (p *SpecColumnPlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecColumnPlain(%+v)", *p)
}

func (p *SpecColumnPlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecColumnPlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecColumnPlain)(nil)

func (p *SpecColumnPlain) Validate() error {
	return nil
}

// The Column Specifications, the Cells-Intervals(SpecIntervalCounter/s) specification for a COUNTER Type column
// 
// Attributes:
//  - cid: The Column ID
//  - intervals: The Cells Interval in a list-container
// 
type SpecColumnCounter struct {
	cid int64 `thrift:"cid,1" db:"cid" json:"cid"`
	intervals []*SpecIntervalCounter `thrift:"intervals,2" db:"intervals" json:"intervals"`
}

func NewSpecColumnCounter() *SpecColumnCounter {
	return &SpecColumnCounter{}
}



func (p *SpecColumnCounter) Getcid() int64 {
	return p.cid
}



func (p *SpecColumnCounter) Getintervals() []*SpecIntervalCounter {
	return p.intervals
}

func (p *SpecColumnCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecColumnCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.cid = v
	}
	return nil
}

func (p *SpecColumnCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecIntervalCounter, 0, size)
	p.intervals = tSlice
	for i := 0; i < size; i++ {
		_elem58 := &SpecIntervalCounter{}
		if err := _elem58.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem58), err)
		}
		p.intervals = append(p.intervals, _elem58)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecColumnCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecColumnCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecColumnCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.cid)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err)
	}
	return err
}

func (p *SpecColumnCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "intervals", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:intervals: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.intervals)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.intervals {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:intervals: ", p), err)
	}
	return err
}

func (p *SpecColumnCounter) Equals(other *SpecColumnCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.cid != other.cid { return false }
	if len(p.intervals) != len(other.intervals) { return false }
	for i, _tgt := range p.intervals {
		_src59 := other.intervals[i]
		if !_tgt.Equals(_src59) { return false }
	}
	return true
}

func (p *SpecColumnCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecColumnCounter(%+v)", *p)
}

func (p *SpecColumnCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecColumnCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecColumnCounter)(nil)

func (p *SpecColumnCounter) Validate() error {
	return nil
}

// The Column Specifications, the Cells-Intervals(SpecIntervalSerial/s) specification for a SERIAL Type Column
// 
// Attributes:
//  - cid: The Column ID
//  - intervals: The Serial Cells Interval in a list-container
// 
type SpecColumnSerial struct {
	cid int64 `thrift:"cid,1" db:"cid" json:"cid"`
	intervals []*SpecIntervalSerial `thrift:"intervals,2" db:"intervals" json:"intervals"`
}

func NewSpecColumnSerial() *SpecColumnSerial {
	return &SpecColumnSerial{}
}



func (p *SpecColumnSerial) Getcid() int64 {
	return p.cid
}



func (p *SpecColumnSerial) Getintervals() []*SpecIntervalSerial {
	return p.intervals
}

func (p *SpecColumnSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecColumnSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.cid = v
	}
	return nil
}

func (p *SpecColumnSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecIntervalSerial, 0, size)
	p.intervals = tSlice
	for i := 0; i < size; i++ {
		_elem60 := &SpecIntervalSerial{}
		if err := _elem60.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem60), err)
		}
		p.intervals = append(p.intervals, _elem60)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecColumnSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecColumnSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecColumnSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.cid)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err)
	}
	return err
}

func (p *SpecColumnSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "intervals", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:intervals: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.intervals)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.intervals {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:intervals: ", p), err)
	}
	return err
}

func (p *SpecColumnSerial) Equals(other *SpecColumnSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.cid != other.cid { return false }
	if len(p.intervals) != len(other.intervals) { return false }
	for i, _tgt := range p.intervals {
		_src61 := other.intervals[i]
		if !_tgt.Equals(_src61) { return false }
	}
	return true
}

func (p *SpecColumnSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecColumnSerial(%+v)", *p)
}

func (p *SpecColumnSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecColumnSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecColumnSerial)(nil)

func (p *SpecColumnSerial) Validate() error {
	return nil
}

// The Scan Specifications, the Columns-Intervals(SpecColumn/s) with global-scope Flags
// 
// Attributes:
//  - columns_plain: The Plain Column Intervals(SpecColumnPlain) in a list-container
//  - columns_counter: The Counter Column Intervals(SpecColumnCounter) in a list-container
//  - columns_serial: The Serial Column Intervals(SpecColumnSerial) in a list-container
//  - flags: The Global Flags Specification
// 
type SpecScan struct {
	columns_plain []*SpecColumnPlain `thrift:"columns_plain,1" db:"columns_plain" json:"columns_plain"`
	columns_counter []*SpecColumnCounter `thrift:"columns_counter,2" db:"columns_counter" json:"columns_counter"`
	columns_serial []*SpecColumnSerial `thrift:"columns_serial,3" db:"columns_serial" json:"columns_serial"`
	flags *SpecFlags `thrift:"flags,4" db:"flags" json:"flags,omitempty"`
}

func NewSpecScan() *SpecScan {
	return &SpecScan{}
}



func (p *SpecScan) Getcolumns_plain() []*SpecColumnPlain {
	return p.columns_plain
}



func (p *SpecScan) Getcolumns_counter() []*SpecColumnCounter {
	return p.columns_counter
}



func (p *SpecScan) Getcolumns_serial() []*SpecColumnSerial {
	return p.columns_serial
}

var SpecScan_flags_DEFAULT *SpecFlags

func (p *SpecScan) Getflags() *SpecFlags {
	if !p.IsSetflags() {
		return SpecScan_flags_DEFAULT
	}
	return p.flags
}

func (p *SpecScan) IsSetflags() bool {
	return p.flags != nil
}

func (p *SpecScan) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SpecScan) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecColumnPlain, 0, size)
	p.columns_plain = tSlice
	for i := 0; i < size; i++ {
		_elem62 := &SpecColumnPlain{}
		if err := _elem62.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem62), err)
		}
		p.columns_plain = append(p.columns_plain, _elem62)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecScan) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecColumnCounter, 0, size)
	p.columns_counter = tSlice
	for i := 0; i < size; i++ {
		_elem63 := &SpecColumnCounter{}
		if err := _elem63.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem63), err)
		}
		p.columns_counter = append(p.columns_counter, _elem63)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecScan) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*SpecColumnSerial, 0, size)
	p.columns_serial = tSlice
	for i := 0; i < size; i++ {
		_elem64 := &SpecColumnSerial{}
		if err := _elem64.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem64), err)
		}
		p.columns_serial = append(p.columns_serial, _elem64)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *SpecScan) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.flags = &SpecFlags{}
	if err := p.flags.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.flags), err)
	}
	return nil
}

func (p *SpecScan) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SpecScan"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SpecScan) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "columns_plain", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:columns_plain: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.columns_plain)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.columns_plain {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:columns_plain: ", p), err)
	}
	return err
}

func (p *SpecScan) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "columns_counter", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:columns_counter: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.columns_counter)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.columns_counter {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:columns_counter: ", p), err)
	}
	return err
}

func (p *SpecScan) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "columns_serial", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:columns_serial: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.columns_serial)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.columns_serial {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:columns_serial: ", p), err)
	}
	return err
}

func (p *SpecScan) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetflags() {
		if err := oprot.WriteFieldBegin(ctx, "flags", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:flags: ", p), err)
		}
		if err := p.flags.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.flags), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:flags: ", p), err)
		}
	}
	return err
}

func (p *SpecScan) Equals(other *SpecScan) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.columns_plain) != len(other.columns_plain) { return false }
	for i, _tgt := range p.columns_plain {
		_src65 := other.columns_plain[i]
		if !_tgt.Equals(_src65) { return false }
	}
	if len(p.columns_counter) != len(other.columns_counter) { return false }
	for i, _tgt := range p.columns_counter {
		_src66 := other.columns_counter[i]
		if !_tgt.Equals(_src66) { return false }
	}
	if len(p.columns_serial) != len(other.columns_serial) { return false }
	for i, _tgt := range p.columns_serial {
		_src67 := other.columns_serial[i]
		if !_tgt.Equals(_src67) { return false }
	}
	if !p.flags.Equals(other.flags) { return false }
	return true
}

func (p *SpecScan) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SpecScan(%+v)", *p)
}

func (p *SpecScan) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.SpecScan",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*SpecScan)(nil)

func (p *SpecScan) Validate() error {
	return nil
}

// The Cell data for using with Update of PLAIN Column Type
// 
// Attributes:
//  - f: The Cell Flag
//  - k: The Cell Key
//  - ts: The Cell Timestamp in nanoseconds
//  - ts_desc: The Cell Version is in timestamp descending
//  - v: The Cell Value
//  - encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
// 
type UCellPlain struct {
	f Flag `thrift:"f,1" db:"f" json:"f"`
	k Key `thrift:"k,2" db:"k" json:"k"`
	ts *int64 `thrift:"ts,3" db:"ts" json:"ts,omitempty"`
	ts_desc *bool `thrift:"ts_desc,4" db:"ts_desc" json:"ts_desc,omitempty"`
	v []byte `thrift:"v,5" db:"v" json:"v"`
	encoder *EncodingType `thrift:"encoder,6" db:"encoder" json:"encoder,omitempty"`
}

func NewUCellPlain() *UCellPlain {
	return &UCellPlain{}
}



func (p *UCellPlain) Getf() Flag {
	return p.f
}



func (p *UCellPlain) Getk() Key {
	return p.k
}

var UCellPlain_ts_DEFAULT int64

func (p *UCellPlain) Getts() int64 {
	if !p.IsSetts() {
		return UCellPlain_ts_DEFAULT
	}
	return *p.ts
}

var UCellPlain_ts_desc_DEFAULT bool

func (p *UCellPlain) Getts_desc() bool {
	if !p.IsSetts_desc() {
		return UCellPlain_ts_desc_DEFAULT
	}
	return *p.ts_desc
}



func (p *UCellPlain) Getv() []byte {
	return p.v
}

var UCellPlain_encoder_DEFAULT EncodingType

func (p *UCellPlain) Getencoder() EncodingType {
	if !p.IsSetencoder() {
		return UCellPlain_encoder_DEFAULT
	}
	return *p.encoder
}

func (p *UCellPlain) IsSetts() bool {
	return p.ts != nil
}

func (p *UCellPlain) IsSetts_desc() bool {
	return p.ts_desc != nil
}

func (p *UCellPlain) IsSetencoder() bool {
	return p.encoder != nil
}

func (p *UCellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UCellPlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Flag(v)
		p.f = temp
	}
	return nil
}

func (p *UCellPlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem68 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem68 = v
		}
		p.k = append(p.k, _elem68)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *UCellPlain) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ts = &v
	}
	return nil
}

func (p *UCellPlain) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ts_desc = &v
	}
	return nil
}

func (p *UCellPlain) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *UCellPlain) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		temp := EncodingType(v)
		p.encoder = &temp
	}
	return nil
}

func (p *UCellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UCellPlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UCellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "f", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:f: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.f)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.f (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:f: ", p), err)
	}
	return err
}

func (p *UCellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err)
	}
	return err
}

func (p *UCellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts() {
		if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.ts)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err)
		}
	}
	return err
}

func (p *UCellPlain) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_desc() {
		if err := oprot.WriteFieldBegin(ctx, "ts_desc", thrift.BOOL, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ts_desc: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.ts_desc)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ts_desc (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ts_desc: ", p), err)
		}
	}
	return err
}

func (p *UCellPlain) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err)
	}
	return err
}

func (p *UCellPlain) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetencoder() {
		if err := oprot.WriteFieldBegin(ctx, "encoder", thrift.I32, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:encoder: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.encoder)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.encoder (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:encoder: ", p), err)
		}
	}
	return err
}

func (p *UCellPlain) Equals(other *UCellPlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.f != other.f { return false }
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src69 := other.k[i]
		if bytes.Compare(_tgt, _src69) != 0 { return false }
	}
	if p.ts != other.ts {
		if p.ts == nil || other.ts == nil {
			return false
		}
		if (*p.ts) != (*other.ts) { return false }
	}
	if p.ts_desc != other.ts_desc {
		if p.ts_desc == nil || other.ts_desc == nil {
			return false
		}
		if (*p.ts_desc) != (*other.ts_desc) { return false }
	}
	if bytes.Compare(p.v, other.v) != 0 { return false }
	if p.encoder != other.encoder {
		if p.encoder == nil || other.encoder == nil {
			return false
		}
		if (*p.encoder) != (*other.encoder) { return false }
	}
	return true
}

func (p *UCellPlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UCellPlain(%+v)", *p)
}

func (p *UCellPlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.UCellPlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*UCellPlain)(nil)

func (p *UCellPlain) Validate() error {
	return nil
}

// The Cell data for using with Update of COUNTER Column Type
// 
// Attributes:
//  - f: The Cell Flag
//  - k: The Cell Key
//  - ts: The Cell Timestamp in nanoseconds
//  - ts_desc: The Cell Version is in timestamp descending
//  - op: The Cell Counter Operation
//  - v: The Cell Counter Value
// 
type UCellCounter struct {
	f Flag `thrift:"f,1" db:"f" json:"f"`
	k Key `thrift:"k,2" db:"k" json:"k"`
	ts *int64 `thrift:"ts,3" db:"ts" json:"ts,omitempty"`
	ts_desc *bool `thrift:"ts_desc,4" db:"ts_desc" json:"ts_desc,omitempty"`
	op int8 `thrift:"op,5" db:"op" json:"op"`
	v int64 `thrift:"v,6" db:"v" json:"v"`
}

func NewUCellCounter() *UCellCounter {
	return &UCellCounter{}
}



func (p *UCellCounter) Getf() Flag {
	return p.f
}



func (p *UCellCounter) Getk() Key {
	return p.k
}

var UCellCounter_ts_DEFAULT int64

func (p *UCellCounter) Getts() int64 {
	if !p.IsSetts() {
		return UCellCounter_ts_DEFAULT
	}
	return *p.ts
}

var UCellCounter_ts_desc_DEFAULT bool

func (p *UCellCounter) Getts_desc() bool {
	if !p.IsSetts_desc() {
		return UCellCounter_ts_desc_DEFAULT
	}
	return *p.ts_desc
}



func (p *UCellCounter) Getop() int8 {
	return p.op
}



func (p *UCellCounter) Getv() int64 {
	return p.v
}

func (p *UCellCounter) IsSetts() bool {
	return p.ts != nil
}

func (p *UCellCounter) IsSetts_desc() bool {
	return p.ts_desc != nil
}

func (p *UCellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UCellCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Flag(v)
		p.f = temp
	}
	return nil
}

func (p *UCellCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem70 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem70 = v
		}
		p.k = append(p.k, _elem70)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *UCellCounter) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ts = &v
	}
	return nil
}

func (p *UCellCounter) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ts_desc = &v
	}
	return nil
}

func (p *UCellCounter) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := int8(v)
		p.op = temp
	}
	return nil
}

func (p *UCellCounter) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *UCellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UCellCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UCellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "f", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:f: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.f)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.f (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:f: ", p), err)
	}
	return err
}

func (p *UCellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err)
	}
	return err
}

func (p *UCellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts() {
		if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.ts)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err)
		}
	}
	return err
}

func (p *UCellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_desc() {
		if err := oprot.WriteFieldBegin(ctx, "ts_desc", thrift.BOOL, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ts_desc: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.ts_desc)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ts_desc (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ts_desc: ", p), err)
		}
	}
	return err
}

func (p *UCellCounter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "op", thrift.BYTE, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:op: ", p), err)
	}
	if err := oprot.WriteByte(ctx, int8(p.op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:op: ", p), err)
	}
	return err
}

func (p *UCellCounter) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (6) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:v: ", p), err)
	}
	return err
}

func (p *UCellCounter) Equals(other *UCellCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.f != other.f { return false }
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src71 := other.k[i]
		if bytes.Compare(_tgt, _src71) != 0 { return false }
	}
	if p.ts != other.ts {
		if p.ts == nil || other.ts == nil {
			return false
		}
		if (*p.ts) != (*other.ts) { return false }
	}
	if p.ts_desc != other.ts_desc {
		if p.ts_desc == nil || other.ts_desc == nil {
			return false
		}
		if (*p.ts_desc) != (*other.ts_desc) { return false }
	}
	if p.op != other.op { return false }
	if p.v != other.v { return false }
	return true
}

func (p *UCellCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UCellCounter(%+v)", *p)
}

func (p *UCellCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.UCellCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*UCellCounter)(nil)

func (p *UCellCounter) Validate() error {
	return nil
}

// The Serial Value Cell field
// 
// Attributes:
//  - field_id: The Field ID, a single ID can have any/all the field types
//  - v_int64: The INT64 type field
//  - v_double: The DOUBLE type field
//  - v_bytes: The BYTES type field
//  - v_key: The Cell KEY type field
//  - v_li: The LIST INT64 type field
//  - v_lb: The LIST BYTES type field
// 
type CellValueSerial struct {
	field_id int32 `thrift:"field_id,1" db:"field_id" json:"field_id"`
	v_int64 *int64 `thrift:"v_int64,2" db:"v_int64" json:"v_int64,omitempty"`
	v_double *float64 `thrift:"v_double,3" db:"v_double" json:"v_double,omitempty"`
	v_bytes []byte `thrift:"v_bytes,4" db:"v_bytes" json:"v_bytes,omitempty"`
	v_key Key `thrift:"v_key,5" db:"v_key" json:"v_key,omitempty"`
	v_li []int64 `thrift:"v_li,6" db:"v_li" json:"v_li,omitempty"`
	v_lb [][]byte `thrift:"v_lb,7" db:"v_lb" json:"v_lb,omitempty"`
}

func NewCellValueSerial() *CellValueSerial {
	return &CellValueSerial{}
}



func (p *CellValueSerial) Getfield_id() int32 {
	return p.field_id
}

var CellValueSerial_v_int64_DEFAULT int64

func (p *CellValueSerial) Getv_int64() int64 {
	if !p.IsSetv_int64() {
		return CellValueSerial_v_int64_DEFAULT
	}
	return *p.v_int64
}

var CellValueSerial_v_double_DEFAULT float64

func (p *CellValueSerial) Getv_double() float64 {
	if !p.IsSetv_double() {
		return CellValueSerial_v_double_DEFAULT
	}
	return *p.v_double
}

var CellValueSerial_v_bytes_DEFAULT []byte


func (p *CellValueSerial) Getv_bytes() []byte {
	return p.v_bytes
}

var CellValueSerial_v_key_DEFAULT Key


func (p *CellValueSerial) Getv_key() Key {
	return p.v_key
}

var CellValueSerial_v_li_DEFAULT []int64


func (p *CellValueSerial) Getv_li() []int64 {
	return p.v_li
}

var CellValueSerial_v_lb_DEFAULT [][]byte


func (p *CellValueSerial) Getv_lb() [][]byte {
	return p.v_lb
}

func (p *CellValueSerial) IsSetv_int64() bool {
	return p.v_int64 != nil
}

func (p *CellValueSerial) IsSetv_double() bool {
	return p.v_double != nil
}

func (p *CellValueSerial) IsSetv_bytes() bool {
	return p.v_bytes != nil
}

func (p *CellValueSerial) IsSetv_key() bool {
	return p.v_key != nil
}

func (p *CellValueSerial) IsSetv_li() bool {
	return p.v_li != nil
}

func (p *CellValueSerial) IsSetv_lb() bool {
	return p.v_lb != nil
}

func (p *CellValueSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CellValueSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.field_id = v
	}
	return nil
}

func (p *CellValueSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.v_int64 = &v
	}
	return nil
}

func (p *CellValueSerial) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.v_double = &v
	}
	return nil
}

func (p *CellValueSerial) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.v_bytes = v
	}
	return nil
}

func (p *CellValueSerial) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.v_key = tSlice
	for i := 0; i < size; i++ {
		var _elem72 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem72 = v
		}
		p.v_key = append(p.v_key, _elem72)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellValueSerial) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]int64, 0, size)
	p.v_li = tSlice
	for i := 0; i < size; i++ {
		var _elem73 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem73 = v
		}
		p.v_li = append(p.v_li, _elem73)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellValueSerial) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.v_lb = tSlice
	for i := 0; i < size; i++ {
		var _elem74 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem74 = v
		}
		p.v_lb = append(p.v_lb, _elem74)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellValueSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CellValueSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CellValueSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "field_id", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field_id: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.field_id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.field_id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field_id: ", p), err)
	}
	return err
}

func (p *CellValueSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_int64() {
		if err := oprot.WriteFieldBegin(ctx, "v_int64", thrift.I64, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v_int64: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.v_int64)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.v_int64 (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v_int64: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_double() {
		if err := oprot.WriteFieldBegin(ctx, "v_double", thrift.DOUBLE, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v_double: ", p), err)
		}
		if err := oprot.WriteDouble(ctx, float64(*p.v_double)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.v_double (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v_double: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_bytes() {
		if err := oprot.WriteFieldBegin(ctx, "v_bytes", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v_bytes: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.v_bytes); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.v_bytes (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v_bytes: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerial) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_key() {
		if err := oprot.WriteFieldBegin(ctx, "v_key", thrift.LIST, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v_key: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.v_key)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.v_key {
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v_key: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerial) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_li() {
		if err := oprot.WriteFieldBegin(ctx, "v_li", thrift.LIST, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:v_li: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.I64, len(p.v_li)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.v_li {
			if err := oprot.WriteI64(ctx, int64(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:v_li: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerial) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_lb() {
		if err := oprot.WriteFieldBegin(ctx, "v_lb", thrift.LIST, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:v_lb: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.v_lb)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.v_lb {
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:v_lb: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerial) Equals(other *CellValueSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.field_id != other.field_id { return false }
	if p.v_int64 != other.v_int64 {
		if p.v_int64 == nil || other.v_int64 == nil {
			return false
		}
		if (*p.v_int64) != (*other.v_int64) { return false }
	}
	if p.v_double != other.v_double {
		if p.v_double == nil || other.v_double == nil {
			return false
		}
		if (*p.v_double) != (*other.v_double) { return false }
	}
	if bytes.Compare(p.v_bytes, other.v_bytes) != 0 { return false }
	if len(p.v_key) != len(other.v_key) { return false }
	for i, _tgt := range p.v_key {
		_src75 := other.v_key[i]
		if bytes.Compare(_tgt, _src75) != 0 { return false }
	}
	if len(p.v_li) != len(other.v_li) { return false }
	for i, _tgt := range p.v_li {
		_src76 := other.v_li[i]
		if _tgt != _src76 { return false }
	}
	if len(p.v_lb) != len(other.v_lb) { return false }
	for i, _tgt := range p.v_lb {
		_src77 := other.v_lb[i]
		if bytes.Compare(_tgt, _src77) != 0 { return false }
	}
	return true
}

func (p *CellValueSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CellValueSerial(%+v)", *p)
}

func (p *CellValueSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CellValueSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellValueSerial)(nil)

func (p *CellValueSerial) Validate() error {
	return nil
}

// Serial INT64 Field Update
// 
// Attributes:
//  - ctrl
//  - op
//  - pos
//  - comp
//  - v
// 
type FU_INT64 struct {
	ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
	op FU_MATH_OP `thrift:"op,2" db:"op" json:"op"`
	pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
	comp *Comp `thrift:"comp,4" db:"comp" json:"comp,omitempty"`
	v int64 `thrift:"v,5" db:"v" json:"v"`
}

func NewFU_INT64() *FU_INT64 {
	return &FU_INT64{
		op: 0,
	}
}



func (p *FU_INT64) Getctrl() int8 {
	return p.ctrl
}



func (p *FU_INT64) Getop() FU_MATH_OP {
	return p.op
}

var FU_INT64_pos_DEFAULT int32

func (p *FU_INT64) Getpos() int32 {
	if !p.IsSetpos() {
		return FU_INT64_pos_DEFAULT
	}
	return *p.pos
}

var FU_INT64_comp_DEFAULT Comp

func (p *FU_INT64) Getcomp() Comp {
	if !p.IsSetcomp() {
		return FU_INT64_comp_DEFAULT
	}
	return *p.comp
}



func (p *FU_INT64) Getv() int64 {
	return p.v
}

func (p *FU_INT64) IsSetpos() bool {
	return p.pos != nil
}

func (p *FU_INT64) IsSetcomp() bool {
	return p.comp != nil
}

func (p *FU_INT64) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FU_INT64) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := int8(v)
		p.ctrl = temp
	}
	return nil
}

func (p *FU_INT64) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := FU_MATH_OP(v)
		p.op = temp
	}
	return nil
}

func (p *FU_INT64) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.pos = &v
	}
	return nil
}

func (p *FU_INT64) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := Comp(v)
		p.comp = &temp
	}
	return nil
}

func (p *FU_INT64) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *FU_INT64) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FU_INT64"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FU_INT64) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err)
	}
	if err := oprot.WriteByte(ctx, int8(p.ctrl)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err)
	}
	return err
}

func (p *FU_INT64) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err)
	}
	return err
}

func (p *FU_INT64) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetpos() {
		if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.pos)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err)
		}
	}
	return err
}

func (p *FU_INT64) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcomp() {
		if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:comp: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.comp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.comp (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:comp: ", p), err)
		}
	}
	return err
}

func (p *FU_INT64) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err)
	}
	return err
}

func (p *FU_INT64) Equals(other *FU_INT64) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ctrl != other.ctrl { return false }
	if p.op != other.op { return false }
	if p.pos != other.pos {
		if p.pos == nil || other.pos == nil {
			return false
		}
		if (*p.pos) != (*other.pos) { return false }
	}
	if p.comp != other.comp {
		if p.comp == nil || other.comp == nil {
			return false
		}
		if (*p.comp) != (*other.comp) { return false }
	}
	if p.v != other.v { return false }
	return true
}

func (p *FU_INT64) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FU_INT64(%+v)", *p)
}

func (p *FU_INT64) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FU_INT64",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_INT64)(nil)

func (p *FU_INT64) Validate() error {
	return nil
}

// Serial DOUBLE Field Update
// 
// Attributes:
//  - ctrl
//  - op
//  - pos
//  - comp
//  - v
// 
type FU_DOUBLE struct {
	ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
	op FU_MATH_OP `thrift:"op,2" db:"op" json:"op"`
	pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
	comp *Comp `thrift:"comp,4" db:"comp" json:"comp,omitempty"`
	v float64 `thrift:"v,5" db:"v" json:"v"`
}

func NewFU_DOUBLE() *FU_DOUBLE {
	return &FU_DOUBLE{
		op: 0,
	}
}



func (p *FU_DOUBLE) Getctrl() int8 {
	return p.ctrl
}



func (p *FU_DOUBLE) Getop() FU_MATH_OP {
	return p.op
}

var FU_DOUBLE_pos_DEFAULT int32

func (p *FU_DOUBLE) Getpos() int32 {
	if !p.IsSetpos() {
		return FU_DOUBLE_pos_DEFAULT
	}
	return *p.pos
}

var FU_DOUBLE_comp_DEFAULT Comp

func (p *FU_DOUBLE) Getcomp() Comp {
	if !p.IsSetcomp() {
		return FU_DOUBLE_comp_DEFAULT
	}
	return *p.comp
}



func (p *FU_DOUBLE) Getv() float64 {
	return p.v
}

func (p *FU_DOUBLE) IsSetpos() bool {
	return p.pos != nil
}

func (p *FU_DOUBLE) IsSetcomp() bool {
	return p.comp != nil
}

func (p *FU_DOUBLE) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FU_DOUBLE) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := int8(v)
		p.ctrl = temp
	}
	return nil
}

func (p *FU_DOUBLE) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := FU_MATH_OP(v)
		p.op = temp
	}
	return nil
}

func (p *FU_DOUBLE) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.pos = &v
	}
	return nil
}

func (p *FU_DOUBLE) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := Comp(v)
		p.comp = &temp
	}
	return nil
}

func (p *FU_DOUBLE) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *FU_DOUBLE) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FU_DOUBLE"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FU_DOUBLE) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err)
	}
	if err := oprot.WriteByte(ctx, int8(p.ctrl)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err)
	}
	return err
}

func (p *FU_DOUBLE) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err)
	}
	return err
}

func (p *FU_DOUBLE) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetpos() {
		if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.pos)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err)
		}
	}
	return err
}

func (p *FU_DOUBLE) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcomp() {
		if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:comp: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.comp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.comp (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:comp: ", p), err)
		}
	}
	return err
}

func (p *FU_DOUBLE) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.DOUBLE, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err)
	}
	return err
}

func (p *FU_DOUBLE) Equals(other *FU_DOUBLE) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ctrl != other.ctrl { return false }
	if p.op != other.op { return false }
	if p.pos != other.pos {
		if p.pos == nil || other.pos == nil {
			return false
		}
		if (*p.pos) != (*other.pos) { return false }
	}
	if p.comp != other.comp {
		if p.comp == nil || other.comp == nil {
			return false
		}
		if (*p.comp) != (*other.comp) { return false }
	}
	if p.v != other.v { return false }
	return true
}

func (p *FU_DOUBLE) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FU_DOUBLE(%+v)", *p)
}

func (p *FU_DOUBLE) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FU_DOUBLE",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_DOUBLE)(nil)

func (p *FU_DOUBLE) Validate() error {
	return nil
}

// Serial BYTES Field Update
// 
// Attributes:
//  - ctrl
//  - op
//  - pos
//  - comp
//  - v
// 
type FU_BYTES struct {
	ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
	op FU_LIST_OP `thrift:"op,2" db:"op" json:"op"`
	pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
	comp *Comp `thrift:"comp,4" db:"comp" json:"comp,omitempty"`
	v []byte `thrift:"v,5" db:"v" json:"v"`
}

func NewFU_BYTES() *FU_BYTES {
	return &FU_BYTES{
		op: 0,
	}
}



func (p *FU_BYTES) Getctrl() int8 {
	return p.ctrl
}



func (p *FU_BYTES) Getop() FU_LIST_OP {
	return p.op
}

var FU_BYTES_pos_DEFAULT int32

func (p *FU_BYTES) Getpos() int32 {
	if !p.IsSetpos() {
		return FU_BYTES_pos_DEFAULT
	}
	return *p.pos
}

var FU_BYTES_comp_DEFAULT Comp

func (p *FU_BYTES) Getcomp() Comp {
	if !p.IsSetcomp() {
		return FU_BYTES_comp_DEFAULT
	}
	return *p.comp
}



func (p *FU_BYTES) Getv() []byte {
	return p.v
}

func (p *FU_BYTES) IsSetpos() bool {
	return p.pos != nil
}

func (p *FU_BYTES) IsSetcomp() bool {
	return p.comp != nil
}

func (p *FU_BYTES) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FU_BYTES) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := int8(v)
		p.ctrl = temp
	}
	return nil
}

func (p *FU_BYTES) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := FU_LIST_OP(v)
		p.op = temp
	}
	return nil
}

func (p *FU_BYTES) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.pos = &v
	}
	return nil
}

func (p *FU_BYTES) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := Comp(v)
		p.comp = &temp
	}
	return nil
}

func (p *FU_BYTES) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *FU_BYTES) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FU_BYTES"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FU_BYTES) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err)
	}
	if err := oprot.WriteByte(ctx, int8(p.ctrl)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err)
	}
	return err
}

func (p *FU_BYTES) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err)
	}
	return err
}

func (p *FU_BYTES) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetpos() {
		if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.pos)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err)
		}
	}
	return err
}

func (p *FU_BYTES) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetcomp() {
		if err := oprot.WriteFieldBegin(ctx, "comp", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:comp: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.comp)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.comp (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:comp: ", p), err)
		}
	}
	return err
}

func (p *FU_BYTES) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err)
	}
	return err
}

func (p *FU_BYTES) Equals(other *FU_BYTES) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ctrl != other.ctrl { return false }
	if p.op != other.op { return false }
	if p.pos != other.pos {
		if p.pos == nil || other.pos == nil {
			return false
		}
		if (*p.pos) != (*other.pos) { return false }
	}
	if p.comp != other.comp {
		if p.comp == nil || other.comp == nil {
			return false
		}
		if (*p.comp) != (*other.comp) { return false }
	}
	if bytes.Compare(p.v, other.v) != 0 { return false }
	return true
}

func (p *FU_BYTES) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FU_BYTES(%+v)", *p)
}

func (p *FU_BYTES) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FU_BYTES",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_BYTES)(nil)

func (p *FU_BYTES) Validate() error {
	return nil
}

// Serial LIST_INT64 Field Update
// 
// Attributes:
//  - ctrl
//  - op
//  - pos
//  - v
// 
type FU_LI struct {
	ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
	op FU_LIST_OP `thrift:"op,2" db:"op" json:"op"`
	pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
	v []*FU_INT64 `thrift:"v,4" db:"v" json:"v"`
}

func NewFU_LI() *FU_LI {
	return &FU_LI{
		op: 0,
	}
}



func (p *FU_LI) Getctrl() int8 {
	return p.ctrl
}



func (p *FU_LI) Getop() FU_LIST_OP {
	return p.op
}

var FU_LI_pos_DEFAULT int32

func (p *FU_LI) Getpos() int32 {
	if !p.IsSetpos() {
		return FU_LI_pos_DEFAULT
	}
	return *p.pos
}



func (p *FU_LI) Getv() []*FU_INT64 {
	return p.v
}

func (p *FU_LI) IsSetpos() bool {
	return p.pos != nil
}

func (p *FU_LI) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FU_LI) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := int8(v)
		p.ctrl = temp
	}
	return nil
}

func (p *FU_LI) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := FU_LIST_OP(v)
		p.op = temp
	}
	return nil
}

func (p *FU_LI) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.pos = &v
	}
	return nil
}

func (p *FU_LI) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FU_INT64, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem78 := &FU_INT64{
			op: 0,
		}
		if err := _elem78.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem78), err)
		}
		p.v = append(p.v, _elem78)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FU_LI) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FU_LI"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FU_LI) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err)
	}
	if err := oprot.WriteByte(ctx, int8(p.ctrl)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err)
	}
	return err
}

func (p *FU_LI) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err)
	}
	return err
}

func (p *FU_LI) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetpos() {
		if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.pos)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err)
		}
	}
	return err
}

func (p *FU_LI) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err)
	}
	return err
}

func (p *FU_LI) Equals(other *FU_LI) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ctrl != other.ctrl { return false }
	if p.op != other.op { return false }
	if p.pos != other.pos {
		if p.pos == nil || other.pos == nil {
			return false
		}
		if (*p.pos) != (*other.pos) { return false }
	}
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src79 := other.v[i]
		if !_tgt.Equals(_src79) { return false }
	}
	return true
}

func (p *FU_LI) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FU_LI(%+v)", *p)
}

func (p *FU_LI) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FU_LI",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_LI)(nil)

func (p *FU_LI) Validate() error {
	return nil
}

// Serial LIST_BYTES Field Update
// 
// Attributes:
//  - ctrl
//  - op
//  - pos
//  - v
// 
type FU_LB struct {
	ctrl int8 `thrift:"ctrl,1" db:"ctrl" json:"ctrl"`
	op FU_LIST_OP `thrift:"op,2" db:"op" json:"op"`
	pos *int32 `thrift:"pos,3" db:"pos" json:"pos,omitempty"`
	v []*FU_BYTES `thrift:"v,4" db:"v" json:"v"`
}

func NewFU_LB() *FU_LB {
	return &FU_LB{
		op: 0,
	}
}



func (p *FU_LB) Getctrl() int8 {
	return p.ctrl
}



func (p *FU_LB) Getop() FU_LIST_OP {
	return p.op
}

var FU_LB_pos_DEFAULT int32

func (p *FU_LB) Getpos() int32 {
	if !p.IsSetpos() {
		return FU_LB_pos_DEFAULT
	}
	return *p.pos
}



func (p *FU_LB) Getv() []*FU_BYTES {
	return p.v
}

func (p *FU_LB) IsSetpos() bool {
	return p.pos != nil
}

func (p *FU_LB) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FU_LB) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := int8(v)
		p.ctrl = temp
	}
	return nil
}

func (p *FU_LB) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := FU_LIST_OP(v)
		p.op = temp
	}
	return nil
}

func (p *FU_LB) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.pos = &v
	}
	return nil
}

func (p *FU_LB) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FU_BYTES, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem80 := &FU_BYTES{
			op: 0,
		}
		if err := _elem80.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem80), err)
		}
		p.v = append(p.v, _elem80)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FU_LB) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FU_LB"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FU_LB) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ctrl", thrift.BYTE, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ctrl: ", p), err)
	}
	if err := oprot.WriteByte(ctx, int8(p.ctrl)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ctrl (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ctrl: ", p), err)
	}
	return err
}

func (p *FU_LB) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "op", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:op: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.op)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.op (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:op: ", p), err)
	}
	return err
}

func (p *FU_LB) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetpos() {
		if err := oprot.WriteFieldBegin(ctx, "pos", thrift.I32, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:pos: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.pos)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.pos (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:pos: ", p), err)
		}
	}
	return err
}

func (p *FU_LB) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err)
	}
	return err
}

func (p *FU_LB) Equals(other *FU_LB) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ctrl != other.ctrl { return false }
	if p.op != other.op { return false }
	if p.pos != other.pos {
		if p.pos == nil || other.pos == nil {
			return false
		}
		if (*p.pos) != (*other.pos) { return false }
	}
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src81 := other.v[i]
		if !_tgt.Equals(_src81) { return false }
	}
	return true
}

func (p *FU_LB) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FU_LB(%+v)", *p)
}

func (p *FU_LB) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FU_LB",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FU_LB)(nil)

func (p *FU_LB) Validate() error {
	return nil
}

// The Serial Values Cell field with Update Operation
// 
// Attributes:
//  - field_id: The Field ID, a single ID can have any/all the field types
//  - v_int64: The INT64 type update-field
//  - v_double: The DOUBLE type update-field
//  - v_bytes: The BYTES type update-field
//  - v_key: The Cell KEY type update-field
//  - v_li: The LIST INT64 type update-field
//  - v_lb: The LIST BYTES type update-field
// 
type CellValueSerialOp struct {
	field_id int32 `thrift:"field_id,1" db:"field_id" json:"field_id"`
	v_int64 *FU_INT64 `thrift:"v_int64,2" db:"v_int64" json:"v_int64,omitempty"`
	v_double *FU_DOUBLE `thrift:"v_double,3" db:"v_double" json:"v_double,omitempty"`
	v_bytes *FU_BYTES `thrift:"v_bytes,4" db:"v_bytes" json:"v_bytes,omitempty"`
	v_key Key `thrift:"v_key,5" db:"v_key" json:"v_key,omitempty"`
	v_li *FU_LI `thrift:"v_li,6" db:"v_li" json:"v_li,omitempty"`
	v_lb *FU_LB `thrift:"v_lb,7" db:"v_lb" json:"v_lb,omitempty"`
}

func NewCellValueSerialOp() *CellValueSerialOp {
	return &CellValueSerialOp{}
}



func (p *CellValueSerialOp) Getfield_id() int32 {
	return p.field_id
}

var CellValueSerialOp_v_int64_DEFAULT *FU_INT64

func (p *CellValueSerialOp) Getv_int64() *FU_INT64 {
	if !p.IsSetv_int64() {
		return CellValueSerialOp_v_int64_DEFAULT
	}
	return p.v_int64
}

var CellValueSerialOp_v_double_DEFAULT *FU_DOUBLE

func (p *CellValueSerialOp) Getv_double() *FU_DOUBLE {
	if !p.IsSetv_double() {
		return CellValueSerialOp_v_double_DEFAULT
	}
	return p.v_double
}

var CellValueSerialOp_v_bytes_DEFAULT *FU_BYTES

func (p *CellValueSerialOp) Getv_bytes() *FU_BYTES {
	if !p.IsSetv_bytes() {
		return CellValueSerialOp_v_bytes_DEFAULT
	}
	return p.v_bytes
}

var CellValueSerialOp_v_key_DEFAULT Key


func (p *CellValueSerialOp) Getv_key() Key {
	return p.v_key
}

var CellValueSerialOp_v_li_DEFAULT *FU_LI

func (p *CellValueSerialOp) Getv_li() *FU_LI {
	if !p.IsSetv_li() {
		return CellValueSerialOp_v_li_DEFAULT
	}
	return p.v_li
}

var CellValueSerialOp_v_lb_DEFAULT *FU_LB

func (p *CellValueSerialOp) Getv_lb() *FU_LB {
	if !p.IsSetv_lb() {
		return CellValueSerialOp_v_lb_DEFAULT
	}
	return p.v_lb
}

func (p *CellValueSerialOp) IsSetv_int64() bool {
	return p.v_int64 != nil
}

func (p *CellValueSerialOp) IsSetv_double() bool {
	return p.v_double != nil
}

func (p *CellValueSerialOp) IsSetv_bytes() bool {
	return p.v_bytes != nil
}

func (p *CellValueSerialOp) IsSetv_key() bool {
	return p.v_key != nil
}

func (p *CellValueSerialOp) IsSetv_li() bool {
	return p.v_li != nil
}

func (p *CellValueSerialOp) IsSetv_lb() bool {
	return p.v_lb != nil
}

func (p *CellValueSerialOp) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CellValueSerialOp) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.field_id = v
	}
	return nil
}

func (p *CellValueSerialOp) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.v_int64 = &FU_INT64{
		op: 0,
	}
	if err := p.v_int64.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.v_int64), err)
	}
	return nil
}

func (p *CellValueSerialOp) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.v_double = &FU_DOUBLE{
		op: 0,
	}
	if err := p.v_double.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.v_double), err)
	}
	return nil
}

func (p *CellValueSerialOp) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.v_bytes = &FU_BYTES{
		op: 0,
	}
	if err := p.v_bytes.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.v_bytes), err)
	}
	return nil
}

func (p *CellValueSerialOp) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.v_key = tSlice
	for i := 0; i < size; i++ {
		var _elem82 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem82 = v
		}
		p.v_key = append(p.v_key, _elem82)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellValueSerialOp) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	p.v_li = &FU_LI{
		op: 0,
	}
	if err := p.v_li.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.v_li), err)
	}
	return nil
}

func (p *CellValueSerialOp) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	p.v_lb = &FU_LB{
		op: 0,
	}
	if err := p.v_lb.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.v_lb), err)
	}
	return nil
}

func (p *CellValueSerialOp) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CellValueSerialOp"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CellValueSerialOp) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "field_id", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field_id: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.field_id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.field_id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field_id: ", p), err)
	}
	return err
}

func (p *CellValueSerialOp) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_int64() {
		if err := oprot.WriteFieldBegin(ctx, "v_int64", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:v_int64: ", p), err)
		}
		if err := p.v_int64.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.v_int64), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:v_int64: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerialOp) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_double() {
		if err := oprot.WriteFieldBegin(ctx, "v_double", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v_double: ", p), err)
		}
		if err := p.v_double.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.v_double), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v_double: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerialOp) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_bytes() {
		if err := oprot.WriteFieldBegin(ctx, "v_bytes", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v_bytes: ", p), err)
		}
		if err := p.v_bytes.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.v_bytes), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v_bytes: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerialOp) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_key() {
		if err := oprot.WriteFieldBegin(ctx, "v_key", thrift.LIST, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v_key: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.v_key)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.v_key {
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v_key: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerialOp) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_li() {
		if err := oprot.WriteFieldBegin(ctx, "v_li", thrift.STRUCT, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:v_li: ", p), err)
		}
		if err := p.v_li.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.v_li), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:v_li: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerialOp) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetv_lb() {
		if err := oprot.WriteFieldBegin(ctx, "v_lb", thrift.STRUCT, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:v_lb: ", p), err)
		}
		if err := p.v_lb.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.v_lb), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:v_lb: ", p), err)
		}
	}
	return err
}

func (p *CellValueSerialOp) Equals(other *CellValueSerialOp) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.field_id != other.field_id { return false }
	if !p.v_int64.Equals(other.v_int64) { return false }
	if !p.v_double.Equals(other.v_double) { return false }
	if !p.v_bytes.Equals(other.v_bytes) { return false }
	if len(p.v_key) != len(other.v_key) { return false }
	for i, _tgt := range p.v_key {
		_src83 := other.v_key[i]
		if bytes.Compare(_tgt, _src83) != 0 { return false }
	}
	if !p.v_li.Equals(other.v_li) { return false }
	if !p.v_lb.Equals(other.v_lb) { return false }
	return true
}

func (p *CellValueSerialOp) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CellValueSerialOp(%+v)", *p)
}

func (p *CellValueSerialOp) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CellValueSerialOp",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellValueSerialOp)(nil)

func (p *CellValueSerialOp) Validate() error {
	return nil
}

// The Cell data for using with Update of SERIAL Column Type
// 
// Attributes:
//  - f: The Cell Flag
//  - k: The Cell Key
//  - ts: The Cell Timestamp in nanoseconds
//  - ts_desc: The Cell Version is in timestamp descending
//  - v: The Serial Cell Value fields
//  - encoder: Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
// 
type UCellSerial struct {
	f Flag `thrift:"f,1" db:"f" json:"f"`
	k Key `thrift:"k,2" db:"k" json:"k"`
	ts *int64 `thrift:"ts,3" db:"ts" json:"ts,omitempty"`
	ts_desc *bool `thrift:"ts_desc,4" db:"ts_desc" json:"ts_desc,omitempty"`
	v CellValuesSerial `thrift:"v,5" db:"v" json:"v"`
	encoder *EncodingType `thrift:"encoder,6" db:"encoder" json:"encoder,omitempty"`
}

func NewUCellSerial() *UCellSerial {
	return &UCellSerial{}
}



func (p *UCellSerial) Getf() Flag {
	return p.f
}



func (p *UCellSerial) Getk() Key {
	return p.k
}

var UCellSerial_ts_DEFAULT int64

func (p *UCellSerial) Getts() int64 {
	if !p.IsSetts() {
		return UCellSerial_ts_DEFAULT
	}
	return *p.ts
}

var UCellSerial_ts_desc_DEFAULT bool

func (p *UCellSerial) Getts_desc() bool {
	if !p.IsSetts_desc() {
		return UCellSerial_ts_desc_DEFAULT
	}
	return *p.ts_desc
}



func (p *UCellSerial) Getv() CellValuesSerial {
	return p.v
}

var UCellSerial_encoder_DEFAULT EncodingType

func (p *UCellSerial) Getencoder() EncodingType {
	if !p.IsSetencoder() {
		return UCellSerial_encoder_DEFAULT
	}
	return *p.encoder
}

func (p *UCellSerial) IsSetts() bool {
	return p.ts != nil
}

func (p *UCellSerial) IsSetts_desc() bool {
	return p.ts_desc != nil
}

func (p *UCellSerial) IsSetencoder() bool {
	return p.encoder != nil
}

func (p *UCellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UCellSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := Flag(v)
		p.f = temp
	}
	return nil
}

func (p *UCellSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem84 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem84 = v
		}
		p.k = append(p.k, _elem84)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *UCellSerial) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ts = &v
	}
	return nil
}

func (p *UCellSerial) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ts_desc = &v
	}
	return nil
}

func (p *UCellSerial) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellValuesSerial, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem85 := &CellValueSerial{}
		if err := _elem85.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem85), err)
		}
		p.v = append(p.v, _elem85)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *UCellSerial) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		temp := EncodingType(v)
		p.encoder = &temp
	}
	return nil
}

func (p *UCellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UCellSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UCellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "f", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:f: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.f)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.f (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:f: ", p), err)
	}
	return err
}

func (p *UCellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err)
	}
	return err
}

func (p *UCellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts() {
		if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.ts)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err)
		}
	}
	return err
}

func (p *UCellSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetts_desc() {
		if err := oprot.WriteFieldBegin(ctx, "ts_desc", thrift.BOOL, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ts_desc: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.ts_desc)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.ts_desc (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ts_desc: ", p), err)
		}
	}
	return err
}

func (p *UCellSerial) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:v: ", p), err)
	}
	return err
}

func (p *UCellSerial) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetencoder() {
		if err := oprot.WriteFieldBegin(ctx, "encoder", thrift.I32, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:encoder: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.encoder)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.encoder (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:encoder: ", p), err)
		}
	}
	return err
}

func (p *UCellSerial) Equals(other *UCellSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.f != other.f { return false }
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src86 := other.k[i]
		if bytes.Compare(_tgt, _src86) != 0 { return false }
	}
	if p.ts != other.ts {
		if p.ts == nil || other.ts == nil {
			return false
		}
		if (*p.ts) != (*other.ts) { return false }
	}
	if p.ts_desc != other.ts_desc {
		if p.ts_desc == nil || other.ts_desc == nil {
			return false
		}
		if (*p.ts_desc) != (*other.ts_desc) { return false }
	}
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src87 := other.v[i]
		if !_tgt.Equals(_src87) { return false }
	}
	if p.encoder != other.encoder {
		if p.encoder == nil || other.encoder == nil {
			return false
		}
		if (*p.encoder) != (*other.encoder) { return false }
	}
	return true
}

func (p *UCellSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UCellSerial(%+v)", *p)
}

func (p *UCellSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.UCellSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*UCellSerial)(nil)

func (p *UCellSerial) Validate() error {
	return nil
}

// The Cell for results list of scan
// 
// Attributes:
//  - c: The Column Name
//  - k: The Cell Key
//  - ts: The Cell Timestamp
//  - v: The Cell Value
// 
type CellPlain struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	k Key `thrift:"k,2" db:"k" json:"k"`
	ts int64 `thrift:"ts,3" db:"ts" json:"ts"`
	v []byte `thrift:"v,4" db:"v" json:"v"`
}

func NewCellPlain() *CellPlain {
	return &CellPlain{}
}



func (p *CellPlain) Getc() string {
	return p.c
}



func (p *CellPlain) Getk() Key {
	return p.k
}



func (p *CellPlain) Getts() int64 {
	return p.ts
}



func (p *CellPlain) Getv() []byte {
	return p.v
}

func (p *CellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CellPlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *CellPlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem88 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem88 = v
		}
		p.k = append(p.k, _elem88)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellPlain) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *CellPlain) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *CellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CellPlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *CellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err)
	}
	return err
}

func (p *CellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err)
	}
	return err
}

func (p *CellPlain) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err)
	}
	return err
}

func (p *CellPlain) Equals(other *CellPlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src89 := other.k[i]
		if bytes.Compare(_tgt, _src89) != 0 { return false }
	}
	if p.ts != other.ts { return false }
	if bytes.Compare(p.v, other.v) != 0 { return false }
	return true
}

func (p *CellPlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CellPlain(%+v)", *p)
}

func (p *CellPlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CellPlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellPlain)(nil)

func (p *CellPlain) Validate() error {
	return nil
}

// The Counter Cell for results list of scan
// 
// Attributes:
//  - c: The Column Name
//  - k: The Cell Key
//  - ts: The Cell Timestamp
//  - v: The Cell Counter Value
//  - eq: The Counter EQ since ts
// 
type CellCounter struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	k Key `thrift:"k,2" db:"k" json:"k"`
	ts int64 `thrift:"ts,3" db:"ts" json:"ts"`
	v int64 `thrift:"v,4" db:"v" json:"v"`
	eq *int64 `thrift:"eq,5" db:"eq" json:"eq,omitempty"`
}

func NewCellCounter() *CellCounter {
	return &CellCounter{}
}



func (p *CellCounter) Getc() string {
	return p.c
}



func (p *CellCounter) Getk() Key {
	return p.k
}



func (p *CellCounter) Getts() int64 {
	return p.ts
}



func (p *CellCounter) Getv() int64 {
	return p.v
}

var CellCounter_eq_DEFAULT int64

func (p *CellCounter) Geteq() int64 {
	if !p.IsSeteq() {
		return CellCounter_eq_DEFAULT
	}
	return *p.eq
}

func (p *CellCounter) IsSeteq() bool {
	return p.eq != nil
}

func (p *CellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CellCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *CellCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem90 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem90 = v
		}
		p.k = append(p.k, _elem90)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellCounter) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *CellCounter) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *CellCounter) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.eq = &v
	}
	return nil
}

func (p *CellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CellCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *CellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err)
	}
	return err
}

func (p *CellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err)
	}
	return err
}

func (p *CellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err)
	}
	return err
}

func (p *CellCounter) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSeteq() {
		if err := oprot.WriteFieldBegin(ctx, "eq", thrift.I64, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:eq: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.eq)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.eq (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:eq: ", p), err)
		}
	}
	return err
}

func (p *CellCounter) Equals(other *CellCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src91 := other.k[i]
		if bytes.Compare(_tgt, _src91) != 0 { return false }
	}
	if p.ts != other.ts { return false }
	if p.v != other.v { return false }
	if p.eq != other.eq {
		if p.eq == nil || other.eq == nil {
			return false
		}
		if (*p.eq) != (*other.eq) { return false }
	}
	return true
}

func (p *CellCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CellCounter(%+v)", *p)
}

func (p *CellCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CellCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellCounter)(nil)

func (p *CellCounter) Validate() error {
	return nil
}

// The Serial Cell for results list of scan
// 
// Attributes:
//  - c: The Column Name
//  - k: The Cell Key
//  - ts: The Cell Timestamp
//  - v: The Cell Serial Value
// 
type CellSerial struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	k Key `thrift:"k,2" db:"k" json:"k"`
	ts int64 `thrift:"ts,3" db:"ts" json:"ts"`
	v CellValuesSerial `thrift:"v,4" db:"v" json:"v"`
}

func NewCellSerial() *CellSerial {
	return &CellSerial{}
}



func (p *CellSerial) Getc() string {
	return p.c
}



func (p *CellSerial) Getk() Key {
	return p.k
}



func (p *CellSerial) Getts() int64 {
	return p.ts
}



func (p *CellSerial) Getv() CellValuesSerial {
	return p.v
}

func (p *CellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CellSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *CellSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem92 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem92 = v
		}
		p.k = append(p.k, _elem92)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellSerial) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *CellSerial) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellValuesSerial, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem93 := &CellValueSerial{}
		if err := _elem93.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem93), err)
		}
		p.v = append(p.v, _elem93)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CellSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *CellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:k: ", p), err)
	}
	return err
}

func (p *CellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ts: ", p), err)
	}
	return err
}

func (p *CellSerial) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:v: ", p), err)
	}
	return err
}

func (p *CellSerial) Equals(other *CellSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src94 := other.k[i]
		if bytes.Compare(_tgt, _src94) != 0 { return false }
	}
	if p.ts != other.ts { return false }
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src95 := other.v[i]
		if !_tgt.Equals(_src95) { return false }
	}
	return true
}

func (p *CellSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CellSerial(%+v)", *p)
}

func (p *CellSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CellSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellSerial)(nil)

func (p *CellSerial) Validate() error {
	return nil
}

// The Cells for results list of scan
// 
// Attributes:
//  - plain_cells: The Cells, defined as Cell items in a list-container
//  - counter_cells: The Cells, defined as Cell items in a list-container
//  - serial_cells: The Serial Cells, defined as CellSerial items in a list-container
// 
type Cells struct {
	plain_cells CellsPlain `thrift:"plain_cells,1" db:"plain_cells" json:"plain_cells"`
	counter_cells CellsCounter `thrift:"counter_cells,2" db:"counter_cells" json:"counter_cells"`
	serial_cells CellsSerial `thrift:"serial_cells,3" db:"serial_cells" json:"serial_cells"`
}

func NewCells() *Cells {
	return &Cells{}
}



func (p *Cells) Getplain_cells() CellsPlain {
	return p.plain_cells
}



func (p *Cells) Getcounter_cells() CellsCounter {
	return p.counter_cells
}



func (p *Cells) Getserial_cells() CellsSerial {
	return p.serial_cells
}

func (p *Cells) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Cells) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellsPlain, 0, size)
	p.plain_cells = tSlice
	for i := 0; i < size; i++ {
		_elem96 := &CellPlain{}
		if err := _elem96.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem96), err)
		}
		p.plain_cells = append(p.plain_cells, _elem96)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Cells) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellsCounter, 0, size)
	p.counter_cells = tSlice
	for i := 0; i < size; i++ {
		_elem97 := &CellCounter{}
		if err := _elem97.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem97), err)
		}
		p.counter_cells = append(p.counter_cells, _elem97)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Cells) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellsSerial, 0, size)
	p.serial_cells = tSlice
	for i := 0; i < size; i++ {
		_elem98 := &CellSerial{}
		if err := _elem98.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem98), err)
		}
		p.serial_cells = append(p.serial_cells, _elem98)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Cells) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Cells"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Cells) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "plain_cells", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:plain_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.plain_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.plain_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:plain_cells: ", p), err)
	}
	return err
}

func (p *Cells) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "counter_cells", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:counter_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.counter_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.counter_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:counter_cells: ", p), err)
	}
	return err
}

func (p *Cells) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "serial_cells", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serial_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.serial_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.serial_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serial_cells: ", p), err)
	}
	return err
}

func (p *Cells) Equals(other *Cells) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.plain_cells) != len(other.plain_cells) { return false }
	for i, _tgt := range p.plain_cells {
		_src99 := other.plain_cells[i]
		if !_tgt.Equals(_src99) { return false }
	}
	if len(p.counter_cells) != len(other.counter_cells) { return false }
	for i, _tgt := range p.counter_cells {
		_src100 := other.counter_cells[i]
		if !_tgt.Equals(_src100) { return false }
	}
	if len(p.serial_cells) != len(other.serial_cells) { return false }
	for i, _tgt := range p.serial_cells {
		_src101 := other.serial_cells[i]
		if !_tgt.Equals(_src101) { return false }
	}
	return true
}

func (p *Cells) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Cells(%+v)", *p)
}

func (p *Cells) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Cells",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Cells)(nil)

func (p *Cells) Validate() error {
	return nil
}

// The Plain column type Cell for results on Columns of scan
// 
// Attributes:
//  - k: The Cell Key
//  - ts: The Cell Timestamp
//  - v: The Cell Value
// 
type CCellPlain struct {
	k Key `thrift:"k,1" db:"k" json:"k"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v []byte `thrift:"v,3" db:"v" json:"v"`
}

func NewCCellPlain() *CCellPlain {
	return &CCellPlain{}
}



func (p *CCellPlain) Getk() Key {
	return p.k
}



func (p *CCellPlain) Getts() int64 {
	return p.ts
}



func (p *CCellPlain) Getv() []byte {
	return p.v
}

func (p *CCellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CCellPlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem102 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem102 = v
		}
		p.k = append(p.k, _elem102)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CCellPlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *CCellPlain) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *CCellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CCellPlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CCellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:k: ", p), err)
	}
	return err
}

func (p *CCellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *CCellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *CCellPlain) Equals(other *CCellPlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src103 := other.k[i]
		if bytes.Compare(_tgt, _src103) != 0 { return false }
	}
	if p.ts != other.ts { return false }
	if bytes.Compare(p.v, other.v) != 0 { return false }
	return true
}

func (p *CCellPlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CCellPlain(%+v)", *p)
}

func (p *CCellPlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CCellPlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CCellPlain)(nil)

func (p *CCellPlain) Validate() error {
	return nil
}

// The Counter column type Cell for results on Columns of scan
// 
// Attributes:
//  - k: The Cell Key
//  - ts: The Cell Timestamp
//  - v: The Cell Counter Value
//  - eq: The Counter EQ since ts
// 
type CCellCounter struct {
	k Key `thrift:"k,1" db:"k" json:"k"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v int64 `thrift:"v,3" db:"v" json:"v"`
	eq *int64 `thrift:"eq,4" db:"eq" json:"eq,omitempty"`
}

func NewCCellCounter() *CCellCounter {
	return &CCellCounter{}
}



func (p *CCellCounter) Getk() Key {
	return p.k
}



func (p *CCellCounter) Getts() int64 {
	return p.ts
}



func (p *CCellCounter) Getv() int64 {
	return p.v
}

var CCellCounter_eq_DEFAULT int64

func (p *CCellCounter) Geteq() int64 {
	if !p.IsSeteq() {
		return CCellCounter_eq_DEFAULT
	}
	return *p.eq
}

func (p *CCellCounter) IsSeteq() bool {
	return p.eq != nil
}

func (p *CCellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CCellCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem104 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem104 = v
		}
		p.k = append(p.k, _elem104)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CCellCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *CCellCounter) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *CCellCounter) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.eq = &v
	}
	return nil
}

func (p *CCellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CCellCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CCellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:k: ", p), err)
	}
	return err
}

func (p *CCellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *CCellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *CCellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSeteq() {
		if err := oprot.WriteFieldBegin(ctx, "eq", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:eq: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.eq)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.eq (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:eq: ", p), err)
		}
	}
	return err
}

func (p *CCellCounter) Equals(other *CCellCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src105 := other.k[i]
		if bytes.Compare(_tgt, _src105) != 0 { return false }
	}
	if p.ts != other.ts { return false }
	if p.v != other.v { return false }
	if p.eq != other.eq {
		if p.eq == nil || other.eq == nil {
			return false
		}
		if (*p.eq) != (*other.eq) { return false }
	}
	return true
}

func (p *CCellCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CCellCounter(%+v)", *p)
}

func (p *CCellCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CCellCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CCellCounter)(nil)

func (p *CCellCounter) Validate() error {
	return nil
}

// The Serial column type Cell for results on Columns of scan
// 
// Attributes:
//  - k: The Cell Key
//  - ts: The Cell Timestamp
//  - v: The Cell Serial Value
// 
type CCellSerial struct {
	k Key `thrift:"k,1" db:"k" json:"k"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v CellValuesSerial `thrift:"v,3" db:"v" json:"v"`
}

func NewCCellSerial() *CCellSerial {
	return &CCellSerial{}
}



func (p *CCellSerial) Getk() Key {
	return p.k
}



func (p *CCellSerial) Getts() int64 {
	return p.ts
}



func (p *CCellSerial) Getv() CellValuesSerial {
	return p.v
}

func (p *CCellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CCellSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem106 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem106 = v
		}
		p.k = append(p.k, _elem106)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CCellSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *CCellSerial) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellValuesSerial, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem107 := &CellValueSerial{}
		if err := _elem107.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem107), err)
		}
		p.v = append(p.v, _elem107)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CCellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CCellSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CCellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:k: ", p), err)
	}
	return err
}

func (p *CCellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *CCellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *CCellSerial) Equals(other *CCellSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src108 := other.k[i]
		if bytes.Compare(_tgt, _src108) != 0 { return false }
	}
	if p.ts != other.ts { return false }
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src109 := other.v[i]
		if !_tgt.Equals(_src109) { return false }
	}
	return true
}

func (p *CCellSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CCellSerial(%+v)", *p)
}

func (p *CCellSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CCellSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CCellSerial)(nil)

func (p *CCellSerial) Validate() error {
	return nil
}

// The Column Cells for results on Columns of scan
// 
// Attributes:
//  - plain_cells: The Plain type Cells, defined as CCellPlain items in a list-container
//  - counter_cells: The Counter type Cells, defined as CCellCounter items in a list-container
//  - serial_cells: The Serial type Cells, defined as CCellSerial items in a list-container
// 
type cCells struct {
	plain_cells []*CCellPlain `thrift:"plain_cells,1" db:"plain_cells" json:"plain_cells"`
	counter_cells []*CCellCounter `thrift:"counter_cells,2" db:"counter_cells" json:"counter_cells"`
	serial_cells []*CCellSerial `thrift:"serial_cells,3" db:"serial_cells" json:"serial_cells"`
}

func NewcCells() *cCells {
	return &cCells{}
}



func (p *cCells) Getplain_cells() []*CCellPlain {
	return p.plain_cells
}



func (p *cCells) Getcounter_cells() []*CCellCounter {
	return p.counter_cells
}



func (p *cCells) Getserial_cells() []*CCellSerial {
	return p.serial_cells
}

func (p *cCells) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *cCells) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CCellPlain, 0, size)
	p.plain_cells = tSlice
	for i := 0; i < size; i++ {
		_elem110 := &CCellPlain{}
		if err := _elem110.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem110), err)
		}
		p.plain_cells = append(p.plain_cells, _elem110)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *cCells) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CCellCounter, 0, size)
	p.counter_cells = tSlice
	for i := 0; i < size; i++ {
		_elem111 := &CCellCounter{}
		if err := _elem111.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem111), err)
		}
		p.counter_cells = append(p.counter_cells, _elem111)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *cCells) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*CCellSerial, 0, size)
	p.serial_cells = tSlice
	for i := 0; i < size; i++ {
		_elem112 := &CCellSerial{}
		if err := _elem112.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem112), err)
		}
		p.serial_cells = append(p.serial_cells, _elem112)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *cCells) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "cCells"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *cCells) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "plain_cells", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:plain_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.plain_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.plain_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:plain_cells: ", p), err)
	}
	return err
}

func (p *cCells) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "counter_cells", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:counter_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.counter_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.counter_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:counter_cells: ", p), err)
	}
	return err
}

func (p *cCells) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "serial_cells", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serial_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.serial_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.serial_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serial_cells: ", p), err)
	}
	return err
}

func (p *cCells) Equals(other *cCells) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.plain_cells) != len(other.plain_cells) { return false }
	for i, _tgt := range p.plain_cells {
		_src113 := other.plain_cells[i]
		if !_tgt.Equals(_src113) { return false }
	}
	if len(p.counter_cells) != len(other.counter_cells) { return false }
	for i, _tgt := range p.counter_cells {
		_src114 := other.counter_cells[i]
		if !_tgt.Equals(_src114) { return false }
	}
	if len(p.serial_cells) != len(other.serial_cells) { return false }
	for i, _tgt := range p.serial_cells {
		_src115 := other.serial_cells[i]
		if !_tgt.Equals(_src115) { return false }
	}
	return true
}

func (p *cCells) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("cCells(%+v)", *p)
}

func (p *cCells) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.cCells",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*cCells)(nil)

func (p *cCells) Validate() error {
	return nil
}

// The Plain column type Key Cell for results on Key of scan
// 
// Attributes:
//  - c: The Column Name
//  - ts: The Cell Timestamp
//  - v: The Cell Value
// 
type KCellPlain struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v []byte `thrift:"v,3" db:"v" json:"v"`
}

func NewKCellPlain() *KCellPlain {
	return &KCellPlain{}
}



func (p *KCellPlain) Getc() string {
	return p.c
}



func (p *KCellPlain) Getts() int64 {
	return p.ts
}



func (p *KCellPlain) Getv() []byte {
	return p.v
}

func (p *KCellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *KCellPlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *KCellPlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *KCellPlain) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *KCellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "KCellPlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *KCellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *KCellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *KCellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *KCellPlain) Equals(other *KCellPlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if p.ts != other.ts { return false }
	if bytes.Compare(p.v, other.v) != 0 { return false }
	return true
}

func (p *KCellPlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KCellPlain(%+v)", *p)
}

func (p *KCellPlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.KCellPlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*KCellPlain)(nil)

func (p *KCellPlain) Validate() error {
	return nil
}

// The Counter column type Key Cell for results on Key of scan
// 
// Attributes:
//  - c: The Column Name
//  - ts: The Cell Timestamp
//  - v: The Cell Counter Value
//  - eq: The Counter EQ since ts
// 
type KCellCounter struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v int64 `thrift:"v,3" db:"v" json:"v"`
	eq *int64 `thrift:"eq,4" db:"eq" json:"eq,omitempty"`
}

func NewKCellCounter() *KCellCounter {
	return &KCellCounter{}
}



func (p *KCellCounter) Getc() string {
	return p.c
}



func (p *KCellCounter) Getts() int64 {
	return p.ts
}



func (p *KCellCounter) Getv() int64 {
	return p.v
}

var KCellCounter_eq_DEFAULT int64

func (p *KCellCounter) Geteq() int64 {
	if !p.IsSeteq() {
		return KCellCounter_eq_DEFAULT
	}
	return *p.eq
}

func (p *KCellCounter) IsSeteq() bool {
	return p.eq != nil
}

func (p *KCellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *KCellCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *KCellCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *KCellCounter) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *KCellCounter) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.eq = &v
	}
	return nil
}

func (p *KCellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "KCellCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *KCellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *KCellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *KCellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *KCellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSeteq() {
		if err := oprot.WriteFieldBegin(ctx, "eq", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:eq: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.eq)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.eq (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:eq: ", p), err)
		}
	}
	return err
}

func (p *KCellCounter) Equals(other *KCellCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if p.ts != other.ts { return false }
	if p.v != other.v { return false }
	if p.eq != other.eq {
		if p.eq == nil || other.eq == nil {
			return false
		}
		if (*p.eq) != (*other.eq) { return false }
	}
	return true
}

func (p *KCellCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KCellCounter(%+v)", *p)
}

func (p *KCellCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.KCellCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*KCellCounter)(nil)

func (p *KCellCounter) Validate() error {
	return nil
}

// The Serial column type Key Cell for results on Key of scan
// 
// Attributes:
//  - c: The Column Name
//  - ts: The Cell Timestamp
//  - v: The Cell Serial Value
// 
type KCellSerial struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v CellValuesSerial `thrift:"v,3" db:"v" json:"v"`
}

func NewKCellSerial() *KCellSerial {
	return &KCellSerial{}
}



func (p *KCellSerial) Getc() string {
	return p.c
}



func (p *KCellSerial) Getts() int64 {
	return p.ts
}



func (p *KCellSerial) Getv() CellValuesSerial {
	return p.v
}

func (p *KCellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *KCellSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *KCellSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *KCellSerial) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellValuesSerial, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem116 := &CellValueSerial{}
		if err := _elem116.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem116), err)
		}
		p.v = append(p.v, _elem116)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *KCellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "KCellSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *KCellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *KCellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *KCellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *KCellSerial) Equals(other *KCellSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if p.ts != other.ts { return false }
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src117 := other.v[i]
		if !_tgt.Equals(_src117) { return false }
	}
	return true
}

func (p *KCellSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KCellSerial(%+v)", *p)
}

func (p *KCellSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.KCellSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*KCellSerial)(nil)

func (p *KCellSerial) Validate() error {
	return nil
}

// The Key Cells for results on Key of scan
// 
// Attributes:
//  - k: The Cell Key
//  - plain_cells: The Plain type Key Cells, defined as KCellPlain items in a list-container
//  - counter_cells: The Counter type Key Cells, defined as KCellCounter items in a list-container
//  - serial_cells: The Serial type Key Cells, defined as KCellSerial items in a list-container
// 
type kCells struct {
	k Key `thrift:"k,1" db:"k" json:"k"`
	plain_cells []*KCellPlain `thrift:"plain_cells,2" db:"plain_cells" json:"plain_cells"`
	counter_cells []*KCellCounter `thrift:"counter_cells,3" db:"counter_cells" json:"counter_cells"`
	serial_cells []*KCellSerial `thrift:"serial_cells,4" db:"serial_cells" json:"serial_cells"`
}

func NewkCells() *kCells {
	return &kCells{}
}



func (p *kCells) Getk() Key {
	return p.k
}



func (p *kCells) Getplain_cells() []*KCellPlain {
	return p.plain_cells
}



func (p *kCells) Getcounter_cells() []*KCellCounter {
	return p.counter_cells
}



func (p *kCells) Getserial_cells() []*KCellSerial {
	return p.serial_cells
}

func (p *kCells) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *kCells) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Key, 0, size)
	p.k = tSlice
	for i := 0; i < size; i++ {
		var _elem118 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem118 = v
		}
		p.k = append(p.k, _elem118)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *kCells) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*KCellPlain, 0, size)
	p.plain_cells = tSlice
	for i := 0; i < size; i++ {
		_elem119 := &KCellPlain{}
		if err := _elem119.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem119), err)
		}
		p.plain_cells = append(p.plain_cells, _elem119)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *kCells) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*KCellCounter, 0, size)
	p.counter_cells = tSlice
	for i := 0; i < size; i++ {
		_elem120 := &KCellCounter{}
		if err := _elem120.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem120), err)
		}
		p.counter_cells = append(p.counter_cells, _elem120)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *kCells) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*KCellSerial, 0, size)
	p.serial_cells = tSlice
	for i := 0; i < size; i++ {
		_elem121 := &KCellSerial{}
		if err := _elem121.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem121), err)
		}
		p.serial_cells = append(p.serial_cells, _elem121)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *kCells) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "kCells"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *kCells) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "k", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:k: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.k)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.k {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:k: ", p), err)
	}
	return err
}

func (p *kCells) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "plain_cells", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:plain_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.plain_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.plain_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:plain_cells: ", p), err)
	}
	return err
}

func (p *kCells) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "counter_cells", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:counter_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.counter_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.counter_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:counter_cells: ", p), err)
	}
	return err
}

func (p *kCells) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "serial_cells", thrift.LIST, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:serial_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.serial_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.serial_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:serial_cells: ", p), err)
	}
	return err
}

func (p *kCells) Equals(other *kCells) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.k) != len(other.k) { return false }
	for i, _tgt := range p.k {
		_src122 := other.k[i]
		if bytes.Compare(_tgt, _src122) != 0 { return false }
	}
	if len(p.plain_cells) != len(other.plain_cells) { return false }
	for i, _tgt := range p.plain_cells {
		_src123 := other.plain_cells[i]
		if !_tgt.Equals(_src123) { return false }
	}
	if len(p.counter_cells) != len(other.counter_cells) { return false }
	for i, _tgt := range p.counter_cells {
		_src124 := other.counter_cells[i]
		if !_tgt.Equals(_src124) { return false }
	}
	if len(p.serial_cells) != len(other.serial_cells) { return false }
	for i, _tgt := range p.serial_cells {
		_src125 := other.serial_cells[i]
		if !_tgt.Equals(_src125) { return false }
	}
	return true
}

func (p *kCells) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("kCells(%+v)", *p)
}

func (p *kCells) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.kCells",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*kCells)(nil)

func (p *kCells) Validate() error {
	return nil
}

// The Plain column type Fraction Cell for results on Fraction of scan
// 
// Attributes:
//  - c: The Column Name
//  - ts: The Cell Timestamp
//  - v: The Cell Value
// 
type FCellPlain struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v []byte `thrift:"v,3" db:"v" json:"v"`
}

func NewFCellPlain() *FCellPlain {
	return &FCellPlain{}
}



func (p *FCellPlain) Getc() string {
	return p.c
}



func (p *FCellPlain) Getts() int64 {
	return p.ts
}



func (p *FCellPlain) Getv() []byte {
	return p.v
}

func (p *FCellPlain) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FCellPlain) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *FCellPlain) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *FCellPlain) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *FCellPlain) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FCellPlain"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FCellPlain) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *FCellPlain) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *FCellPlain) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.v); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *FCellPlain) Equals(other *FCellPlain) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if p.ts != other.ts { return false }
	if bytes.Compare(p.v, other.v) != 0 { return false }
	return true
}

func (p *FCellPlain) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FCellPlain(%+v)", *p)
}

func (p *FCellPlain) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FCellPlain",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FCellPlain)(nil)

func (p *FCellPlain) Validate() error {
	return nil
}

// The Counter column type Fraction Cell for results on Fraction of scan
// 
// Attributes:
//  - c: The Column Name
//  - ts: The Cell Timestamp
//  - v: The Cell Counter Value
//  - eq: The Counter EQ since ts
// 
type FCellCounter struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v int64 `thrift:"v,3" db:"v" json:"v"`
	eq *int64 `thrift:"eq,4" db:"eq" json:"eq,omitempty"`
}

func NewFCellCounter() *FCellCounter {
	return &FCellCounter{}
}



func (p *FCellCounter) Getc() string {
	return p.c
}



func (p *FCellCounter) Getts() int64 {
	return p.ts
}



func (p *FCellCounter) Getv() int64 {
	return p.v
}

var FCellCounter_eq_DEFAULT int64

func (p *FCellCounter) Geteq() int64 {
	if !p.IsSeteq() {
		return FCellCounter_eq_DEFAULT
	}
	return *p.eq
}

func (p *FCellCounter) IsSeteq() bool {
	return p.eq != nil
}

func (p *FCellCounter) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FCellCounter) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *FCellCounter) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *FCellCounter) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.v = v
	}
	return nil
}

func (p *FCellCounter) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.eq = &v
	}
	return nil
}

func (p *FCellCounter) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FCellCounter"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FCellCounter) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *FCellCounter) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *FCellCounter) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.v)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.v (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *FCellCounter) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSeteq() {
		if err := oprot.WriteFieldBegin(ctx, "eq", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:eq: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.eq)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.eq (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:eq: ", p), err)
		}
	}
	return err
}

func (p *FCellCounter) Equals(other *FCellCounter) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if p.ts != other.ts { return false }
	if p.v != other.v { return false }
	if p.eq != other.eq {
		if p.eq == nil || other.eq == nil {
			return false
		}
		if (*p.eq) != (*other.eq) { return false }
	}
	return true
}

func (p *FCellCounter) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FCellCounter(%+v)", *p)
}

func (p *FCellCounter) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FCellCounter",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FCellCounter)(nil)

func (p *FCellCounter) Validate() error {
	return nil
}

// The Serial column type Fraction Cell for results on Fraction of scan
// 
// Attributes:
//  - c: The Column Name
//  - ts: The Cell Timestamp
//  - v: The Cell Serial Value
// 
type FCellSerial struct {
	c string `thrift:"c,1" db:"c" json:"c"`
	ts int64 `thrift:"ts,2" db:"ts" json:"ts"`
	v CellValuesSerial `thrift:"v,3" db:"v" json:"v"`
}

func NewFCellSerial() *FCellSerial {
	return &FCellSerial{}
}



func (p *FCellSerial) Getc() string {
	return p.c
}



func (p *FCellSerial) Getts() int64 {
	return p.ts
}



func (p *FCellSerial) Getv() CellValuesSerial {
	return p.v
}

func (p *FCellSerial) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FCellSerial) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.c = v
	}
	return nil
}

func (p *FCellSerial) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ts = v
	}
	return nil
}

func (p *FCellSerial) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellValuesSerial, 0, size)
	p.v = tSlice
	for i := 0; i < size; i++ {
		_elem126 := &CellValueSerial{}
		if err := _elem126.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem126), err)
		}
		p.v = append(p.v, _elem126)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FCellSerial) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FCellSerial"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FCellSerial) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "c", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:c: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.c)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.c (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:c: ", p), err)
	}
	return err
}

func (p *FCellSerial) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ts", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ts: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ts)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ts (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ts: ", p), err)
	}
	return err
}

func (p *FCellSerial) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "v", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:v: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.v)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.v {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:v: ", p), err)
	}
	return err
}

func (p *FCellSerial) Equals(other *FCellSerial) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.c != other.c { return false }
	if p.ts != other.ts { return false }
	if len(p.v) != len(other.v) { return false }
	for i, _tgt := range p.v {
		_src127 := other.v[i]
		if !_tgt.Equals(_src127) { return false }
	}
	return true
}

func (p *FCellSerial) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FCellSerial(%+v)", *p)
}

func (p *FCellSerial) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FCellSerial",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FCellSerial)(nil)

func (p *FCellSerial) Validate() error {
	return nil
}

// The Fraction Cells for results on Fraction of scan
// 
// Attributes:
//  - f: The Fraction Container for the Next Fractions Tree,  defined as FCells items in a map-container by current Fraction bytes
//  - plain_cells: The current Fraction's Cells, defined as FCellPlain items in a list-container
//  - counter_cells: The current Fraction's Cells, defined as FCellCounter items in a list-container
//  - serial_cells: The current Fraction's Serial Cells, defined as FCellSerial items in a list-container
// 
type FCells struct {
	f map[string]*FCells `thrift:"f,1" db:"f" json:"f"`
	plain_cells []*FCellPlain `thrift:"plain_cells,2" db:"plain_cells" json:"plain_cells"`
	counter_cells []*FCellCounter `thrift:"counter_cells,3" db:"counter_cells" json:"counter_cells"`
	serial_cells []*FCellSerial `thrift:"serial_cells,4" db:"serial_cells" json:"serial_cells"`
}

func NewFCells() *FCells {
	return &FCells{}
}



func (p *FCells) Getf() map[string]*FCells {
	return p.f
}



func (p *FCells) Getplain_cells() []*FCellPlain {
	return p.plain_cells
}



func (p *FCells) Getcounter_cells() []*FCellCounter {
	return p.counter_cells
}



func (p *FCells) Getserial_cells() []*FCellSerial {
	return p.serial_cells
}

func (p *FCells) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *FCells) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]*FCells, size)
	p.f = tMap
	for i := 0; i < size; i++ {
		var _key128 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key128 = v
		}
		_val129 := &FCells{}
		if err := _val129.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val129), err)
		}
		p.f[_key128] = _val129
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *FCells) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FCellPlain, 0, size)
	p.plain_cells = tSlice
	for i := 0; i < size; i++ {
		_elem130 := &FCellPlain{}
		if err := _elem130.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem130), err)
		}
		p.plain_cells = append(p.plain_cells, _elem130)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FCells) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FCellCounter, 0, size)
	p.counter_cells = tSlice
	for i := 0; i < size; i++ {
		_elem131 := &FCellCounter{}
		if err := _elem131.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem131), err)
		}
		p.counter_cells = append(p.counter_cells, _elem131)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FCells) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FCellSerial, 0, size)
	p.serial_cells = tSlice
	for i := 0; i < size; i++ {
		_elem132 := &FCellSerial{}
		if err := _elem132.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem132), err)
		}
		p.serial_cells = append(p.serial_cells, _elem132)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FCells) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FCells"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FCells) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "f", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:f: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.f)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.f {
		if err := oprot.WriteString(ctx, string(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:f: ", p), err)
	}
	return err
}

func (p *FCells) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "plain_cells", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:plain_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.plain_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.plain_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:plain_cells: ", p), err)
	}
	return err
}

func (p *FCells) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "counter_cells", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:counter_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.counter_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.counter_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:counter_cells: ", p), err)
	}
	return err
}

func (p *FCells) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "serial_cells", thrift.LIST, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:serial_cells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.serial_cells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.serial_cells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:serial_cells: ", p), err)
	}
	return err
}

func (p *FCells) Equals(other *FCells) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.f) != len(other.f) { return false }
	for k, _tgt := range p.f {
		_src133 := other.f[k]
		if !_tgt.Equals(_src133) { return false }
	}
	if len(p.plain_cells) != len(other.plain_cells) { return false }
	for i, _tgt := range p.plain_cells {
		_src134 := other.plain_cells[i]
		if !_tgt.Equals(_src134) { return false }
	}
	if len(p.counter_cells) != len(other.counter_cells) { return false }
	for i, _tgt := range p.counter_cells {
		_src135 := other.counter_cells[i]
		if !_tgt.Equals(_src135) { return false }
	}
	if len(p.serial_cells) != len(other.serial_cells) { return false }
	for i, _tgt := range p.serial_cells {
		_src136 := other.serial_cells[i]
		if !_tgt.Equals(_src136) { return false }
	}
	return true
}

func (p *FCells) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FCells(%+v)", *p)
}

func (p *FCells) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.FCells",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FCells)(nil)

func (p *FCells) Validate() error {
	return nil
}

// A Grouped Cells result for results of scan, determined by the request's CellsResult enum
// 
// Attributes:
//  - cells: The Cells in a list, defined as Cell items in a list-container
//  - ccells: The Columns Cells in a map-container, defined as cCells items by Column Name
//  - kcells: The Keys Cells in a list, defined as kCells items in a list-container
//  - fcells: The Fraction Cells in struct FCells
// 
type CellsGroup struct {
	cells *Cells `thrift:"cells,1" db:"cells" json:"cells"`
	ccells CCells `thrift:"ccells,2" db:"ccells" json:"ccells"`
	kcells KCells `thrift:"kcells,3" db:"kcells" json:"kcells"`
	fcells *FCells `thrift:"fcells,4" db:"fcells" json:"fcells"`
}

func NewCellsGroup() *CellsGroup {
	return &CellsGroup{}
}

var CellsGroup_cells_DEFAULT *Cells

func (p *CellsGroup) Getcells() *Cells {
	if !p.IsSetcells() {
		return CellsGroup_cells_DEFAULT
	}
	return p.cells
}



func (p *CellsGroup) Getccells() CCells {
	return p.ccells
}



func (p *CellsGroup) Getkcells() KCells {
	return p.kcells
}

var CellsGroup_fcells_DEFAULT *FCells

func (p *CellsGroup) Getfcells() *FCells {
	if !p.IsSetfcells() {
		return CellsGroup_fcells_DEFAULT
	}
	return p.fcells
}

func (p *CellsGroup) IsSetcells() bool {
	return p.cells != nil
}

func (p *CellsGroup) IsSetfcells() bool {
	return p.fcells != nil
}

func (p *CellsGroup) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CellsGroup) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.cells = &Cells{}
	if err := p.cells.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.cells), err)
	}
	return nil
}

func (p *CellsGroup) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(CCells, size)
	p.ccells = tMap
	for i := 0; i < size; i++ {
		var _key137 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key137 = v
		}
		_val138 := &cCells{}
		if err := _val138.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val138), err)
		}
		p.ccells[_key137] = _val138
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *CellsGroup) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(KCells, 0, size)
	p.kcells = tSlice
	for i := 0; i < size; i++ {
		_elem139 := &kCells{}
		if err := _elem139.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem139), err)
		}
		p.kcells = append(p.kcells, _elem139)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *CellsGroup) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.fcells = &FCells{}
	if err := p.fcells.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.fcells), err)
	}
	return nil
}

func (p *CellsGroup) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CellsGroup"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CellsGroup) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cells", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cells: ", p), err)
	}
	if err := p.cells.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.cells), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cells: ", p), err)
	}
	return err
}

func (p *CellsGroup) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ccells", thrift.MAP, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:ccells: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.ccells)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.ccells {
		if err := oprot.WriteString(ctx, string(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:ccells: ", p), err)
	}
	return err
}

func (p *CellsGroup) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "kcells", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:kcells: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.kcells)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.kcells {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:kcells: ", p), err)
	}
	return err
}

func (p *CellsGroup) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "fcells", thrift.STRUCT, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:fcells: ", p), err)
	}
	if err := p.fcells.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.fcells), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:fcells: ", p), err)
	}
	return err
}

func (p *CellsGroup) Equals(other *CellsGroup) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.cells.Equals(other.cells) { return false }
	if len(p.ccells) != len(other.ccells) { return false }
	for k, _tgt := range p.ccells {
		_src140 := other.ccells[k]
		if !_tgt.Equals(_src140) { return false }
	}
	if len(p.kcells) != len(other.kcells) { return false }
	for i, _tgt := range p.kcells {
		_src141 := other.kcells[i]
		if !_tgt.Equals(_src141) { return false }
	}
	if !p.fcells.Equals(other.fcells) { return false }
	return true
}

func (p *CellsGroup) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CellsGroup(%+v)", *p)
}

func (p *CellsGroup) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CellsGroup",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CellsGroup)(nil)

func (p *CellsGroup) Validate() error {
	return nil
}

// The Compact Result
// 
// Attributes:
//  - cid: Column ID
//  - err: Error
// 
type CompactResult_ struct {
	cid int64 `thrift:"cid,1" db:"cid" json:"cid"`
	err int32 `thrift:"err,2" db:"err" json:"err"`
}

func NewCompactResult_() *CompactResult_ {
	return &CompactResult_{}
}



func (p *CompactResult_) Getcid() int64 {
	return p.cid
}



func (p *CompactResult_) Geterr() int32 {
	return p.err
}

func (p *CompactResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *CompactResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.cid = v
	}
	return nil
}

func (p *CompactResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.err = v
	}
	return nil
}

func (p *CompactResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CompactResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *CompactResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cid", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cid: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.cid)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.cid (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cid: ", p), err)
	}
	return err
}

func (p *CompactResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "err", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:err: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.err)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.err (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:err: ", p), err)
	}
	return err
}

func (p *CompactResult_) Equals(other *CompactResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.cid != other.cid { return false }
	if p.err != other.err { return false }
	return true
}

func (p *CompactResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompactResult_(%+v)", *p)
}

func (p *CompactResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.CompactResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*CompactResult_)(nil)

func (p *CompactResult_) Validate() error {
	return nil
}

// The Result of 'exec_sql'
// 
// Attributes:
//  - schemas: Set with result for 'list columns' query
//  - cells: Set with result for 'select' query
//  - compact: Set with result for 'compact columns' query
// 
type Result_ struct {
	schemas Schemas `thrift:"schemas,1" db:"schemas" json:"schemas"`
	cells *Cells `thrift:"cells,2" db:"cells" json:"cells"`
	compact CompactResults `thrift:"compact,3" db:"compact" json:"compact"`
}

func NewResult_() *Result_ {
	return &Result_{}
}



func (p *Result_) Getschemas() Schemas {
	return p.schemas
}

var Result__cells_DEFAULT *Cells

func (p *Result_) Getcells() *Cells {
	if !p.IsSetcells() {
		return Result__cells_DEFAULT
	}
	return p.cells
}



func (p *Result_) Getcompact() CompactResults {
	return p.compact
}

func (p *Result_) IsSetcells() bool {
	return p.cells != nil
}

func (p *Result_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Result_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Schemas, 0, size)
	p.schemas = tSlice
	for i := 0; i < size; i++ {
		_elem142 := &Schema{}
		if err := _elem142.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem142), err)
		}
		p.schemas = append(p.schemas, _elem142)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Result_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.cells = &Cells{}
	if err := p.cells.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.cells), err)
	}
	return nil
}

func (p *Result_) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CompactResults, 0, size)
	p.compact = tSlice
	for i := 0; i < size; i++ {
		_elem143 := &CompactResult_{}
		if err := _elem143.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem143), err)
		}
		p.compact = append(p.compact, _elem143)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Result_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Result_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "schemas", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:schemas: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.schemas)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.schemas {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:schemas: ", p), err)
	}
	return err
}

func (p *Result_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cells", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:cells: ", p), err)
	}
	if err := p.cells.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.cells), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:cells: ", p), err)
	}
	return err
}

func (p *Result_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "compact", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:compact: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.compact)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.compact {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:compact: ", p), err)
	}
	return err
}

func (p *Result_) Equals(other *Result_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.schemas) != len(other.schemas) { return false }
	for i, _tgt := range p.schemas {
		_src144 := other.schemas[i]
		if !_tgt.Equals(_src144) { return false }
	}
	if !p.cells.Equals(other.cells) { return false }
	if len(p.compact) != len(other.compact) { return false }
	for i, _tgt := range p.compact {
		_src145 := other.compact[i]
		if !_tgt.Equals(_src145) { return false }
	}
	return true
}

func (p *Result_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Result_(%+v)", *p)
}

func (p *Result_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Result_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Result_)(nil)

func (p *Result_) Validate() error {
	return nil
}

type Service interface {	//The SWC-DB Thrift Service

	// The direct SQL method to Manage Column.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_mng_column(ctx context.Context, sql string) (_err error)
	// The direct SQL method to List Columns
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_list_columns(ctx context.Context, sql string) (_r Schemas, _err error)
	// The direct SQL method to Compact Columns
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_compact_columns(ctx context.Context, sql string) (_r CompactResults, _err error)
	// The direct SQL method to select cells with result in CellsPlain.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_select_plain(ctx context.Context, sql string) (_r CellsPlain, _err error)
	// The direct SQL method to select cells with result in CellsCounter.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_select_counter(ctx context.Context, sql string) (_r CellsCounter, _err error)
	// The direct SQL method to select cells with result in CellsSerial.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_select_serial(ctx context.Context, sql string) (_r CellsSerial, _err error)
	// The direct SQL method to select cells with result in Cells List.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_select(ctx context.Context, sql string) (_r *Cells, _err error)
	// The direct SQL method to select cells with result in Columns Cells map.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_select_rslt_on_column(ctx context.Context, sql string) (_r CCells, _err error)
	// The direct SQL method to select cells with result in Key Cells list.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_select_rslt_on_key(ctx context.Context, sql string) (_r KCells, _err error)
	// The direct SQL method to select cells with result in Fractons Cells.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	sql_select_rslt_on_fraction(ctx context.Context, sql string) (_r *FCells, _err error)
	// The SQL method to select cells with result set by the request's type of CellsResult.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	//  - rslt: The Type of Cells Result for the response
	// 
	sql_query(ctx context.Context, sql string, rslt CellsResult_) (_r *CellsGroup, _err error)
	// The direct SQL method to update cells optionally to work with updater-id.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	//  - updater_id: The Updater ID to work with
	// 
	sql_update(ctx context.Context, sql string, updater_id int64) (_err error)
	// The SQL method to execute any query.
	// 
	// Parameters:
	//  - sql: The SQL string to Execute
	// 
	exec_sql(ctx context.Context, sql string) (_r *Result_, _err error)
	// The method to Create an Updater ID with buffering size in bytes.
	// 
	// Parameters:
	//  - buffer_size: The buffer size of the Updater
	// 
	updater_create(ctx context.Context, buffer_size int32) (_r int64, _err error)
	// The method to Close an Updater ID.
	// 
	// Parameters:
	//  - id: The Updater ID to close
	// 
	updater_close(ctx context.Context, id int64) (_err error)
	// The direct method to update cells with cell in Update-Columns-Cells-Plain,
	// optionally to work with updater-id.
	// 
	// Parameters:
	//  - cells: The Cells to update
	//  - updater_id: The Updater ID to use for write
	// 
	update_plain(ctx context.Context, cells UCCellsPlain, updater_id int64) (_err error)
	// The direct method to update cells with cell in Update-Columns-Cells-Counter,
	// optionally to work with updater-id.
	// 
	// Parameters:
	//  - cells: The Counter Cells to update
	//  - updater_id: The Updater ID to use for write
	// 
	update_counter(ctx context.Context, cells UCCellsCounter, updater_id int64) (_err error)
	// The direct method to update cells with cell in Update-Columns-Cells-Serial,
	// optionally to work with updater-id.
	// 
	// Parameters:
	//  - cells: The Serial Cells to update
	//  - updater_id: The Updater ID to use for write
	// 
	update_serial(ctx context.Context, cells UCCellsSerial, updater_id int64) (_err error)
	// The method is to update cells by several Column-Types,
	// optionally to work with updater-id.
	// 
	// Parameters:
	//  - plain: The PLAIN Cells to update
	//  - counter: The COUNTER Cells to update
	//  - serial: The SERIAL Cells to update
	//  - updater_id: The Updater ID to use for write
	// 
	update_by_types(ctx context.Context, plain UCCellsPlain, counter UCCellsCounter, serial UCCellsSerial, updater_id int64) (_err error)
	// The direct method to Manage Column
	// 
	// Parameters:
	//  - func: The Action Function to use
	//  - schema: The Schema for the Action
	// 
	mng_column(ctx context.Context, func_a1 SchemaFunc, schema *Schema) (_err error)
	// The direct method to List Columns
	// 
	// Parameters:
	//  - spec: The Schemas Specifications to match Schema for response
	// 
	list_columns(ctx context.Context, spec *SpecSchemas) (_r Schemas, _err error)
	// The direct method to Compact Columns
	// 
	// Parameters:
	//  - spec: The Schemas Specifications to match columns to Compact
	// 
	compact_columns(ctx context.Context, spec *SpecSchemas) (_r CompactResults, _err error)
	// The direct method to select cells with result in Cells List.
	// 
	// Parameters:
	//  - spec: The Scan Specifications for the scan
	// 
	scan(ctx context.Context, spec *SpecScan) (_r *Cells, _err error)
	// The direct method to select cells with result in Columns Cells map.
	// 
	// Parameters:
	//  - spec: The Scan Specifications for the scan
	// 
	scan_rslt_on_column(ctx context.Context, spec *SpecScan) (_r CCells, _err error)
	// The direct method to select cells with result in Key Cells list.
	// 
	// Parameters:
	//  - spec: The Scan Specifications for the scan
	// 
	scan_rslt_on_key(ctx context.Context, spec *SpecScan) (_r KCells, _err error)
	// The direct method to select cells with result in Fractons Cells.
	// 
	// Parameters:
	//  - spec: The Scan Specifications for the scan
	// 
	scan_rslt_on_fraction(ctx context.Context, spec *SpecScan) (_r *FCells, _err error)
	// The method to select cells with result set by the request's type of CellsResult.
	// 
	// Parameters:
	//  - spec: The Scan Specifications for the scan
	//  - rslt: The Type of Cells Result for the response
	// 
	scan_rslt_on(ctx context.Context, spec *SpecScan, rslt CellsResult_) (_r *CellsGroup, _err error)
}

//The SWC-DB Thrift Service
type ServiceClient struct {
	c thrift.TClient
	meta thrift.ResponseMeta
}

func NewServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ServiceClient {
	return &ServiceClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ServiceClient {
	return &ServiceClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewServiceClient(c thrift.TClient) *ServiceClient {
	return &ServiceClient{
		c: c,
	}
}

func (p *ServiceClient) Client_() thrift.TClient {
	return p.c
}

func (p *ServiceClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *ServiceClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

// The direct SQL method to Manage Column.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_mng_column(ctx context.Context, sql string) (_err error) {
	var _args146 Servicesql_mng_column_args
	_args146.sql = sql
	var _result148 Servicesql_mng_column_result
	var _meta147 thrift.ResponseMeta
	_meta147, _err = p.Client_().Call(ctx, "sql_mng_column", &_args146, &_result148)
	p.SetLastResponseMeta_(_meta147)
	if _err != nil {
		return
	}
	switch {
	case _result148.e!= nil:
		return _result148.e
	}

	return nil
}

// The direct SQL method to List Columns
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_list_columns(ctx context.Context, sql string) (_r Schemas, _err error) {
	var _args149 Servicesql_list_columns_args
	_args149.sql = sql
	var _result151 Servicesql_list_columns_result
	var _meta150 thrift.ResponseMeta
	_meta150, _err = p.Client_().Call(ctx, "sql_list_columns", &_args149, &_result151)
	p.SetLastResponseMeta_(_meta150)
	if _err != nil {
		return
	}
	switch {
	case _result151.e!= nil:
		return _r, _result151.e
	}

	return _result151.GetSuccess(), nil
}

// The direct SQL method to Compact Columns
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_compact_columns(ctx context.Context, sql string) (_r CompactResults, _err error) {
	var _args152 Servicesql_compact_columns_args
	_args152.sql = sql
	var _result154 Servicesql_compact_columns_result
	var _meta153 thrift.ResponseMeta
	_meta153, _err = p.Client_().Call(ctx, "sql_compact_columns", &_args152, &_result154)
	p.SetLastResponseMeta_(_meta153)
	if _err != nil {
		return
	}
	switch {
	case _result154.e!= nil:
		return _r, _result154.e
	}

	return _result154.GetSuccess(), nil
}

// The direct SQL method to select cells with result in CellsPlain.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_select_plain(ctx context.Context, sql string) (_r CellsPlain, _err error) {
	var _args155 Servicesql_select_plain_args
	_args155.sql = sql
	var _result157 Servicesql_select_plain_result
	var _meta156 thrift.ResponseMeta
	_meta156, _err = p.Client_().Call(ctx, "sql_select_plain", &_args155, &_result157)
	p.SetLastResponseMeta_(_meta156)
	if _err != nil {
		return
	}
	switch {
	case _result157.e!= nil:
		return _r, _result157.e
	}

	return _result157.GetSuccess(), nil
}

// The direct SQL method to select cells with result in CellsCounter.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_select_counter(ctx context.Context, sql string) (_r CellsCounter, _err error) {
	var _args158 Servicesql_select_counter_args
	_args158.sql = sql
	var _result160 Servicesql_select_counter_result
	var _meta159 thrift.ResponseMeta
	_meta159, _err = p.Client_().Call(ctx, "sql_select_counter", &_args158, &_result160)
	p.SetLastResponseMeta_(_meta159)
	if _err != nil {
		return
	}
	switch {
	case _result160.e!= nil:
		return _r, _result160.e
	}

	return _result160.GetSuccess(), nil
}

// The direct SQL method to select cells with result in CellsSerial.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_select_serial(ctx context.Context, sql string) (_r CellsSerial, _err error) {
	var _args161 Servicesql_select_serial_args
	_args161.sql = sql
	var _result163 Servicesql_select_serial_result
	var _meta162 thrift.ResponseMeta
	_meta162, _err = p.Client_().Call(ctx, "sql_select_serial", &_args161, &_result163)
	p.SetLastResponseMeta_(_meta162)
	if _err != nil {
		return
	}
	switch {
	case _result163.e!= nil:
		return _r, _result163.e
	}

	return _result163.GetSuccess(), nil
}

// The direct SQL method to select cells with result in Cells List.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_select(ctx context.Context, sql string) (_r *Cells, _err error) {
	var _args164 Servicesql_select_args
	_args164.sql = sql
	var _result166 Servicesql_select_result
	var _meta165 thrift.ResponseMeta
	_meta165, _err = p.Client_().Call(ctx, "sql_select", &_args164, &_result166)
	p.SetLastResponseMeta_(_meta165)
	if _err != nil {
		return
	}
	switch {
	case _result166.e!= nil:
		return _r, _result166.e
	}

	if _ret167 := _result166.GetSuccess(); _ret167 != nil {
		return _ret167, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "sql_select failed: unknown result")
}

// The direct SQL method to select cells with result in Columns Cells map.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_select_rslt_on_column(ctx context.Context, sql string) (_r CCells, _err error) {
	var _args168 Servicesql_select_rslt_on_column_args
	_args168.sql = sql
	var _result170 Servicesql_select_rslt_on_column_result
	var _meta169 thrift.ResponseMeta
	_meta169, _err = p.Client_().Call(ctx, "sql_select_rslt_on_column", &_args168, &_result170)
	p.SetLastResponseMeta_(_meta169)
	if _err != nil {
		return
	}
	switch {
	case _result170.e!= nil:
		return _r, _result170.e
	}

	return _result170.GetSuccess(), nil
}

// The direct SQL method to select cells with result in Key Cells list.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_select_rslt_on_key(ctx context.Context, sql string) (_r KCells, _err error) {
	var _args171 Servicesql_select_rslt_on_key_args
	_args171.sql = sql
	var _result173 Servicesql_select_rslt_on_key_result
	var _meta172 thrift.ResponseMeta
	_meta172, _err = p.Client_().Call(ctx, "sql_select_rslt_on_key", &_args171, &_result173)
	p.SetLastResponseMeta_(_meta172)
	if _err != nil {
		return
	}
	switch {
	case _result173.e!= nil:
		return _r, _result173.e
	}

	return _result173.GetSuccess(), nil
}

// The direct SQL method to select cells with result in Fractons Cells.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) sql_select_rslt_on_fraction(ctx context.Context, sql string) (_r *FCells, _err error) {
	var _args174 Servicesql_select_rslt_on_fraction_args
	_args174.sql = sql
	var _result176 Servicesql_select_rslt_on_fraction_result
	var _meta175 thrift.ResponseMeta
	_meta175, _err = p.Client_().Call(ctx, "sql_select_rslt_on_fraction", &_args174, &_result176)
	p.SetLastResponseMeta_(_meta175)
	if _err != nil {
		return
	}
	switch {
	case _result176.e!= nil:
		return _r, _result176.e
	}

	if _ret177 := _result176.GetSuccess(); _ret177 != nil {
		return _ret177, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "sql_select_rslt_on_fraction failed: unknown result")
}

// The SQL method to select cells with result set by the request's type of CellsResult.
// 
// Parameters:
//  - sql: The SQL string to Execute
//  - rslt: The Type of Cells Result for the response
// 
func (p *ServiceClient) sql_query(ctx context.Context, sql string, rslt CellsResult_) (_r *CellsGroup, _err error) {
	var _args178 Servicesql_query_args
	_args178.sql = sql
	_args178.rslt = rslt
	var _result180 Servicesql_query_result
	var _meta179 thrift.ResponseMeta
	_meta179, _err = p.Client_().Call(ctx, "sql_query", &_args178, &_result180)
	p.SetLastResponseMeta_(_meta179)
	if _err != nil {
		return
	}
	switch {
	case _result180.e!= nil:
		return _r, _result180.e
	}

	if _ret181 := _result180.GetSuccess(); _ret181 != nil {
		return _ret181, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "sql_query failed: unknown result")
}

// The direct SQL method to update cells optionally to work with updater-id.
// 
// Parameters:
//  - sql: The SQL string to Execute
//  - updater_id: The Updater ID to work with
// 
func (p *ServiceClient) sql_update(ctx context.Context, sql string, updater_id int64) (_err error) {
	var _args182 Servicesql_update_args
	_args182.sql = sql
	_args182.updater_id = updater_id
	var _result184 Servicesql_update_result
	var _meta183 thrift.ResponseMeta
	_meta183, _err = p.Client_().Call(ctx, "sql_update", &_args182, &_result184)
	p.SetLastResponseMeta_(_meta183)
	if _err != nil {
		return
	}
	switch {
	case _result184.e!= nil:
		return _result184.e
	}

	return nil
}

// The SQL method to execute any query.
// 
// Parameters:
//  - sql: The SQL string to Execute
// 
func (p *ServiceClient) exec_sql(ctx context.Context, sql string) (_r *Result_, _err error) {
	var _args185 Serviceexec_sql_args
	_args185.sql = sql
	var _result187 Serviceexec_sql_result
	var _meta186 thrift.ResponseMeta
	_meta186, _err = p.Client_().Call(ctx, "exec_sql", &_args185, &_result187)
	p.SetLastResponseMeta_(_meta186)
	if _err != nil {
		return
	}
	switch {
	case _result187.e!= nil:
		return _r, _result187.e
	}

	if _ret188 := _result187.GetSuccess(); _ret188 != nil {
		return _ret188, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "exec_sql failed: unknown result")
}

// The method to Create an Updater ID with buffering size in bytes.
// 
// Parameters:
//  - buffer_size: The buffer size of the Updater
// 
func (p *ServiceClient) updater_create(ctx context.Context, buffer_size int32) (_r int64, _err error) {
	var _args189 Serviceupdater_create_args
	_args189.buffer_size = buffer_size
	var _result191 Serviceupdater_create_result
	var _meta190 thrift.ResponseMeta
	_meta190, _err = p.Client_().Call(ctx, "updater_create", &_args189, &_result191)
	p.SetLastResponseMeta_(_meta190)
	if _err != nil {
		return
	}
	switch {
	case _result191.e!= nil:
		return _r, _result191.e
	}

	return _result191.GetSuccess(), nil
}

// The method to Close an Updater ID.
// 
// Parameters:
//  - id: The Updater ID to close
// 
func (p *ServiceClient) updater_close(ctx context.Context, id int64) (_err error) {
	var _args192 Serviceupdater_close_args
	_args192.id = id
	var _result194 Serviceupdater_close_result
	var _meta193 thrift.ResponseMeta
	_meta193, _err = p.Client_().Call(ctx, "updater_close", &_args192, &_result194)
	p.SetLastResponseMeta_(_meta193)
	if _err != nil {
		return
	}
	switch {
	case _result194.e!= nil:
		return _result194.e
	}

	return nil
}

// The direct method to update cells with cell in Update-Columns-Cells-Plain,
// optionally to work with updater-id.
// 
// Parameters:
//  - cells: The Cells to update
//  - updater_id: The Updater ID to use for write
// 
func (p *ServiceClient) update_plain(ctx context.Context, cells UCCellsPlain, updater_id int64) (_err error) {
	var _args195 Serviceupdate_plain_args
	_args195.cells = cells
	_args195.updater_id = updater_id
	var _result197 Serviceupdate_plain_result
	var _meta196 thrift.ResponseMeta
	_meta196, _err = p.Client_().Call(ctx, "update_plain", &_args195, &_result197)
	p.SetLastResponseMeta_(_meta196)
	if _err != nil {
		return
	}
	switch {
	case _result197.e!= nil:
		return _result197.e
	}

	return nil
}

// The direct method to update cells with cell in Update-Columns-Cells-Counter,
// optionally to work with updater-id.
// 
// Parameters:
//  - cells: The Counter Cells to update
//  - updater_id: The Updater ID to use for write
// 
func (p *ServiceClient) update_counter(ctx context.Context, cells UCCellsCounter, updater_id int64) (_err error) {
	var _args198 Serviceupdate_counter_args
	_args198.cells = cells
	_args198.updater_id = updater_id
	var _result200 Serviceupdate_counter_result
	var _meta199 thrift.ResponseMeta
	_meta199, _err = p.Client_().Call(ctx, "update_counter", &_args198, &_result200)
	p.SetLastResponseMeta_(_meta199)
	if _err != nil {
		return
	}
	switch {
	case _result200.e!= nil:
		return _result200.e
	}

	return nil
}

// The direct method to update cells with cell in Update-Columns-Cells-Serial,
// optionally to work with updater-id.
// 
// Parameters:
//  - cells: The Serial Cells to update
//  - updater_id: The Updater ID to use for write
// 
func (p *ServiceClient) update_serial(ctx context.Context, cells UCCellsSerial, updater_id int64) (_err error) {
	var _args201 Serviceupdate_serial_args
	_args201.cells = cells
	_args201.updater_id = updater_id
	var _result203 Serviceupdate_serial_result
	var _meta202 thrift.ResponseMeta
	_meta202, _err = p.Client_().Call(ctx, "update_serial", &_args201, &_result203)
	p.SetLastResponseMeta_(_meta202)
	if _err != nil {
		return
	}
	switch {
	case _result203.e!= nil:
		return _result203.e
	}

	return nil
}

// The method is to update cells by several Column-Types,
// optionally to work with updater-id.
// 
// Parameters:
//  - plain: The PLAIN Cells to update
//  - counter: The COUNTER Cells to update
//  - serial: The SERIAL Cells to update
//  - updater_id: The Updater ID to use for write
// 
func (p *ServiceClient) update_by_types(ctx context.Context, plain UCCellsPlain, counter UCCellsCounter, serial UCCellsSerial, updater_id int64) (_err error) {
	var _args204 Serviceupdate_by_types_args
	_args204.plain = plain
	_args204.counter = counter
	_args204.serial = serial
	_args204.updater_id = updater_id
	var _result206 Serviceupdate_by_types_result
	var _meta205 thrift.ResponseMeta
	_meta205, _err = p.Client_().Call(ctx, "update_by_types", &_args204, &_result206)
	p.SetLastResponseMeta_(_meta205)
	if _err != nil {
		return
	}
	switch {
	case _result206.e!= nil:
		return _result206.e
	}

	return nil
}

// The direct method to Manage Column
// 
// Parameters:
//  - func: The Action Function to use
//  - schema: The Schema for the Action
// 
func (p *ServiceClient) mng_column(ctx context.Context, func_a1 SchemaFunc, schema *Schema) (_err error) {
	var _args207 Servicemng_column_args
	_args207.func = func_a1
	_args207.schema = schema
	var _result209 Servicemng_column_result
	var _meta208 thrift.ResponseMeta
	_meta208, _err = p.Client_().Call(ctx, "mng_column", &_args207, &_result209)
	p.SetLastResponseMeta_(_meta208)
	if _err != nil {
		return
	}
	switch {
	case _result209.e!= nil:
		return _result209.e
	}

	return nil
}

// The direct method to List Columns
// 
// Parameters:
//  - spec: The Schemas Specifications to match Schema for response
// 
func (p *ServiceClient) list_columns(ctx context.Context, spec *SpecSchemas) (_r Schemas, _err error) {
	var _args210 Servicelist_columns_args
	_args210.spec = spec
	var _result212 Servicelist_columns_result
	var _meta211 thrift.ResponseMeta
	_meta211, _err = p.Client_().Call(ctx, "list_columns", &_args210, &_result212)
	p.SetLastResponseMeta_(_meta211)
	if _err != nil {
		return
	}
	switch {
	case _result212.e!= nil:
		return _r, _result212.e
	}

	return _result212.GetSuccess(), nil
}

// The direct method to Compact Columns
// 
// Parameters:
//  - spec: The Schemas Specifications to match columns to Compact
// 
func (p *ServiceClient) compact_columns(ctx context.Context, spec *SpecSchemas) (_r CompactResults, _err error) {
	var _args213 Servicecompact_columns_args
	_args213.spec = spec
	var _result215 Servicecompact_columns_result
	var _meta214 thrift.ResponseMeta
	_meta214, _err = p.Client_().Call(ctx, "compact_columns", &_args213, &_result215)
	p.SetLastResponseMeta_(_meta214)
	if _err != nil {
		return
	}
	switch {
	case _result215.e!= nil:
		return _r, _result215.e
	}

	return _result215.GetSuccess(), nil
}

// The direct method to select cells with result in Cells List.
// 
// Parameters:
//  - spec: The Scan Specifications for the scan
// 
func (p *ServiceClient) scan(ctx context.Context, spec *SpecScan) (_r *Cells, _err error) {
	var _args216 Servicescan_args
	_args216.spec = spec
	var _result218 Servicescan_result
	var _meta217 thrift.ResponseMeta
	_meta217, _err = p.Client_().Call(ctx, "scan", &_args216, &_result218)
	p.SetLastResponseMeta_(_meta217)
	if _err != nil {
		return
	}
	switch {
	case _result218.e!= nil:
		return _r, _result218.e
	}

	if _ret219 := _result218.GetSuccess(); _ret219 != nil {
		return _ret219, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "scan failed: unknown result")
}

// The direct method to select cells with result in Columns Cells map.
// 
// Parameters:
//  - spec: The Scan Specifications for the scan
// 
func (p *ServiceClient) scan_rslt_on_column(ctx context.Context, spec *SpecScan) (_r CCells, _err error) {
	var _args220 Servicescan_rslt_on_column_args
	_args220.spec = spec
	var _result222 Servicescan_rslt_on_column_result
	var _meta221 thrift.ResponseMeta
	_meta221, _err = p.Client_().Call(ctx, "scan_rslt_on_column", &_args220, &_result222)
	p.SetLastResponseMeta_(_meta221)
	if _err != nil {
		return
	}
	switch {
	case _result222.e!= nil:
		return _r, _result222.e
	}

	return _result222.GetSuccess(), nil
}

// The direct method to select cells with result in Key Cells list.
// 
// Parameters:
//  - spec: The Scan Specifications for the scan
// 
func (p *ServiceClient) scan_rslt_on_key(ctx context.Context, spec *SpecScan) (_r KCells, _err error) {
	var _args223 Servicescan_rslt_on_key_args
	_args223.spec = spec
	var _result225 Servicescan_rslt_on_key_result
	var _meta224 thrift.ResponseMeta
	_meta224, _err = p.Client_().Call(ctx, "scan_rslt_on_key", &_args223, &_result225)
	p.SetLastResponseMeta_(_meta224)
	if _err != nil {
		return
	}
	switch {
	case _result225.e!= nil:
		return _r, _result225.e
	}

	return _result225.GetSuccess(), nil
}

// The direct method to select cells with result in Fractons Cells.
// 
// Parameters:
//  - spec: The Scan Specifications for the scan
// 
func (p *ServiceClient) scan_rslt_on_fraction(ctx context.Context, spec *SpecScan) (_r *FCells, _err error) {
	var _args226 Servicescan_rslt_on_fraction_args
	_args226.spec = spec
	var _result228 Servicescan_rslt_on_fraction_result
	var _meta227 thrift.ResponseMeta
	_meta227, _err = p.Client_().Call(ctx, "scan_rslt_on_fraction", &_args226, &_result228)
	p.SetLastResponseMeta_(_meta227)
	if _err != nil {
		return
	}
	switch {
	case _result228.e!= nil:
		return _r, _result228.e
	}

	if _ret229 := _result228.GetSuccess(); _ret229 != nil {
		return _ret229, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "scan_rslt_on_fraction failed: unknown result")
}

// The method to select cells with result set by the request's type of CellsResult.
// 
// Parameters:
//  - spec: The Scan Specifications for the scan
//  - rslt: The Type of Cells Result for the response
// 
func (p *ServiceClient) scan_rslt_on(ctx context.Context, spec *SpecScan, rslt CellsResult_) (_r *CellsGroup, _err error) {
	var _args230 Servicescan_rslt_on_args
	_args230.spec = spec
	_args230.rslt = rslt
	var _result232 Servicescan_rslt_on_result
	var _meta231 thrift.ResponseMeta
	_meta231, _err = p.Client_().Call(ctx, "scan_rslt_on", &_args230, &_result232)
	p.SetLastResponseMeta_(_meta231)
	if _err != nil {
		return
	}
	switch {
	case _result232.e!= nil:
		return _r, _result232.e
	}

	if _ret233 := _result232.GetSuccess(); _ret233 != nil {
		return _ret233, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "scan_rslt_on failed: unknown result")
}

type ServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler Service
}

func (p *ServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewServiceProcessor(handler Service) *ServiceProcessor {

	self234 := &ServiceProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
	self234.processorMap["sql_mng_column"] = &ServiceProcessorsql_mng_column{handler:handler}
	self234.processorMap["sql_list_columns"] = &ServiceProcessorsql_list_columns{handler:handler}
	self234.processorMap["sql_compact_columns"] = &ServiceProcessorsql_compact_columns{handler:handler}
	self234.processorMap["sql_select_plain"] = &ServiceProcessorsql_select_plain{handler:handler}
	self234.processorMap["sql_select_counter"] = &ServiceProcessorsql_select_counter{handler:handler}
	self234.processorMap["sql_select_serial"] = &ServiceProcessorsql_select_serial{handler:handler}
	self234.processorMap["sql_select"] = &ServiceProcessorsql_select{handler:handler}
	self234.processorMap["sql_select_rslt_on_column"] = &ServiceProcessorsql_select_rslt_on_column{handler:handler}
	self234.processorMap["sql_select_rslt_on_key"] = &ServiceProcessorsql_select_rslt_on_key{handler:handler}
	self234.processorMap["sql_select_rslt_on_fraction"] = &ServiceProcessorsql_select_rslt_on_fraction{handler:handler}
	self234.processorMap["sql_query"] = &ServiceProcessorsql_query{handler:handler}
	self234.processorMap["sql_update"] = &ServiceProcessorsql_update{handler:handler}
	self234.processorMap["exec_sql"] = &ServiceProcessorexec_sql{handler:handler}
	self234.processorMap["updater_create"] = &ServiceProcessorupdater_create{handler:handler}
	self234.processorMap["updater_close"] = &ServiceProcessorupdater_close{handler:handler}
	self234.processorMap["update_plain"] = &ServiceProcessorupdate_plain{handler:handler}
	self234.processorMap["update_counter"] = &ServiceProcessorupdate_counter{handler:handler}
	self234.processorMap["update_serial"] = &ServiceProcessorupdate_serial{handler:handler}
	self234.processorMap["update_by_types"] = &ServiceProcessorupdate_by_types{handler:handler}
	self234.processorMap["mng_column"] = &ServiceProcessormng_column{handler:handler}
	self234.processorMap["list_columns"] = &ServiceProcessorlist_columns{handler:handler}
	self234.processorMap["compact_columns"] = &ServiceProcessorcompact_columns{handler:handler}
	self234.processorMap["scan"] = &ServiceProcessorscan{handler:handler}
	self234.processorMap["scan_rslt_on_column"] = &ServiceProcessorscan_rslt_on_column{handler:handler}
	self234.processorMap["scan_rslt_on_key"] = &ServiceProcessorscan_rslt_on_key{handler:handler}
	self234.processorMap["scan_rslt_on_fraction"] = &ServiceProcessorscan_rslt_on_fraction{handler:handler}
	self234.processorMap["scan_rslt_on"] = &ServiceProcessorscan_rslt_on{handler:handler}
	return self234
}

func (p *ServiceProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil { return false, thrift.WrapTException(err2) }
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x235 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x235.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x235
}

type ServiceProcessorsql_mng_column struct {
	handler Service
}

func (p *ServiceProcessorsql_mng_column) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err236 error
	args := Servicesql_mng_column_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_mng_column", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_mng_column_result{}
	if err2 := p.handler.sql_mng_column(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc237 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_mng_column: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_mng_column", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err236 = thrift.WrapTException(err2)
			}
			if err2 := _exc237.Write(ctx, oprot); _write_err236 == nil && err2 != nil {
				_write_err236 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err236 == nil && err2 != nil {
				_write_err236 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err236 == nil && err2 != nil {
				_write_err236 = thrift.WrapTException(err2)
			}
			if _write_err236 != nil {
				return false, thrift.WrapTException(_write_err236)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_mng_column", thrift.REPLY, seqId); err2 != nil {
		_write_err236 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err236 == nil && err2 != nil {
		_write_err236 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err236 == nil && err2 != nil {
		_write_err236 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err236 == nil && err2 != nil {
		_write_err236 = thrift.WrapTException(err2)
	}
	if _write_err236 != nil {
		return false, thrift.WrapTException(_write_err236)
	}
	return true, err
}

type ServiceProcessorsql_list_columns struct {
	handler Service
}

func (p *ServiceProcessorsql_list_columns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err238 error
	args := Servicesql_list_columns_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_list_columns", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_list_columns_result{}
	if retval, err2 := p.handler.sql_list_columns(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc239 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_list_columns: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_list_columns", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err238 = thrift.WrapTException(err2)
			}
			if err2 := _exc239.Write(ctx, oprot); _write_err238 == nil && err2 != nil {
				_write_err238 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err238 == nil && err2 != nil {
				_write_err238 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err238 == nil && err2 != nil {
				_write_err238 = thrift.WrapTException(err2)
			}
			if _write_err238 != nil {
				return false, thrift.WrapTException(_write_err238)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_list_columns", thrift.REPLY, seqId); err2 != nil {
		_write_err238 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err238 == nil && err2 != nil {
		_write_err238 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err238 == nil && err2 != nil {
		_write_err238 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err238 == nil && err2 != nil {
		_write_err238 = thrift.WrapTException(err2)
	}
	if _write_err238 != nil {
		return false, thrift.WrapTException(_write_err238)
	}
	return true, err
}

type ServiceProcessorsql_compact_columns struct {
	handler Service
}

func (p *ServiceProcessorsql_compact_columns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err240 error
	args := Servicesql_compact_columns_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_compact_columns", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_compact_columns_result{}
	if retval, err2 := p.handler.sql_compact_columns(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc241 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_compact_columns: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_compact_columns", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err240 = thrift.WrapTException(err2)
			}
			if err2 := _exc241.Write(ctx, oprot); _write_err240 == nil && err2 != nil {
				_write_err240 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err240 == nil && err2 != nil {
				_write_err240 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err240 == nil && err2 != nil {
				_write_err240 = thrift.WrapTException(err2)
			}
			if _write_err240 != nil {
				return false, thrift.WrapTException(_write_err240)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_compact_columns", thrift.REPLY, seqId); err2 != nil {
		_write_err240 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err240 == nil && err2 != nil {
		_write_err240 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err240 == nil && err2 != nil {
		_write_err240 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err240 == nil && err2 != nil {
		_write_err240 = thrift.WrapTException(err2)
	}
	if _write_err240 != nil {
		return false, thrift.WrapTException(_write_err240)
	}
	return true, err
}

type ServiceProcessorsql_select_plain struct {
	handler Service
}

func (p *ServiceProcessorsql_select_plain) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err242 error
	args := Servicesql_select_plain_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_select_plain", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_select_plain_result{}
	if retval, err2 := p.handler.sql_select_plain(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc243 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_plain: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_select_plain", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err242 = thrift.WrapTException(err2)
			}
			if err2 := _exc243.Write(ctx, oprot); _write_err242 == nil && err2 != nil {
				_write_err242 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err242 == nil && err2 != nil {
				_write_err242 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err242 == nil && err2 != nil {
				_write_err242 = thrift.WrapTException(err2)
			}
			if _write_err242 != nil {
				return false, thrift.WrapTException(_write_err242)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_select_plain", thrift.REPLY, seqId); err2 != nil {
		_write_err242 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err242 == nil && err2 != nil {
		_write_err242 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err242 == nil && err2 != nil {
		_write_err242 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err242 == nil && err2 != nil {
		_write_err242 = thrift.WrapTException(err2)
	}
	if _write_err242 != nil {
		return false, thrift.WrapTException(_write_err242)
	}
	return true, err
}

type ServiceProcessorsql_select_counter struct {
	handler Service
}

func (p *ServiceProcessorsql_select_counter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err244 error
	args := Servicesql_select_counter_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_select_counter", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_select_counter_result{}
	if retval, err2 := p.handler.sql_select_counter(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc245 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_counter: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_select_counter", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err244 = thrift.WrapTException(err2)
			}
			if err2 := _exc245.Write(ctx, oprot); _write_err244 == nil && err2 != nil {
				_write_err244 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err244 == nil && err2 != nil {
				_write_err244 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err244 == nil && err2 != nil {
				_write_err244 = thrift.WrapTException(err2)
			}
			if _write_err244 != nil {
				return false, thrift.WrapTException(_write_err244)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_select_counter", thrift.REPLY, seqId); err2 != nil {
		_write_err244 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err244 == nil && err2 != nil {
		_write_err244 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err244 == nil && err2 != nil {
		_write_err244 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err244 == nil && err2 != nil {
		_write_err244 = thrift.WrapTException(err2)
	}
	if _write_err244 != nil {
		return false, thrift.WrapTException(_write_err244)
	}
	return true, err
}

type ServiceProcessorsql_select_serial struct {
	handler Service
}

func (p *ServiceProcessorsql_select_serial) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err246 error
	args := Servicesql_select_serial_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_select_serial", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_select_serial_result{}
	if retval, err2 := p.handler.sql_select_serial(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc247 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_serial: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_select_serial", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err246 = thrift.WrapTException(err2)
			}
			if err2 := _exc247.Write(ctx, oprot); _write_err246 == nil && err2 != nil {
				_write_err246 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err246 == nil && err2 != nil {
				_write_err246 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err246 == nil && err2 != nil {
				_write_err246 = thrift.WrapTException(err2)
			}
			if _write_err246 != nil {
				return false, thrift.WrapTException(_write_err246)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_select_serial", thrift.REPLY, seqId); err2 != nil {
		_write_err246 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err246 == nil && err2 != nil {
		_write_err246 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err246 == nil && err2 != nil {
		_write_err246 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err246 == nil && err2 != nil {
		_write_err246 = thrift.WrapTException(err2)
	}
	if _write_err246 != nil {
		return false, thrift.WrapTException(_write_err246)
	}
	return true, err
}

type ServiceProcessorsql_select struct {
	handler Service
}

func (p *ServiceProcessorsql_select) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err248 error
	args := Servicesql_select_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_select", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_select_result{}
	if retval, err2 := p.handler.sql_select(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc249 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_select", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err248 = thrift.WrapTException(err2)
			}
			if err2 := _exc249.Write(ctx, oprot); _write_err248 == nil && err2 != nil {
				_write_err248 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err248 == nil && err2 != nil {
				_write_err248 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err248 == nil && err2 != nil {
				_write_err248 = thrift.WrapTException(err2)
			}
			if _write_err248 != nil {
				return false, thrift.WrapTException(_write_err248)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_select", thrift.REPLY, seqId); err2 != nil {
		_write_err248 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err248 == nil && err2 != nil {
		_write_err248 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err248 == nil && err2 != nil {
		_write_err248 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err248 == nil && err2 != nil {
		_write_err248 = thrift.WrapTException(err2)
	}
	if _write_err248 != nil {
		return false, thrift.WrapTException(_write_err248)
	}
	return true, err
}

type ServiceProcessorsql_select_rslt_on_column struct {
	handler Service
}

func (p *ServiceProcessorsql_select_rslt_on_column) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err250 error
	args := Servicesql_select_rslt_on_column_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_column", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_select_rslt_on_column_result{}
	if retval, err2 := p.handler.sql_select_rslt_on_column(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc251 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_rslt_on_column: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_column", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err250 = thrift.WrapTException(err2)
			}
			if err2 := _exc251.Write(ctx, oprot); _write_err250 == nil && err2 != nil {
				_write_err250 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err250 == nil && err2 != nil {
				_write_err250 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err250 == nil && err2 != nil {
				_write_err250 = thrift.WrapTException(err2)
			}
			if _write_err250 != nil {
				return false, thrift.WrapTException(_write_err250)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_column", thrift.REPLY, seqId); err2 != nil {
		_write_err250 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err250 == nil && err2 != nil {
		_write_err250 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err250 == nil && err2 != nil {
		_write_err250 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err250 == nil && err2 != nil {
		_write_err250 = thrift.WrapTException(err2)
	}
	if _write_err250 != nil {
		return false, thrift.WrapTException(_write_err250)
	}
	return true, err
}

type ServiceProcessorsql_select_rslt_on_key struct {
	handler Service
}

func (p *ServiceProcessorsql_select_rslt_on_key) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err252 error
	args := Servicesql_select_rslt_on_key_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_key", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_select_rslt_on_key_result{}
	if retval, err2 := p.handler.sql_select_rslt_on_key(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc253 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_rslt_on_key: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_key", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err252 = thrift.WrapTException(err2)
			}
			if err2 := _exc253.Write(ctx, oprot); _write_err252 == nil && err2 != nil {
				_write_err252 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err252 == nil && err2 != nil {
				_write_err252 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err252 == nil && err2 != nil {
				_write_err252 = thrift.WrapTException(err2)
			}
			if _write_err252 != nil {
				return false, thrift.WrapTException(_write_err252)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_key", thrift.REPLY, seqId); err2 != nil {
		_write_err252 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err252 == nil && err2 != nil {
		_write_err252 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err252 == nil && err2 != nil {
		_write_err252 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err252 == nil && err2 != nil {
		_write_err252 = thrift.WrapTException(err2)
	}
	if _write_err252 != nil {
		return false, thrift.WrapTException(_write_err252)
	}
	return true, err
}

type ServiceProcessorsql_select_rslt_on_fraction struct {
	handler Service
}

func (p *ServiceProcessorsql_select_rslt_on_fraction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err254 error
	args := Servicesql_select_rslt_on_fraction_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_fraction", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_select_rslt_on_fraction_result{}
	if retval, err2 := p.handler.sql_select_rslt_on_fraction(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc255 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_select_rslt_on_fraction: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_fraction", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err254 = thrift.WrapTException(err2)
			}
			if err2 := _exc255.Write(ctx, oprot); _write_err254 == nil && err2 != nil {
				_write_err254 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err254 == nil && err2 != nil {
				_write_err254 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err254 == nil && err2 != nil {
				_write_err254 = thrift.WrapTException(err2)
			}
			if _write_err254 != nil {
				return false, thrift.WrapTException(_write_err254)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_select_rslt_on_fraction", thrift.REPLY, seqId); err2 != nil {
		_write_err254 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err254 == nil && err2 != nil {
		_write_err254 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err254 == nil && err2 != nil {
		_write_err254 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err254 == nil && err2 != nil {
		_write_err254 = thrift.WrapTException(err2)
	}
	if _write_err254 != nil {
		return false, thrift.WrapTException(_write_err254)
	}
	return true, err
}

type ServiceProcessorsql_query struct {
	handler Service
}

func (p *ServiceProcessorsql_query) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err256 error
	args := Servicesql_query_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_query", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_query_result{}
	if retval, err2 := p.handler.sql_query(ctx, args.sql, args.rslt); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc257 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_query: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_query", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err256 = thrift.WrapTException(err2)
			}
			if err2 := _exc257.Write(ctx, oprot); _write_err256 == nil && err2 != nil {
				_write_err256 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err256 == nil && err2 != nil {
				_write_err256 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err256 == nil && err2 != nil {
				_write_err256 = thrift.WrapTException(err2)
			}
			if _write_err256 != nil {
				return false, thrift.WrapTException(_write_err256)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_query", thrift.REPLY, seqId); err2 != nil {
		_write_err256 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err256 == nil && err2 != nil {
		_write_err256 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err256 == nil && err2 != nil {
		_write_err256 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err256 == nil && err2 != nil {
		_write_err256 = thrift.WrapTException(err2)
	}
	if _write_err256 != nil {
		return false, thrift.WrapTException(_write_err256)
	}
	return true, err
}

type ServiceProcessorsql_update struct {
	handler Service
}

func (p *ServiceProcessorsql_update) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err258 error
	args := Servicesql_update_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "sql_update", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicesql_update_result{}
	if err2 := p.handler.sql_update(ctx, args.sql, args.updater_id); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc259 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing sql_update: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "sql_update", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err258 = thrift.WrapTException(err2)
			}
			if err2 := _exc259.Write(ctx, oprot); _write_err258 == nil && err2 != nil {
				_write_err258 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err258 == nil && err2 != nil {
				_write_err258 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err258 == nil && err2 != nil {
				_write_err258 = thrift.WrapTException(err2)
			}
			if _write_err258 != nil {
				return false, thrift.WrapTException(_write_err258)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "sql_update", thrift.REPLY, seqId); err2 != nil {
		_write_err258 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err258 == nil && err2 != nil {
		_write_err258 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err258 == nil && err2 != nil {
		_write_err258 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err258 == nil && err2 != nil {
		_write_err258 = thrift.WrapTException(err2)
	}
	if _write_err258 != nil {
		return false, thrift.WrapTException(_write_err258)
	}
	return true, err
}

type ServiceProcessorexec_sql struct {
	handler Service
}

func (p *ServiceProcessorexec_sql) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err260 error
	args := Serviceexec_sql_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "exec_sql", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Serviceexec_sql_result{}
	if retval, err2 := p.handler.exec_sql(ctx, args.sql); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc261 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing exec_sql: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "exec_sql", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err260 = thrift.WrapTException(err2)
			}
			if err2 := _exc261.Write(ctx, oprot); _write_err260 == nil && err2 != nil {
				_write_err260 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err260 == nil && err2 != nil {
				_write_err260 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err260 == nil && err2 != nil {
				_write_err260 = thrift.WrapTException(err2)
			}
			if _write_err260 != nil {
				return false, thrift.WrapTException(_write_err260)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "exec_sql", thrift.REPLY, seqId); err2 != nil {
		_write_err260 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err260 == nil && err2 != nil {
		_write_err260 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err260 == nil && err2 != nil {
		_write_err260 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err260 == nil && err2 != nil {
		_write_err260 = thrift.WrapTException(err2)
	}
	if _write_err260 != nil {
		return false, thrift.WrapTException(_write_err260)
	}
	return true, err
}

type ServiceProcessorupdater_create struct {
	handler Service
}

func (p *ServiceProcessorupdater_create) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err262 error
	args := Serviceupdater_create_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "updater_create", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Serviceupdater_create_result{}
	if retval, err2 := p.handler.updater_create(ctx, args.buffer_size); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc263 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updater_create: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "updater_create", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err262 = thrift.WrapTException(err2)
			}
			if err2 := _exc263.Write(ctx, oprot); _write_err262 == nil && err2 != nil {
				_write_err262 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err262 == nil && err2 != nil {
				_write_err262 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err262 == nil && err2 != nil {
				_write_err262 = thrift.WrapTException(err2)
			}
			if _write_err262 != nil {
				return false, thrift.WrapTException(_write_err262)
			}
			return true, err
		}
	} else {
		result.Success = &retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "updater_create", thrift.REPLY, seqId); err2 != nil {
		_write_err262 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err262 == nil && err2 != nil {
		_write_err262 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err262 == nil && err2 != nil {
		_write_err262 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err262 == nil && err2 != nil {
		_write_err262 = thrift.WrapTException(err2)
	}
	if _write_err262 != nil {
		return false, thrift.WrapTException(_write_err262)
	}
	return true, err
}

type ServiceProcessorupdater_close struct {
	handler Service
}

func (p *ServiceProcessorupdater_close) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err264 error
	args := Serviceupdater_close_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "updater_close", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Serviceupdater_close_result{}
	if err2 := p.handler.updater_close(ctx, args.id); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc265 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updater_close: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "updater_close", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err264 = thrift.WrapTException(err2)
			}
			if err2 := _exc265.Write(ctx, oprot); _write_err264 == nil && err2 != nil {
				_write_err264 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err264 == nil && err2 != nil {
				_write_err264 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err264 == nil && err2 != nil {
				_write_err264 = thrift.WrapTException(err2)
			}
			if _write_err264 != nil {
				return false, thrift.WrapTException(_write_err264)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "updater_close", thrift.REPLY, seqId); err2 != nil {
		_write_err264 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err264 == nil && err2 != nil {
		_write_err264 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err264 == nil && err2 != nil {
		_write_err264 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err264 == nil && err2 != nil {
		_write_err264 = thrift.WrapTException(err2)
	}
	if _write_err264 != nil {
		return false, thrift.WrapTException(_write_err264)
	}
	return true, err
}

type ServiceProcessorupdate_plain struct {
	handler Service
}

func (p *ServiceProcessorupdate_plain) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err266 error
	args := Serviceupdate_plain_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "update_plain", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Serviceupdate_plain_result{}
	if err2 := p.handler.update_plain(ctx, args.cells, args.updater_id); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc267 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing update_plain: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "update_plain", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err266 = thrift.WrapTException(err2)
			}
			if err2 := _exc267.Write(ctx, oprot); _write_err266 == nil && err2 != nil {
				_write_err266 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err266 == nil && err2 != nil {
				_write_err266 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err266 == nil && err2 != nil {
				_write_err266 = thrift.WrapTException(err2)
			}
			if _write_err266 != nil {
				return false, thrift.WrapTException(_write_err266)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "update_plain", thrift.REPLY, seqId); err2 != nil {
		_write_err266 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err266 == nil && err2 != nil {
		_write_err266 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err266 == nil && err2 != nil {
		_write_err266 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err266 == nil && err2 != nil {
		_write_err266 = thrift.WrapTException(err2)
	}
	if _write_err266 != nil {
		return false, thrift.WrapTException(_write_err266)
	}
	return true, err
}

type ServiceProcessorupdate_counter struct {
	handler Service
}

func (p *ServiceProcessorupdate_counter) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err268 error
	args := Serviceupdate_counter_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "update_counter", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Serviceupdate_counter_result{}
	if err2 := p.handler.update_counter(ctx, args.cells, args.updater_id); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc269 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing update_counter: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "update_counter", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err268 = thrift.WrapTException(err2)
			}
			if err2 := _exc269.Write(ctx, oprot); _write_err268 == nil && err2 != nil {
				_write_err268 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err268 == nil && err2 != nil {
				_write_err268 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err268 == nil && err2 != nil {
				_write_err268 = thrift.WrapTException(err2)
			}
			if _write_err268 != nil {
				return false, thrift.WrapTException(_write_err268)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "update_counter", thrift.REPLY, seqId); err2 != nil {
		_write_err268 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err268 == nil && err2 != nil {
		_write_err268 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err268 == nil && err2 != nil {
		_write_err268 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err268 == nil && err2 != nil {
		_write_err268 = thrift.WrapTException(err2)
	}
	if _write_err268 != nil {
		return false, thrift.WrapTException(_write_err268)
	}
	return true, err
}

type ServiceProcessorupdate_serial struct {
	handler Service
}

func (p *ServiceProcessorupdate_serial) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err270 error
	args := Serviceupdate_serial_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "update_serial", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Serviceupdate_serial_result{}
	if err2 := p.handler.update_serial(ctx, args.cells, args.updater_id); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc271 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing update_serial: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "update_serial", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err270 = thrift.WrapTException(err2)
			}
			if err2 := _exc271.Write(ctx, oprot); _write_err270 == nil && err2 != nil {
				_write_err270 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err270 == nil && err2 != nil {
				_write_err270 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err270 == nil && err2 != nil {
				_write_err270 = thrift.WrapTException(err2)
			}
			if _write_err270 != nil {
				return false, thrift.WrapTException(_write_err270)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "update_serial", thrift.REPLY, seqId); err2 != nil {
		_write_err270 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err270 == nil && err2 != nil {
		_write_err270 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err270 == nil && err2 != nil {
		_write_err270 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err270 == nil && err2 != nil {
		_write_err270 = thrift.WrapTException(err2)
	}
	if _write_err270 != nil {
		return false, thrift.WrapTException(_write_err270)
	}
	return true, err
}

type ServiceProcessorupdate_by_types struct {
	handler Service
}

func (p *ServiceProcessorupdate_by_types) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err272 error
	args := Serviceupdate_by_types_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "update_by_types", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Serviceupdate_by_types_result{}
	if err2 := p.handler.update_by_types(ctx, args.plain, args.counter, args.serial, args.updater_id); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc273 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing update_by_types: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "update_by_types", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err272 = thrift.WrapTException(err2)
			}
			if err2 := _exc273.Write(ctx, oprot); _write_err272 == nil && err2 != nil {
				_write_err272 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err272 == nil && err2 != nil {
				_write_err272 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err272 == nil && err2 != nil {
				_write_err272 = thrift.WrapTException(err2)
			}
			if _write_err272 != nil {
				return false, thrift.WrapTException(_write_err272)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "update_by_types", thrift.REPLY, seqId); err2 != nil {
		_write_err272 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err272 == nil && err2 != nil {
		_write_err272 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err272 == nil && err2 != nil {
		_write_err272 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err272 == nil && err2 != nil {
		_write_err272 = thrift.WrapTException(err2)
	}
	if _write_err272 != nil {
		return false, thrift.WrapTException(_write_err272)
	}
	return true, err
}

type ServiceProcessormng_column struct {
	handler Service
}

func (p *ServiceProcessormng_column) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err274 error
	args := Servicemng_column_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "mng_column", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicemng_column_result{}
	if err2 := p.handler.mng_column(ctx, args.func, args.schema); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc275 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mng_column: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "mng_column", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err274 = thrift.WrapTException(err2)
			}
			if err2 := _exc275.Write(ctx, oprot); _write_err274 == nil && err2 != nil {
				_write_err274 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err274 == nil && err2 != nil {
				_write_err274 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err274 == nil && err2 != nil {
				_write_err274 = thrift.WrapTException(err2)
			}
			if _write_err274 != nil {
				return false, thrift.WrapTException(_write_err274)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "mng_column", thrift.REPLY, seqId); err2 != nil {
		_write_err274 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err274 == nil && err2 != nil {
		_write_err274 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err274 == nil && err2 != nil {
		_write_err274 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err274 == nil && err2 != nil {
		_write_err274 = thrift.WrapTException(err2)
	}
	if _write_err274 != nil {
		return false, thrift.WrapTException(_write_err274)
	}
	return true, err
}

type ServiceProcessorlist_columns struct {
	handler Service
}

func (p *ServiceProcessorlist_columns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err276 error
	args := Servicelist_columns_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "list_columns", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicelist_columns_result{}
	if retval, err2 := p.handler.list_columns(ctx, args.spec); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc277 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing list_columns: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "list_columns", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err276 = thrift.WrapTException(err2)
			}
			if err2 := _exc277.Write(ctx, oprot); _write_err276 == nil && err2 != nil {
				_write_err276 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err276 == nil && err2 != nil {
				_write_err276 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err276 == nil && err2 != nil {
				_write_err276 = thrift.WrapTException(err2)
			}
			if _write_err276 != nil {
				return false, thrift.WrapTException(_write_err276)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "list_columns", thrift.REPLY, seqId); err2 != nil {
		_write_err276 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err276 == nil && err2 != nil {
		_write_err276 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err276 == nil && err2 != nil {
		_write_err276 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err276 == nil && err2 != nil {
		_write_err276 = thrift.WrapTException(err2)
	}
	if _write_err276 != nil {
		return false, thrift.WrapTException(_write_err276)
	}
	return true, err
}

type ServiceProcessorcompact_columns struct {
	handler Service
}

func (p *ServiceProcessorcompact_columns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err278 error
	args := Servicecompact_columns_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "compact_columns", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicecompact_columns_result{}
	if retval, err2 := p.handler.compact_columns(ctx, args.spec); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc279 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing compact_columns: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "compact_columns", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err278 = thrift.WrapTException(err2)
			}
			if err2 := _exc279.Write(ctx, oprot); _write_err278 == nil && err2 != nil {
				_write_err278 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err278 == nil && err2 != nil {
				_write_err278 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err278 == nil && err2 != nil {
				_write_err278 = thrift.WrapTException(err2)
			}
			if _write_err278 != nil {
				return false, thrift.WrapTException(_write_err278)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "compact_columns", thrift.REPLY, seqId); err2 != nil {
		_write_err278 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err278 == nil && err2 != nil {
		_write_err278 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err278 == nil && err2 != nil {
		_write_err278 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err278 == nil && err2 != nil {
		_write_err278 = thrift.WrapTException(err2)
	}
	if _write_err278 != nil {
		return false, thrift.WrapTException(_write_err278)
	}
	return true, err
}

type ServiceProcessorscan struct {
	handler Service
}

func (p *ServiceProcessorscan) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err280 error
	args := Servicescan_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "scan", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicescan_result{}
	if retval, err2 := p.handler.scan(ctx, args.spec); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc281 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "scan", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err280 = thrift.WrapTException(err2)
			}
			if err2 := _exc281.Write(ctx, oprot); _write_err280 == nil && err2 != nil {
				_write_err280 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err280 == nil && err2 != nil {
				_write_err280 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err280 == nil && err2 != nil {
				_write_err280 = thrift.WrapTException(err2)
			}
			if _write_err280 != nil {
				return false, thrift.WrapTException(_write_err280)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "scan", thrift.REPLY, seqId); err2 != nil {
		_write_err280 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err280 == nil && err2 != nil {
		_write_err280 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err280 == nil && err2 != nil {
		_write_err280 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err280 == nil && err2 != nil {
		_write_err280 = thrift.WrapTException(err2)
	}
	if _write_err280 != nil {
		return false, thrift.WrapTException(_write_err280)
	}
	return true, err
}

type ServiceProcessorscan_rslt_on_column struct {
	handler Service
}

func (p *ServiceProcessorscan_rslt_on_column) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err282 error
	args := Servicescan_rslt_on_column_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "scan_rslt_on_column", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicescan_rslt_on_column_result{}
	if retval, err2 := p.handler.scan_rslt_on_column(ctx, args.spec); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc283 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan_rslt_on_column: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_column", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err282 = thrift.WrapTException(err2)
			}
			if err2 := _exc283.Write(ctx, oprot); _write_err282 == nil && err2 != nil {
				_write_err282 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err282 == nil && err2 != nil {
				_write_err282 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err282 == nil && err2 != nil {
				_write_err282 = thrift.WrapTException(err2)
			}
			if _write_err282 != nil {
				return false, thrift.WrapTException(_write_err282)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_column", thrift.REPLY, seqId); err2 != nil {
		_write_err282 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err282 == nil && err2 != nil {
		_write_err282 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err282 == nil && err2 != nil {
		_write_err282 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err282 == nil && err2 != nil {
		_write_err282 = thrift.WrapTException(err2)
	}
	if _write_err282 != nil {
		return false, thrift.WrapTException(_write_err282)
	}
	return true, err
}

type ServiceProcessorscan_rslt_on_key struct {
	handler Service
}

func (p *ServiceProcessorscan_rslt_on_key) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err284 error
	args := Servicescan_rslt_on_key_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "scan_rslt_on_key", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicescan_rslt_on_key_result{}
	if retval, err2 := p.handler.scan_rslt_on_key(ctx, args.spec); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc285 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan_rslt_on_key: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_key", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err284 = thrift.WrapTException(err2)
			}
			if err2 := _exc285.Write(ctx, oprot); _write_err284 == nil && err2 != nil {
				_write_err284 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err284 == nil && err2 != nil {
				_write_err284 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err284 == nil && err2 != nil {
				_write_err284 = thrift.WrapTException(err2)
			}
			if _write_err284 != nil {
				return false, thrift.WrapTException(_write_err284)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_key", thrift.REPLY, seqId); err2 != nil {
		_write_err284 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err284 == nil && err2 != nil {
		_write_err284 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err284 == nil && err2 != nil {
		_write_err284 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err284 == nil && err2 != nil {
		_write_err284 = thrift.WrapTException(err2)
	}
	if _write_err284 != nil {
		return false, thrift.WrapTException(_write_err284)
	}
	return true, err
}

type ServiceProcessorscan_rslt_on_fraction struct {
	handler Service
}

func (p *ServiceProcessorscan_rslt_on_fraction) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err286 error
	args := Servicescan_rslt_on_fraction_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "scan_rslt_on_fraction", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicescan_rslt_on_fraction_result{}
	if retval, err2 := p.handler.scan_rslt_on_fraction(ctx, args.spec); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc287 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan_rslt_on_fraction: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_fraction", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err286 = thrift.WrapTException(err2)
			}
			if err2 := _exc287.Write(ctx, oprot); _write_err286 == nil && err2 != nil {
				_write_err286 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err286 == nil && err2 != nil {
				_write_err286 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err286 == nil && err2 != nil {
				_write_err286 = thrift.WrapTException(err2)
			}
			if _write_err286 != nil {
				return false, thrift.WrapTException(_write_err286)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on_fraction", thrift.REPLY, seqId); err2 != nil {
		_write_err286 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err286 == nil && err2 != nil {
		_write_err286 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err286 == nil && err2 != nil {
		_write_err286 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err286 == nil && err2 != nil {
		_write_err286 = thrift.WrapTException(err2)
	}
	if _write_err286 != nil {
		return false, thrift.WrapTException(_write_err286)
	}
	return true, err
}

type ServiceProcessorscan_rslt_on struct {
	handler Service
}

func (p *ServiceProcessorscan_rslt_on) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err288 error
	args := Servicescan_rslt_on_args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "scan_rslt_on", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := Servicescan_rslt_on_result{}
	if retval, err2 := p.handler.scan_rslt_on(ctx, args.spec, args.rslt); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Exception:
			result.e = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc289 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scan_rslt_on: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err288 = thrift.WrapTException(err2)
			}
			if err2 := _exc289.Write(ctx, oprot); _write_err288 == nil && err2 != nil {
				_write_err288 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err288 == nil && err2 != nil {
				_write_err288 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err288 == nil && err2 != nil {
				_write_err288 = thrift.WrapTException(err2)
			}
			if _write_err288 != nil {
				return false, thrift.WrapTException(_write_err288)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "scan_rslt_on", thrift.REPLY, seqId); err2 != nil {
		_write_err288 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err288 == nil && err2 != nil {
		_write_err288 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err288 == nil && err2 != nil {
		_write_err288 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err288 == nil && err2 != nil {
		_write_err288 = thrift.WrapTException(err2)
	}
	if _write_err288 != nil {
		return false, thrift.WrapTException(_write_err288)
	}
	return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_mng_column_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_mng_column_args() *Servicesql_mng_column_args {
	return &Servicesql_mng_column_args{}
}



func (p *Servicesql_mng_column_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_mng_column_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_mng_column_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_mng_column_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_mng_column_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_mng_column_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_mng_column_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_mng_column_args(%+v)", *p)
}

func (p *Servicesql_mng_column_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_mng_column_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_mng_column_args)(nil)

// Attributes:
//  - e
// 
type Servicesql_mng_column_result struct {
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_mng_column_result() *Servicesql_mng_column_result {
	return &Servicesql_mng_column_result{}
}

var Servicesql_mng_column_result_e_DEFAULT *Exception

func (p *Servicesql_mng_column_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_mng_column_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_mng_column_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_mng_column_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_mng_column_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_mng_column_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_mng_column_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_mng_column_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_mng_column_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_mng_column_result(%+v)", *p)
}

func (p *Servicesql_mng_column_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_mng_column_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_mng_column_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_list_columns_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_list_columns_args() *Servicesql_list_columns_args {
	return &Servicesql_list_columns_args{}
}



func (p *Servicesql_list_columns_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_list_columns_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_list_columns_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_list_columns_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_list_columns_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_list_columns_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_list_columns_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_list_columns_args(%+v)", *p)
}

func (p *Servicesql_list_columns_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_list_columns_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_list_columns_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_list_columns_result struct {
	success Schemas `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_list_columns_result() *Servicesql_list_columns_result {
	return &Servicesql_list_columns_result{}
}

var Servicesql_list_columns_result_success_DEFAULT Schemas


func (p *Servicesql_list_columns_result) Getsuccess() Schemas {
	return p.success
}

var Servicesql_list_columns_result_e_DEFAULT *Exception

func (p *Servicesql_list_columns_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_list_columns_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_list_columns_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_list_columns_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_list_columns_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_list_columns_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Schemas, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem290 := &Schema{}
		if err := _elem290.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem290), err)
		}
		p.success = append(p.success, _elem290)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicesql_list_columns_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_list_columns_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_list_columns_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_list_columns_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_list_columns_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_list_columns_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_list_columns_result(%+v)", *p)
}

func (p *Servicesql_list_columns_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_list_columns_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_list_columns_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_compact_columns_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_compact_columns_args() *Servicesql_compact_columns_args {
	return &Servicesql_compact_columns_args{}
}



func (p *Servicesql_compact_columns_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_compact_columns_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_compact_columns_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_compact_columns_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_compact_columns_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_compact_columns_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_compact_columns_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_compact_columns_args(%+v)", *p)
}

func (p *Servicesql_compact_columns_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_compact_columns_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_compact_columns_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_compact_columns_result struct {
	success CompactResults `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_compact_columns_result() *Servicesql_compact_columns_result {
	return &Servicesql_compact_columns_result{}
}

var Servicesql_compact_columns_result_success_DEFAULT CompactResults


func (p *Servicesql_compact_columns_result) Getsuccess() CompactResults {
	return p.success
}

var Servicesql_compact_columns_result_e_DEFAULT *Exception

func (p *Servicesql_compact_columns_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_compact_columns_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_compact_columns_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_compact_columns_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_compact_columns_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_compact_columns_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CompactResults, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem291 := &CompactResult_{}
		if err := _elem291.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem291), err)
		}
		p.success = append(p.success, _elem291)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicesql_compact_columns_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_compact_columns_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_compact_columns_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_compact_columns_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_compact_columns_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_compact_columns_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_compact_columns_result(%+v)", *p)
}

func (p *Servicesql_compact_columns_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_compact_columns_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_compact_columns_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_select_plain_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_select_plain_args() *Servicesql_select_plain_args {
	return &Servicesql_select_plain_args{}
}



func (p *Servicesql_select_plain_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_select_plain_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_plain_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_select_plain_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_plain_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_plain_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_select_plain_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_plain_args(%+v)", *p)
}

func (p *Servicesql_select_plain_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_plain_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_plain_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_select_plain_result struct {
	success CellsPlain `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_select_plain_result() *Servicesql_select_plain_result {
	return &Servicesql_select_plain_result{}
}

var Servicesql_select_plain_result_success_DEFAULT CellsPlain


func (p *Servicesql_select_plain_result) Getsuccess() CellsPlain {
	return p.success
}

var Servicesql_select_plain_result_e_DEFAULT *Exception

func (p *Servicesql_select_plain_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_select_plain_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_select_plain_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_select_plain_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_select_plain_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_plain_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellsPlain, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem292 := &CellPlain{}
		if err := _elem292.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem292), err)
		}
		p.success = append(p.success, _elem292)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicesql_select_plain_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_select_plain_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_plain_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_plain_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_plain_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_plain_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_plain_result(%+v)", *p)
}

func (p *Servicesql_select_plain_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_plain_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_plain_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_select_counter_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_select_counter_args() *Servicesql_select_counter_args {
	return &Servicesql_select_counter_args{}
}



func (p *Servicesql_select_counter_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_select_counter_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_counter_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_select_counter_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_counter_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_counter_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_select_counter_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_counter_args(%+v)", *p)
}

func (p *Servicesql_select_counter_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_counter_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_counter_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_select_counter_result struct {
	success CellsCounter `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_select_counter_result() *Servicesql_select_counter_result {
	return &Servicesql_select_counter_result{}
}

var Servicesql_select_counter_result_success_DEFAULT CellsCounter


func (p *Servicesql_select_counter_result) Getsuccess() CellsCounter {
	return p.success
}

var Servicesql_select_counter_result_e_DEFAULT *Exception

func (p *Servicesql_select_counter_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_select_counter_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_select_counter_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_select_counter_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_select_counter_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_counter_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellsCounter, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem293 := &CellCounter{}
		if err := _elem293.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem293), err)
		}
		p.success = append(p.success, _elem293)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicesql_select_counter_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_select_counter_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_counter_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_counter_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_counter_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_counter_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_counter_result(%+v)", *p)
}

func (p *Servicesql_select_counter_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_counter_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_counter_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_select_serial_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_select_serial_args() *Servicesql_select_serial_args {
	return &Servicesql_select_serial_args{}
}



func (p *Servicesql_select_serial_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_select_serial_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_serial_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_select_serial_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_serial_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_serial_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_select_serial_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_serial_args(%+v)", *p)
}

func (p *Servicesql_select_serial_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_serial_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_serial_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_select_serial_result struct {
	success CellsSerial `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_select_serial_result() *Servicesql_select_serial_result {
	return &Servicesql_select_serial_result{}
}

var Servicesql_select_serial_result_success_DEFAULT CellsSerial


func (p *Servicesql_select_serial_result) Getsuccess() CellsSerial {
	return p.success
}

var Servicesql_select_serial_result_e_DEFAULT *Exception

func (p *Servicesql_select_serial_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_select_serial_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_select_serial_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_select_serial_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_select_serial_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_serial_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CellsSerial, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem294 := &CellSerial{}
		if err := _elem294.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem294), err)
		}
		p.success = append(p.success, _elem294)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicesql_select_serial_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_select_serial_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_serial_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_serial_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_serial_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_serial_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_serial_result(%+v)", *p)
}

func (p *Servicesql_select_serial_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_serial_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_serial_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_select_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_select_args() *Servicesql_select_args {
	return &Servicesql_select_args{}
}



func (p *Servicesql_select_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_select_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_select_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_select_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_args(%+v)", *p)
}

func (p *Servicesql_select_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_select_result struct {
	success *Cells `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_select_result() *Servicesql_select_result {
	return &Servicesql_select_result{}
}

var Servicesql_select_result_success_DEFAULT *Cells

func (p *Servicesql_select_result) Getsuccess() *Cells {
	if !p.IsSetsuccess() {
		return Servicesql_select_result_success_DEFAULT
	}
	return p.success
}

var Servicesql_select_result_e_DEFAULT *Exception

func (p *Servicesql_select_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_select_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_select_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_select_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_select_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.success = &Cells{}
	if err := p.success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.success), err)
	}
	return nil
}

func (p *Servicesql_select_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_select_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_result(%+v)", *p)
}

func (p *Servicesql_select_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_select_rslt_on_column_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_select_rslt_on_column_args() *Servicesql_select_rslt_on_column_args {
	return &Servicesql_select_rslt_on_column_args{}
}



func (p *Servicesql_select_rslt_on_column_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_select_rslt_on_column_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_column_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_select_rslt_on_column_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_column_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_column_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_select_rslt_on_column_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_rslt_on_column_args(%+v)", *p)
}

func (p *Servicesql_select_rslt_on_column_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_rslt_on_column_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_rslt_on_column_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_select_rslt_on_column_result struct {
	success CCells `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_select_rslt_on_column_result() *Servicesql_select_rslt_on_column_result {
	return &Servicesql_select_rslt_on_column_result{}
}

var Servicesql_select_rslt_on_column_result_success_DEFAULT CCells


func (p *Servicesql_select_rslt_on_column_result) Getsuccess() CCells {
	return p.success
}

var Servicesql_select_rslt_on_column_result_e_DEFAULT *Exception

func (p *Servicesql_select_rslt_on_column_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_select_rslt_on_column_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_select_rslt_on_column_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_select_rslt_on_column_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_select_rslt_on_column_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_column_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(CCells, size)
	p.success = tMap
	for i := 0; i < size; i++ {
		var _key295 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key295 = v
		}
		_val296 := &cCells{}
		if err := _val296.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val296), err)
		}
		p.success[_key295] = _val296
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_column_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_column_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_column_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_column_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.MAP, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.success {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_rslt_on_column_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_rslt_on_column_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_rslt_on_column_result(%+v)", *p)
}

func (p *Servicesql_select_rslt_on_column_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_rslt_on_column_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_rslt_on_column_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_select_rslt_on_key_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_select_rslt_on_key_args() *Servicesql_select_rslt_on_key_args {
	return &Servicesql_select_rslt_on_key_args{}
}



func (p *Servicesql_select_rslt_on_key_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_select_rslt_on_key_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_key_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_select_rslt_on_key_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_key_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_key_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_select_rslt_on_key_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_rslt_on_key_args(%+v)", *p)
}

func (p *Servicesql_select_rslt_on_key_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_rslt_on_key_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_rslt_on_key_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_select_rslt_on_key_result struct {
	success KCells `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_select_rslt_on_key_result() *Servicesql_select_rslt_on_key_result {
	return &Servicesql_select_rslt_on_key_result{}
}

var Servicesql_select_rslt_on_key_result_success_DEFAULT KCells


func (p *Servicesql_select_rslt_on_key_result) Getsuccess() KCells {
	return p.success
}

var Servicesql_select_rslt_on_key_result_e_DEFAULT *Exception

func (p *Servicesql_select_rslt_on_key_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_select_rslt_on_key_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_select_rslt_on_key_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_select_rslt_on_key_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_select_rslt_on_key_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_key_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(KCells, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem297 := &kCells{}
		if err := _elem297.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem297), err)
		}
		p.success = append(p.success, _elem297)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_key_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_key_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_key_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_key_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_rslt_on_key_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_rslt_on_key_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_rslt_on_key_result(%+v)", *p)
}

func (p *Servicesql_select_rslt_on_key_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_rslt_on_key_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_rslt_on_key_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Servicesql_select_rslt_on_fraction_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServicesql_select_rslt_on_fraction_args() *Servicesql_select_rslt_on_fraction_args {
	return &Servicesql_select_rslt_on_fraction_args{}
}



func (p *Servicesql_select_rslt_on_fraction_args) Getsql() string {
	return p.sql
}

func (p *Servicesql_select_rslt_on_fraction_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_fraction_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_select_rslt_on_fraction_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_fraction_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_fraction_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_select_rslt_on_fraction_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_rslt_on_fraction_args(%+v)", *p)
}

func (p *Servicesql_select_rslt_on_fraction_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_rslt_on_fraction_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_rslt_on_fraction_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_select_rslt_on_fraction_result struct {
	success *FCells `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_select_rslt_on_fraction_result() *Servicesql_select_rslt_on_fraction_result {
	return &Servicesql_select_rslt_on_fraction_result{}
}

var Servicesql_select_rslt_on_fraction_result_success_DEFAULT *FCells

func (p *Servicesql_select_rslt_on_fraction_result) Getsuccess() *FCells {
	if !p.IsSetsuccess() {
		return Servicesql_select_rslt_on_fraction_result_success_DEFAULT
	}
	return p.success
}

var Servicesql_select_rslt_on_fraction_result_e_DEFAULT *Exception

func (p *Servicesql_select_rslt_on_fraction_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_select_rslt_on_fraction_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_select_rslt_on_fraction_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_select_rslt_on_fraction_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_select_rslt_on_fraction_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_fraction_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.success = &FCells{}
	if err := p.success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.success), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_fraction_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_fraction_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_select_rslt_on_fraction_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_select_rslt_on_fraction_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_rslt_on_fraction_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_select_rslt_on_fraction_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_select_rslt_on_fraction_result(%+v)", *p)
}

func (p *Servicesql_select_rslt_on_fraction_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_select_rslt_on_fraction_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_select_rslt_on_fraction_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
//  - rslt: The Type of Cells Result for the response
// 
type Servicesql_query_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
	rslt CellsResult_ `thrift:"rslt,2" db:"rslt" json:"rslt"`
}

func NewServicesql_query_args() *Servicesql_query_args {
	return &Servicesql_query_args{}
}



func (p *Servicesql_query_args) Getsql() string {
	return p.sql
}



func (p *Servicesql_query_args) Getrslt() CellsResult_ {
	return p.rslt
}

func (p *Servicesql_query_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_query_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_query_args) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := CellsResult_(v)
		p.rslt = temp
	}
	return nil
}

func (p *Servicesql_query_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_query_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_query_args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rslt", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rslt: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.rslt)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rslt (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rslt: ", p), err)
	}
	return err
}

func (p *Servicesql_query_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_query_args(%+v)", *p)
}

func (p *Servicesql_query_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_query_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_query_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicesql_query_result struct {
	success *CellsGroup `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_query_result() *Servicesql_query_result {
	return &Servicesql_query_result{}
}

var Servicesql_query_result_success_DEFAULT *CellsGroup

func (p *Servicesql_query_result) Getsuccess() *CellsGroup {
	if !p.IsSetsuccess() {
		return Servicesql_query_result_success_DEFAULT
	}
	return p.success
}

var Servicesql_query_result_e_DEFAULT *Exception

func (p *Servicesql_query_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_query_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_query_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicesql_query_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_query_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_query_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.success = &CellsGroup{}
	if err := p.success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.success), err)
	}
	return nil
}

func (p *Servicesql_query_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_query_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_query_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_query_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_query_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_query_result(%+v)", *p)
}

func (p *Servicesql_query_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_query_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_query_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
//  - updater_id: The Updater ID to work with
// 
type Servicesql_update_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
	updater_id int64 `thrift:"updater_id,2" db:"updater_id" json:"updater_id"`
}

func NewServicesql_update_args() *Servicesql_update_args {
	return &Servicesql_update_args{}
}



func (p *Servicesql_update_args) Getsql() string {
	return p.sql
}



func (p *Servicesql_update_args) Getupdater_id() int64 {
	return p.updater_id
}

func (p *Servicesql_update_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_update_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Servicesql_update_args) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.updater_id = v
	}
	return nil
}

func (p *Servicesql_update_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_update_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_update_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Servicesql_update_args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updater_id: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.updater_id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.updater_id (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updater_id: ", p), err)
	}
	return err
}

func (p *Servicesql_update_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_update_args(%+v)", *p)
}

func (p *Servicesql_update_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_update_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_update_args)(nil)

// Attributes:
//  - e
// 
type Servicesql_update_result struct {
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicesql_update_result() *Servicesql_update_result {
	return &Servicesql_update_result{}
}

var Servicesql_update_result_e_DEFAULT *Exception

func (p *Servicesql_update_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicesql_update_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicesql_update_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicesql_update_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicesql_update_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicesql_update_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "sql_update_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicesql_update_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicesql_update_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicesql_update_result(%+v)", *p)
}

func (p *Servicesql_update_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicesql_update_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicesql_update_result)(nil)

// Attributes:
//  - sql: The SQL string to Execute
// 
type Serviceexec_sql_args struct {
	sql string `thrift:"sql,1" db:"sql" json:"sql"`
}

func NewServiceexec_sql_args() *Serviceexec_sql_args {
	return &Serviceexec_sql_args{}
}



func (p *Serviceexec_sql_args) Getsql() string {
	return p.sql
}

func (p *Serviceexec_sql_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceexec_sql_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.sql = v
	}
	return nil
}

func (p *Serviceexec_sql_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "exec_sql_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceexec_sql_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sql", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sql: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.sql)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sql (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sql: ", p), err)
	}
	return err
}

func (p *Serviceexec_sql_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceexec_sql_args(%+v)", *p)
}

func (p *Serviceexec_sql_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceexec_sql_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceexec_sql_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Serviceexec_sql_result struct {
	success *Result_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceexec_sql_result() *Serviceexec_sql_result {
	return &Serviceexec_sql_result{}
}

var Serviceexec_sql_result_success_DEFAULT *Result_

func (p *Serviceexec_sql_result) Getsuccess() *Result_ {
	if !p.IsSetsuccess() {
		return Serviceexec_sql_result_success_DEFAULT
	}
	return p.success
}

var Serviceexec_sql_result_e_DEFAULT *Exception

func (p *Serviceexec_sql_result) Gete() *Exception {
	if !p.IsSete() {
		return Serviceexec_sql_result_e_DEFAULT
	}
	return p.e
}

func (p *Serviceexec_sql_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Serviceexec_sql_result) IsSete() bool {
	return p.e != nil
}

func (p *Serviceexec_sql_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceexec_sql_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.success = &Result_{}
	if err := p.success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.success), err)
	}
	return nil
}

func (p *Serviceexec_sql_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Serviceexec_sql_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "exec_sql_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceexec_sql_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Serviceexec_sql_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Serviceexec_sql_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceexec_sql_result(%+v)", *p)
}

func (p *Serviceexec_sql_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceexec_sql_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceexec_sql_result)(nil)

// Attributes:
//  - buffer_size: The buffer size of the Updater
// 
type Serviceupdater_create_args struct {
	buffer_size int32 `thrift:"buffer_size,1" db:"buffer_size" json:"buffer_size"`
}

func NewServiceupdater_create_args() *Serviceupdater_create_args {
	return &Serviceupdater_create_args{}
}



func (p *Serviceupdater_create_args) Getbuffer_size() int32 {
	return p.buffer_size
}

func (p *Serviceupdater_create_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdater_create_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.buffer_size = v
	}
	return nil
}

func (p *Serviceupdater_create_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updater_create_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdater_create_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "buffer_size", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:buffer_size: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.buffer_size)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.buffer_size (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:buffer_size: ", p), err)
	}
	return err
}

func (p *Serviceupdater_create_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdater_create_args(%+v)", *p)
}

func (p *Serviceupdater_create_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdater_create_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdater_create_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Serviceupdater_create_result struct {
	success *int64 `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceupdater_create_result() *Serviceupdater_create_result {
	return &Serviceupdater_create_result{}
}

var Serviceupdater_create_result_success_DEFAULT int64

func (p *Serviceupdater_create_result) Getsuccess() int64 {
	if !p.IsSetsuccess() {
		return Serviceupdater_create_result_success_DEFAULT
	}
	return *p.success
}

var Serviceupdater_create_result_e_DEFAULT *Exception

func (p *Serviceupdater_create_result) Gete() *Exception {
	if !p.IsSete() {
		return Serviceupdater_create_result_e_DEFAULT
	}
	return p.e
}

func (p *Serviceupdater_create_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Serviceupdater_create_result) IsSete() bool {
	return p.e != nil
}

func (p *Serviceupdater_create_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdater_create_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.success = &v
	}
	return nil
}

func (p *Serviceupdater_create_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Serviceupdater_create_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updater_create_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdater_create_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.I64, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Serviceupdater_create_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Serviceupdater_create_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdater_create_result(%+v)", *p)
}

func (p *Serviceupdater_create_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdater_create_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdater_create_result)(nil)

// Attributes:
//  - id: The Updater ID to close
// 
type Serviceupdater_close_args struct {
	id int64 `thrift:"id,1" db:"id" json:"id"`
}

func NewServiceupdater_close_args() *Serviceupdater_close_args {
	return &Serviceupdater_close_args{}
}



func (p *Serviceupdater_close_args) Getid() int64 {
	return p.id
}

func (p *Serviceupdater_close_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdater_close_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.id = v
	}
	return nil
}

func (p *Serviceupdater_close_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updater_close_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdater_close_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *Serviceupdater_close_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdater_close_args(%+v)", *p)
}

func (p *Serviceupdater_close_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdater_close_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdater_close_args)(nil)

// Attributes:
//  - e
// 
type Serviceupdater_close_result struct {
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceupdater_close_result() *Serviceupdater_close_result {
	return &Serviceupdater_close_result{}
}

var Serviceupdater_close_result_e_DEFAULT *Exception

func (p *Serviceupdater_close_result) Gete() *Exception {
	if !p.IsSete() {
		return Serviceupdater_close_result_e_DEFAULT
	}
	return p.e
}

func (p *Serviceupdater_close_result) IsSete() bool {
	return p.e != nil
}

func (p *Serviceupdater_close_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdater_close_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Serviceupdater_close_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "updater_close_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdater_close_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Serviceupdater_close_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdater_close_result(%+v)", *p)
}

func (p *Serviceupdater_close_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdater_close_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdater_close_result)(nil)

// Attributes:
//  - cells: The Cells to update
//  - updater_id: The Updater ID to use for write
// 
type Serviceupdate_plain_args struct {
	cells UCCellsPlain `thrift:"cells,1" db:"cells" json:"cells"`
	updater_id int64 `thrift:"updater_id,2" db:"updater_id" json:"updater_id"`
}

func NewServiceupdate_plain_args() *Serviceupdate_plain_args {
	return &Serviceupdate_plain_args{}
}



func (p *Serviceupdate_plain_args) Getcells() UCCellsPlain {
	return p.cells
}



func (p *Serviceupdate_plain_args) Getupdater_id() int64 {
	return p.updater_id
}

func (p *Serviceupdate_plain_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdate_plain_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(UCCellsPlain, size)
	p.cells = tMap
	for i := 0; i < size; i++ {
		var _key298 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key298 = v
		}
		_, size, err := iprot.ReadListBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make(UCellsPlain, 0, size)
		_val299 := tSlice
		for i := 0; i < size; i++ {
			_elem300 := &UCellPlain{}
			if err := _elem300.Read(ctx, iprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem300), err)
			}
			_val299 = append(_val299, _elem300)
		}
		if err := iprot.ReadListEnd(ctx); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.cells[_key298] = _val299
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Serviceupdate_plain_args) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.updater_id = v
	}
	return nil
}

func (p *Serviceupdate_plain_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "update_plain_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdate_plain_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cells", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cells: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.cells)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.cells {
		if err := oprot.WriteI64(ctx, int64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range v {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cells: ", p), err)
	}
	return err
}

func (p *Serviceupdate_plain_args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updater_id: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.updater_id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.updater_id (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updater_id: ", p), err)
	}
	return err
}

func (p *Serviceupdate_plain_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdate_plain_args(%+v)", *p)
}

func (p *Serviceupdate_plain_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdate_plain_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdate_plain_args)(nil)

// Attributes:
//  - e
// 
type Serviceupdate_plain_result struct {
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceupdate_plain_result() *Serviceupdate_plain_result {
	return &Serviceupdate_plain_result{}
}

var Serviceupdate_plain_result_e_DEFAULT *Exception

func (p *Serviceupdate_plain_result) Gete() *Exception {
	if !p.IsSete() {
		return Serviceupdate_plain_result_e_DEFAULT
	}
	return p.e
}

func (p *Serviceupdate_plain_result) IsSete() bool {
	return p.e != nil
}

func (p *Serviceupdate_plain_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdate_plain_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Serviceupdate_plain_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "update_plain_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdate_plain_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Serviceupdate_plain_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdate_plain_result(%+v)", *p)
}

func (p *Serviceupdate_plain_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdate_plain_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdate_plain_result)(nil)

// Attributes:
//  - cells: The Counter Cells to update
//  - updater_id: The Updater ID to use for write
// 
type Serviceupdate_counter_args struct {
	cells UCCellsCounter `thrift:"cells,1" db:"cells" json:"cells"`
	updater_id int64 `thrift:"updater_id,2" db:"updater_id" json:"updater_id"`
}

func NewServiceupdate_counter_args() *Serviceupdate_counter_args {
	return &Serviceupdate_counter_args{}
}



func (p *Serviceupdate_counter_args) Getcells() UCCellsCounter {
	return p.cells
}



func (p *Serviceupdate_counter_args) Getupdater_id() int64 {
	return p.updater_id
}

func (p *Serviceupdate_counter_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdate_counter_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(UCCellsCounter, size)
	p.cells = tMap
	for i := 0; i < size; i++ {
		var _key301 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key301 = v
		}
		_, size, err := iprot.ReadListBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make(UCellsCounter, 0, size)
		_val302 := tSlice
		for i := 0; i < size; i++ {
			_elem303 := &UCellCounter{}
			if err := _elem303.Read(ctx, iprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem303), err)
			}
			_val302 = append(_val302, _elem303)
		}
		if err := iprot.ReadListEnd(ctx); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.cells[_key301] = _val302
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Serviceupdate_counter_args) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.updater_id = v
	}
	return nil
}

func (p *Serviceupdate_counter_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "update_counter_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdate_counter_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cells", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cells: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.cells)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.cells {
		if err := oprot.WriteI64(ctx, int64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range v {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cells: ", p), err)
	}
	return err
}

func (p *Serviceupdate_counter_args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updater_id: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.updater_id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.updater_id (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updater_id: ", p), err)
	}
	return err
}

func (p *Serviceupdate_counter_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdate_counter_args(%+v)", *p)
}

func (p *Serviceupdate_counter_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdate_counter_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdate_counter_args)(nil)

// Attributes:
//  - e
// 
type Serviceupdate_counter_result struct {
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceupdate_counter_result() *Serviceupdate_counter_result {
	return &Serviceupdate_counter_result{}
}

var Serviceupdate_counter_result_e_DEFAULT *Exception

func (p *Serviceupdate_counter_result) Gete() *Exception {
	if !p.IsSete() {
		return Serviceupdate_counter_result_e_DEFAULT
	}
	return p.e
}

func (p *Serviceupdate_counter_result) IsSete() bool {
	return p.e != nil
}

func (p *Serviceupdate_counter_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdate_counter_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Serviceupdate_counter_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "update_counter_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdate_counter_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Serviceupdate_counter_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdate_counter_result(%+v)", *p)
}

func (p *Serviceupdate_counter_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdate_counter_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdate_counter_result)(nil)

// Attributes:
//  - cells: The Serial Cells to update
//  - updater_id: The Updater ID to use for write
// 
type Serviceupdate_serial_args struct {
	cells UCCellsSerial `thrift:"cells,1" db:"cells" json:"cells"`
	updater_id int64 `thrift:"updater_id,2" db:"updater_id" json:"updater_id"`
}

func NewServiceupdate_serial_args() *Serviceupdate_serial_args {
	return &Serviceupdate_serial_args{}
}



func (p *Serviceupdate_serial_args) Getcells() UCCellsSerial {
	return p.cells
}



func (p *Serviceupdate_serial_args) Getupdater_id() int64 {
	return p.updater_id
}

func (p *Serviceupdate_serial_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdate_serial_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(UCCellsSerial, size)
	p.cells = tMap
	for i := 0; i < size; i++ {
		var _key304 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key304 = v
		}
		_, size, err := iprot.ReadListBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make(UCellsSerial, 0, size)
		_val305 := tSlice
		for i := 0; i < size; i++ {
			_elem306 := &UCellSerial{}
			if err := _elem306.Read(ctx, iprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem306), err)
			}
			_val305 = append(_val305, _elem306)
		}
		if err := iprot.ReadListEnd(ctx); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.cells[_key304] = _val305
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Serviceupdate_serial_args) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.updater_id = v
	}
	return nil
}

func (p *Serviceupdate_serial_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "update_serial_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdate_serial_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "cells", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:cells: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.cells)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.cells {
		if err := oprot.WriteI64(ctx, int64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range v {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:cells: ", p), err)
	}
	return err
}

func (p *Serviceupdate_serial_args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:updater_id: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.updater_id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.updater_id (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:updater_id: ", p), err)
	}
	return err
}

func (p *Serviceupdate_serial_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdate_serial_args(%+v)", *p)
}

func (p *Serviceupdate_serial_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdate_serial_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdate_serial_args)(nil)

// Attributes:
//  - e
// 
type Serviceupdate_serial_result struct {
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceupdate_serial_result() *Serviceupdate_serial_result {
	return &Serviceupdate_serial_result{}
}

var Serviceupdate_serial_result_e_DEFAULT *Exception

func (p *Serviceupdate_serial_result) Gete() *Exception {
	if !p.IsSete() {
		return Serviceupdate_serial_result_e_DEFAULT
	}
	return p.e
}

func (p *Serviceupdate_serial_result) IsSete() bool {
	return p.e != nil
}

func (p *Serviceupdate_serial_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdate_serial_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Serviceupdate_serial_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "update_serial_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdate_serial_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Serviceupdate_serial_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdate_serial_result(%+v)", *p)
}

func (p *Serviceupdate_serial_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdate_serial_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdate_serial_result)(nil)

// Attributes:
//  - plain: The PLAIN Cells to update
//  - counter: The COUNTER Cells to update
//  - serial: The SERIAL Cells to update
//  - updater_id: The Updater ID to use for write
// 
type Serviceupdate_by_types_args struct {
	plain UCCellsPlain `thrift:"plain,1" db:"plain" json:"plain"`
	counter UCCellsCounter `thrift:"counter,2" db:"counter" json:"counter"`
	serial UCCellsSerial `thrift:"serial,3" db:"serial" json:"serial"`
	updater_id int64 `thrift:"updater_id,4" db:"updater_id" json:"updater_id"`
}

func NewServiceupdate_by_types_args() *Serviceupdate_by_types_args {
	return &Serviceupdate_by_types_args{}
}



func (p *Serviceupdate_by_types_args) Getplain() UCCellsPlain {
	return p.plain
}



func (p *Serviceupdate_by_types_args) Getcounter() UCCellsCounter {
	return p.counter
}



func (p *Serviceupdate_by_types_args) Getserial() UCCellsSerial {
	return p.serial
}



func (p *Serviceupdate_by_types_args) Getupdater_id() int64 {
	return p.updater_id
}

func (p *Serviceupdate_by_types_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdate_by_types_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(UCCellsPlain, size)
	p.plain = tMap
	for i := 0; i < size; i++ {
		var _key307 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key307 = v
		}
		_, size, err := iprot.ReadListBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make(UCellsPlain, 0, size)
		_val308 := tSlice
		for i := 0; i < size; i++ {
			_elem309 := &UCellPlain{}
			if err := _elem309.Read(ctx, iprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem309), err)
			}
			_val308 = append(_val308, _elem309)
		}
		if err := iprot.ReadListEnd(ctx); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.plain[_key307] = _val308
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Serviceupdate_by_types_args) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(UCCellsCounter, size)
	p.counter = tMap
	for i := 0; i < size; i++ {
		var _key310 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key310 = v
		}
		_, size, err := iprot.ReadListBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make(UCellsCounter, 0, size)
		_val311 := tSlice
		for i := 0; i < size; i++ {
			_elem312 := &UCellCounter{}
			if err := _elem312.Read(ctx, iprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem312), err)
			}
			_val311 = append(_val311, _elem312)
		}
		if err := iprot.ReadListEnd(ctx); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.counter[_key310] = _val311
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Serviceupdate_by_types_args) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(UCCellsSerial, size)
	p.serial = tMap
	for i := 0; i < size; i++ {
		var _key313 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key313 = v
		}
		_, size, err := iprot.ReadListBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make(UCellsSerial, 0, size)
		_val314 := tSlice
		for i := 0; i < size; i++ {
			_elem315 := &UCellSerial{}
			if err := _elem315.Read(ctx, iprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem315), err)
			}
			_val314 = append(_val314, _elem315)
		}
		if err := iprot.ReadListEnd(ctx); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.serial[_key313] = _val314
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Serviceupdate_by_types_args) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.updater_id = v
	}
	return nil
}

func (p *Serviceupdate_by_types_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "update_by_types_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdate_by_types_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "plain", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:plain: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.plain)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.plain {
		if err := oprot.WriteI64(ctx, int64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range v {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:plain: ", p), err)
	}
	return err
}

func (p *Serviceupdate_by_types_args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "counter", thrift.MAP, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:counter: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.counter)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.counter {
		if err := oprot.WriteI64(ctx, int64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range v {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:counter: ", p), err)
	}
	return err
}

func (p *Serviceupdate_by_types_args) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "serial", thrift.MAP, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:serial: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I64, thrift.LIST, len(p.serial)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.serial {
		if err := oprot.WriteI64(ctx, int64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(v)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range v {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:serial: ", p), err)
	}
	return err
}

func (p *Serviceupdate_by_types_args) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "updater_id", thrift.I64, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:updater_id: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.updater_id)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.updater_id (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:updater_id: ", p), err)
	}
	return err
}

func (p *Serviceupdate_by_types_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdate_by_types_args(%+v)", *p)
}

func (p *Serviceupdate_by_types_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdate_by_types_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdate_by_types_args)(nil)

// Attributes:
//  - e
// 
type Serviceupdate_by_types_result struct {
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServiceupdate_by_types_result() *Serviceupdate_by_types_result {
	return &Serviceupdate_by_types_result{}
}

var Serviceupdate_by_types_result_e_DEFAULT *Exception

func (p *Serviceupdate_by_types_result) Gete() *Exception {
	if !p.IsSete() {
		return Serviceupdate_by_types_result_e_DEFAULT
	}
	return p.e
}

func (p *Serviceupdate_by_types_result) IsSete() bool {
	return p.e != nil
}

func (p *Serviceupdate_by_types_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Serviceupdate_by_types_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Serviceupdate_by_types_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "update_by_types_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Serviceupdate_by_types_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Serviceupdate_by_types_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Serviceupdate_by_types_result(%+v)", *p)
}

func (p *Serviceupdate_by_types_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Serviceupdate_by_types_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Serviceupdate_by_types_result)(nil)

// Attributes:
//  - func: The Action Function to use
//  - schema: The Schema for the Action
// 
type Servicemng_column_args struct {
	func SchemaFunc `thrift:"func,1" db:"func" json:"func"`
	schema *Schema `thrift:"schema,2" db:"schema" json:"schema"`
}

func NewServicemng_column_args() *Servicemng_column_args {
	return &Servicemng_column_args{}
}



func (p *Servicemng_column_args) Getfunc() SchemaFunc {
	return p.func
}

var Servicemng_column_args_schema_DEFAULT *Schema

func (p *Servicemng_column_args) Getschema() *Schema {
	if !p.IsSetschema() {
		return Servicemng_column_args_schema_DEFAULT
	}
	return p.schema
}

func (p *Servicemng_column_args) IsSetschema() bool {
	return p.schema != nil
}

func (p *Servicemng_column_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicemng_column_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := SchemaFunc(v)
		p.func = temp
	}
	return nil
}

func (p *Servicemng_column_args) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.schema = &Schema{}
	if err := p.schema.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.schema), err)
	}
	return nil
}

func (p *Servicemng_column_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "mng_column_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicemng_column_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "func", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:func: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.func)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.func (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:func: ", p), err)
	}
	return err
}

func (p *Servicemng_column_args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "schema", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:schema: ", p), err)
	}
	if err := p.schema.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.schema), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:schema: ", p), err)
	}
	return err
}

func (p *Servicemng_column_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicemng_column_args(%+v)", *p)
}

func (p *Servicemng_column_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicemng_column_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicemng_column_args)(nil)

// Attributes:
//  - e
// 
type Servicemng_column_result struct {
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicemng_column_result() *Servicemng_column_result {
	return &Servicemng_column_result{}
}

var Servicemng_column_result_e_DEFAULT *Exception

func (p *Servicemng_column_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicemng_column_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicemng_column_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicemng_column_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicemng_column_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicemng_column_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "mng_column_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicemng_column_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicemng_column_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicemng_column_result(%+v)", *p)
}

func (p *Servicemng_column_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicemng_column_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicemng_column_result)(nil)

// Attributes:
//  - spec: The Schemas Specifications to match Schema for response
// 
type Servicelist_columns_args struct {
	spec *SpecSchemas `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServicelist_columns_args() *Servicelist_columns_args {
	return &Servicelist_columns_args{}
}

var Servicelist_columns_args_spec_DEFAULT *SpecSchemas

func (p *Servicelist_columns_args) Getspec() *SpecSchemas {
	if !p.IsSetspec() {
		return Servicelist_columns_args_spec_DEFAULT
	}
	return p.spec
}

func (p *Servicelist_columns_args) IsSetspec() bool {
	return p.spec != nil
}

func (p *Servicelist_columns_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicelist_columns_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec = &SpecSchemas{}
	if err := p.spec.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec), err)
	}
	return nil
}

func (p *Servicelist_columns_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "list_columns_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicelist_columns_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err)
	}
	if err := p.spec.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err)
	}
	return err
}

func (p *Servicelist_columns_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicelist_columns_args(%+v)", *p)
}

func (p *Servicelist_columns_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicelist_columns_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicelist_columns_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicelist_columns_result struct {
	success Schemas `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicelist_columns_result() *Servicelist_columns_result {
	return &Servicelist_columns_result{}
}

var Servicelist_columns_result_success_DEFAULT Schemas


func (p *Servicelist_columns_result) Getsuccess() Schemas {
	return p.success
}

var Servicelist_columns_result_e_DEFAULT *Exception

func (p *Servicelist_columns_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicelist_columns_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicelist_columns_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicelist_columns_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicelist_columns_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicelist_columns_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(Schemas, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem316 := &Schema{}
		if err := _elem316.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem316), err)
		}
		p.success = append(p.success, _elem316)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicelist_columns_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicelist_columns_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "list_columns_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicelist_columns_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicelist_columns_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicelist_columns_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicelist_columns_result(%+v)", *p)
}

func (p *Servicelist_columns_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicelist_columns_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicelist_columns_result)(nil)

// Attributes:
//  - spec: The Schemas Specifications to match columns to Compact
// 
type Servicecompact_columns_args struct {
	spec *SpecSchemas `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServicecompact_columns_args() *Servicecompact_columns_args {
	return &Servicecompact_columns_args{}
}

var Servicecompact_columns_args_spec_DEFAULT *SpecSchemas

func (p *Servicecompact_columns_args) Getspec() *SpecSchemas {
	if !p.IsSetspec() {
		return Servicecompact_columns_args_spec_DEFAULT
	}
	return p.spec
}

func (p *Servicecompact_columns_args) IsSetspec() bool {
	return p.spec != nil
}

func (p *Servicecompact_columns_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicecompact_columns_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec = &SpecSchemas{}
	if err := p.spec.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec), err)
	}
	return nil
}

func (p *Servicecompact_columns_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "compact_columns_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicecompact_columns_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err)
	}
	if err := p.spec.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err)
	}
	return err
}

func (p *Servicecompact_columns_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicecompact_columns_args(%+v)", *p)
}

func (p *Servicecompact_columns_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicecompact_columns_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicecompact_columns_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicecompact_columns_result struct {
	success CompactResults `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicecompact_columns_result() *Servicecompact_columns_result {
	return &Servicecompact_columns_result{}
}

var Servicecompact_columns_result_success_DEFAULT CompactResults


func (p *Servicecompact_columns_result) Getsuccess() CompactResults {
	return p.success
}

var Servicecompact_columns_result_e_DEFAULT *Exception

func (p *Servicecompact_columns_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicecompact_columns_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicecompact_columns_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicecompact_columns_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicecompact_columns_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicecompact_columns_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(CompactResults, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem317 := &CompactResult_{}
		if err := _elem317.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem317), err)
		}
		p.success = append(p.success, _elem317)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicecompact_columns_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicecompact_columns_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "compact_columns_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicecompact_columns_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicecompact_columns_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicecompact_columns_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicecompact_columns_result(%+v)", *p)
}

func (p *Servicecompact_columns_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicecompact_columns_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicecompact_columns_result)(nil)

// Attributes:
//  - spec: The Scan Specifications for the scan
// 
type Servicescan_args struct {
	spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServicescan_args() *Servicescan_args {
	return &Servicescan_args{}
}

var Servicescan_args_spec_DEFAULT *SpecScan

func (p *Servicescan_args) Getspec() *SpecScan {
	if !p.IsSetspec() {
		return Servicescan_args_spec_DEFAULT
	}
	return p.spec
}

func (p *Servicescan_args) IsSetspec() bool {
	return p.spec != nil
}

func (p *Servicescan_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec = &SpecScan{}
	if err := p.spec.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec), err)
	}
	return nil
}

func (p *Servicescan_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err)
	}
	if err := p.spec.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err)
	}
	return err
}

func (p *Servicescan_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_args(%+v)", *p)
}

func (p *Servicescan_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicescan_result struct {
	success *Cells `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicescan_result() *Servicescan_result {
	return &Servicescan_result{}
}

var Servicescan_result_success_DEFAULT *Cells

func (p *Servicescan_result) Getsuccess() *Cells {
	if !p.IsSetsuccess() {
		return Servicescan_result_success_DEFAULT
	}
	return p.success
}

var Servicescan_result_e_DEFAULT *Exception

func (p *Servicescan_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicescan_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicescan_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicescan_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicescan_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.success = &Cells{}
	if err := p.success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.success), err)
	}
	return nil
}

func (p *Servicescan_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicescan_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_result(%+v)", *p)
}

func (p *Servicescan_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_result)(nil)

// Attributes:
//  - spec: The Scan Specifications for the scan
// 
type Servicescan_rslt_on_column_args struct {
	spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServicescan_rslt_on_column_args() *Servicescan_rslt_on_column_args {
	return &Servicescan_rslt_on_column_args{}
}

var Servicescan_rslt_on_column_args_spec_DEFAULT *SpecScan

func (p *Servicescan_rslt_on_column_args) Getspec() *SpecScan {
	if !p.IsSetspec() {
		return Servicescan_rslt_on_column_args_spec_DEFAULT
	}
	return p.spec
}

func (p *Servicescan_rslt_on_column_args) IsSetspec() bool {
	return p.spec != nil
}

func (p *Servicescan_rslt_on_column_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_column_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec = &SpecScan{}
	if err := p.spec.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_column_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_column_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_column_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err)
	}
	if err := p.spec.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err)
	}
	return err
}

func (p *Servicescan_rslt_on_column_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_rslt_on_column_args(%+v)", *p)
}

func (p *Servicescan_rslt_on_column_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_rslt_on_column_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_rslt_on_column_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicescan_rslt_on_column_result struct {
	success CCells `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicescan_rslt_on_column_result() *Servicescan_rslt_on_column_result {
	return &Servicescan_rslt_on_column_result{}
}

var Servicescan_rslt_on_column_result_success_DEFAULT CCells


func (p *Servicescan_rslt_on_column_result) Getsuccess() CCells {
	return p.success
}

var Servicescan_rslt_on_column_result_e_DEFAULT *Exception

func (p *Servicescan_rslt_on_column_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicescan_rslt_on_column_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicescan_rslt_on_column_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicescan_rslt_on_column_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicescan_rslt_on_column_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_column_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(CCells, size)
	p.success = tMap
	for i := 0; i < size; i++ {
		var _key318 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key318 = v
		}
		_val319 := &cCells{}
		if err := _val319.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val319), err)
		}
		p.success[_key318] = _val319
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_column_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_column_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_column_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_column_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.MAP, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.success {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_rslt_on_column_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_rslt_on_column_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_rslt_on_column_result(%+v)", *p)
}

func (p *Servicescan_rslt_on_column_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_rslt_on_column_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_rslt_on_column_result)(nil)

// Attributes:
//  - spec: The Scan Specifications for the scan
// 
type Servicescan_rslt_on_key_args struct {
	spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServicescan_rslt_on_key_args() *Servicescan_rslt_on_key_args {
	return &Servicescan_rslt_on_key_args{}
}

var Servicescan_rslt_on_key_args_spec_DEFAULT *SpecScan

func (p *Servicescan_rslt_on_key_args) Getspec() *SpecScan {
	if !p.IsSetspec() {
		return Servicescan_rslt_on_key_args_spec_DEFAULT
	}
	return p.spec
}

func (p *Servicescan_rslt_on_key_args) IsSetspec() bool {
	return p.spec != nil
}

func (p *Servicescan_rslt_on_key_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_key_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec = &SpecScan{}
	if err := p.spec.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_key_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_key_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_key_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err)
	}
	if err := p.spec.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err)
	}
	return err
}

func (p *Servicescan_rslt_on_key_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_rslt_on_key_args(%+v)", *p)
}

func (p *Servicescan_rslt_on_key_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_rslt_on_key_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_rslt_on_key_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicescan_rslt_on_key_result struct {
	success KCells `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicescan_rslt_on_key_result() *Servicescan_rslt_on_key_result {
	return &Servicescan_rslt_on_key_result{}
}

var Servicescan_rslt_on_key_result_success_DEFAULT KCells


func (p *Servicescan_rslt_on_key_result) Getsuccess() KCells {
	return p.success
}

var Servicescan_rslt_on_key_result_e_DEFAULT *Exception

func (p *Servicescan_rslt_on_key_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicescan_rslt_on_key_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicescan_rslt_on_key_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicescan_rslt_on_key_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicescan_rslt_on_key_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_key_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make(KCells, 0, size)
	p.success = tSlice
	for i := 0; i < size; i++ {
		_elem320 := &kCells{}
		if err := _elem320.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem320), err)
		}
		p.success = append(p.success, _elem320)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_key_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_key_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_key_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_key_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_rslt_on_key_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_rslt_on_key_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_rslt_on_key_result(%+v)", *p)
}

func (p *Servicescan_rslt_on_key_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_rslt_on_key_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_rslt_on_key_result)(nil)

// Attributes:
//  - spec: The Scan Specifications for the scan
// 
type Servicescan_rslt_on_fraction_args struct {
	spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
}

func NewServicescan_rslt_on_fraction_args() *Servicescan_rslt_on_fraction_args {
	return &Servicescan_rslt_on_fraction_args{}
}

var Servicescan_rslt_on_fraction_args_spec_DEFAULT *SpecScan

func (p *Servicescan_rslt_on_fraction_args) Getspec() *SpecScan {
	if !p.IsSetspec() {
		return Servicescan_rslt_on_fraction_args_spec_DEFAULT
	}
	return p.spec
}

func (p *Servicescan_rslt_on_fraction_args) IsSetspec() bool {
	return p.spec != nil
}

func (p *Servicescan_rslt_on_fraction_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_fraction_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec = &SpecScan{}
	if err := p.spec.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_fraction_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_fraction_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_fraction_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err)
	}
	if err := p.spec.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err)
	}
	return err
}

func (p *Servicescan_rslt_on_fraction_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_rslt_on_fraction_args(%+v)", *p)
}

func (p *Servicescan_rslt_on_fraction_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_rslt_on_fraction_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_rslt_on_fraction_args)(nil)

// Attributes:
//  - success
//  - e
// 
type Servicescan_rslt_on_fraction_result struct {
	success *FCells `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicescan_rslt_on_fraction_result() *Servicescan_rslt_on_fraction_result {
	return &Servicescan_rslt_on_fraction_result{}
}

var Servicescan_rslt_on_fraction_result_success_DEFAULT *FCells

func (p *Servicescan_rslt_on_fraction_result) Getsuccess() *FCells {
	if !p.IsSetsuccess() {
		return Servicescan_rslt_on_fraction_result_success_DEFAULT
	}
	return p.success
}

var Servicescan_rslt_on_fraction_result_e_DEFAULT *Exception

func (p *Servicescan_rslt_on_fraction_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicescan_rslt_on_fraction_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicescan_rslt_on_fraction_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicescan_rslt_on_fraction_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicescan_rslt_on_fraction_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_fraction_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.success = &FCells{}
	if err := p.success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.success), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_fraction_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_fraction_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_fraction_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_fraction_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_rslt_on_fraction_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_rslt_on_fraction_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_rslt_on_fraction_result(%+v)", *p)
}

func (p *Servicescan_rslt_on_fraction_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_rslt_on_fraction_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_rslt_on_fraction_result)(nil)

// Attributes:
//  - spec: The Scan Specifications for the scan
//  - rslt: The Type of Cells Result for the response
// 
type Servicescan_rslt_on_args struct {
	spec *SpecScan `thrift:"spec,1" db:"spec" json:"spec"`
	rslt CellsResult_ `thrift:"rslt,2" db:"rslt" json:"rslt"`
}

func NewServicescan_rslt_on_args() *Servicescan_rslt_on_args {
	return &Servicescan_rslt_on_args{}
}

var Servicescan_rslt_on_args_spec_DEFAULT *SpecScan

func (p *Servicescan_rslt_on_args) Getspec() *SpecScan {
	if !p.IsSetspec() {
		return Servicescan_rslt_on_args_spec_DEFAULT
	}
	return p.spec
}



func (p *Servicescan_rslt_on_args) Getrslt() CellsResult_ {
	return p.rslt
}

func (p *Servicescan_rslt_on_args) IsSetspec() bool {
	return p.spec != nil
}

func (p *Servicescan_rslt_on_args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.spec = &SpecScan{}
	if err := p.spec.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.spec), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_args) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := CellsResult_(v)
		p.rslt = temp
	}
	return nil
}

func (p *Servicescan_rslt_on_args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "spec", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:spec: ", p), err)
	}
	if err := p.spec.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.spec), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:spec: ", p), err)
	}
	return err
}

func (p *Servicescan_rslt_on_args) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rslt", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rslt: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.rslt)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rslt (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rslt: ", p), err)
	}
	return err
}

func (p *Servicescan_rslt_on_args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_rslt_on_args(%+v)", *p)
}

func (p *Servicescan_rslt_on_args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_rslt_on_args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_rslt_on_args)(nil)

// Attributes:
//  - success
//  - e: The Base Exception
// 
type Servicescan_rslt_on_result struct {
	success *CellsGroup `thrift:"success,0" db:"success" json:"success,omitempty"`
	e *Exception `thrift:"e,1" db:"e" json:"e,omitempty"`
}

func NewServicescan_rslt_on_result() *Servicescan_rslt_on_result {
	return &Servicescan_rslt_on_result{}
}

var Servicescan_rslt_on_result_success_DEFAULT *CellsGroup

func (p *Servicescan_rslt_on_result) Getsuccess() *CellsGroup {
	if !p.IsSetsuccess() {
		return Servicescan_rslt_on_result_success_DEFAULT
	}
	return p.success
}

var Servicescan_rslt_on_result_e_DEFAULT *Exception

func (p *Servicescan_rslt_on_result) Gete() *Exception {
	if !p.IsSete() {
		return Servicescan_rslt_on_result_e_DEFAULT
	}
	return p.e
}

func (p *Servicescan_rslt_on_result) IsSetsuccess() bool {
	return p.success != nil
}

func (p *Servicescan_rslt_on_result) IsSete() bool {
	return p.e != nil
}

func (p *Servicescan_rslt_on_result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.success = &CellsGroup{}
	if err := p.success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.success), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.e = &Exception{}
	if err := p.e.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.e), err)
	}
	return nil
}

func (p *Servicescan_rslt_on_result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "scan_rslt_on_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Servicescan_rslt_on_result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetsuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_rslt_on_result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSete() {
		if err := oprot.WriteFieldBegin(ctx, "e", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:e: ", p), err)
		}
		if err := p.e.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.e), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:e: ", p), err)
		}
	}
	return err
}

func (p *Servicescan_rslt_on_result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Servicescan_rslt_on_result(%+v)", *p)
}

func (p *Servicescan_rslt_on_result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*swcdb_thrift.Servicescan_rslt_on_result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Servicescan_rslt_on_result)(nil)


