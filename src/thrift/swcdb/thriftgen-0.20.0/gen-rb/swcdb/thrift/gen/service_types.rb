#
# Autogenerated by Thrift Compiler (0.20.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'

module Swcdb
  module Thrift
    module Gen
      module KeySeq
        # Unknown/Unrecognized Type
        UNKNOWN = 0
        # The Lexical Key Order Sequence
        LEXIC = 1
        # The Volumetric Key Order Sequence
        VOLUME = 2
        # The by Fractions Count on Lexical Key Order Sequence
        FC_LEXIC = 3
        # The by Fractions Count on Volumetric Key Order Sequence
        FC_VOLUME = 4
        VALUE_MAP = {0 => "UNKNOWN", 1 => "LEXIC", 2 => "VOLUME", 3 => "FC_LEXIC", 4 => "FC_VOLUME"}
        VALID_VALUES = Set.new([UNKNOWN, LEXIC, VOLUME, FC_LEXIC, FC_VOLUME]).freeze
      end

      module ColumnType
        # Unknown/Unrecognized Type
        UNKNOWN = 0
        # A Plain Column Value
        PLAIN = 1
        # A Counter Column Value with integrity of signed-64bit
        COUNTER_I64 = 2
        # A Counter Column Value with integrity of signed-32bit
        COUNTER_I32 = 3
        # A Counter Column Value with integrity of signed-16bit
        COUNTER_I16 = 4
        # A Counter Column Value with integrity of signed-8bit
        COUNTER_I8 = 5
        # A Serial Column Value
        SERIAL = 6
        # Not used - experimental
        CELL_DEFINED = 15
        VALUE_MAP = {0 => "UNKNOWN", 1 => "PLAIN", 2 => "COUNTER_I64", 3 => "COUNTER_I32", 4 => "COUNTER_I16", 5 => "COUNTER_I8", 6 => "SERIAL", 15 => "CELL_DEFINED"}
        VALID_VALUES = Set.new([UNKNOWN, PLAIN, COUNTER_I64, COUNTER_I32, COUNTER_I16, COUNTER_I8, SERIAL, CELL_DEFINED]).freeze
      end

      module EncodingType
        # Encoding by Ranger DEFAULT configurations
        DEFAULT = 0
        # No Encoding
        PLAIN = 1
        # Encode with zlib
        ZLIB = 2
        # Encode with snappy
        SNAPPY = 3
        # Encode with zstandard
        ZSTD = 4
        # Unrecognized Type
        UNKNOWN = 255
        VALUE_MAP = {0 => "DEFAULT", 1 => "PLAIN", 2 => "ZLIB", 3 => "SNAPPY", 4 => "ZSTD", 255 => "UNKNOWN"}
        VALID_VALUES = Set.new([DEFAULT, PLAIN, ZLIB, SNAPPY, ZSTD, UNKNOWN]).freeze
      end

      module SchemaFunc
        # Create Column Function
        CREATE = 3
        # Delete Column Function
        REMOVE = 5
        # Modify Column Function
        MODIFY = 7
        VALUE_MAP = {3 => "CREATE", 5 => "REMOVE", 7 => "MODIFY"}
        VALID_VALUES = Set.new([CREATE, REMOVE, MODIFY]).freeze
      end

      module Comp
        # [         ]  :   none               (no comparison applied)
        NONE = 0
        # [  =^     ]  :   -pf [prefix]       (starts-with)
        PF = 1
        # [ &gt;    ]  :   -gt                (greater-than)
        GT = 2
        # [ &gt;=   ]  :   -ge                (greater-equal)
        GE = 3
        # [  =      ]  :   -eq                (equal)
        EQ = 4
        # [ &lt;=   ]  :   -le                (lower-equal)
        LE = 5
        # [ &lt;    ]  :   -lt                (lower-than)
        LT = 6
        # [  !=     ]  :   -ne                (not-equal)
        NE = 7
        # [  re     ]  :   -re [r,regexp]     (regular-expression)
        RE = 8
        # [ v&gt;   ]  :   -vgt               (vol greater-than)
        VGT = 9
        # [ v&gt;=  ]  :   -vge               (vol greater-equal)
        VGE = 10
        # [ v&lt;=  ]  :   -vle               (vol lower-equal)
        VLE = 11
        # [ v&lt;   ]  :   -vlt               (vol lower-than)
        VLT = 12
        # [ %&gt;   ]  :   -subset [sbs]      (subset)
        SBS = 13
        # [ &lt;%   ]  :   -supset [sps]      (superset)
        SPS = 14
        # [ ~&gt;   ]  :   -posubset [posbs]  (eq/part ordered subset)
        POSBS = 15
        # [ &lt;~   ]  :   -posupset [posps]  (eq/part ordered superset)
        POSPS = 16
        # [ -&gt;   ]  :   -fosubset [fosbs]  (eq/full ordered subset)
        FOSBS = 17
        # [ &lt;-   ]  :   -fosupset [fosps]  (eq/full ordered superset)
        FOSPS = 18
        # [ :&lt;   ]  :   -fip  (fraction include prior)
        FIP = 19
        # [ :       ]  :   -fi   (fraction include)
        FI = 20
        # [ ||      ]  :   -or   (match any)
        OR = 21
        VALUE_MAP = {0 => "NONE", 1 => "PF", 2 => "GT", 3 => "GE", 4 => "EQ", 5 => "LE", 6 => "LT", 7 => "NE", 8 => "RE", 9 => "VGT", 10 => "VGE", 11 => "VLE", 12 => "VLT", 13 => "SBS", 14 => "SPS", 15 => "POSBS", 16 => "POSPS", 17 => "FOSBS", 18 => "FOSPS", 19 => "FIP", 20 => "FI", 21 => "OR"}
        VALID_VALUES = Set.new([NONE, PF, GT, GE, EQ, LE, LT, NE, RE, VGT, VGE, VLE, VLT, SBS, SPS, POSBS, POSPS, FOSBS, FOSPS, FIP, FI, OR]).freeze
      end

      module SpecFlagsOpt
        # No Flag Applied
        NONE = 0
        # Cells Limit by Keys
        LIMIT_BY_KEYS = 1
        # Cells Offset by Keys
        OFFSET_BY_KEYS = 4
        # Select Cells Only Keys without Value data
        ONLY_KEYS = 8
        # Select Cells Only with DELETE(cell-flag)
        ONLY_DELETES = 10
        VALUE_MAP = {0 => "NONE", 1 => "LIMIT_BY_KEYS", 4 => "OFFSET_BY_KEYS", 8 => "ONLY_KEYS", 10 => "ONLY_DELETES"}
        VALID_VALUES = Set.new([NONE, LIMIT_BY_KEYS, OFFSET_BY_KEYS, ONLY_KEYS, ONLY_DELETES]).freeze
      end

      module UpdateOP
        # The OP supported by column-types: PLAIN, SERIAL, COUNTER. Replaces with the update value (_default as well if other OP not supported by the col-type_)
        REPLACE = 0
        # The OP supported by column-types: PLAIN, SERIAL. Appends the update value to the cell's current
        APPEND = 1
        # The OP supported by column-types: PLAIN, SERIAL. Prepends the update value to the cell's current
        PREPEND = 2
        # The OP supported by column-type PLAIN. Inserts the update value at position in current value (appends if pos above value)
        INSERT = 3
        # The OP supported by column-type PLAIN. Overwrites the current value at position with new value (appends if pos above value)
        OVERWRITE = 4
        # The OP supported by column-type SERIAL. update is done by the inner serial-fields defintions
        SERIAL = 5
        VALUE_MAP = {0 => "REPLACE", 1 => "APPEND", 2 => "PREPEND", 3 => "INSERT", 4 => "OVERWRITE", 5 => "SERIAL"}
        VALID_VALUES = Set.new([REPLACE, APPEND, PREPEND, INSERT, OVERWRITE, SERIAL]).freeze
      end

      module SpecIntervalOptions
        # Update Bit Option
        UPDATING = 4
        # Delete Bit Option
        DELETING = 8
        VALUE_MAP = {4 => "UPDATING", 8 => "DELETING"}
        VALID_VALUES = Set.new([UPDATING, DELETING]).freeze
      end

      module Flag
        # Unknown/Undefined
        NONE = 0
        # The Cell is an insert
        INSERT = 1
        # The Cell is a delete versions lower-equal
        DELETE_LE = 2
        # The Cell is a  delete version equal
        DELETE_EQ = 3
        VALUE_MAP = {0 => "NONE", 1 => "INSERT", 2 => "DELETE_LE", 3 => "DELETE_EQ"}
        VALID_VALUES = Set.new([NONE, INSERT, DELETE_LE, DELETE_EQ]).freeze
      end

      module FU_MATH_OP
        # set field value to the new value
        EQUAL = 0
        # plus new value to field's value (negative number allowed)
        PLUS = 1
        # multiply current value by update value
        MULTIPLY = 2
        # divide current value by the new value (ignored at zero)
        DIVIDE = 3
        VALUE_MAP = {0 => "EQUAL", 1 => "PLUS", 2 => "MULTIPLY", 3 => "DIVIDE"}
        VALID_VALUES = Set.new([EQUAL, PLUS, MULTIPLY, DIVIDE]).freeze
      end

      module FU_LIST_OP
        # Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Replaces with the update value
        REPLACE = 0
        # Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Appends the update value to a field value
        APPEND = 1
        # Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Prepends the update value to a field value
        PREPEND = 2
        # Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Insert the update value at position in a field value (appends if pos above value)
        INSERT = 3
        # Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Overwrites a field value at position with new value (appends if pos above value)
        OVERWRITE = 4
        # Supported by field-types: BYTES, LIST_BYTES, LIST_INT64. Erases the position in a field value
        ERASE = 5
        # Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP
        BY_UNIQUE = 6
        # Supported by field-types: LIST_BYTES, LIST_INT64. The field value items have CTRL_VALUE_SET/DEL OP and Comparator
        BY_COND = 7
        # Supported by field-types: LIST_BYTES, LIST_INT64. The field value is with Postion and OP in items
        BY_INDEX = 8
        VALUE_MAP = {0 => "REPLACE", 1 => "APPEND", 2 => "PREPEND", 3 => "INSERT", 4 => "OVERWRITE", 5 => "ERASE", 6 => "BY_UNIQUE", 7 => "BY_COND", 8 => "BY_INDEX"}
        VALID_VALUES = Set.new([REPLACE, APPEND, PREPEND, INSERT, OVERWRITE, ERASE, BY_UNIQUE, BY_COND, BY_INDEX]).freeze
      end

      module CellsResult
        # Correspond to result on Cells (Cells in list)
        IN_LIST = 0
        # Correspond to result on CCells (Columns Cells)
        ON_COLUMN = 1
        # Correspond to result on KCells (Keys Cells)
        ON_KEY = 2
        # Correspond to result on FCells (Fraction Cells)
        ON_FRACTION = 3
        VALUE_MAP = {0 => "IN_LIST", 1 => "ON_COLUMN", 2 => "ON_KEY", 3 => "ON_FRACTION"}
        VALID_VALUES = Set.new([IN_LIST, ON_COLUMN, ON_KEY, ON_FRACTION]).freeze
      end

      class Exception < ::Thrift::Exception; end

      class Schema; end

      class SchemaPattern; end

      class SchemaTagsPatterns; end

      class SchemaPatterns; end

      class SpecSchemas; end

      class SpecFlags; end

      class SpecUpdateOP; end

      class SpecIntervalUpdatePlain; end

      class SpecIntervalUpdateCounter; end

      class SpecIntervalUpdateSerial; end

      class SpecValueSerial_INT64; end

      class SpecValueSerial_DOUBLE; end

      class SpecValueSerial_BYTES; end

      class SpecValueSerial_KEY; end

      class SpecValueSerial_LI; end

      class SpecValueSerial_LB; end

      class SpecValueSerialField; end

      class SpecValuePlain; end

      class SpecValueCounter; end

      class SpecValueSerial; end

      class SpecFraction; end

      class SpecTimestamp; end

      class SpecKeyInterval; end

      class SpecIntervalPlain; end

      class SpecIntervalCounter; end

      class SpecIntervalSerial; end

      class SpecColumnPlain; end

      class SpecColumnCounter; end

      class SpecColumnSerial; end

      class SpecScan; end

      class UCellPlain; end

      class UCellCounter; end

      class CellValueSerial; end

      class FU_INT64; end

      class FU_DOUBLE; end

      class FU_BYTES; end

      class FU_LI; end

      class FU_LB; end

      class CellValueSerialOp; end

      class UCellSerial; end

      class CellPlain; end

      class CellCounter; end

      class CellSerial; end

      class Cells; end

      class CCellPlain; end

      class CCellCounter; end

      class CCellSerial; end

      class CCells; end

      class KCellPlain; end

      class KCellCounter; end

      class KCellSerial; end

      class KCells; end

      class FCellPlain; end

      class FCellCounter; end

      class FCellSerial; end

      class FCells; end

      class CellsGroup; end

      class CompactResult; end

      class Result; end

      # The SWC::Thrift::Exception a base for any Exceptions
# both for the Thrift-Protocol and SWC-DB Errors.
      class Exception < ::Thrift::Exception
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CODE = 1
        MESSAGE = 2

        FIELDS = {
          # The corresponding Thrift-Procotol or SWC-DB Error Code
          CODE => {:type => ::Thrift::Types::I32, :name => 'code'},
          # The message describing the error code
          MESSAGE => {:type => ::Thrift::Types::STRING, :name => 'message'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Schema Definition
      class Schema
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        COL_NAME = 2
        COL_TAGS = 3
        COL_SEQ = 4
        COL_TYPE = 5
        CELL_VERSIONS = 6
        CELL_TTL = 7
        BLK_ENCODING = 8
        BLK_SIZE = 9
        BLK_CELLS = 10
        CS_REPLICATION = 11
        CS_SIZE = 12
        CS_MAX = 13
        LOG_ROLLOUT_RATIO = 14
        LOG_COMPACT_COINTERVALING = 15
        LOG_FRAGMENT_PRELOAD = 16
        COMPACT_PERCENT = 17
        REVISION = 18

        FIELDS = {
          # Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid', :optional => true},
          # Column Name
          COL_NAME => {:type => ::Thrift::Types::STRING, :name => 'col_name', :optional => true},
          # Column Tags
          COL_TAGS => {:type => ::Thrift::Types::LIST, :name => 'col_tags', :element => {:type => ::Thrift::Types::STRING}},
          # Column Key Sequence
          COL_SEQ => {:type => ::Thrift::Types::I32, :name => 'col_seq', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::KeySeq},
          # Column Type
          COL_TYPE => {:type => ::Thrift::Types::I32, :name => 'col_type', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::ColumnType},
          # Cell Versions
          CELL_VERSIONS => {:type => ::Thrift::Types::I32, :name => 'cell_versions', :optional => true},
          # Cell Time to Live
          CELL_TTL => {:type => ::Thrift::Types::I32, :name => 'cell_ttl', :optional => true},
          # Block Encoding
          BLK_ENCODING => {:type => ::Thrift::Types::I32, :name => 'blk_encoding', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::EncodingType},
          # Block Size in Bytes
          BLK_SIZE => {:type => ::Thrift::Types::I32, :name => 'blk_size', :optional => true},
          # Number of Cells in Block
          BLK_CELLS => {:type => ::Thrift::Types::I32, :name => 'blk_cells', :optional => true},
          # CellStore file Replication
          CS_REPLICATION => {:type => ::Thrift::Types::BYTE, :name => 'cs_replication', :optional => true},
          # CellStore Size in Bytes
          CS_SIZE => {:type => ::Thrift::Types::I32, :name => 'cs_size', :optional => true},
          # Max CellStores in a Range
          CS_MAX => {:type => ::Thrift::Types::BYTE, :name => 'cs_max', :optional => true},
          # Write Fragment File on ratio reached
          LOG_ROLLOUT_RATIO => {:type => ::Thrift::Types::BYTE, :name => 'log_rollout_ratio', :optional => true},
          # Min. Cointervaling Fragments for Compaction
          LOG_COMPACT_COINTERVALING => {:type => ::Thrift::Types::BYTE, :name => 'log_compact_cointervaling', :optional => true},
          # Number of Fragment to Preload
          LOG_FRAGMENT_PRELOAD => {:type => ::Thrift::Types::BYTE, :name => 'log_fragment_preload', :optional => true},
          # Compact at percent reach
          COMPACT_PERCENT => {:type => ::Thrift::Types::BYTE, :name => 'compact_percent', :optional => true},
          # Schema's revision/id
          REVISION => {:type => ::Thrift::Types::I64, :name => 'revision', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @col_seq.nil? || ::Swcdb::Thrift::Gen::KeySeq::VALID_VALUES.include?(@col_seq)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field col_seq!')
          end
          unless @col_type.nil? || ::Swcdb::Thrift::Gen::ColumnType::VALID_VALUES.include?(@col_type)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field col_type!')
          end
          unless @blk_encoding.nil? || ::Swcdb::Thrift::Gen::EncodingType::VALID_VALUES.include?(@blk_encoding)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field blk_encoding!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Schema matching Pattern
      class SchemaPattern
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        VALUE = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The patern value to match against
          VALUE => {:type => ::Thrift::Types::STRING, :name => 'value'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Schema Tags patterns for the SchemaPatterns
      class SchemaTagsPatterns
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        VALUES = 2

        FIELDS = {
          # Logical comparator to Apply, unsupported PF, RE and Vol. kind
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The tags patterns to match against schema's column tags
          VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SchemaPattern}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Schema Patterns for the SpecSchemas
      class SchemaPatterns
        include ::Thrift::Struct, ::Thrift::Struct_Union
        NAMES = 1
        TAGS = 2

        FIELDS = {
          # The Schema patterns for selecting by Column Name
          NAMES => {:type => ::Thrift::Types::LIST, :name => 'names', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SchemaPattern}},
          # The Schema patterns for selecting by Column Tags
          TAGS => {:type => ::Thrift::Types::STRUCT, :name => 'tags', :class => ::Swcdb::Thrift::Gen::SchemaTagsPatterns}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specs for Schemas for using with list_columns or compact_columns
      class SpecSchemas
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CIDS = 1
        NAMES = 2
        PATTERNS = 3

        FIELDS = {
          # The Column IDs
          CIDS => {:type => ::Thrift::Types::LIST, :name => 'cids', :element => {:type => ::Thrift::Types::I64}},
          # The Column Names
          NAMES => {:type => ::Thrift::Types::LIST, :name => 'names', :element => {:type => ::Thrift::Types::STRING}},
          # The Schema's selector patterns
          PATTERNS => {:type => ::Thrift::Types::STRUCT, :name => 'patterns', :class => ::Swcdb::Thrift::Gen::SchemaPatterns}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Scan Specifications Flags
      class SpecFlags
        include ::Thrift::Struct, ::Thrift::Struct_Union
        LIMIT = 1
        OFFSET = 2
        MAX_VERSIONS = 3
        MAX_BUFFER = 4
        OPTIONS = 5

        FIELDS = {
          # Limit to this number of cells
          LIMIT => {:type => ::Thrift::Types::I64, :name => 'limit', :optional => true},
          # Scan from this number of cells Offset on matching Cell-Interval
          OFFSET => {:type => ::Thrift::Types::I64, :name => 'offset', :optional => true},
          # Select only this number of Versions of a given Cell-Key
          MAX_VERSIONS => {:type => ::Thrift::Types::I32, :name => 'max_versions', :optional => true},
          # return results with reach of this Buffer size in bytes
          MAX_BUFFER => {:type => ::Thrift::Types::I32, :name => 'max_buffer', :optional => true},
          # The options bit by SpecFlagsOpt
          OPTIONS => {:type => ::Thrift::Types::BYTE, :name => 'options', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SpecUpdateOP
        include ::Thrift::Struct, ::Thrift::Struct_Union
        OP = 1
        POS = 2

        FIELDS = {
          # The Operation of update
          OP => {:type => ::Thrift::Types::I32, :name => 'op', :enum_class => ::Swcdb::Thrift::Gen::UpdateOP},
          # The position/index of INSERT and OVERWRITE update operations
          POS => {:type => ::Thrift::Types::I32, :name => 'pos', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @op.nil? || ::Swcdb::Thrift::Gen::UpdateOP::VALID_VALUES.include?(@op)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field op!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Value specs for an Updating Interval of 'updating' in SpecIntervalPlain
      class SpecIntervalUpdatePlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        V = 1
        TS = 2
        ENCODER = 3
        UPDATE_OP = 4

        FIELDS = {
          # The bytes value for the updated cell
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true},
          # The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
          TS => {:type => ::Thrift::Types::I64, :name => 'ts', :optional => true},
          # Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
          ENCODER => {:type => ::Thrift::Types::I32, :name => 'encoder', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::EncodingType},
          # Optionally the operaton of value update
          UPDATE_OP => {:type => ::Thrift::Types::STRUCT, :name => 'update_op', :class => ::Swcdb::Thrift::Gen::SpecUpdateOP, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @encoder.nil? || ::Swcdb::Thrift::Gen::EncodingType::VALID_VALUES.include?(@encoder)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoder!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Value specs for an Updating Interval of 'updating' in SpecIntervalCounter
      class SpecIntervalUpdateCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        V = 1
        OP = 2
        TS = 3
        UPDATE_OP = 4

        FIELDS = {
          # The int64 value for the updated cell
          V => {:type => ::Thrift::Types::I64, :name => 'v'},
          # The Opration pf Counter, available: COUNTER_OP_EQUAL
          OP => {:type => ::Thrift::Types::I64, :name => 'op', :default => 0},
          # The timestamp for the updated cell NULL: MIN_INT64+1, AUTO:MIN_INT64+2 (or not-set)
          TS => {:type => ::Thrift::Types::I64, :name => 'ts', :optional => true},
          # Optionally the operaton of value update
          UPDATE_OP => {:type => ::Thrift::Types::STRUCT, :name => 'update_op', :class => ::Swcdb::Thrift::Gen::SpecUpdateOP, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Value specs for an Updating Interval of 'updating' in SpecIntervalSerial
      class SpecIntervalUpdateSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        TS = 1
        V = 2
        V_OP = 3
        ENCODER = 4
        UPDATE_OP = 5

        FIELDS = {
          # The timestamp for the updated cell NULL: MIN_INT64-1, AUTO:MIN_INT64-1
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The values of serial-fields for the updated cell
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}},
          # The values of serial-fields for the the SERIAL operation update
          V_OP => {:type => ::Thrift::Types::LIST, :name => 'v_op', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerialOp}},
          # Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
          ENCODER => {:type => ::Thrift::Types::I32, :name => 'encoder', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::EncodingType},
          # Optionally the operaton of value update
          UPDATE_OP => {:type => ::Thrift::Types::STRUCT, :name => 'update_op', :class => ::Swcdb::Thrift::Gen::SpecUpdateOP, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @encoder.nil? || ::Swcdb::Thrift::Gen::EncodingType::VALID_VALUES.include?(@encoder)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoder!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of INT64 Serial Value Field
      class SpecValueSerial_INT64
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The int64 to match against the value field
          V => {:type => ::Thrift::Types::I64, :name => 'v'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of DOUBLE Serial Value Field
      class SpecValueSerial_DOUBLE
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The double to match against the value field
          V => {:type => ::Thrift::Types::DOUBLE, :name => 'v'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of BYTES Serial Value Field
      class SpecValueSerial_BYTES
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The binary(bytes) to match against the value field
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of KEY Serial Value Field
      class SpecValueSerial_KEY
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SEQ = 1
        V = 2

        FIELDS = {
          # The Key Sequence to use
          SEQ => {:type => ::Thrift::Types::I32, :name => 'seq', :enum_class => ::Swcdb::Thrift::Gen::KeySeq},
          # The Specification of the Key to match against the value field
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecFraction}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @seq.nil? || ::Swcdb::Thrift::Gen::KeySeq::VALID_VALUES.include?(@seq)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field seq!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of LIST_INT64(LI) Serial Value Field
      class SpecValueSerial_LI
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The List of Int64 to match against the value field
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueSerial_INT64}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Specifications of LIST_BYTES(LB) Serial Value Field
      class SpecValueSerial_LB
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The List of Bytes to match against the value field
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueSerial_BYTES}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      class SpecValueSerialField
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_ID = 1
        SPEC_INT64 = 2
        SPEC_DOUBLE = 3
        SPEC_BYTES = 4
        SPEC_KEY = 5
        SPEC_LI = 6
        SPEC_LB = 7

        FIELDS = {
          # The Field Id of the Value Field
          FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'field_id'},
          # The specifications of Int64 for the field
          SPEC_INT64 => {:type => ::Thrift::Types::STRUCT, :name => 'spec_int64', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_INT64, :optional => true},
          # The specifications of Double for the field
          SPEC_DOUBLE => {:type => ::Thrift::Types::STRUCT, :name => 'spec_double', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_DOUBLE, :optional => true},
          # The specifications of Bytes for the field
          SPEC_BYTES => {:type => ::Thrift::Types::STRUCT, :name => 'spec_bytes', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_BYTES},
          # The specifications of Cell-Key for the field
          SPEC_KEY => {:type => ::Thrift::Types::STRUCT, :name => 'spec_key', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_KEY},
          # The specifications of List Int64 for the field
          SPEC_LI => {:type => ::Thrift::Types::STRUCT, :name => 'spec_li', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_LI},
          # The specifications of List Bytes for the field
          SPEC_LB => {:type => ::Thrift::Types::STRUCT, :name => 'spec_lb', :class => ::Swcdb::Thrift::Gen::SpecValueSerial_LB}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Plain Value Specifications, option to use with Extended Logical Comparators
      class SpecValuePlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The binary(bytes) to match against the Cell value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Counter Value Specifications, option to use with Extended Logical Comparators
      class SpecValueCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        V = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The int64 to match against the Cell value
          V => {:type => ::Thrift::Types::I64, :name => 'v'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial Value Specifications
      class SpecValueSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        FIELDS = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The Serial Value Specifications to match against the SERIAL Cell value fields
          FIELDS => {:type => ::Thrift::Types::LIST, :name => 'fields', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueSerialField}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Fraction Specifications
      class SpecFraction
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        F = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The binary(bytes) to match against a fraction of a Cell-Key
          F => {:type => ::Thrift::Types::STRING, :name => 'f', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Timestamp Specifications
      class SpecTimestamp
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COMP = 1
        TS = 2

        FIELDS = {
          # Logical comparator to Apply
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :enum_class => ::Swcdb::Thrift::Gen::Comp},
          # The timestamp in nanoseconds to match against the Cell timestamp/version (not the revision)
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Key Interval Specifications
      class SpecKeyInterval
        include ::Thrift::Struct, ::Thrift::Struct_Union
        START = 1
        FINISH = 2

        FIELDS = {
          # The Key Start Spec, the start of cells-interval key match
          START => {:type => ::Thrift::Types::LIST, :name => 'start', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecFraction}},
          # The Key Finish Spec, the finish of cells-interval key match
          FINISH => {:type => ::Thrift::Types::LIST, :name => 'finish', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecFraction}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cells Interval Plain type Specifications with interval-scope Flags
      class SpecIntervalPlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RANGE_BEGIN = 1
        RANGE_END = 2
        OFFSET_KEY = 3
        OFFSET_REV = 4
        KEY_INTERVALS = 5
        VALUES = 6
        TS_START = 7
        TS_FINISH = 8
        FLAGS = 9
        OPTIONS = 10
        UPDATING = 11

        FIELDS = {
          # Begin of Ranges evaluation with this Key inclusive
          RANGE_BEGIN => {:type => ::Thrift::Types::LIST, :name => 'range_begin', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # End of Ranges evaluation with this Key inclusive
          RANGE_END => {:type => ::Thrift::Types::LIST, :name => 'range_end', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Key of a Scan, select cells from this key inclusive
          OFFSET_KEY => {:type => ::Thrift::Types::LIST, :name => 'offset_key', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Timestamp of a Scan, select cells after this timestamp
          OFFSET_REV => {:type => ::Thrift::Types::I64, :name => 'offset_rev', :optional => true},
          # The Key Intervals
          KEY_INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'key_intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecKeyInterval}},
          # The Cell Value Specifications, cell-value match for plain type
          VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValuePlain}},
          # The Timestamp Start Spec, the start of cells-interval timestamp match
          TS_START => {:type => ::Thrift::Types::STRUCT, :name => 'ts_start', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Timestamp Finish Spec, the finish of cells-interval timestamp match
          TS_FINISH => {:type => ::Thrift::Types::STRUCT, :name => 'ts_finish', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Interval Flags Specification
          FLAGS => {:type => ::Thrift::Types::STRUCT, :name => 'flags', :class => ::Swcdb::Thrift::Gen::SpecFlags, :optional => true},
          # The Interval Options Specification
          OPTIONS => {:type => ::Thrift::Types::I32, :name => 'options', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::SpecIntervalOptions},
          # The Value spec of an Updating Interval
          UPDATING => {:type => ::Thrift::Types::STRUCT, :name => 'updating', :class => ::Swcdb::Thrift::Gen::SpecIntervalUpdatePlain, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @options.nil? || ::Swcdb::Thrift::Gen::SpecIntervalOptions::VALID_VALUES.include?(@options)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field options!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cells Interval Counter type Specifications with interval-scope Flags
      class SpecIntervalCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RANGE_BEGIN = 1
        RANGE_END = 2
        OFFSET_KEY = 3
        OFFSET_REV = 4
        KEY_INTERVALS = 5
        VALUES = 6
        TS_START = 7
        TS_FINISH = 8
        FLAGS = 9
        OPTIONS = 10
        UPDATING = 11

        FIELDS = {
          # Begin of Ranges evaluation with this Key inclusive
          RANGE_BEGIN => {:type => ::Thrift::Types::LIST, :name => 'range_begin', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # End of Ranges evaluation with this Key inclusive
          RANGE_END => {:type => ::Thrift::Types::LIST, :name => 'range_end', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Key of a Scan, select cells from this key inclusive
          OFFSET_KEY => {:type => ::Thrift::Types::LIST, :name => 'offset_key', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Timestamp of a Scan, select cells after this timestamp
          OFFSET_REV => {:type => ::Thrift::Types::I64, :name => 'offset_rev', :optional => true},
          # The Key Intervals
          KEY_INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'key_intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecKeyInterval}},
          # The Cell Value Specifications, cell-value match for counter type
          VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueCounter}},
          # The Timestamp Start Spec, the start of cells-interval timestamp match
          TS_START => {:type => ::Thrift::Types::STRUCT, :name => 'ts_start', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Timestamp Finish Spec, the finish of cells-interval timestamp match
          TS_FINISH => {:type => ::Thrift::Types::STRUCT, :name => 'ts_finish', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Interval Flags Specification
          FLAGS => {:type => ::Thrift::Types::STRUCT, :name => 'flags', :class => ::Swcdb::Thrift::Gen::SpecFlags, :optional => true},
          # The Interval Options Specification
          OPTIONS => {:type => ::Thrift::Types::I32, :name => 'options', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::SpecIntervalOptions},
          # The Value spec of an Updating Interval
          UPDATING => {:type => ::Thrift::Types::STRUCT, :name => 'updating', :class => ::Swcdb::Thrift::Gen::SpecIntervalUpdateCounter, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @options.nil? || ::Swcdb::Thrift::Gen::SpecIntervalOptions::VALID_VALUES.include?(@options)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field options!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cells Interval Serial type Specifications with interval-scope Flags
      class SpecIntervalSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        RANGE_BEGIN = 1
        RANGE_END = 2
        OFFSET_KEY = 3
        OFFSET_REV = 4
        KEY_INTERVALS = 5
        VALUES = 6
        TS_START = 7
        TS_FINISH = 8
        FLAGS = 9
        OPTIONS = 10
        UPDATING = 11

        FIELDS = {
          # Begin of Ranges evaluation with this Key inclusive
          RANGE_BEGIN => {:type => ::Thrift::Types::LIST, :name => 'range_begin', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # End of Ranges evaluation with this Key inclusive
          RANGE_END => {:type => ::Thrift::Types::LIST, :name => 'range_end', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Key of a Scan, select cells from this key inclusive
          OFFSET_KEY => {:type => ::Thrift::Types::LIST, :name => 'offset_key', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # Offset Cell Timestamp of a Scan, select cells after this timestamp
          OFFSET_REV => {:type => ::Thrift::Types::I64, :name => 'offset_rev', :optional => true},
          # The Key Intervals
          KEY_INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'key_intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecKeyInterval}},
          # The Serial Cell Value Specifications, cell-value fields match
          VALUES => {:type => ::Thrift::Types::LIST, :name => 'values', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecValueSerial}},
          # The Timestamp Start Spec, the start of cells-interval timestamp match
          TS_START => {:type => ::Thrift::Types::STRUCT, :name => 'ts_start', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Timestamp Finish Spec, the finish of cells-interval timestamp match
          TS_FINISH => {:type => ::Thrift::Types::STRUCT, :name => 'ts_finish', :class => ::Swcdb::Thrift::Gen::SpecTimestamp, :optional => true},
          # The Interval Flags Specification
          FLAGS => {:type => ::Thrift::Types::STRUCT, :name => 'flags', :class => ::Swcdb::Thrift::Gen::SpecFlags, :optional => true},
          # The Interval Options Specification
          OPTIONS => {:type => ::Thrift::Types::I32, :name => 'options', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::SpecIntervalOptions},
          # The Serial-Value spec of an Updating Interval
          UPDATING => {:type => ::Thrift::Types::STRUCT, :name => 'updating', :class => ::Swcdb::Thrift::Gen::SpecIntervalUpdateSerial, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @options.nil? || ::Swcdb::Thrift::Gen::SpecIntervalOptions::VALID_VALUES.include?(@options)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field options!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Specifications, the Cells-Intervals(SpecIntervalPlain/s) specification for a PLAIN Type column
      class SpecColumnPlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        INTERVALS = 2

        FIELDS = {
          # The Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid'},
          # The Cells Interval in a list-container
          INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecIntervalPlain}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Specifications, the Cells-Intervals(SpecIntervalCounter/s) specification for a COUNTER Type column
      class SpecColumnCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        INTERVALS = 2

        FIELDS = {
          # The Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid'},
          # The Cells Interval in a list-container
          INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecIntervalCounter}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Specifications, the Cells-Intervals(SpecIntervalSerial/s) specification for a SERIAL Type Column
      class SpecColumnSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        INTERVALS = 2

        FIELDS = {
          # The Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid'},
          # The Serial Cells Interval in a list-container
          INTERVALS => {:type => ::Thrift::Types::LIST, :name => 'intervals', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecIntervalSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Scan Specifications, the Columns-Intervals(SpecColumn/s) with global-scope Flags
      class SpecScan
        include ::Thrift::Struct, ::Thrift::Struct_Union
        COLUMNS_PLAIN = 1
        COLUMNS_COUNTER = 2
        COLUMNS_SERIAL = 3
        FLAGS = 4

        FIELDS = {
          # The Plain Column Intervals(SpecColumnPlain) in a list-container
          COLUMNS_PLAIN => {:type => ::Thrift::Types::LIST, :name => 'columns_plain', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecColumnPlain}},
          # The Counter Column Intervals(SpecColumnCounter) in a list-container
          COLUMNS_COUNTER => {:type => ::Thrift::Types::LIST, :name => 'columns_counter', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecColumnCounter}},
          # The Serial Column Intervals(SpecColumnSerial) in a list-container
          COLUMNS_SERIAL => {:type => ::Thrift::Types::LIST, :name => 'columns_serial', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::SpecColumnSerial}},
          # The Global Flags Specification
          FLAGS => {:type => ::Thrift::Types::STRUCT, :name => 'flags', :class => ::Swcdb::Thrift::Gen::SpecFlags, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cell data for using with Update of PLAIN Column Type
      class UCellPlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        F = 1
        K = 2
        TS = 3
        TS_DESC = 4
        V = 5
        ENCODER = 6

        FIELDS = {
          # The Cell Flag
          F => {:type => ::Thrift::Types::I32, :name => 'f', :enum_class => ::Swcdb::Thrift::Gen::Flag},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp in nanoseconds
          TS => {:type => ::Thrift::Types::I64, :name => 'ts', :optional => true},
          # The Cell Version is in timestamp descending
          TS_DESC => {:type => ::Thrift::Types::BOOL, :name => 'ts_desc', :optional => true},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true},
          # Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
          ENCODER => {:type => ::Thrift::Types::I32, :name => 'encoder', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::EncodingType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @f.nil? || ::Swcdb::Thrift::Gen::Flag::VALID_VALUES.include?(@f)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field f!')
          end
          unless @encoder.nil? || ::Swcdb::Thrift::Gen::EncodingType::VALID_VALUES.include?(@encoder)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoder!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cell data for using with Update of COUNTER Column Type
      class UCellCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        F = 1
        K = 2
        TS = 3
        TS_DESC = 4
        OP = 5
        V = 6

        FIELDS = {
          # The Cell Flag
          F => {:type => ::Thrift::Types::I32, :name => 'f', :enum_class => ::Swcdb::Thrift::Gen::Flag},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp in nanoseconds
          TS => {:type => ::Thrift::Types::I64, :name => 'ts', :optional => true},
          # The Cell Version is in timestamp descending
          TS_DESC => {:type => ::Thrift::Types::BOOL, :name => 'ts_desc', :optional => true},
          # The Cell Counter Operation
          OP => {:type => ::Thrift::Types::BYTE, :name => 'op', :default => 0},
          # The Cell Counter Value
          V => {:type => ::Thrift::Types::I64, :name => 'v', :default => 0}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @f.nil? || ::Swcdb::Thrift::Gen::Flag::VALID_VALUES.include?(@f)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field f!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial Value Cell field
      class CellValueSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_ID = 1
        V_INT64 = 2
        V_DOUBLE = 3
        V_BYTES = 4
        V_KEY = 5
        V_LI = 6
        V_LB = 7

        FIELDS = {
          # The Field ID, a single ID can have any/all the field types
          FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'field_id'},
          # The INT64 type field
          V_INT64 => {:type => ::Thrift::Types::I64, :name => 'v_int64', :optional => true},
          # The DOUBLE type field
          V_DOUBLE => {:type => ::Thrift::Types::DOUBLE, :name => 'v_double', :optional => true},
          # The BYTES type field
          V_BYTES => {:type => ::Thrift::Types::STRING, :name => 'v_bytes', :binary => true, :optional => true},
          # The Cell KEY type field
          V_KEY => {:type => ::Thrift::Types::LIST, :name => 'v_key', :element => {:type => ::Thrift::Types::STRING, :binary => true}, :optional => true},
          # The LIST INT64 type field
          V_LI => {:type => ::Thrift::Types::LIST, :name => 'v_li', :element => {:type => ::Thrift::Types::I64}, :optional => true},
          # The LIST BYTES type field
          V_LB => {:type => ::Thrift::Types::LIST, :name => 'v_lb', :element => {:type => ::Thrift::Types::STRING, :binary => true}, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Serial INT64 Field Update
      class FU_INT64
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CTRL = 1
        OP = 2
        POS = 3
        COMP = 4
        V = 5

        FIELDS = {
          CTRL => {:type => ::Thrift::Types::BYTE, :name => 'ctrl', :default => 0},
          OP => {:type => ::Thrift::Types::I32, :name => 'op', :default =>           0, :enum_class => ::Swcdb::Thrift::Gen::FU_MATH_OP},
          POS => {:type => ::Thrift::Types::I32, :name => 'pos', :optional => true},
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::Comp},
          V => {:type => ::Thrift::Types::I64, :name => 'v'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @op.nil? || ::Swcdb::Thrift::Gen::FU_MATH_OP::VALID_VALUES.include?(@op)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field op!')
          end
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Serial DOUBLE Field Update
      class FU_DOUBLE
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CTRL = 1
        OP = 2
        POS = 3
        COMP = 4
        V = 5

        FIELDS = {
          CTRL => {:type => ::Thrift::Types::BYTE, :name => 'ctrl', :default => 0},
          OP => {:type => ::Thrift::Types::I32, :name => 'op', :default =>           0, :enum_class => ::Swcdb::Thrift::Gen::FU_MATH_OP},
          POS => {:type => ::Thrift::Types::I32, :name => 'pos', :optional => true},
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::Comp},
          V => {:type => ::Thrift::Types::DOUBLE, :name => 'v'}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @op.nil? || ::Swcdb::Thrift::Gen::FU_MATH_OP::VALID_VALUES.include?(@op)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field op!')
          end
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Serial BYTES Field Update
      class FU_BYTES
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CTRL = 1
        OP = 2
        POS = 3
        COMP = 4
        V = 5

        FIELDS = {
          CTRL => {:type => ::Thrift::Types::BYTE, :name => 'ctrl', :default => 0},
          OP => {:type => ::Thrift::Types::I32, :name => 'op', :default =>           0, :enum_class => ::Swcdb::Thrift::Gen::FU_LIST_OP},
          POS => {:type => ::Thrift::Types::I32, :name => 'pos', :optional => true},
          COMP => {:type => ::Thrift::Types::I32, :name => 'comp', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::Comp},
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @op.nil? || ::Swcdb::Thrift::Gen::FU_LIST_OP::VALID_VALUES.include?(@op)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field op!')
          end
          unless @comp.nil? || ::Swcdb::Thrift::Gen::Comp::VALID_VALUES.include?(@comp)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field comp!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Serial LIST_INT64 Field Update
      class FU_LI
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CTRL = 1
        OP = 2
        POS = 3
        V = 4

        FIELDS = {
          CTRL => {:type => ::Thrift::Types::BYTE, :name => 'ctrl', :default => 0},
          OP => {:type => ::Thrift::Types::I32, :name => 'op', :default =>           0, :enum_class => ::Swcdb::Thrift::Gen::FU_LIST_OP},
          POS => {:type => ::Thrift::Types::I32, :name => 'pos', :optional => true},
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FU_INT64}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @op.nil? || ::Swcdb::Thrift::Gen::FU_LIST_OP::VALID_VALUES.include?(@op)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field op!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # Serial LIST_BYTES Field Update
      class FU_LB
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CTRL = 1
        OP = 2
        POS = 3
        V = 4

        FIELDS = {
          CTRL => {:type => ::Thrift::Types::BYTE, :name => 'ctrl', :default => 0},
          OP => {:type => ::Thrift::Types::I32, :name => 'op', :default =>           0, :enum_class => ::Swcdb::Thrift::Gen::FU_LIST_OP},
          POS => {:type => ::Thrift::Types::I32, :name => 'pos', :optional => true},
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FU_BYTES}}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @op.nil? || ::Swcdb::Thrift::Gen::FU_LIST_OP::VALID_VALUES.include?(@op)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field op!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial Values Cell field with Update Operation
      class CellValueSerialOp
        include ::Thrift::Struct, ::Thrift::Struct_Union
        FIELD_ID = 1
        V_INT64 = 2
        V_DOUBLE = 3
        V_BYTES = 4
        V_KEY = 5
        V_LI = 6
        V_LB = 7

        FIELDS = {
          # The Field ID, a single ID can have any/all the field types
          FIELD_ID => {:type => ::Thrift::Types::I32, :name => 'field_id'},
          # The INT64 type update-field
          V_INT64 => {:type => ::Thrift::Types::STRUCT, :name => 'v_int64', :class => ::Swcdb::Thrift::Gen::FU_INT64, :optional => true},
          # The DOUBLE type update-field
          V_DOUBLE => {:type => ::Thrift::Types::STRUCT, :name => 'v_double', :class => ::Swcdb::Thrift::Gen::FU_DOUBLE, :optional => true},
          # The BYTES type update-field
          V_BYTES => {:type => ::Thrift::Types::STRUCT, :name => 'v_bytes', :class => ::Swcdb::Thrift::Gen::FU_BYTES, :optional => true},
          # The Cell KEY type update-field
          V_KEY => {:type => ::Thrift::Types::LIST, :name => 'v_key', :element => {:type => ::Thrift::Types::STRING, :binary => true}, :optional => true},
          # The LIST INT64 type update-field
          V_LI => {:type => ::Thrift::Types::STRUCT, :name => 'v_li', :class => ::Swcdb::Thrift::Gen::FU_LI, :optional => true},
          # The LIST BYTES type update-field
          V_LB => {:type => ::Thrift::Types::STRUCT, :name => 'v_lb', :class => ::Swcdb::Thrift::Gen::FU_LB, :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cell data for using with Update of SERIAL Column Type
      class UCellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        F = 1
        K = 2
        TS = 3
        TS_DESC = 4
        V = 5
        ENCODER = 6

        FIELDS = {
          # The Cell Flag
          F => {:type => ::Thrift::Types::I32, :name => 'f', :enum_class => ::Swcdb::Thrift::Gen::Flag},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp in nanoseconds
          TS => {:type => ::Thrift::Types::I64, :name => 'ts', :optional => true},
          # The Cell Version is in timestamp descending
          TS_DESC => {:type => ::Thrift::Types::BOOL, :name => 'ts_desc', :optional => true},
          # The Serial Cell Value fields
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}},
          # Optionally the Cell Value Encoding Type: ZLIB/SNAPPY/ZSTD
          ENCODER => {:type => ::Thrift::Types::I32, :name => 'encoder', :optional => true, :enum_class => ::Swcdb::Thrift::Gen::EncodingType}
        }

        def struct_fields; FIELDS; end

        def validate
          unless @f.nil? || ::Swcdb::Thrift::Gen::Flag::VALID_VALUES.include?(@f)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field f!')
          end
          unless @encoder.nil? || ::Swcdb::Thrift::Gen::EncodingType::VALID_VALUES.include?(@encoder)
            raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field encoder!')
          end
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cell for results list of scan
      class CellPlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        K = 2
        TS = 3
        V = 4

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Counter Cell for results list of scan
      class CellCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        K = 2
        TS = 3
        V = 4
        EQ = 5

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Counter Value
          V => {:type => ::Thrift::Types::I64, :name => 'v'},
          # The Counter EQ since ts
          EQ => {:type => ::Thrift::Types::I64, :name => 'eq', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial Cell for results list of scan
      class CellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        K = 2
        TS = 3
        V = 4

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Serial Value
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Cells for results list of scan
      class Cells
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PLAIN_CELLS = 1
        COUNTER_CELLS = 2
        SERIAL_CELLS = 3

        FIELDS = {
          # The Cells, defined as Cell items in a list-container
          PLAIN_CELLS => {:type => ::Thrift::Types::LIST, :name => 'plain_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellPlain}},
          # The Cells, defined as Cell items in a list-container
          COUNTER_CELLS => {:type => ::Thrift::Types::LIST, :name => 'counter_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellCounter}},
          # The Serial Cells, defined as CellSerial items in a list-container
          SERIAL_CELLS => {:type => ::Thrift::Types::LIST, :name => 'serial_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Plain column type Cell for results on Columns of scan
      class CCellPlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        K = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Counter column type Cell for results on Columns of scan
      class CCellCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        K = 1
        TS = 2
        V = 3
        EQ = 4

        FIELDS = {
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Counter Value
          V => {:type => ::Thrift::Types::I64, :name => 'v'},
          # The Counter EQ since ts
          EQ => {:type => ::Thrift::Types::I64, :name => 'eq', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial column type Cell for results on Columns of scan
      class CCellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        K = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Serial Value
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Column Cells for results on Columns of scan
      class CCells
        include ::Thrift::Struct, ::Thrift::Struct_Union
        PLAIN_CELLS = 1
        COUNTER_CELLS = 2
        SERIAL_CELLS = 3

        FIELDS = {
          # The Plain type Cells, defined as CCellPlain items in a list-container
          PLAIN_CELLS => {:type => ::Thrift::Types::LIST, :name => 'plain_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CCellPlain}},
          # The Counter type Cells, defined as CCellCounter items in a list-container
          COUNTER_CELLS => {:type => ::Thrift::Types::LIST, :name => 'counter_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CCellCounter}},
          # The Serial type Cells, defined as CCellSerial items in a list-container
          SERIAL_CELLS => {:type => ::Thrift::Types::LIST, :name => 'serial_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CCellSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Plain column type Key Cell for results on Key of scan
      class KCellPlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Counter column type Key Cell for results on Key of scan
      class KCellCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3
        EQ = 4

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Counter Value
          V => {:type => ::Thrift::Types::I64, :name => 'v'},
          # The Counter EQ since ts
          EQ => {:type => ::Thrift::Types::I64, :name => 'eq', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial column type Key Cell for results on Key of scan
      class KCellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Serial Value
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Key Cells for results on Key of scan
      class KCells
        include ::Thrift::Struct, ::Thrift::Struct_Union
        K = 1
        PLAIN_CELLS = 2
        COUNTER_CELLS = 3
        SERIAL_CELLS = 4

        FIELDS = {
          # The Cell Key
          K => {:type => ::Thrift::Types::LIST, :name => 'k', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
          # The Plain type Key Cells, defined as KCellPlain items in a list-container
          PLAIN_CELLS => {:type => ::Thrift::Types::LIST, :name => 'plain_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::KCellPlain}},
          # The Counter type Key Cells, defined as KCellCounter items in a list-container
          COUNTER_CELLS => {:type => ::Thrift::Types::LIST, :name => 'counter_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::KCellCounter}},
          # The Serial type Key Cells, defined as KCellSerial items in a list-container
          SERIAL_CELLS => {:type => ::Thrift::Types::LIST, :name => 'serial_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::KCellSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Plain column type Fraction Cell for results on Fraction of scan
      class FCellPlain
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Value
          V => {:type => ::Thrift::Types::STRING, :name => 'v', :binary => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Counter column type Fraction Cell for results on Fraction of scan
      class FCellCounter
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3
        EQ = 4

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Counter Value
          V => {:type => ::Thrift::Types::I64, :name => 'v'},
          # The Counter EQ since ts
          EQ => {:type => ::Thrift::Types::I64, :name => 'eq', :optional => true}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Serial column type Fraction Cell for results on Fraction of scan
      class FCellSerial
        include ::Thrift::Struct, ::Thrift::Struct_Union
        C = 1
        TS = 2
        V = 3

        FIELDS = {
          # The Column Name
          C => {:type => ::Thrift::Types::STRING, :name => 'c'},
          # The Cell Timestamp
          TS => {:type => ::Thrift::Types::I64, :name => 'ts'},
          # The Cell Serial Value
          V => {:type => ::Thrift::Types::LIST, :name => 'v', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CellValueSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Fraction Cells for results on Fraction of scan
      class FCells
        include ::Thrift::Struct, ::Thrift::Struct_Union
        F = 1
        PLAIN_CELLS = 2
        COUNTER_CELLS = 3
        SERIAL_CELLS = 4

        FIELDS = {
          # The Fraction Container for the Next Fractions Tree,  defined as FCells items in a map-container by current Fraction bytes
          F => {:type => ::Thrift::Types::MAP, :name => 'f', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FCells}},
          # The current Fraction's Cells, defined as FCellPlain items in a list-container
          PLAIN_CELLS => {:type => ::Thrift::Types::LIST, :name => 'plain_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FCellPlain}},
          # The current Fraction's Cells, defined as FCellCounter items in a list-container
          COUNTER_CELLS => {:type => ::Thrift::Types::LIST, :name => 'counter_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FCellCounter}},
          # The current Fraction's Serial Cells, defined as FCellSerial items in a list-container
          SERIAL_CELLS => {:type => ::Thrift::Types::LIST, :name => 'serial_cells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::FCellSerial}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # A Grouped Cells result for results of scan, determined by the request's CellsResult enum
      class CellsGroup
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CELLS = 1
        CCELLS = 2
        KCELLS = 3
        FCELLS = 4

        FIELDS = {
          # The Cells in a list, defined as Cell items in a list-container
          CELLS => {:type => ::Thrift::Types::STRUCT, :name => 'cells', :class => ::Swcdb::Thrift::Gen::Cells},
          # The Columns Cells in a map-container, defined as cCells items by Column Name
          CCELLS => {:type => ::Thrift::Types::MAP, :name => 'ccells', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CCells}},
          # The Keys Cells in a list, defined as kCells items in a list-container
          KCELLS => {:type => ::Thrift::Types::LIST, :name => 'kcells', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::KCells}},
          # The Fraction Cells in struct FCells
          FCELLS => {:type => ::Thrift::Types::STRUCT, :name => 'fcells', :class => ::Swcdb::Thrift::Gen::FCells}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Compact Result
      class CompactResult
        include ::Thrift::Struct, ::Thrift::Struct_Union
        CID = 1
        ERR = 2

        FIELDS = {
          # Column ID
          CID => {:type => ::Thrift::Types::I64, :name => 'cid'},
          # Error
          ERR => {:type => ::Thrift::Types::I32, :name => 'err'}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

      # The Result of 'exec_sql'
      class Result
        include ::Thrift::Struct, ::Thrift::Struct_Union
        SCHEMAS = 1
        CELLS = 2
        COMPACT = 3

        FIELDS = {
          # Set with result for 'list columns' query
          SCHEMAS => {:type => ::Thrift::Types::LIST, :name => 'schemas', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::Schema}},
          # Set with result for 'select' query
          CELLS => {:type => ::Thrift::Types::STRUCT, :name => 'cells', :class => ::Swcdb::Thrift::Gen::Cells},
          # Set with result for 'compact columns' query
          COMPACT => {:type => ::Thrift::Types::LIST, :name => 'compact', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Swcdb::Thrift::Gen::CompactResult}}
        }

        def struct_fields; FIELDS; end

        def validate
        end

        ::Thrift::Struct.generate_accessors self
      end

    end
  end
end
