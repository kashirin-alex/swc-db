/**
 * Autogenerated by Thrift Compiler (0.18.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <math.h>

#include "swcdb_thrift_service_types.h"
#include <thrift/c_glib/thrift.h>

/* return the name of the constant */
const char *
toString_KeySeq(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_KEY_SEQ_UNKNOWN:return "SWCDB_THRIFT_KEY_SEQ_UNKNOWN";
  case SWCDB_THRIFT_KEY_SEQ_LEXIC:return "SWCDB_THRIFT_KEY_SEQ_LEXIC";
  case SWCDB_THRIFT_KEY_SEQ_VOLUME:return "SWCDB_THRIFT_KEY_SEQ_VOLUME";
  case SWCDB_THRIFT_KEY_SEQ_FC_LEXIC:return "SWCDB_THRIFT_KEY_SEQ_FC_LEXIC";
  case SWCDB_THRIFT_KEY_SEQ_FC_VOLUME:return "SWCDB_THRIFT_KEY_SEQ_FC_VOLUME";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_ColumnType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_COLUMN_TYPE_UNKNOWN:return "SWCDB_THRIFT_COLUMN_TYPE_UNKNOWN";
  case SWCDB_THRIFT_COLUMN_TYPE_PLAIN:return "SWCDB_THRIFT_COLUMN_TYPE_PLAIN";
  case SWCDB_THRIFT_COLUMN_TYPE_COUNTER_I64:return "SWCDB_THRIFT_COLUMN_TYPE_COUNTER_I64";
  case SWCDB_THRIFT_COLUMN_TYPE_COUNTER_I32:return "SWCDB_THRIFT_COLUMN_TYPE_COUNTER_I32";
  case SWCDB_THRIFT_COLUMN_TYPE_COUNTER_I16:return "SWCDB_THRIFT_COLUMN_TYPE_COUNTER_I16";
  case SWCDB_THRIFT_COLUMN_TYPE_COUNTER_I8:return "SWCDB_THRIFT_COLUMN_TYPE_COUNTER_I8";
  case SWCDB_THRIFT_COLUMN_TYPE_SERIAL:return "SWCDB_THRIFT_COLUMN_TYPE_SERIAL";
  case SWCDB_THRIFT_COLUMN_TYPE_CELL_DEFINED:return "SWCDB_THRIFT_COLUMN_TYPE_CELL_DEFINED";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_EncodingType(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_ENCODING_TYPE_DEFAULT:return "SWCDB_THRIFT_ENCODING_TYPE_DEFAULT";
  case SWCDB_THRIFT_ENCODING_TYPE_PLAIN:return "SWCDB_THRIFT_ENCODING_TYPE_PLAIN";
  case SWCDB_THRIFT_ENCODING_TYPE_ZLIB:return "SWCDB_THRIFT_ENCODING_TYPE_ZLIB";
  case SWCDB_THRIFT_ENCODING_TYPE_SNAPPY:return "SWCDB_THRIFT_ENCODING_TYPE_SNAPPY";
  case SWCDB_THRIFT_ENCODING_TYPE_ZSTD:return "SWCDB_THRIFT_ENCODING_TYPE_ZSTD";
  case SWCDB_THRIFT_ENCODING_TYPE_UNKNOWN:return "SWCDB_THRIFT_ENCODING_TYPE_UNKNOWN";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_SchemaFunc(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_SCHEMA_FUNC_CREATE:return "SWCDB_THRIFT_SCHEMA_FUNC_CREATE";
  case SWCDB_THRIFT_SCHEMA_FUNC_REMOVE:return "SWCDB_THRIFT_SCHEMA_FUNC_REMOVE";
  case SWCDB_THRIFT_SCHEMA_FUNC_MODIFY:return "SWCDB_THRIFT_SCHEMA_FUNC_MODIFY";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Comp(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_COMP_NONE:return "SWCDB_THRIFT_COMP_NONE";
  case SWCDB_THRIFT_COMP_PF:return "SWCDB_THRIFT_COMP_PF";
  case SWCDB_THRIFT_COMP_GT:return "SWCDB_THRIFT_COMP_GT";
  case SWCDB_THRIFT_COMP_GE:return "SWCDB_THRIFT_COMP_GE";
  case SWCDB_THRIFT_COMP_EQ:return "SWCDB_THRIFT_COMP_EQ";
  case SWCDB_THRIFT_COMP_LE:return "SWCDB_THRIFT_COMP_LE";
  case SWCDB_THRIFT_COMP_LT:return "SWCDB_THRIFT_COMP_LT";
  case SWCDB_THRIFT_COMP_NE:return "SWCDB_THRIFT_COMP_NE";
  case SWCDB_THRIFT_COMP_RE:return "SWCDB_THRIFT_COMP_RE";
  case SWCDB_THRIFT_COMP_VGT:return "SWCDB_THRIFT_COMP_VGT";
  case SWCDB_THRIFT_COMP_VGE:return "SWCDB_THRIFT_COMP_VGE";
  case SWCDB_THRIFT_COMP_VLE:return "SWCDB_THRIFT_COMP_VLE";
  case SWCDB_THRIFT_COMP_VLT:return "SWCDB_THRIFT_COMP_VLT";
  case SWCDB_THRIFT_COMP_SBS:return "SWCDB_THRIFT_COMP_SBS";
  case SWCDB_THRIFT_COMP_SPS:return "SWCDB_THRIFT_COMP_SPS";
  case SWCDB_THRIFT_COMP_POSBS:return "SWCDB_THRIFT_COMP_POSBS";
  case SWCDB_THRIFT_COMP_POSPS:return "SWCDB_THRIFT_COMP_POSPS";
  case SWCDB_THRIFT_COMP_FOSBS:return "SWCDB_THRIFT_COMP_FOSBS";
  case SWCDB_THRIFT_COMP_FOSPS:return "SWCDB_THRIFT_COMP_FOSPS";
  case SWCDB_THRIFT_COMP_FIP:return "SWCDB_THRIFT_COMP_FIP";
  case SWCDB_THRIFT_COMP_FI:return "SWCDB_THRIFT_COMP_FI";
  case SWCDB_THRIFT_COMP_OR:return "SWCDB_THRIFT_COMP_OR";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_SpecFlagsOpt(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_SPEC_FLAGS_OPT_NONE:return "SWCDB_THRIFT_SPEC_FLAGS_OPT_NONE";
  case SWCDB_THRIFT_SPEC_FLAGS_OPT_LIMIT_BY_KEYS:return "SWCDB_THRIFT_SPEC_FLAGS_OPT_LIMIT_BY_KEYS";
  case SWCDB_THRIFT_SPEC_FLAGS_OPT_OFFSET_BY_KEYS:return "SWCDB_THRIFT_SPEC_FLAGS_OPT_OFFSET_BY_KEYS";
  case SWCDB_THRIFT_SPEC_FLAGS_OPT_ONLY_KEYS:return "SWCDB_THRIFT_SPEC_FLAGS_OPT_ONLY_KEYS";
  case SWCDB_THRIFT_SPEC_FLAGS_OPT_ONLY_DELETES:return "SWCDB_THRIFT_SPEC_FLAGS_OPT_ONLY_DELETES";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_UpdateOP(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_UPDATE_O_P_REPLACE:return "SWCDB_THRIFT_UPDATE_O_P_REPLACE";
  case SWCDB_THRIFT_UPDATE_O_P_APPEND:return "SWCDB_THRIFT_UPDATE_O_P_APPEND";
  case SWCDB_THRIFT_UPDATE_O_P_PREPEND:return "SWCDB_THRIFT_UPDATE_O_P_PREPEND";
  case SWCDB_THRIFT_UPDATE_O_P_INSERT:return "SWCDB_THRIFT_UPDATE_O_P_INSERT";
  case SWCDB_THRIFT_UPDATE_O_P_OVERWRITE:return "SWCDB_THRIFT_UPDATE_O_P_OVERWRITE";
  case SWCDB_THRIFT_UPDATE_O_P_SERIAL:return "SWCDB_THRIFT_UPDATE_O_P_SERIAL";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_SpecIntervalOptions(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_SPEC_INTERVAL_OPTIONS_UPDATING:return "SWCDB_THRIFT_SPEC_INTERVAL_OPTIONS_UPDATING";
  case SWCDB_THRIFT_SPEC_INTERVAL_OPTIONS_DELETING:return "SWCDB_THRIFT_SPEC_INTERVAL_OPTIONS_DELETING";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_Flag(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_FLAG_NONE:return "SWCDB_THRIFT_FLAG_NONE";
  case SWCDB_THRIFT_FLAG_INSERT:return "SWCDB_THRIFT_FLAG_INSERT";
  case SWCDB_THRIFT_FLAG_DELETE_LE:return "SWCDB_THRIFT_FLAG_DELETE_LE";
  case SWCDB_THRIFT_FLAG_DELETE_EQ:return "SWCDB_THRIFT_FLAG_DELETE_EQ";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_FU_MATH_OP(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_F_U__M_A_T_H__O_P_EQUAL:return "SWCDB_THRIFT_F_U__M_A_T_H__O_P_EQUAL";
  case SWCDB_THRIFT_F_U__M_A_T_H__O_P_PLUS:return "SWCDB_THRIFT_F_U__M_A_T_H__O_P_PLUS";
  case SWCDB_THRIFT_F_U__M_A_T_H__O_P_MULTIPLY:return "SWCDB_THRIFT_F_U__M_A_T_H__O_P_MULTIPLY";
  case SWCDB_THRIFT_F_U__M_A_T_H__O_P_DIVIDE:return "SWCDB_THRIFT_F_U__M_A_T_H__O_P_DIVIDE";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_FU_LIST_OP(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_REPLACE:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_REPLACE";
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_APPEND:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_APPEND";
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_PREPEND:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_PREPEND";
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_INSERT:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_INSERT";
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_OVERWRITE:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_OVERWRITE";
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_ERASE:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_ERASE";
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_BY_UNIQUE:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_BY_UNIQUE";
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_BY_COND:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_BY_COND";
  case SWCDB_THRIFT_F_U__L_I_S_T__O_P_BY_INDEX:return "SWCDB_THRIFT_F_U__L_I_S_T__O_P_BY_INDEX";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

/* return the name of the constant */
const char *
toString_CellsResult(int value) 
{
  static __thread char buf[16] = {0};
  switch(value) {
  case SWCDB_THRIFT_CELLS_RESULT_IN_LIST:return "SWCDB_THRIFT_CELLS_RESULT_IN_LIST";
  case SWCDB_THRIFT_CELLS_RESULT_ON_COLUMN:return "SWCDB_THRIFT_CELLS_RESULT_ON_COLUMN";
  case SWCDB_THRIFT_CELLS_RESULT_ON_KEY:return "SWCDB_THRIFT_CELLS_RESULT_ON_KEY";
  case SWCDB_THRIFT_CELLS_RESULT_ON_FRACTION:return "SWCDB_THRIFT_CELLS_RESULT_ON_FRACTION";
  default: g_snprintf(buf, 16, "%d", value); return buf;
  }
}

enum _swcdb_thriftExceptionProperties
{
  PROP_SWCDB_THRIFT_EXCEPTION_0,
  PROP_SWCDB_THRIFT_EXCEPTION_CODE,
  PROP_SWCDB_THRIFT_EXCEPTION_MESSAGE
};

/* reads a exception object */
static gint32
swcdb_thrift_exception_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftException * this_object = SWCDB_THRIFT_EXCEPTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->code, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_code = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->message != NULL)
          {
            g_free(this_object->message);
            this_object->message = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->message, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_message = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_exception_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftException * this_object = SWCDB_THRIFT_EXCEPTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Exception", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "code", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->code, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "message", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->message, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_exception_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  swcdb_thriftException *self = SWCDB_THRIFT_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_EXCEPTION_CODE:
      self->code = g_value_get_int (value);
      self->__isset_code = TRUE;
      break;

    case PROP_SWCDB_THRIFT_EXCEPTION_MESSAGE:
      if (self->message != NULL)
        g_free (self->message);
      self->message = g_value_dup_string (value);
      self->__isset_message = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_exception_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  swcdb_thriftException *self = SWCDB_THRIFT_EXCEPTION (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_EXCEPTION_CODE:
      g_value_set_int (value, self->code);
      break;

    case PROP_SWCDB_THRIFT_EXCEPTION_MESSAGE:
      g_value_set_string (value, self->message);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_exception_instance_init (swcdb_thriftException * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->code = 0;
  object->__isset_code = FALSE;
  object->message = NULL;
  object->__isset_message = FALSE;
}

static void 
swcdb_thrift_exception_finalize (GObject *object)
{
  swcdb_thriftException *tobject = SWCDB_THRIFT_EXCEPTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->message != NULL)
  {
    g_free(tobject->message);
    tobject->message = NULL;
  }
}

static void
swcdb_thrift_exception_class_init (swcdb_thriftExceptionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_exception_read;
  struct_class->write = swcdb_thrift_exception_write;

  gobject_class->finalize = swcdb_thrift_exception_finalize;
  gobject_class->get_property = swcdb_thrift_exception_get_property;
  gobject_class->set_property = swcdb_thrift_exception_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_EXCEPTION_CODE,
     g_param_spec_int ("code",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_EXCEPTION_MESSAGE,
     g_param_spec_string ("message",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_exception_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftExceptionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_exception_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftException),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_exception_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftExceptionType",
                                   &type_info, 0);
  }

  return type;
}

/* define the GError domain for exceptions */
#define SWCDB_THRIFT_EXCEPTION_ERROR_DOMAIN "swcdb_thrift_exception_error_quark"
GQuark
swcdb_thrift_exception_error_quark (void)
{
  return g_quark_from_static_string (SWCDB_THRIFT_EXCEPTION_ERROR_DOMAIN);
}

enum _swcdb_thriftSchemaProperties
{
  PROP_SWCDB_THRIFT_SCHEMA_0,
  PROP_SWCDB_THRIFT_SCHEMA_CID,
  PROP_SWCDB_THRIFT_SCHEMA_COL_NAME,
  PROP_SWCDB_THRIFT_SCHEMA_COL_TAGS,
  PROP_SWCDB_THRIFT_SCHEMA_COL_SEQ,
  PROP_SWCDB_THRIFT_SCHEMA_COL_TYPE,
  PROP_SWCDB_THRIFT_SCHEMA_CELL_VERSIONS,
  PROP_SWCDB_THRIFT_SCHEMA_CELL_TTL,
  PROP_SWCDB_THRIFT_SCHEMA_BLK_ENCODING,
  PROP_SWCDB_THRIFT_SCHEMA_BLK_SIZE,
  PROP_SWCDB_THRIFT_SCHEMA_BLK_CELLS,
  PROP_SWCDB_THRIFT_SCHEMA_CS_REPLICATION,
  PROP_SWCDB_THRIFT_SCHEMA_CS_SIZE,
  PROP_SWCDB_THRIFT_SCHEMA_CS_MAX,
  PROP_SWCDB_THRIFT_SCHEMA_LOG_ROLLOUT_RATIO,
  PROP_SWCDB_THRIFT_SCHEMA_LOG_COMPACT_COINTERVALING,
  PROP_SWCDB_THRIFT_SCHEMA_LOG_FRAGMENT_PRELOAD,
  PROP_SWCDB_THRIFT_SCHEMA_COMPACT_PERCENT,
  PROP_SWCDB_THRIFT_SCHEMA_REVISION
};

/* reads a schema object */
static gint32
swcdb_thrift_schema_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSchema * this_object = SWCDB_THRIFT_SCHEMA(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->cid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->col_name != NULL)
          {
            g_free(this_object->col_name);
            this_object->col_name = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->col_name, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_col_name = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem0 = NULL;
              if (_elem0 != NULL)
              {
                g_free(_elem0);
                _elem0 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem0, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->col_tags, _elem0);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_col_tags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast1;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast1, error)) < 0)
            return -1;
          xfer += ret;
          this_object->col_seq = (swcdb_thriftKeySeq)ecast1;
          this_object->__isset_col_seq = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I32)
        {
          gint32 ecast2;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast2, error)) < 0)
            return -1;
          xfer += ret;
          this_object->col_type = (swcdb_thriftColumnType)ecast2;
          this_object->__isset_col_type = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cell_versions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cell_versions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cell_ttl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cell_ttl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_I32)
        {
          gint32 ecast3;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast3, error)) < 0)
            return -1;
          xfer += ret;
          this_object->blk_encoding = (swcdb_thriftEncodingType)ecast3;
          this_object->__isset_blk_encoding = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->blk_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blk_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->blk_cells, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_blk_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->cs_replication, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cs_replication = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 12:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->cs_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cs_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 13:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->cs_max, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cs_max = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 14:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->log_rollout_ratio, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_log_rollout_ratio = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 15:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->log_compact_cointervaling, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_log_compact_cointervaling = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 16:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->log_fragment_preload, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_log_fragment_preload = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 17:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->compact_percent, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_compact_percent = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 18:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->revision, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_revision = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_schema_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSchema * this_object = SWCDB_THRIFT_SCHEMA(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Schema", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_cid == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cid", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->cid, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_col_name == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "col_name", T_STRING, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_string (protocol, this_object->col_name, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "col_tags", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i4;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->col_tags ? this_object->col_tags->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i4 = 0; i4 < (this_object->col_tags ? this_object->col_tags->len : 0); i4++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->col_tags, i4)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_col_seq == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "col_seq", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->col_seq, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_col_type == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "col_type", T_I32, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->col_type, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cell_versions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cell_versions", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->cell_versions, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cell_ttl == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cell_ttl", T_I32, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->cell_ttl, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_blk_encoding == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "blk_encoding", T_I32, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->blk_encoding, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_blk_size == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "blk_size", T_I32, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->blk_size, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_blk_cells == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "blk_cells", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->blk_cells, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cs_replication == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cs_replication", T_BYTE, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->cs_replication, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cs_size == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cs_size", T_I32, 12, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->cs_size, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_cs_max == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "cs_max", T_BYTE, 13, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->cs_max, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_log_rollout_ratio == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "log_rollout_ratio", T_BYTE, 14, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->log_rollout_ratio, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_log_compact_cointervaling == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "log_compact_cointervaling", T_BYTE, 15, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->log_compact_cointervaling, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_log_fragment_preload == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "log_fragment_preload", T_BYTE, 16, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->log_fragment_preload, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_compact_percent == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "compact_percent", T_BYTE, 17, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->compact_percent, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_revision == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "revision", T_I64, 18, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->revision, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_schema_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  swcdb_thriftSchema *self = SWCDB_THRIFT_SCHEMA (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SCHEMA_CID:
      self->cid = g_value_get_int64 (value);
      self->__isset_cid = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COL_NAME:
      if (self->col_name != NULL)
        g_free (self->col_name);
      self->col_name = g_value_dup_string (value);
      self->__isset_col_name = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COL_TAGS:
      if (self->col_tags != NULL)
        g_ptr_array_unref (self->col_tags);
      self->col_tags = g_value_dup_boxed (value);
      self->__isset_col_tags = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COL_SEQ:
      self->col_seq = g_value_get_int (value);
      self->__isset_col_seq = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COL_TYPE:
      self->col_type = g_value_get_int (value);
      self->__isset_col_type = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CELL_VERSIONS:
      self->cell_versions = g_value_get_int (value);
      self->__isset_cell_versions = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CELL_TTL:
      self->cell_ttl = g_value_get_int (value);
      self->__isset_cell_ttl = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_BLK_ENCODING:
      self->blk_encoding = g_value_get_int (value);
      self->__isset_blk_encoding = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_BLK_SIZE:
      self->blk_size = g_value_get_int (value);
      self->__isset_blk_size = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_BLK_CELLS:
      self->blk_cells = g_value_get_int (value);
      self->__isset_blk_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CS_REPLICATION:
      self->cs_replication = g_value_get_int (value);
      self->__isset_cs_replication = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CS_SIZE:
      self->cs_size = g_value_get_int (value);
      self->__isset_cs_size = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CS_MAX:
      self->cs_max = g_value_get_int (value);
      self->__isset_cs_max = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_LOG_ROLLOUT_RATIO:
      self->log_rollout_ratio = g_value_get_int (value);
      self->__isset_log_rollout_ratio = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_LOG_COMPACT_COINTERVALING:
      self->log_compact_cointervaling = g_value_get_int (value);
      self->__isset_log_compact_cointervaling = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_LOG_FRAGMENT_PRELOAD:
      self->log_fragment_preload = g_value_get_int (value);
      self->__isset_log_fragment_preload = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COMPACT_PERCENT:
      self->compact_percent = g_value_get_int (value);
      self->__isset_compact_percent = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_REVISION:
      self->revision = g_value_get_int64 (value);
      self->__isset_revision = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_schema_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  swcdb_thriftSchema *self = SWCDB_THRIFT_SCHEMA (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SCHEMA_CID:
      g_value_set_int64 (value, self->cid);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COL_NAME:
      g_value_set_string (value, self->col_name);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COL_TAGS:
      g_value_set_boxed (value, self->col_tags);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COL_SEQ:
      g_value_set_int (value, self->col_seq);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COL_TYPE:
      g_value_set_int (value, self->col_type);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CELL_VERSIONS:
      g_value_set_int (value, self->cell_versions);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CELL_TTL:
      g_value_set_int (value, self->cell_ttl);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_BLK_ENCODING:
      g_value_set_int (value, self->blk_encoding);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_BLK_SIZE:
      g_value_set_int (value, self->blk_size);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_BLK_CELLS:
      g_value_set_int (value, self->blk_cells);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CS_REPLICATION:
      g_value_set_int (value, self->cs_replication);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CS_SIZE:
      g_value_set_int (value, self->cs_size);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_CS_MAX:
      g_value_set_int (value, self->cs_max);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_LOG_ROLLOUT_RATIO:
      g_value_set_int (value, self->log_rollout_ratio);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_LOG_COMPACT_COINTERVALING:
      g_value_set_int (value, self->log_compact_cointervaling);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_LOG_FRAGMENT_PRELOAD:
      g_value_set_int (value, self->log_fragment_preload);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_COMPACT_PERCENT:
      g_value_set_int (value, self->compact_percent);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_REVISION:
      g_value_set_int64 (value, self->revision);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_schema_instance_init (swcdb_thriftSchema * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cid = 0;
  object->__isset_cid = FALSE;
  object->col_name = NULL;
  object->__isset_col_name = FALSE;
  object->col_tags = g_ptr_array_new_with_free_func (g_free);
  object->__isset_col_tags = FALSE;
  object->__isset_col_seq = FALSE;
  object->__isset_col_type = FALSE;
  object->cell_versions = 0;
  object->__isset_cell_versions = FALSE;
  object->cell_ttl = 0;
  object->__isset_cell_ttl = FALSE;
  object->__isset_blk_encoding = FALSE;
  object->blk_size = 0;
  object->__isset_blk_size = FALSE;
  object->blk_cells = 0;
  object->__isset_blk_cells = FALSE;
  object->cs_replication = 0;
  object->__isset_cs_replication = FALSE;
  object->cs_size = 0;
  object->__isset_cs_size = FALSE;
  object->cs_max = 0;
  object->__isset_cs_max = FALSE;
  object->log_rollout_ratio = 0;
  object->__isset_log_rollout_ratio = FALSE;
  object->log_compact_cointervaling = 0;
  object->__isset_log_compact_cointervaling = FALSE;
  object->log_fragment_preload = 0;
  object->__isset_log_fragment_preload = FALSE;
  object->compact_percent = 0;
  object->__isset_compact_percent = FALSE;
  object->revision = 0;
  object->__isset_revision = FALSE;
}

static void 
swcdb_thrift_schema_finalize (GObject *object)
{
  swcdb_thriftSchema *tobject = SWCDB_THRIFT_SCHEMA (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->col_name != NULL)
  {
    g_free(tobject->col_name);
    tobject->col_name = NULL;
  }
  if (tobject->col_tags != NULL)
  {
    g_ptr_array_unref (tobject->col_tags);
    tobject->col_tags = NULL;
  }
}

static void
swcdb_thrift_schema_class_init (swcdb_thriftSchemaClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_schema_read;
  struct_class->write = swcdb_thrift_schema_write;

  gobject_class->finalize = swcdb_thrift_schema_finalize;
  gobject_class->get_property = swcdb_thrift_schema_get_property;
  gobject_class->set_property = swcdb_thrift_schema_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_CID,
     g_param_spec_int64 ("cid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_COL_NAME,
     g_param_spec_string ("col_name",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_COL_TAGS,
     g_param_spec_boxed ("col_tags",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_COL_SEQ,
     g_param_spec_int ("col_seq",
                       NULL,
                       NULL,
                       0,
                       4,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_COL_TYPE,
     g_param_spec_int ("col_type",
                       NULL,
                       NULL,
                       0,
                       15,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_CELL_VERSIONS,
     g_param_spec_int ("cell_versions",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_CELL_TTL,
     g_param_spec_int ("cell_ttl",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_BLK_ENCODING,
     g_param_spec_int ("blk_encoding",
                       NULL,
                       NULL,
                       0,
                       255,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_BLK_SIZE,
     g_param_spec_int ("blk_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_BLK_CELLS,
     g_param_spec_int ("blk_cells",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_CS_REPLICATION,
     g_param_spec_int ("cs_replication",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_CS_SIZE,
     g_param_spec_int ("cs_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_CS_MAX,
     g_param_spec_int ("cs_max",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_LOG_ROLLOUT_RATIO,
     g_param_spec_int ("log_rollout_ratio",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_LOG_COMPACT_COINTERVALING,
     g_param_spec_int ("log_compact_cointervaling",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_LOG_FRAGMENT_PRELOAD,
     g_param_spec_int ("log_fragment_preload",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_COMPACT_PERCENT,
     g_param_spec_int ("compact_percent",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_REVISION,
     g_param_spec_int64 ("revision",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_schema_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSchemaClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_schema_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSchema),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_schema_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSchemaType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSchemaPatternProperties
{
  PROP_SWCDB_THRIFT_SCHEMA_PATTERN_0,
  PROP_SWCDB_THRIFT_SCHEMA_PATTERN_COMP,
  PROP_SWCDB_THRIFT_SCHEMA_PATTERN_VALUE
};

/* reads a schema_pattern object */
static gint32
swcdb_thrift_schema_pattern_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSchemaPattern * this_object = SWCDB_THRIFT_SCHEMA_PATTERN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast5;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast5, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast5;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->value != NULL)
          {
            g_free(this_object->value);
            this_object->value = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->value, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_value = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_schema_pattern_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSchemaPattern * this_object = SWCDB_THRIFT_SCHEMA_PATTERN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaPattern", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "value", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->value, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_schema_pattern_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftSchemaPattern *self = SWCDB_THRIFT_SCHEMA_PATTERN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SCHEMA_PATTERN_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_PATTERN_VALUE:
      if (self->value != NULL)
        g_free (self->value);
      self->value = g_value_dup_string (value);
      self->__isset_value = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_schema_pattern_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftSchemaPattern *self = SWCDB_THRIFT_SCHEMA_PATTERN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SCHEMA_PATTERN_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_PATTERN_VALUE:
      g_value_set_string (value, self->value);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_schema_pattern_instance_init (swcdb_thriftSchemaPattern * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->value = NULL;
  object->__isset_value = FALSE;
}

static void 
swcdb_thrift_schema_pattern_finalize (GObject *object)
{
  swcdb_thriftSchemaPattern *tobject = SWCDB_THRIFT_SCHEMA_PATTERN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->value != NULL)
  {
    g_free(tobject->value);
    tobject->value = NULL;
  }
}

static void
swcdb_thrift_schema_pattern_class_init (swcdb_thriftSchemaPatternClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_schema_pattern_read;
  struct_class->write = swcdb_thrift_schema_pattern_write;

  gobject_class->finalize = swcdb_thrift_schema_pattern_finalize;
  gobject_class->get_property = swcdb_thrift_schema_pattern_get_property;
  gobject_class->set_property = swcdb_thrift_schema_pattern_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_PATTERN_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_PATTERN_VALUE,
     g_param_spec_string ("value",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_schema_pattern_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSchemaPatternClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_schema_pattern_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSchemaPattern),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_schema_pattern_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSchemaPatternType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSchemaTagsPatternsProperties
{
  PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_0,
  PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_COMP,
  PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_VALUES
};

/* reads a schema_tags_patterns object */
static gint32
swcdb_thrift_schema_tags_patterns_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSchemaTagsPatterns * this_object = SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast6;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast6, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast6;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSchemaPattern * _elem7 = NULL;
              if ( _elem7 != NULL)
              {
                g_object_unref (_elem7);
              }
              _elem7 = g_object_new (SWCDB_THRIFT_TYPE_SCHEMA_PATTERN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem7), protocol, error)) < 0)
              {
                g_object_unref (_elem7);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->values, _elem7);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_schema_tags_patterns_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSchemaTagsPatterns * this_object = SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaTagsPatterns", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "values", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i8;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->values ? this_object->values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i8 = 0; i8 < (this_object->values ? this_object->values->len : 0); i8++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->values, i8))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_schema_tags_patterns_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  swcdb_thriftSchemaTagsPatterns *self = SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_VALUES:
      if (self->values != NULL)
        g_ptr_array_unref (self->values);
      self->values = g_value_dup_boxed (value);
      self->__isset_values = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_schema_tags_patterns_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  swcdb_thriftSchemaTagsPatterns *self = SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_VALUES:
      g_value_set_boxed (value, self->values);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_schema_tags_patterns_instance_init (swcdb_thriftSchemaTagsPatterns * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->values = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_values = FALSE;
}

static void 
swcdb_thrift_schema_tags_patterns_finalize (GObject *object)
{
  swcdb_thriftSchemaTagsPatterns *tobject = SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->values != NULL)
  {
    g_ptr_array_unref (tobject->values);
    tobject->values = NULL;
  }
}

static void
swcdb_thrift_schema_tags_patterns_class_init (swcdb_thriftSchemaTagsPatternsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_schema_tags_patterns_read;
  struct_class->write = swcdb_thrift_schema_tags_patterns_write;

  gobject_class->finalize = swcdb_thrift_schema_tags_patterns_finalize;
  gobject_class->get_property = swcdb_thrift_schema_tags_patterns_get_property;
  gobject_class->set_property = swcdb_thrift_schema_tags_patterns_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_TAGS_PATTERNS_VALUES,
     g_param_spec_boxed ("values",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_schema_tags_patterns_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSchemaTagsPatternsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_schema_tags_patterns_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSchemaTagsPatterns),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_schema_tags_patterns_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSchemaTagsPatternsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSchemaPatternsProperties
{
  PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_0,
  PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_NAMES,
  PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_TAGS
};

/* reads a schema_patterns object */
static gint32
swcdb_thrift_schema_patterns_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSchemaPatterns * this_object = SWCDB_THRIFT_SCHEMA_PATTERNS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSchemaPattern * _elem9 = NULL;
              if ( _elem9 != NULL)
              {
                g_object_unref (_elem9);
              }
              _elem9 = g_object_new (SWCDB_THRIFT_TYPE_SCHEMA_PATTERN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem9), protocol, error)) < 0)
              {
                g_object_unref (_elem9);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->names, _elem9);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_names = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->tags), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_tags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_schema_patterns_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSchemaPatterns * this_object = SWCDB_THRIFT_SCHEMA_PATTERNS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SchemaPatterns", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "names", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i10;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->names ? this_object->names->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i10 = 0; i10 < (this_object->names ? this_object->names->len : 0); i10++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->names, i10))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "tags", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->tags), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_schema_patterns_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  swcdb_thriftSchemaPatterns *self = SWCDB_THRIFT_SCHEMA_PATTERNS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_NAMES:
      if (self->names != NULL)
        g_ptr_array_unref (self->names);
      self->names = g_value_dup_boxed (value);
      self->__isset_names = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_TAGS:
      if (self->tags != NULL)
        g_object_unref (self->tags);
      self->tags = g_value_dup_object (value);
      self->__isset_tags = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_schema_patterns_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  swcdb_thriftSchemaPatterns *self = SWCDB_THRIFT_SCHEMA_PATTERNS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_NAMES:
      g_value_set_boxed (value, self->names);
      break;

    case PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_TAGS:
      g_value_set_object (value, self->tags);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_schema_patterns_instance_init (swcdb_thriftSchemaPatterns * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->names = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_names = FALSE;
  object->tags = g_object_new (SWCDB_THRIFT_TYPE_SCHEMA_TAGS_PATTERNS, NULL);
  object->__isset_tags = FALSE;
}

static void 
swcdb_thrift_schema_patterns_finalize (GObject *object)
{
  swcdb_thriftSchemaPatterns *tobject = SWCDB_THRIFT_SCHEMA_PATTERNS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->names != NULL)
  {
    g_ptr_array_unref (tobject->names);
    tobject->names = NULL;
  }
  if (tobject->tags != NULL)
  {
    g_object_unref(tobject->tags);
    tobject->tags = NULL;
  }
}

static void
swcdb_thrift_schema_patterns_class_init (swcdb_thriftSchemaPatternsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_schema_patterns_read;
  struct_class->write = swcdb_thrift_schema_patterns_write;

  gobject_class->finalize = swcdb_thrift_schema_patterns_finalize;
  gobject_class->get_property = swcdb_thrift_schema_patterns_get_property;
  gobject_class->set_property = swcdb_thrift_schema_patterns_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_NAMES,
     g_param_spec_boxed ("names",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SCHEMA_PATTERNS_TAGS,
     g_param_spec_object ("tags",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SCHEMA_TAGS_PATTERNS,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_schema_patterns_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSchemaPatternsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_schema_patterns_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSchemaPatterns),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_schema_patterns_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSchemaPatternsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecSchemasProperties
{
  PROP_SWCDB_THRIFT_SPEC_SCHEMAS_0,
  PROP_SWCDB_THRIFT_SPEC_SCHEMAS_CIDS,
  PROP_SWCDB_THRIFT_SPEC_SCHEMAS_NAMES,
  PROP_SWCDB_THRIFT_SPEC_SCHEMAS_PATTERNS
};

/* reads a spec_schemas object */
static gint32
swcdb_thrift_spec_schemas_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecSchemas * this_object = SWCDB_THRIFT_SPEC_SCHEMAS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem11 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem11, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->cids, _elem11, 1);
              g_free (_elem11);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cids = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gchar * _elem12 = NULL;
              if (_elem12 != NULL)
              {
                g_free(_elem12);
                _elem12 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &_elem12, error)) < 0)
                return -1;
              xfer += ret;
              g_ptr_array_add (this_object->names, _elem12);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_names = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->patterns), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_patterns = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_schemas_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecSchemas * this_object = SWCDB_THRIFT_SPEC_SCHEMAS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecSchemas", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cids", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i13;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->cids ? this_object->cids->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i13 = 0; i13 < (this_object->cids ? this_object->cids->len : 0); i13++)
    {
      if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->cids, gint64, i13)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "names", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i14;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->names ? this_object->names->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i14 = 0; i14 < (this_object->names ? this_object->names->len : 0); i14++)
    {
      if ((ret = thrift_protocol_write_string (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->names, i14)), error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "patterns", T_STRUCT, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->patterns), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_schemas_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftSpecSchemas *self = SWCDB_THRIFT_SPEC_SCHEMAS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_SCHEMAS_CIDS:
      if (self->cids != NULL)
        g_array_unref (self->cids);
      self->cids = g_value_dup_boxed (value);
      self->__isset_cids = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCHEMAS_NAMES:
      if (self->names != NULL)
        g_ptr_array_unref (self->names);
      self->names = g_value_dup_boxed (value);
      self->__isset_names = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCHEMAS_PATTERNS:
      if (self->patterns != NULL)
        g_object_unref (self->patterns);
      self->patterns = g_value_dup_object (value);
      self->__isset_patterns = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_schemas_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftSpecSchemas *self = SWCDB_THRIFT_SPEC_SCHEMAS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_SCHEMAS_CIDS:
      g_value_set_boxed (value, self->cids);
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCHEMAS_NAMES:
      g_value_set_boxed (value, self->names);
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCHEMAS_PATTERNS:
      g_value_set_object (value, self->patterns);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_schemas_instance_init (swcdb_thriftSpecSchemas * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cids = g_array_new (0, 1, sizeof (gint64));
  object->__isset_cids = FALSE;
  object->names = g_ptr_array_new_with_free_func (g_free);
  object->__isset_names = FALSE;
  object->patterns = g_object_new (SWCDB_THRIFT_TYPE_SCHEMA_PATTERNS, NULL);
  object->__isset_patterns = FALSE;
}

static void 
swcdb_thrift_spec_schemas_finalize (GObject *object)
{
  swcdb_thriftSpecSchemas *tobject = SWCDB_THRIFT_SPEC_SCHEMAS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cids != NULL)
  {
    g_array_unref (tobject->cids);
    tobject->cids = NULL;
  }
  if (tobject->names != NULL)
  {
    g_ptr_array_unref (tobject->names);
    tobject->names = NULL;
  }
  if (tobject->patterns != NULL)
  {
    g_object_unref(tobject->patterns);
    tobject->patterns = NULL;
  }
}

static void
swcdb_thrift_spec_schemas_class_init (swcdb_thriftSpecSchemasClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_schemas_read;
  struct_class->write = swcdb_thrift_spec_schemas_write;

  gobject_class->finalize = swcdb_thrift_spec_schemas_finalize;
  gobject_class->get_property = swcdb_thrift_spec_schemas_get_property;
  gobject_class->set_property = swcdb_thrift_spec_schemas_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_SCHEMAS_CIDS,
     g_param_spec_boxed ("cids",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_SCHEMAS_NAMES,
     g_param_spec_boxed ("names",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_SCHEMAS_PATTERNS,
     g_param_spec_object ("patterns",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SCHEMA_PATTERNS,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_schemas_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecSchemasClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_schemas_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecSchemas),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_schemas_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecSchemasType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecFlagsProperties
{
  PROP_SWCDB_THRIFT_SPEC_FLAGS_0,
  PROP_SWCDB_THRIFT_SPEC_FLAGS_LIMIT,
  PROP_SWCDB_THRIFT_SPEC_FLAGS_OFFSET,
  PROP_SWCDB_THRIFT_SPEC_FLAGS_MAX_VERSIONS,
  PROP_SWCDB_THRIFT_SPEC_FLAGS_MAX_BUFFER,
  PROP_SWCDB_THRIFT_SPEC_FLAGS_OPTIONS
};

/* reads a spec_flags object */
static gint32
swcdb_thrift_spec_flags_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecFlags * this_object = SWCDB_THRIFT_SPEC_FLAGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->limit, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_limit = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->max_versions, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_max_versions = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->max_buffer, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_max_buffer = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->options, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_options = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_flags_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecFlags * this_object = SWCDB_THRIFT_SPEC_FLAGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecFlags", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_limit == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "limit", T_I64, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->limit, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_offset == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset", T_I64, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_max_versions == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "max_versions", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->max_versions, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_max_buffer == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "max_buffer", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->max_buffer, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_options == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "options", T_BYTE, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_byte (protocol, this_object->options, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_flags_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  swcdb_thriftSpecFlags *self = SWCDB_THRIFT_SPEC_FLAGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_FLAGS_LIMIT:
      self->limit = g_value_get_int64 (value);
      self->__isset_limit = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_FLAGS_OFFSET:
      self->offset = g_value_get_int64 (value);
      self->__isset_offset = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_FLAGS_MAX_VERSIONS:
      self->max_versions = g_value_get_int (value);
      self->__isset_max_versions = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_FLAGS_MAX_BUFFER:
      self->max_buffer = g_value_get_int (value);
      self->__isset_max_buffer = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_FLAGS_OPTIONS:
      self->options = g_value_get_int (value);
      self->__isset_options = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_flags_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  swcdb_thriftSpecFlags *self = SWCDB_THRIFT_SPEC_FLAGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_FLAGS_LIMIT:
      g_value_set_int64 (value, self->limit);
      break;

    case PROP_SWCDB_THRIFT_SPEC_FLAGS_OFFSET:
      g_value_set_int64 (value, self->offset);
      break;

    case PROP_SWCDB_THRIFT_SPEC_FLAGS_MAX_VERSIONS:
      g_value_set_int (value, self->max_versions);
      break;

    case PROP_SWCDB_THRIFT_SPEC_FLAGS_MAX_BUFFER:
      g_value_set_int (value, self->max_buffer);
      break;

    case PROP_SWCDB_THRIFT_SPEC_FLAGS_OPTIONS:
      g_value_set_int (value, self->options);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_flags_instance_init (swcdb_thriftSpecFlags * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->limit = 0;
  object->__isset_limit = FALSE;
  object->offset = 0;
  object->__isset_offset = FALSE;
  object->max_versions = 0;
  object->__isset_max_versions = FALSE;
  object->max_buffer = 0;
  object->__isset_max_buffer = FALSE;
  object->options = 0;
  object->__isset_options = FALSE;
}

static void 
swcdb_thrift_spec_flags_finalize (GObject *object)
{
  swcdb_thriftSpecFlags *tobject = SWCDB_THRIFT_SPEC_FLAGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_spec_flags_class_init (swcdb_thriftSpecFlagsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_flags_read;
  struct_class->write = swcdb_thrift_spec_flags_write;

  gobject_class->finalize = swcdb_thrift_spec_flags_finalize;
  gobject_class->get_property = swcdb_thrift_spec_flags_get_property;
  gobject_class->set_property = swcdb_thrift_spec_flags_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_FLAGS_LIMIT,
     g_param_spec_int64 ("limit",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_FLAGS_OFFSET,
     g_param_spec_int64 ("offset",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_FLAGS_MAX_VERSIONS,
     g_param_spec_int ("max_versions",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_FLAGS_MAX_BUFFER,
     g_param_spec_int ("max_buffer",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_FLAGS_OPTIONS,
     g_param_spec_int ("options",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_flags_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecFlagsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_flags_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecFlags),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_flags_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecFlagsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecUpdateOPProperties
{
  PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_0,
  PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_OP,
  PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_POS
};

/* reads a spec_update_o_p object */
static gint32
swcdb_thrift_spec_update_o_p_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecUpdateOP * this_object = SWCDB_THRIFT_SPEC_UPDATE_O_P(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast15;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast15, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (swcdb_thriftUpdateOP)ecast15;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->pos, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pos = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_update_o_p_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecUpdateOP * this_object = SWCDB_THRIFT_SPEC_UPDATE_O_P(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecUpdateOP", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_pos == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pos", T_I32, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->pos, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_update_o_p_set_property (GObject *object,
                                           guint property_id,
                                           const GValue *value,
                                           GParamSpec *pspec)
{
  swcdb_thriftSpecUpdateOP *self = SWCDB_THRIFT_SPEC_UPDATE_O_P (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_POS:
      self->pos = g_value_get_int (value);
      self->__isset_pos = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_update_o_p_get_property (GObject *object,
                                           guint property_id,
                                           GValue *value,
                                           GParamSpec *pspec)
{
  swcdb_thriftSpecUpdateOP *self = SWCDB_THRIFT_SPEC_UPDATE_O_P (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_POS:
      g_value_set_int (value, self->pos);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_update_o_p_instance_init (swcdb_thriftSpecUpdateOP * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_op = FALSE;
  object->pos = 0;
  object->__isset_pos = FALSE;
}

static void 
swcdb_thrift_spec_update_o_p_finalize (GObject *object)
{
  swcdb_thriftSpecUpdateOP *tobject = SWCDB_THRIFT_SPEC_UPDATE_O_P (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_spec_update_o_p_class_init (swcdb_thriftSpecUpdateOPClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_update_o_p_read;
  struct_class->write = swcdb_thrift_spec_update_o_p_write;

  gobject_class->finalize = swcdb_thrift_spec_update_o_p_finalize;
  gobject_class->get_property = swcdb_thrift_spec_update_o_p_get_property;
  gobject_class->set_property = swcdb_thrift_spec_update_o_p_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       5,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_UPDATE_O_P_POS,
     g_param_spec_int ("pos",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_update_o_p_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecUpdateOPClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_update_o_p_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecUpdateOP),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_update_o_p_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecUpdateOPType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecIntervalUpdatePlainProperties
{
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_0,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_V,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_TS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_ENCODER,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_UPDATE_OP
};

/* reads a spec_interval_update_plain object */
static gint32
swcdb_thrift_spec_interval_update_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecIntervalUpdatePlain * this_object = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          gint32 ecast16;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast16, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoder = (swcdb_thriftEncodingType)ecast16;
          this_object->__isset_encoder = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->update_op), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_update_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_interval_update_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecIntervalUpdatePlain * this_object = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecIntervalUpdatePlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_encoder == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encoder", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoder, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_update_op == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "update_op", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->update_op), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_interval_update_plain_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalUpdatePlain *self = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_ENCODER:
      self->encoder = g_value_get_int (value);
      self->__isset_encoder = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_UPDATE_OP:
      if (self->update_op != NULL)
        g_object_unref (self->update_op);
      self->update_op = g_value_dup_object (value);
      self->__isset_update_op = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_interval_update_plain_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalUpdatePlain *self = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_V:
      g_value_set_boxed (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_ENCODER:
      g_value_set_int (value, self->encoder);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_UPDATE_OP:
      g_value_set_object (value, self->update_op);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_interval_update_plain_instance_init (swcdb_thriftSpecIntervalUpdatePlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->v = NULL;
  object->__isset_v = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->__isset_encoder = FALSE;
  object->update_op = g_object_new (SWCDB_THRIFT_TYPE_SPEC_UPDATE_O_P, NULL);
  object->__isset_update_op = FALSE;
}

static void 
swcdb_thrift_spec_interval_update_plain_finalize (GObject *object)
{
  swcdb_thriftSpecIntervalUpdatePlain *tobject = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
  if (tobject->update_op != NULL)
  {
    g_object_unref(tobject->update_op);
    tobject->update_op = NULL;
  }
}

static void
swcdb_thrift_spec_interval_update_plain_class_init (swcdb_thriftSpecIntervalUpdatePlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_interval_update_plain_read;
  struct_class->write = swcdb_thrift_spec_interval_update_plain_write;

  gobject_class->finalize = swcdb_thrift_spec_interval_update_plain_finalize;
  gobject_class->get_property = swcdb_thrift_spec_interval_update_plain_get_property;
  gobject_class->set_property = swcdb_thrift_spec_interval_update_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_ENCODER,
     g_param_spec_int ("encoder",
                       NULL,
                       NULL,
                       0,
                       255,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_PLAIN_UPDATE_OP,
     g_param_spec_object ("update_op",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_UPDATE_O_P,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_interval_update_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecIntervalUpdatePlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_interval_update_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecIntervalUpdatePlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_interval_update_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecIntervalUpdatePlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecIntervalUpdateCounterProperties
{
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_0,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_V,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_OP,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_TS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_UPDATE_OP
};

/* reads a spec_interval_update_counter object */
static gint32
swcdb_thrift_spec_interval_update_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecIntervalUpdateCounter * this_object = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->op, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->update_op), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_update_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_interval_update_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecIntervalUpdateCounter * this_object = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecIntervalUpdateCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_update_op == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "update_op", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->update_op), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_interval_update_counter_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalUpdateCounter *self = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_OP:
      self->op = g_value_get_int64 (value);
      self->__isset_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_UPDATE_OP:
      if (self->update_op != NULL)
        g_object_unref (self->update_op);
      self->update_op = g_value_dup_object (value);
      self->__isset_update_op = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_interval_update_counter_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalUpdateCounter *self = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_V:
      g_value_set_int64 (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_OP:
      g_value_set_int64 (value, self->op);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_UPDATE_OP:
      g_value_set_object (value, self->update_op);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_interval_update_counter_instance_init (swcdb_thriftSpecIntervalUpdateCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->v = 0;
  object->__isset_v = FALSE;
  object->op = G_GINT64_CONSTANT (0);
  object->__isset_op = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->update_op = g_object_new (SWCDB_THRIFT_TYPE_SPEC_UPDATE_O_P, NULL);
  object->__isset_update_op = FALSE;
}

static void 
swcdb_thrift_spec_interval_update_counter_finalize (GObject *object)
{
  swcdb_thriftSpecIntervalUpdateCounter *tobject = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->update_op != NULL)
  {
    g_object_unref(tobject->update_op);
    tobject->update_op = NULL;
  }
}

static void
swcdb_thrift_spec_interval_update_counter_class_init (swcdb_thriftSpecIntervalUpdateCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_interval_update_counter_read;
  struct_class->write = swcdb_thrift_spec_interval_update_counter_write;

  gobject_class->finalize = swcdb_thrift_spec_interval_update_counter_finalize;
  gobject_class->get_property = swcdb_thrift_spec_interval_update_counter_get_property;
  gobject_class->set_property = swcdb_thrift_spec_interval_update_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_OP,
     g_param_spec_int64 ("op",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_COUNTER_UPDATE_OP,
     g_param_spec_object ("update_op",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_UPDATE_O_P,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_interval_update_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecIntervalUpdateCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_interval_update_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecIntervalUpdateCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_interval_update_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecIntervalUpdateCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecIntervalUpdateSerialProperties
{
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_0,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_TS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_V,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_V_OP,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_ENCODER,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_UPDATE_OP
};

/* reads a spec_interval_update_serial object */
static gint32
swcdb_thrift_spec_interval_update_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecIntervalUpdateSerial * this_object = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellValueSerial * _elem17 = NULL;
              if ( _elem17 != NULL)
              {
                g_object_unref (_elem17);
              }
              _elem17 = g_object_new (SWCDB_THRIFT_TYPE_CELL_VALUE_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem17), protocol, error)) < 0)
              {
                g_object_unref (_elem17);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem17);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellValueSerialOp * _elem18 = NULL;
              if ( _elem18 != NULL)
              {
                g_object_unref (_elem18);
              }
              _elem18 = g_object_new (SWCDB_THRIFT_TYPE_CELL_VALUE_SERIAL_OP, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem18), protocol, error)) < 0)
              {
                g_object_unref (_elem18);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v_op, _elem18);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast19;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast19, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoder = (swcdb_thriftEncodingType)ecast19;
          this_object->__isset_encoder = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->update_op), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_update_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_interval_update_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecIntervalUpdateSerial * this_object = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecIntervalUpdateSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i20;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i20 = 0; i20 < (this_object->v ? this_object->v->len : 0); i20++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i20))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v_op", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i21;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v_op ? this_object->v_op->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i21 = 0; i21 < (this_object->v_op ? this_object->v_op->len : 0); i21++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v_op, i21))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_encoder == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encoder", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoder, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_update_op == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "update_op", T_STRUCT, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->update_op), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_interval_update_serial_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalUpdateSerial *self = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_V_OP:
      if (self->v_op != NULL)
        g_ptr_array_unref (self->v_op);
      self->v_op = g_value_dup_boxed (value);
      self->__isset_v_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_ENCODER:
      self->encoder = g_value_get_int (value);
      self->__isset_encoder = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_UPDATE_OP:
      if (self->update_op != NULL)
        g_object_unref (self->update_op);
      self->update_op = g_value_dup_object (value);
      self->__isset_update_op = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_interval_update_serial_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalUpdateSerial *self = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_V:
      g_value_set_boxed (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_V_OP:
      g_value_set_boxed (value, self->v_op);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_ENCODER:
      g_value_set_int (value, self->encoder);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_UPDATE_OP:
      g_value_set_object (value, self->update_op);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_interval_update_serial_instance_init (swcdb_thriftSpecIntervalUpdateSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
  object->v_op = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v_op = FALSE;
  object->__isset_encoder = FALSE;
  object->update_op = g_object_new (SWCDB_THRIFT_TYPE_SPEC_UPDATE_O_P, NULL);
  object->__isset_update_op = FALSE;
}

static void 
swcdb_thrift_spec_interval_update_serial_finalize (GObject *object)
{
  swcdb_thriftSpecIntervalUpdateSerial *tobject = SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
  if (tobject->v_op != NULL)
  {
    g_ptr_array_unref (tobject->v_op);
    tobject->v_op = NULL;
  }
  if (tobject->update_op != NULL)
  {
    g_object_unref(tobject->update_op);
    tobject->update_op = NULL;
  }
}

static void
swcdb_thrift_spec_interval_update_serial_class_init (swcdb_thriftSpecIntervalUpdateSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_interval_update_serial_read;
  struct_class->write = swcdb_thrift_spec_interval_update_serial_write;

  gobject_class->finalize = swcdb_thrift_spec_interval_update_serial_finalize;
  gobject_class->get_property = swcdb_thrift_spec_interval_update_serial_get_property;
  gobject_class->set_property = swcdb_thrift_spec_interval_update_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_V_OP,
     g_param_spec_boxed ("v_op",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_ENCODER,
     g_param_spec_int ("encoder",
                       NULL,
                       NULL,
                       0,
                       255,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_UPDATE_SERIAL_UPDATE_OP,
     g_param_spec_object ("update_op",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_UPDATE_O_P,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_interval_update_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecIntervalUpdateSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_interval_update_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecIntervalUpdateSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_interval_update_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecIntervalUpdateSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueSerial_INT64Properties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_COMP,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_V
};

/* reads a spec_value_serial__i_n_t64 object */
static gint32
swcdb_thrift_spec_value_serial__i_n_t64_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueSerial_INT64 * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast22;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast22, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast22;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_serial__i_n_t64_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueSerial_INT64 * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueSerial_INT64", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_serial__i_n_t64_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_INT64 *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64 (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_serial__i_n_t64_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_INT64 *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64 (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_V:
      g_value_set_int64 (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_serial__i_n_t64_instance_init (swcdb_thriftSpecValueSerial_INT64 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_spec_value_serial__i_n_t64_finalize (GObject *object)
{
  swcdb_thriftSpecValueSerial_INT64 *tobject = SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_spec_value_serial__i_n_t64_class_init (swcdb_thriftSpecValueSerial_INT64Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_serial__i_n_t64_read;
  struct_class->write = swcdb_thrift_spec_value_serial__i_n_t64_write;

  gobject_class->finalize = swcdb_thrift_spec_value_serial__i_n_t64_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_serial__i_n_t64_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_serial__i_n_t64_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__I_N_T64_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_serial__i_n_t64_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueSerial_INT64Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_serial__i_n_t64_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueSerial_INT64),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_serial__i_n_t64_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueSerial_INT64Type",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueSerial_DOUBLEProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_COMP,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_V
};

/* reads a spec_value_serial__d_o_u_b_l_e object */
static gint32
swcdb_thrift_spec_value_serial__d_o_u_b_l_e_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueSerial_DOUBLE * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast23;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast23, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast23;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_serial__d_o_u_b_l_e_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueSerial_DOUBLE * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueSerial_DOUBLE", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_DOUBLE, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_serial__d_o_u_b_l_e_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_DOUBLE *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_V:
      self->v = g_value_get_double (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_serial__d_o_u_b_l_e_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_DOUBLE *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_V:
      g_value_set_double (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_serial__d_o_u_b_l_e_instance_init (swcdb_thriftSpecValueSerial_DOUBLE * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_spec_value_serial__d_o_u_b_l_e_finalize (GObject *object)
{
  swcdb_thriftSpecValueSerial_DOUBLE *tobject = SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_spec_value_serial__d_o_u_b_l_e_class_init (swcdb_thriftSpecValueSerial_DOUBLEClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_serial__d_o_u_b_l_e_read;
  struct_class->write = swcdb_thrift_spec_value_serial__d_o_u_b_l_e_write;

  gobject_class->finalize = swcdb_thrift_spec_value_serial__d_o_u_b_l_e_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_serial__d_o_u_b_l_e_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_serial__d_o_u_b_l_e_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__D_O_U_B_L_E_V,
     g_param_spec_double ("v",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_serial__d_o_u_b_l_e_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueSerial_DOUBLEClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_serial__d_o_u_b_l_e_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueSerial_DOUBLE),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_serial__d_o_u_b_l_e_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueSerial_DOUBLEType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueSerial_BYTESProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_COMP,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_V
};

/* reads a spec_value_serial__b_y_t_e_s object */
static gint32
swcdb_thrift_spec_value_serial__b_y_t_e_s_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueSerial_BYTES * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast24;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast24, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast24;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_serial__b_y_t_e_s_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueSerial_BYTES * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueSerial_BYTES", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_serial__b_y_t_e_s_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_BYTES *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_serial__b_y_t_e_s_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_BYTES *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_serial__b_y_t_e_s_instance_init (swcdb_thriftSpecValueSerial_BYTES * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_spec_value_serial__b_y_t_e_s_finalize (GObject *object)
{
  swcdb_thriftSpecValueSerial_BYTES *tobject = SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_spec_value_serial__b_y_t_e_s_class_init (swcdb_thriftSpecValueSerial_BYTESClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_serial__b_y_t_e_s_read;
  struct_class->write = swcdb_thrift_spec_value_serial__b_y_t_e_s_write;

  gobject_class->finalize = swcdb_thrift_spec_value_serial__b_y_t_e_s_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_serial__b_y_t_e_s_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_serial__b_y_t_e_s_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__B_Y_T_E_S_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_serial__b_y_t_e_s_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueSerial_BYTESClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_serial__b_y_t_e_s_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueSerial_BYTES),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_serial__b_y_t_e_s_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueSerial_BYTESType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueSerial_KEYProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_SEQ,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_V
};

/* reads a spec_value_serial__k_e_y object */
static gint32
swcdb_thrift_spec_value_serial__k_e_y_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueSerial_KEY * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast25;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast25, error)) < 0)
            return -1;
          xfer += ret;
          this_object->seq = (swcdb_thriftKeySeq)ecast25;
          this_object->__isset_seq = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecFraction * _elem26 = NULL;
              if ( _elem26 != NULL)
              {
                g_object_unref (_elem26);
              }
              _elem26 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_FRACTION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem26), protocol, error)) < 0)
              {
                g_object_unref (_elem26);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem26);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_serial__k_e_y_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueSerial_KEY * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueSerial_KEY", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "seq", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->seq, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i27;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i27 = 0; i27 < (this_object->v ? this_object->v->len : 0); i27++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i27))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_serial__k_e_y_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_KEY *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_SEQ:
      self->seq = g_value_get_int (value);
      self->__isset_seq = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_serial__k_e_y_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_KEY *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_SEQ:
      g_value_set_int (value, self->seq);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_serial__k_e_y_instance_init (swcdb_thriftSpecValueSerial_KEY * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_seq = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_spec_value_serial__k_e_y_finalize (GObject *object)
{
  swcdb_thriftSpecValueSerial_KEY *tobject = SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_spec_value_serial__k_e_y_class_init (swcdb_thriftSpecValueSerial_KEYClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_serial__k_e_y_read;
  struct_class->write = swcdb_thrift_spec_value_serial__k_e_y_write;

  gobject_class->finalize = swcdb_thrift_spec_value_serial__k_e_y_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_serial__k_e_y_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_serial__k_e_y_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_SEQ,
     g_param_spec_int ("seq",
                       NULL,
                       NULL,
                       0,
                       4,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__K_E_Y_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_serial__k_e_y_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueSerial_KEYClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_serial__k_e_y_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueSerial_KEY),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_serial__k_e_y_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueSerial_KEYType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueSerial_LIProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_COMP,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_V
};

/* reads a spec_value_serial__l_i object */
static gint32
swcdb_thrift_spec_value_serial__l_i_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueSerial_LI * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast28;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast28, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast28;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecValueSerial_INT64 * _elem29 = NULL;
              if ( _elem29 != NULL)
              {
                g_object_unref (_elem29);
              }
              _elem29 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__I_N_T64, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem29), protocol, error)) < 0)
              {
                g_object_unref (_elem29);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem29);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_serial__l_i_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueSerial_LI * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueSerial_LI", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i30;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i30 = 0; i30 < (this_object->v ? this_object->v->len : 0); i30++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i30))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_serial__l_i_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_LI *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_serial__l_i_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_LI *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_serial__l_i_instance_init (swcdb_thriftSpecValueSerial_LI * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_spec_value_serial__l_i_finalize (GObject *object)
{
  swcdb_thriftSpecValueSerial_LI *tobject = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_spec_value_serial__l_i_class_init (swcdb_thriftSpecValueSerial_LIClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_serial__l_i_read;
  struct_class->write = swcdb_thrift_spec_value_serial__l_i_write;

  gobject_class->finalize = swcdb_thrift_spec_value_serial__l_i_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_serial__l_i_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_serial__l_i_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_I_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_serial__l_i_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueSerial_LIClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_serial__l_i_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueSerial_LI),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_serial__l_i_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueSerial_LIType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueSerial_LBProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_COMP,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_V
};

/* reads a spec_value_serial__l_b object */
static gint32
swcdb_thrift_spec_value_serial__l_b_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueSerial_LB * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast31;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast31, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast31;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecValueSerial_BYTES * _elem32 = NULL;
              if ( _elem32 != NULL)
              {
                g_object_unref (_elem32);
              }
              _elem32 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__B_Y_T_E_S, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem32), protocol, error)) < 0)
              {
                g_object_unref (_elem32);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem32);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_serial__l_b_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueSerial_LB * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueSerial_LB", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i33;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i33 = 0; i33 < (this_object->v ? this_object->v->len : 0); i33++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i33))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_serial__l_b_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_LB *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_serial__l_b_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial_LB *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_serial__l_b_instance_init (swcdb_thriftSpecValueSerial_LB * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_spec_value_serial__l_b_finalize (GObject *object)
{
  swcdb_thriftSpecValueSerial_LB *tobject = SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_spec_value_serial__l_b_class_init (swcdb_thriftSpecValueSerial_LBClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_serial__l_b_read;
  struct_class->write = swcdb_thrift_spec_value_serial__l_b_write;

  gobject_class->finalize = swcdb_thrift_spec_value_serial__l_b_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_serial__l_b_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_serial__l_b_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL__L_B_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_serial__l_b_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueSerial_LBClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_serial__l_b_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueSerial_LB),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_serial__l_b_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueSerial_LBType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueSerialFieldProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_FIELD_ID,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_INT64,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_DOUBLE,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_BYTES,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_KEY,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_LI,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_LB
};

/* reads a spec_value_serial_field object */
static gint32
swcdb_thrift_spec_value_serial_field_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueSerialField * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec_int64), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec_int64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec_double), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec_double = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec_bytes), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec_bytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec_key), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec_li), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec_li = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec_lb), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec_lb = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_serial_field_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueSerialField * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueSerialField", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field_id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->field_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_spec_int64 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "spec_int64", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec_int64), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_spec_double == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "spec_double", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec_double), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec_bytes", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec_bytes), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec_key", T_STRUCT, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec_key), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec_li", T_STRUCT, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec_li), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec_lb", T_STRUCT, 7, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec_lb), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_serial_field_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerialField *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_FIELD_ID:
      self->field_id = g_value_get_int (value);
      self->__isset_field_id = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_INT64:
      if (self->spec_int64 != NULL)
        g_object_unref (self->spec_int64);
      self->spec_int64 = g_value_dup_object (value);
      self->__isset_spec_int64 = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_DOUBLE:
      if (self->spec_double != NULL)
        g_object_unref (self->spec_double);
      self->spec_double = g_value_dup_object (value);
      self->__isset_spec_double = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_BYTES:
      if (self->spec_bytes != NULL)
        g_object_unref (self->spec_bytes);
      self->spec_bytes = g_value_dup_object (value);
      self->__isset_spec_bytes = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_KEY:
      if (self->spec_key != NULL)
        g_object_unref (self->spec_key);
      self->spec_key = g_value_dup_object (value);
      self->__isset_spec_key = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_LI:
      if (self->spec_li != NULL)
        g_object_unref (self->spec_li);
      self->spec_li = g_value_dup_object (value);
      self->__isset_spec_li = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_LB:
      if (self->spec_lb != NULL)
        g_object_unref (self->spec_lb);
      self->spec_lb = g_value_dup_object (value);
      self->__isset_spec_lb = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_serial_field_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerialField *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_FIELD_ID:
      g_value_set_int (value, self->field_id);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_INT64:
      g_value_set_object (value, self->spec_int64);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_DOUBLE:
      g_value_set_object (value, self->spec_double);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_BYTES:
      g_value_set_object (value, self->spec_bytes);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_KEY:
      g_value_set_object (value, self->spec_key);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_LI:
      g_value_set_object (value, self->spec_li);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_LB:
      g_value_set_object (value, self->spec_lb);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_serial_field_instance_init (swcdb_thriftSpecValueSerialField * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field_id = 0;
  object->__isset_field_id = FALSE;
  object->spec_int64 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__I_N_T64, NULL);
  object->__isset_spec_int64 = FALSE;
  object->spec_double = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__D_O_U_B_L_E, NULL);
  object->__isset_spec_double = FALSE;
  object->spec_bytes = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__B_Y_T_E_S, NULL);
  object->__isset_spec_bytes = FALSE;
  object->spec_key = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__K_E_Y, NULL);
  object->__isset_spec_key = FALSE;
  object->spec_li = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__L_I, NULL);
  object->__isset_spec_li = FALSE;
  object->spec_lb = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__L_B, NULL);
  object->__isset_spec_lb = FALSE;
}

static void 
swcdb_thrift_spec_value_serial_field_finalize (GObject *object)
{
  swcdb_thriftSpecValueSerialField *tobject = SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->spec_int64 != NULL)
  {
    g_object_unref(tobject->spec_int64);
    tobject->spec_int64 = NULL;
  }
  if (tobject->spec_double != NULL)
  {
    g_object_unref(tobject->spec_double);
    tobject->spec_double = NULL;
  }
  if (tobject->spec_bytes != NULL)
  {
    g_object_unref(tobject->spec_bytes);
    tobject->spec_bytes = NULL;
  }
  if (tobject->spec_key != NULL)
  {
    g_object_unref(tobject->spec_key);
    tobject->spec_key = NULL;
  }
  if (tobject->spec_li != NULL)
  {
    g_object_unref(tobject->spec_li);
    tobject->spec_li = NULL;
  }
  if (tobject->spec_lb != NULL)
  {
    g_object_unref(tobject->spec_lb);
    tobject->spec_lb = NULL;
  }
}

static void
swcdb_thrift_spec_value_serial_field_class_init (swcdb_thriftSpecValueSerialFieldClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_serial_field_read;
  struct_class->write = swcdb_thrift_spec_value_serial_field_write;

  gobject_class->finalize = swcdb_thrift_spec_value_serial_field_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_serial_field_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_serial_field_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_FIELD_ID,
     g_param_spec_int ("field_id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_INT64,
     g_param_spec_object ("spec_int64",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__I_N_T64,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_DOUBLE,
     g_param_spec_object ("spec_double",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__D_O_U_B_L_E,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_BYTES,
     g_param_spec_object ("spec_bytes",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__B_Y_T_E_S,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_KEY,
     g_param_spec_object ("spec_key",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__K_E_Y,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_LI,
     g_param_spec_object ("spec_li",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__L_I,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELD_SPEC_LB,
     g_param_spec_object ("spec_lb",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL__L_B,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_serial_field_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueSerialFieldClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_serial_field_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueSerialField),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_serial_field_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueSerialFieldType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValuePlainProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_COMP,
  PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_V
};

/* reads a spec_value_plain object */
static gint32
swcdb_thrift_spec_value_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValuePlain * this_object = SWCDB_THRIFT_SPEC_VALUE_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast34;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast34, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast34;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValuePlain * this_object = SWCDB_THRIFT_SPEC_VALUE_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValuePlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_plain_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  swcdb_thriftSpecValuePlain *self = SWCDB_THRIFT_SPEC_VALUE_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_plain_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  swcdb_thriftSpecValuePlain *self = SWCDB_THRIFT_SPEC_VALUE_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_plain_instance_init (swcdb_thriftSpecValuePlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_spec_value_plain_finalize (GObject *object)
{
  swcdb_thriftSpecValuePlain *tobject = SWCDB_THRIFT_SPEC_VALUE_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_spec_value_plain_class_init (swcdb_thriftSpecValuePlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_plain_read;
  struct_class->write = swcdb_thrift_spec_value_plain_write;

  gobject_class->finalize = swcdb_thrift_spec_value_plain_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_plain_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_PLAIN_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValuePlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValuePlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValuePlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueCounterProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_COMP,
  PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_V
};

/* reads a spec_value_counter object */
static gint32
swcdb_thrift_spec_value_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueCounter * this_object = SWCDB_THRIFT_SPEC_VALUE_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast35;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast35, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast35;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueCounter * this_object = SWCDB_THRIFT_SPEC_VALUE_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_counter_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  swcdb_thriftSpecValueCounter *self = SWCDB_THRIFT_SPEC_VALUE_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_counter_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  swcdb_thriftSpecValueCounter *self = SWCDB_THRIFT_SPEC_VALUE_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_V:
      g_value_set_int64 (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_counter_instance_init (swcdb_thriftSpecValueCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_spec_value_counter_finalize (GObject *object)
{
  swcdb_thriftSpecValueCounter *tobject = SWCDB_THRIFT_SPEC_VALUE_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_spec_value_counter_class_init (swcdb_thriftSpecValueCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_counter_read;
  struct_class->write = swcdb_thrift_spec_value_counter_write;

  gobject_class->finalize = swcdb_thrift_spec_value_counter_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_counter_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_COUNTER_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecValueSerialProperties
{
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_0,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_COMP,
  PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELDS
};

/* reads a spec_value_serial object */
static gint32
swcdb_thrift_spec_value_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecValueSerial * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast36;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast36, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast36;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecValueSerialField * _elem37 = NULL;
              if ( _elem37 != NULL)
              {
                g_object_unref (_elem37);
              }
              _elem37 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL_FIELD, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem37), protocol, error)) < 0)
              {
                g_object_unref (_elem37);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->fields, _elem37);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_fields = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_value_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecValueSerial * this_object = SWCDB_THRIFT_SPEC_VALUE_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecValueSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fields", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i38;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->fields ? this_object->fields->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i38 = 0; i38 < (this_object->fields ? this_object->fields->len : 0); i38++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->fields, i38))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_value_serial_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELDS:
      if (self->fields != NULL)
        g_ptr_array_unref (self->fields);
      self->fields = g_value_dup_boxed (value);
      self->__isset_fields = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_value_serial_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftSpecValueSerial *self = SWCDB_THRIFT_SPEC_VALUE_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELDS:
      g_value_set_boxed (value, self->fields);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_value_serial_instance_init (swcdb_thriftSpecValueSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->fields = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_fields = FALSE;
}

static void 
swcdb_thrift_spec_value_serial_finalize (GObject *object)
{
  swcdb_thriftSpecValueSerial *tobject = SWCDB_THRIFT_SPEC_VALUE_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->fields != NULL)
  {
    g_ptr_array_unref (tobject->fields);
    tobject->fields = NULL;
  }
}

static void
swcdb_thrift_spec_value_serial_class_init (swcdb_thriftSpecValueSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_value_serial_read;
  struct_class->write = swcdb_thrift_spec_value_serial_write;

  gobject_class->finalize = swcdb_thrift_spec_value_serial_finalize;
  gobject_class->get_property = swcdb_thrift_spec_value_serial_get_property;
  gobject_class->set_property = swcdb_thrift_spec_value_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_VALUE_SERIAL_FIELDS,
     g_param_spec_boxed ("fields",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_value_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecValueSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_value_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecValueSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_value_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecValueSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecFractionProperties
{
  PROP_SWCDB_THRIFT_SPEC_FRACTION_0,
  PROP_SWCDB_THRIFT_SPEC_FRACTION_COMP,
  PROP_SWCDB_THRIFT_SPEC_FRACTION_F
};

/* reads a spec_fraction object */
static gint32
swcdb_thrift_spec_fraction_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecFraction * this_object = SWCDB_THRIFT_SPEC_FRACTION(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast39;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast39, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast39;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRING)
        {
          if (this_object->f != NULL)
          {
            g_free(this_object->f);
            this_object->f = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->f = g_byte_array_new();
          g_byte_array_append (this_object->f, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_f = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_fraction_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecFraction * this_object = SWCDB_THRIFT_SPEC_FRACTION(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecFraction", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "f", T_STRING, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->f ? ((GByteArray *) this_object->f)->data : NULL, this_object->f ? ((GByteArray *) this_object->f)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_fraction_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftSpecFraction *self = SWCDB_THRIFT_SPEC_FRACTION (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_FRACTION_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_FRACTION_F:
      if (self->f != NULL)
        g_byte_array_unref (self->f);
      self->f = g_value_dup_boxed (value);
      self->__isset_f = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_fraction_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftSpecFraction *self = SWCDB_THRIFT_SPEC_FRACTION (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_FRACTION_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_FRACTION_F:
      g_value_set_boxed (value, self->f);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_fraction_instance_init (swcdb_thriftSpecFraction * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->f = NULL;
  object->__isset_f = FALSE;
}

static void 
swcdb_thrift_spec_fraction_finalize (GObject *object)
{
  swcdb_thriftSpecFraction *tobject = SWCDB_THRIFT_SPEC_FRACTION (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->f != NULL)
  {
    thrift_string_free(tobject->f);
    tobject->f = NULL;
  }
}

static void
swcdb_thrift_spec_fraction_class_init (swcdb_thriftSpecFractionClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_fraction_read;
  struct_class->write = swcdb_thrift_spec_fraction_write;

  gobject_class->finalize = swcdb_thrift_spec_fraction_finalize;
  gobject_class->get_property = swcdb_thrift_spec_fraction_get_property;
  gobject_class->set_property = swcdb_thrift_spec_fraction_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_FRACTION_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_FRACTION_F,
     g_param_spec_boxed ("f",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_fraction_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecFractionClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_fraction_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecFraction),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_fraction_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecFractionType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecTimestampProperties
{
  PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_0,
  PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_COMP,
  PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_TS
};

/* reads a spec_timestamp object */
static gint32
swcdb_thrift_spec_timestamp_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecTimestamp * this_object = SWCDB_THRIFT_SPEC_TIMESTAMP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast40;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast40, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast40;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_timestamp_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecTimestamp * this_object = SWCDB_THRIFT_SPEC_TIMESTAMP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecTimestamp", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_timestamp_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftSpecTimestamp *self = SWCDB_THRIFT_SPEC_TIMESTAMP (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_timestamp_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftSpecTimestamp *self = SWCDB_THRIFT_SPEC_TIMESTAMP (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_TS:
      g_value_set_int64 (value, self->ts);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_timestamp_instance_init (swcdb_thriftSpecTimestamp * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_comp = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
}

static void 
swcdb_thrift_spec_timestamp_finalize (GObject *object)
{
  swcdb_thriftSpecTimestamp *tobject = SWCDB_THRIFT_SPEC_TIMESTAMP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_spec_timestamp_class_init (swcdb_thriftSpecTimestampClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_timestamp_read;
  struct_class->write = swcdb_thrift_spec_timestamp_write;

  gobject_class->finalize = swcdb_thrift_spec_timestamp_finalize;
  gobject_class->get_property = swcdb_thrift_spec_timestamp_get_property;
  gobject_class->set_property = swcdb_thrift_spec_timestamp_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_TIMESTAMP_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_timestamp_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecTimestampClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_timestamp_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecTimestamp),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_timestamp_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecTimestampType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecKeyIntervalProperties
{
  PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_0,
  PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_START,
  PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_FINISH
};

/* reads a spec_key_interval object */
static gint32
swcdb_thrift_spec_key_interval_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecKeyInterval * this_object = SWCDB_THRIFT_SPEC_KEY_INTERVAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecFraction * _elem41 = NULL;
              if ( _elem41 != NULL)
              {
                g_object_unref (_elem41);
              }
              _elem41 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_FRACTION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem41), protocol, error)) < 0)
              {
                g_object_unref (_elem41);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->start, _elem41);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_start = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecFraction * _elem42 = NULL;
              if ( _elem42 != NULL)
              {
                g_object_unref (_elem42);
              }
              _elem42 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_FRACTION, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem42), protocol, error)) < 0)
              {
                g_object_unref (_elem42);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->finish, _elem42);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_finish = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_key_interval_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecKeyInterval * this_object = SWCDB_THRIFT_SPEC_KEY_INTERVAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecKeyInterval", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "start", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i43;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->start ? this_object->start->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i43 = 0; i43 < (this_object->start ? this_object->start->len : 0); i43++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->start, i43))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "finish", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i44;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->finish ? this_object->finish->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i44 = 0; i44 < (this_object->finish ? this_object->finish->len : 0); i44++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->finish, i44))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_key_interval_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftSpecKeyInterval *self = SWCDB_THRIFT_SPEC_KEY_INTERVAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_START:
      if (self->start != NULL)
        g_ptr_array_unref (self->start);
      self->start = g_value_dup_boxed (value);
      self->__isset_start = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_FINISH:
      if (self->finish != NULL)
        g_ptr_array_unref (self->finish);
      self->finish = g_value_dup_boxed (value);
      self->__isset_finish = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_key_interval_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftSpecKeyInterval *self = SWCDB_THRIFT_SPEC_KEY_INTERVAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_START:
      g_value_set_boxed (value, self->start);
      break;

    case PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_FINISH:
      g_value_set_boxed (value, self->finish);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_key_interval_instance_init (swcdb_thriftSpecKeyInterval * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->start = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_start = FALSE;
  object->finish = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_finish = FALSE;
}

static void 
swcdb_thrift_spec_key_interval_finalize (GObject *object)
{
  swcdb_thriftSpecKeyInterval *tobject = SWCDB_THRIFT_SPEC_KEY_INTERVAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->start != NULL)
  {
    g_ptr_array_unref (tobject->start);
    tobject->start = NULL;
  }
  if (tobject->finish != NULL)
  {
    g_ptr_array_unref (tobject->finish);
    tobject->finish = NULL;
  }
}

static void
swcdb_thrift_spec_key_interval_class_init (swcdb_thriftSpecKeyIntervalClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_key_interval_read;
  struct_class->write = swcdb_thrift_spec_key_interval_write;

  gobject_class->finalize = swcdb_thrift_spec_key_interval_finalize;
  gobject_class->get_property = swcdb_thrift_spec_key_interval_get_property;
  gobject_class->set_property = swcdb_thrift_spec_key_interval_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_START,
     g_param_spec_boxed ("start",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_KEY_INTERVAL_FINISH,
     g_param_spec_boxed ("finish",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_key_interval_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecKeyIntervalClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_key_interval_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecKeyInterval),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_key_interval_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecKeyIntervalType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecIntervalPlainProperties
{
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_0,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_RANGE_BEGIN,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_RANGE_END,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OFFSET_KEY,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OFFSET_REV,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_KEY_INTERVALS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_VALUES,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_TS_START,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_TS_FINISH,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_FLAGS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OPTIONS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_UPDATING
};

/* reads a spec_interval_plain object */
static gint32
swcdb_thrift_spec_interval_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecIntervalPlain * this_object = SWCDB_THRIFT_SPEC_INTERVAL_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem45 = NULL;
              if (_elem45 != NULL)
              {
                g_free(_elem45);
                _elem45 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem45 = g_byte_array_new();
              g_byte_array_append (_elem45, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->range_begin, _elem45);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_range_begin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem46 = NULL;
              if (_elem46 != NULL)
              {
                g_free(_elem46);
                _elem46 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem46 = g_byte_array_new();
              g_byte_array_append (_elem46, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->range_end, _elem46);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_range_end = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem47 = NULL;
              if (_elem47 != NULL)
              {
                g_free(_elem47);
                _elem47 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem47 = g_byte_array_new();
              g_byte_array_append (_elem47, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->offset_key, _elem47);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_offset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset_rev, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset_rev = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecKeyInterval * _elem48 = NULL;
              if ( _elem48 != NULL)
              {
                g_object_unref (_elem48);
              }
              _elem48 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_KEY_INTERVAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem48), protocol, error)) < 0)
              {
                g_object_unref (_elem48);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->key_intervals, _elem48);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_key_intervals = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecValuePlain * _elem49 = NULL;
              if ( _elem49 != NULL)
              {
                g_object_unref (_elem49);
              }
              _elem49 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_PLAIN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem49), protocol, error)) < 0)
              {
                g_object_unref (_elem49);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->values, _elem49);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ts_start), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ts_start = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ts_finish), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ts_finish = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->flags), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_flags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          gint32 ecast50;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast50, error)) < 0)
            return -1;
          xfer += ret;
          this_object->options = (swcdb_thriftSpecIntervalOptions)ecast50;
          this_object->__isset_options = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->updating), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_updating = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_interval_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecIntervalPlain * this_object = SWCDB_THRIFT_SPEC_INTERVAL_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecIntervalPlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "range_begin", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i51;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->range_begin ? this_object->range_begin->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i51 = 0; i51 < (this_object->range_begin ? this_object->range_begin->len : 0); i51++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i51)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i51)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i51)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i51)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "range_end", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i52;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->range_end ? this_object->range_end->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i52 = 0; i52 < (this_object->range_end ? this_object->range_end->len : 0); i52++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i52)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i52)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i52)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i52)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "offset_key", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i53;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->offset_key ? this_object->offset_key->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i53 = 0; i53 < (this_object->offset_key ? this_object->offset_key->len : 0); i53++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i53)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i53)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i53)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i53)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_offset_rev == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset_rev", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset_rev, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "key_intervals", T_LIST, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i54;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->key_intervals ? this_object->key_intervals->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i54 = 0; i54 < (this_object->key_intervals ? this_object->key_intervals->len : 0); i54++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->key_intervals, i54))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "values", T_LIST, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i55;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->values ? this_object->values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i55 = 0; i55 < (this_object->values ? this_object->values->len : 0); i55++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->values, i55))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts_start == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_start", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ts_start), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ts_finish == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_finish", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ts_finish), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_flags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "flags", T_STRUCT, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->flags), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_options == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "options", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->options, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updating == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updating", T_STRUCT, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->updating), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_interval_plain_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalPlain *self = SWCDB_THRIFT_SPEC_INTERVAL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_RANGE_BEGIN:
      if (self->range_begin != NULL)
        g_ptr_array_unref (self->range_begin);
      self->range_begin = g_value_dup_boxed (value);
      self->__isset_range_begin = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_RANGE_END:
      if (self->range_end != NULL)
        g_ptr_array_unref (self->range_end);
      self->range_end = g_value_dup_boxed (value);
      self->__isset_range_end = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OFFSET_KEY:
      if (self->offset_key != NULL)
        g_ptr_array_unref (self->offset_key);
      self->offset_key = g_value_dup_boxed (value);
      self->__isset_offset_key = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OFFSET_REV:
      self->offset_rev = g_value_get_int64 (value);
      self->__isset_offset_rev = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_KEY_INTERVALS:
      if (self->key_intervals != NULL)
        g_ptr_array_unref (self->key_intervals);
      self->key_intervals = g_value_dup_boxed (value);
      self->__isset_key_intervals = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_VALUES:
      if (self->values != NULL)
        g_ptr_array_unref (self->values);
      self->values = g_value_dup_boxed (value);
      self->__isset_values = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_TS_START:
      if (self->ts_start != NULL)
        g_object_unref (self->ts_start);
      self->ts_start = g_value_dup_object (value);
      self->__isset_ts_start = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_TS_FINISH:
      if (self->ts_finish != NULL)
        g_object_unref (self->ts_finish);
      self->ts_finish = g_value_dup_object (value);
      self->__isset_ts_finish = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_FLAGS:
      if (self->flags != NULL)
        g_object_unref (self->flags);
      self->flags = g_value_dup_object (value);
      self->__isset_flags = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OPTIONS:
      self->options = g_value_get_int (value);
      self->__isset_options = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_UPDATING:
      if (self->updating != NULL)
        g_object_unref (self->updating);
      self->updating = g_value_dup_object (value);
      self->__isset_updating = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_interval_plain_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalPlain *self = SWCDB_THRIFT_SPEC_INTERVAL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_RANGE_BEGIN:
      g_value_set_boxed (value, self->range_begin);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_RANGE_END:
      g_value_set_boxed (value, self->range_end);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OFFSET_KEY:
      g_value_set_boxed (value, self->offset_key);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OFFSET_REV:
      g_value_set_int64 (value, self->offset_rev);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_KEY_INTERVALS:
      g_value_set_boxed (value, self->key_intervals);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_VALUES:
      g_value_set_boxed (value, self->values);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_TS_START:
      g_value_set_object (value, self->ts_start);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_TS_FINISH:
      g_value_set_object (value, self->ts_finish);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_FLAGS:
      g_value_set_object (value, self->flags);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OPTIONS:
      g_value_set_int (value, self->options);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_UPDATING:
      g_value_set_object (value, self->updating);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_interval_plain_instance_init (swcdb_thriftSpecIntervalPlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->range_begin = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_range_begin = FALSE;
  object->range_end = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_range_end = FALSE;
  object->offset_key = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_offset_key = FALSE;
  object->offset_rev = 0;
  object->__isset_offset_rev = FALSE;
  object->key_intervals = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_key_intervals = FALSE;
  object->values = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_values = FALSE;
  object->ts_start = g_object_new (SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP, NULL);
  object->__isset_ts_start = FALSE;
  object->ts_finish = g_object_new (SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP, NULL);
  object->__isset_ts_finish = FALSE;
  object->flags = g_object_new (SWCDB_THRIFT_TYPE_SPEC_FLAGS, NULL);
  object->__isset_flags = FALSE;
  object->__isset_options = FALSE;
  object->updating = g_object_new (SWCDB_THRIFT_TYPE_SPEC_INTERVAL_UPDATE_PLAIN, NULL);
  object->__isset_updating = FALSE;
}

static void 
swcdb_thrift_spec_interval_plain_finalize (GObject *object)
{
  swcdb_thriftSpecIntervalPlain *tobject = SWCDB_THRIFT_SPEC_INTERVAL_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->range_begin != NULL)
  {
    g_ptr_array_unref (tobject->range_begin);
    tobject->range_begin = NULL;
  }
  if (tobject->range_end != NULL)
  {
    g_ptr_array_unref (tobject->range_end);
    tobject->range_end = NULL;
  }
  if (tobject->offset_key != NULL)
  {
    g_ptr_array_unref (tobject->offset_key);
    tobject->offset_key = NULL;
  }
  if (tobject->key_intervals != NULL)
  {
    g_ptr_array_unref (tobject->key_intervals);
    tobject->key_intervals = NULL;
  }
  if (tobject->values != NULL)
  {
    g_ptr_array_unref (tobject->values);
    tobject->values = NULL;
  }
  if (tobject->ts_start != NULL)
  {
    g_object_unref(tobject->ts_start);
    tobject->ts_start = NULL;
  }
  if (tobject->ts_finish != NULL)
  {
    g_object_unref(tobject->ts_finish);
    tobject->ts_finish = NULL;
  }
  if (tobject->flags != NULL)
  {
    g_object_unref(tobject->flags);
    tobject->flags = NULL;
  }
  if (tobject->updating != NULL)
  {
    g_object_unref(tobject->updating);
    tobject->updating = NULL;
  }
}

static void
swcdb_thrift_spec_interval_plain_class_init (swcdb_thriftSpecIntervalPlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_interval_plain_read;
  struct_class->write = swcdb_thrift_spec_interval_plain_write;

  gobject_class->finalize = swcdb_thrift_spec_interval_plain_finalize;
  gobject_class->get_property = swcdb_thrift_spec_interval_plain_get_property;
  gobject_class->set_property = swcdb_thrift_spec_interval_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_RANGE_BEGIN,
     g_param_spec_boxed ("range_begin",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_RANGE_END,
     g_param_spec_boxed ("range_end",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OFFSET_KEY,
     g_param_spec_boxed ("offset_key",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OFFSET_REV,
     g_param_spec_int64 ("offset_rev",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_KEY_INTERVALS,
     g_param_spec_boxed ("key_intervals",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_VALUES,
     g_param_spec_boxed ("values",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_TS_START,
     g_param_spec_object ("ts_start",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_TS_FINISH,
     g_param_spec_object ("ts_finish",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_FLAGS,
     g_param_spec_object ("flags",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_FLAGS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_OPTIONS,
     g_param_spec_int ("options",
                       NULL,
                       NULL,
                       4,
                       8,
                       4,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_PLAIN_UPDATING,
     g_param_spec_object ("updating",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_INTERVAL_UPDATE_PLAIN,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_interval_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecIntervalPlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_interval_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecIntervalPlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_interval_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecIntervalPlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecIntervalCounterProperties
{
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_0,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_RANGE_BEGIN,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_RANGE_END,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OFFSET_KEY,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OFFSET_REV,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_KEY_INTERVALS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_VALUES,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_TS_START,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_TS_FINISH,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_FLAGS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OPTIONS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_UPDATING
};

/* reads a spec_interval_counter object */
static gint32
swcdb_thrift_spec_interval_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecIntervalCounter * this_object = SWCDB_THRIFT_SPEC_INTERVAL_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem56 = NULL;
              if (_elem56 != NULL)
              {
                g_free(_elem56);
                _elem56 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem56 = g_byte_array_new();
              g_byte_array_append (_elem56, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->range_begin, _elem56);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_range_begin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem57 = NULL;
              if (_elem57 != NULL)
              {
                g_free(_elem57);
                _elem57 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem57 = g_byte_array_new();
              g_byte_array_append (_elem57, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->range_end, _elem57);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_range_end = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem58 = NULL;
              if (_elem58 != NULL)
              {
                g_free(_elem58);
                _elem58 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem58 = g_byte_array_new();
              g_byte_array_append (_elem58, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->offset_key, _elem58);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_offset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset_rev, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset_rev = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecKeyInterval * _elem59 = NULL;
              if ( _elem59 != NULL)
              {
                g_object_unref (_elem59);
              }
              _elem59 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_KEY_INTERVAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem59), protocol, error)) < 0)
              {
                g_object_unref (_elem59);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->key_intervals, _elem59);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_key_intervals = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecValueCounter * _elem60 = NULL;
              if ( _elem60 != NULL)
              {
                g_object_unref (_elem60);
              }
              _elem60 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_COUNTER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem60), protocol, error)) < 0)
              {
                g_object_unref (_elem60);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->values, _elem60);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ts_start), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ts_start = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ts_finish), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ts_finish = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->flags), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_flags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          gint32 ecast61;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast61, error)) < 0)
            return -1;
          xfer += ret;
          this_object->options = (swcdb_thriftSpecIntervalOptions)ecast61;
          this_object->__isset_options = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->updating), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_updating = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_interval_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecIntervalCounter * this_object = SWCDB_THRIFT_SPEC_INTERVAL_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecIntervalCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "range_begin", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i62;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->range_begin ? this_object->range_begin->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i62 = 0; i62 < (this_object->range_begin ? this_object->range_begin->len : 0); i62++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i62)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i62)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i62)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i62)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "range_end", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i63;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->range_end ? this_object->range_end->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i63 = 0; i63 < (this_object->range_end ? this_object->range_end->len : 0); i63++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i63)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i63)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i63)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i63)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "offset_key", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i64;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->offset_key ? this_object->offset_key->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i64 = 0; i64 < (this_object->offset_key ? this_object->offset_key->len : 0); i64++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i64)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i64)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i64)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i64)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_offset_rev == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset_rev", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset_rev, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "key_intervals", T_LIST, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i65;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->key_intervals ? this_object->key_intervals->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i65 = 0; i65 < (this_object->key_intervals ? this_object->key_intervals->len : 0); i65++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->key_intervals, i65))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "values", T_LIST, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i66;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->values ? this_object->values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i66 = 0; i66 < (this_object->values ? this_object->values->len : 0); i66++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->values, i66))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts_start == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_start", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ts_start), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ts_finish == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_finish", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ts_finish), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_flags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "flags", T_STRUCT, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->flags), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_options == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "options", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->options, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updating == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updating", T_STRUCT, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->updating), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_interval_counter_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalCounter *self = SWCDB_THRIFT_SPEC_INTERVAL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_RANGE_BEGIN:
      if (self->range_begin != NULL)
        g_ptr_array_unref (self->range_begin);
      self->range_begin = g_value_dup_boxed (value);
      self->__isset_range_begin = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_RANGE_END:
      if (self->range_end != NULL)
        g_ptr_array_unref (self->range_end);
      self->range_end = g_value_dup_boxed (value);
      self->__isset_range_end = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OFFSET_KEY:
      if (self->offset_key != NULL)
        g_ptr_array_unref (self->offset_key);
      self->offset_key = g_value_dup_boxed (value);
      self->__isset_offset_key = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OFFSET_REV:
      self->offset_rev = g_value_get_int64 (value);
      self->__isset_offset_rev = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_KEY_INTERVALS:
      if (self->key_intervals != NULL)
        g_ptr_array_unref (self->key_intervals);
      self->key_intervals = g_value_dup_boxed (value);
      self->__isset_key_intervals = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_VALUES:
      if (self->values != NULL)
        g_ptr_array_unref (self->values);
      self->values = g_value_dup_boxed (value);
      self->__isset_values = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_TS_START:
      if (self->ts_start != NULL)
        g_object_unref (self->ts_start);
      self->ts_start = g_value_dup_object (value);
      self->__isset_ts_start = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_TS_FINISH:
      if (self->ts_finish != NULL)
        g_object_unref (self->ts_finish);
      self->ts_finish = g_value_dup_object (value);
      self->__isset_ts_finish = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_FLAGS:
      if (self->flags != NULL)
        g_object_unref (self->flags);
      self->flags = g_value_dup_object (value);
      self->__isset_flags = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OPTIONS:
      self->options = g_value_get_int (value);
      self->__isset_options = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_UPDATING:
      if (self->updating != NULL)
        g_object_unref (self->updating);
      self->updating = g_value_dup_object (value);
      self->__isset_updating = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_interval_counter_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalCounter *self = SWCDB_THRIFT_SPEC_INTERVAL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_RANGE_BEGIN:
      g_value_set_boxed (value, self->range_begin);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_RANGE_END:
      g_value_set_boxed (value, self->range_end);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OFFSET_KEY:
      g_value_set_boxed (value, self->offset_key);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OFFSET_REV:
      g_value_set_int64 (value, self->offset_rev);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_KEY_INTERVALS:
      g_value_set_boxed (value, self->key_intervals);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_VALUES:
      g_value_set_boxed (value, self->values);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_TS_START:
      g_value_set_object (value, self->ts_start);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_TS_FINISH:
      g_value_set_object (value, self->ts_finish);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_FLAGS:
      g_value_set_object (value, self->flags);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OPTIONS:
      g_value_set_int (value, self->options);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_UPDATING:
      g_value_set_object (value, self->updating);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_interval_counter_instance_init (swcdb_thriftSpecIntervalCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->range_begin = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_range_begin = FALSE;
  object->range_end = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_range_end = FALSE;
  object->offset_key = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_offset_key = FALSE;
  object->offset_rev = 0;
  object->__isset_offset_rev = FALSE;
  object->key_intervals = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_key_intervals = FALSE;
  object->values = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_values = FALSE;
  object->ts_start = g_object_new (SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP, NULL);
  object->__isset_ts_start = FALSE;
  object->ts_finish = g_object_new (SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP, NULL);
  object->__isset_ts_finish = FALSE;
  object->flags = g_object_new (SWCDB_THRIFT_TYPE_SPEC_FLAGS, NULL);
  object->__isset_flags = FALSE;
  object->__isset_options = FALSE;
  object->updating = g_object_new (SWCDB_THRIFT_TYPE_SPEC_INTERVAL_UPDATE_COUNTER, NULL);
  object->__isset_updating = FALSE;
}

static void 
swcdb_thrift_spec_interval_counter_finalize (GObject *object)
{
  swcdb_thriftSpecIntervalCounter *tobject = SWCDB_THRIFT_SPEC_INTERVAL_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->range_begin != NULL)
  {
    g_ptr_array_unref (tobject->range_begin);
    tobject->range_begin = NULL;
  }
  if (tobject->range_end != NULL)
  {
    g_ptr_array_unref (tobject->range_end);
    tobject->range_end = NULL;
  }
  if (tobject->offset_key != NULL)
  {
    g_ptr_array_unref (tobject->offset_key);
    tobject->offset_key = NULL;
  }
  if (tobject->key_intervals != NULL)
  {
    g_ptr_array_unref (tobject->key_intervals);
    tobject->key_intervals = NULL;
  }
  if (tobject->values != NULL)
  {
    g_ptr_array_unref (tobject->values);
    tobject->values = NULL;
  }
  if (tobject->ts_start != NULL)
  {
    g_object_unref(tobject->ts_start);
    tobject->ts_start = NULL;
  }
  if (tobject->ts_finish != NULL)
  {
    g_object_unref(tobject->ts_finish);
    tobject->ts_finish = NULL;
  }
  if (tobject->flags != NULL)
  {
    g_object_unref(tobject->flags);
    tobject->flags = NULL;
  }
  if (tobject->updating != NULL)
  {
    g_object_unref(tobject->updating);
    tobject->updating = NULL;
  }
}

static void
swcdb_thrift_spec_interval_counter_class_init (swcdb_thriftSpecIntervalCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_interval_counter_read;
  struct_class->write = swcdb_thrift_spec_interval_counter_write;

  gobject_class->finalize = swcdb_thrift_spec_interval_counter_finalize;
  gobject_class->get_property = swcdb_thrift_spec_interval_counter_get_property;
  gobject_class->set_property = swcdb_thrift_spec_interval_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_RANGE_BEGIN,
     g_param_spec_boxed ("range_begin",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_RANGE_END,
     g_param_spec_boxed ("range_end",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OFFSET_KEY,
     g_param_spec_boxed ("offset_key",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OFFSET_REV,
     g_param_spec_int64 ("offset_rev",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_KEY_INTERVALS,
     g_param_spec_boxed ("key_intervals",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_VALUES,
     g_param_spec_boxed ("values",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_TS_START,
     g_param_spec_object ("ts_start",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_TS_FINISH,
     g_param_spec_object ("ts_finish",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_FLAGS,
     g_param_spec_object ("flags",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_FLAGS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_OPTIONS,
     g_param_spec_int ("options",
                       NULL,
                       NULL,
                       4,
                       8,
                       4,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_COUNTER_UPDATING,
     g_param_spec_object ("updating",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_INTERVAL_UPDATE_COUNTER,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_interval_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecIntervalCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_interval_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecIntervalCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_interval_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecIntervalCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecIntervalSerialProperties
{
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_0,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_RANGE_BEGIN,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_RANGE_END,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OFFSET_KEY,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OFFSET_REV,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_KEY_INTERVALS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_VALUES,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_TS_START,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_TS_FINISH,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_FLAGS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OPTIONS,
  PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_UPDATING
};

/* reads a spec_interval_serial object */
static gint32
swcdb_thrift_spec_interval_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecIntervalSerial * this_object = SWCDB_THRIFT_SPEC_INTERVAL_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem67 = NULL;
              if (_elem67 != NULL)
              {
                g_free(_elem67);
                _elem67 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem67 = g_byte_array_new();
              g_byte_array_append (_elem67, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->range_begin, _elem67);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_range_begin = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem68 = NULL;
              if (_elem68 != NULL)
              {
                g_free(_elem68);
                _elem68 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem68 = g_byte_array_new();
              g_byte_array_append (_elem68, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->range_end, _elem68);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_range_end = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem69 = NULL;
              if (_elem69 != NULL)
              {
                g_free(_elem69);
                _elem69 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem69 = g_byte_array_new();
              g_byte_array_append (_elem69, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->offset_key, _elem69);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_offset_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->offset_rev, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_offset_rev = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecKeyInterval * _elem70 = NULL;
              if ( _elem70 != NULL)
              {
                g_object_unref (_elem70);
              }
              _elem70 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_KEY_INTERVAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem70), protocol, error)) < 0)
              {
                g_object_unref (_elem70);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->key_intervals, _elem70);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_key_intervals = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecValueSerial * _elem71 = NULL;
              if ( _elem71 != NULL)
              {
                g_object_unref (_elem71);
              }
              _elem71 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_VALUE_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem71), protocol, error)) < 0)
              {
                g_object_unref (_elem71);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->values, _elem71);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_values = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ts_start), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ts_start = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 8:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->ts_finish), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_ts_finish = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 9:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->flags), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_flags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 10:
        if (ftype == T_I32)
        {
          gint32 ecast72;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast72, error)) < 0)
            return -1;
          xfer += ret;
          this_object->options = (swcdb_thriftSpecIntervalOptions)ecast72;
          this_object->__isset_options = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 11:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->updating), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_updating = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_interval_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecIntervalSerial * this_object = SWCDB_THRIFT_SPEC_INTERVAL_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecIntervalSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "range_begin", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i73;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->range_begin ? this_object->range_begin->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i73 = 0; i73 < (this_object->range_begin ? this_object->range_begin->len : 0); i73++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i73)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i73)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i73)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_begin, i73)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "range_end", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i74;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->range_end ? this_object->range_end->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i74 = 0; i74 < (this_object->range_end ? this_object->range_end->len : 0); i74++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i74)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i74)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i74)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->range_end, i74)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "offset_key", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i75;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->offset_key ? this_object->offset_key->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i75 = 0; i75 < (this_object->offset_key ? this_object->offset_key->len : 0); i75++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i75)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i75)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i75)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->offset_key, i75)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_offset_rev == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "offset_rev", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->offset_rev, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "key_intervals", T_LIST, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i76;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->key_intervals ? this_object->key_intervals->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i76 = 0; i76 < (this_object->key_intervals ? this_object->key_intervals->len : 0); i76++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->key_intervals, i76))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "values", T_LIST, 6, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i77;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->values ? this_object->values->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i77 = 0; i77 < (this_object->values ? this_object->values->len : 0); i77++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->values, i77))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts_start == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_start", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ts_start), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ts_finish == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_finish", T_STRUCT, 8, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->ts_finish), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_flags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "flags", T_STRUCT, 9, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->flags), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_options == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "options", T_I32, 10, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->options, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_updating == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "updating", T_STRUCT, 11, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->updating), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_interval_serial_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalSerial *self = SWCDB_THRIFT_SPEC_INTERVAL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_RANGE_BEGIN:
      if (self->range_begin != NULL)
        g_ptr_array_unref (self->range_begin);
      self->range_begin = g_value_dup_boxed (value);
      self->__isset_range_begin = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_RANGE_END:
      if (self->range_end != NULL)
        g_ptr_array_unref (self->range_end);
      self->range_end = g_value_dup_boxed (value);
      self->__isset_range_end = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OFFSET_KEY:
      if (self->offset_key != NULL)
        g_ptr_array_unref (self->offset_key);
      self->offset_key = g_value_dup_boxed (value);
      self->__isset_offset_key = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OFFSET_REV:
      self->offset_rev = g_value_get_int64 (value);
      self->__isset_offset_rev = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_KEY_INTERVALS:
      if (self->key_intervals != NULL)
        g_ptr_array_unref (self->key_intervals);
      self->key_intervals = g_value_dup_boxed (value);
      self->__isset_key_intervals = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_VALUES:
      if (self->values != NULL)
        g_ptr_array_unref (self->values);
      self->values = g_value_dup_boxed (value);
      self->__isset_values = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_TS_START:
      if (self->ts_start != NULL)
        g_object_unref (self->ts_start);
      self->ts_start = g_value_dup_object (value);
      self->__isset_ts_start = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_TS_FINISH:
      if (self->ts_finish != NULL)
        g_object_unref (self->ts_finish);
      self->ts_finish = g_value_dup_object (value);
      self->__isset_ts_finish = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_FLAGS:
      if (self->flags != NULL)
        g_object_unref (self->flags);
      self->flags = g_value_dup_object (value);
      self->__isset_flags = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OPTIONS:
      self->options = g_value_get_int (value);
      self->__isset_options = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_UPDATING:
      if (self->updating != NULL)
        g_object_unref (self->updating);
      self->updating = g_value_dup_object (value);
      self->__isset_updating = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_interval_serial_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  swcdb_thriftSpecIntervalSerial *self = SWCDB_THRIFT_SPEC_INTERVAL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_RANGE_BEGIN:
      g_value_set_boxed (value, self->range_begin);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_RANGE_END:
      g_value_set_boxed (value, self->range_end);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OFFSET_KEY:
      g_value_set_boxed (value, self->offset_key);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OFFSET_REV:
      g_value_set_int64 (value, self->offset_rev);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_KEY_INTERVALS:
      g_value_set_boxed (value, self->key_intervals);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_VALUES:
      g_value_set_boxed (value, self->values);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_TS_START:
      g_value_set_object (value, self->ts_start);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_TS_FINISH:
      g_value_set_object (value, self->ts_finish);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_FLAGS:
      g_value_set_object (value, self->flags);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OPTIONS:
      g_value_set_int (value, self->options);
      break;

    case PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_UPDATING:
      g_value_set_object (value, self->updating);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_interval_serial_instance_init (swcdb_thriftSpecIntervalSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->range_begin = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_range_begin = FALSE;
  object->range_end = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_range_end = FALSE;
  object->offset_key = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_offset_key = FALSE;
  object->offset_rev = 0;
  object->__isset_offset_rev = FALSE;
  object->key_intervals = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_key_intervals = FALSE;
  object->values = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_values = FALSE;
  object->ts_start = g_object_new (SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP, NULL);
  object->__isset_ts_start = FALSE;
  object->ts_finish = g_object_new (SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP, NULL);
  object->__isset_ts_finish = FALSE;
  object->flags = g_object_new (SWCDB_THRIFT_TYPE_SPEC_FLAGS, NULL);
  object->__isset_flags = FALSE;
  object->__isset_options = FALSE;
  object->updating = g_object_new (SWCDB_THRIFT_TYPE_SPEC_INTERVAL_UPDATE_SERIAL, NULL);
  object->__isset_updating = FALSE;
}

static void 
swcdb_thrift_spec_interval_serial_finalize (GObject *object)
{
  swcdb_thriftSpecIntervalSerial *tobject = SWCDB_THRIFT_SPEC_INTERVAL_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->range_begin != NULL)
  {
    g_ptr_array_unref (tobject->range_begin);
    tobject->range_begin = NULL;
  }
  if (tobject->range_end != NULL)
  {
    g_ptr_array_unref (tobject->range_end);
    tobject->range_end = NULL;
  }
  if (tobject->offset_key != NULL)
  {
    g_ptr_array_unref (tobject->offset_key);
    tobject->offset_key = NULL;
  }
  if (tobject->key_intervals != NULL)
  {
    g_ptr_array_unref (tobject->key_intervals);
    tobject->key_intervals = NULL;
  }
  if (tobject->values != NULL)
  {
    g_ptr_array_unref (tobject->values);
    tobject->values = NULL;
  }
  if (tobject->ts_start != NULL)
  {
    g_object_unref(tobject->ts_start);
    tobject->ts_start = NULL;
  }
  if (tobject->ts_finish != NULL)
  {
    g_object_unref(tobject->ts_finish);
    tobject->ts_finish = NULL;
  }
  if (tobject->flags != NULL)
  {
    g_object_unref(tobject->flags);
    tobject->flags = NULL;
  }
  if (tobject->updating != NULL)
  {
    g_object_unref(tobject->updating);
    tobject->updating = NULL;
  }
}

static void
swcdb_thrift_spec_interval_serial_class_init (swcdb_thriftSpecIntervalSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_interval_serial_read;
  struct_class->write = swcdb_thrift_spec_interval_serial_write;

  gobject_class->finalize = swcdb_thrift_spec_interval_serial_finalize;
  gobject_class->get_property = swcdb_thrift_spec_interval_serial_get_property;
  gobject_class->set_property = swcdb_thrift_spec_interval_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_RANGE_BEGIN,
     g_param_spec_boxed ("range_begin",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_RANGE_END,
     g_param_spec_boxed ("range_end",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OFFSET_KEY,
     g_param_spec_boxed ("offset_key",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OFFSET_REV,
     g_param_spec_int64 ("offset_rev",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_KEY_INTERVALS,
     g_param_spec_boxed ("key_intervals",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_VALUES,
     g_param_spec_boxed ("values",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_TS_START,
     g_param_spec_object ("ts_start",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_TS_FINISH,
     g_param_spec_object ("ts_finish",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_TIMESTAMP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_FLAGS,
     g_param_spec_object ("flags",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_FLAGS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_OPTIONS,
     g_param_spec_int ("options",
                       NULL,
                       NULL,
                       4,
                       8,
                       4,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_INTERVAL_SERIAL_UPDATING,
     g_param_spec_object ("updating",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_INTERVAL_UPDATE_SERIAL,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_interval_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecIntervalSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_interval_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecIntervalSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_interval_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecIntervalSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecColumnPlainProperties
{
  PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_0,
  PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_CID,
  PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_INTERVALS
};

/* reads a spec_column_plain object */
static gint32
swcdb_thrift_spec_column_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecColumnPlain * this_object = SWCDB_THRIFT_SPEC_COLUMN_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->cid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecIntervalPlain * _elem78 = NULL;
              if ( _elem78 != NULL)
              {
                g_object_unref (_elem78);
              }
              _elem78 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_INTERVAL_PLAIN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem78), protocol, error)) < 0)
              {
                g_object_unref (_elem78);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->intervals, _elem78);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_intervals = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_column_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecColumnPlain * this_object = SWCDB_THRIFT_SPEC_COLUMN_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecColumnPlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cid", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->cid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "intervals", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i79;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->intervals ? this_object->intervals->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i79 = 0; i79 < (this_object->intervals ? this_object->intervals->len : 0); i79++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->intervals, i79))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_column_plain_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftSpecColumnPlain *self = SWCDB_THRIFT_SPEC_COLUMN_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_CID:
      self->cid = g_value_get_int64 (value);
      self->__isset_cid = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_INTERVALS:
      if (self->intervals != NULL)
        g_ptr_array_unref (self->intervals);
      self->intervals = g_value_dup_boxed (value);
      self->__isset_intervals = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_column_plain_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftSpecColumnPlain *self = SWCDB_THRIFT_SPEC_COLUMN_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_CID:
      g_value_set_int64 (value, self->cid);
      break;

    case PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_INTERVALS:
      g_value_set_boxed (value, self->intervals);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_column_plain_instance_init (swcdb_thriftSpecColumnPlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cid = 0;
  object->__isset_cid = FALSE;
  object->intervals = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_intervals = FALSE;
}

static void 
swcdb_thrift_spec_column_plain_finalize (GObject *object)
{
  swcdb_thriftSpecColumnPlain *tobject = SWCDB_THRIFT_SPEC_COLUMN_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->intervals != NULL)
  {
    g_ptr_array_unref (tobject->intervals);
    tobject->intervals = NULL;
  }
}

static void
swcdb_thrift_spec_column_plain_class_init (swcdb_thriftSpecColumnPlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_column_plain_read;
  struct_class->write = swcdb_thrift_spec_column_plain_write;

  gobject_class->finalize = swcdb_thrift_spec_column_plain_finalize;
  gobject_class->get_property = swcdb_thrift_spec_column_plain_get_property;
  gobject_class->set_property = swcdb_thrift_spec_column_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_CID,
     g_param_spec_int64 ("cid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_COLUMN_PLAIN_INTERVALS,
     g_param_spec_boxed ("intervals",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_column_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecColumnPlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_column_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecColumnPlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_column_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecColumnPlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecColumnCounterProperties
{
  PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_0,
  PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_CID,
  PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_INTERVALS
};

/* reads a spec_column_counter object */
static gint32
swcdb_thrift_spec_column_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecColumnCounter * this_object = SWCDB_THRIFT_SPEC_COLUMN_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->cid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecIntervalCounter * _elem80 = NULL;
              if ( _elem80 != NULL)
              {
                g_object_unref (_elem80);
              }
              _elem80 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_INTERVAL_COUNTER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem80), protocol, error)) < 0)
              {
                g_object_unref (_elem80);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->intervals, _elem80);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_intervals = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_column_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecColumnCounter * this_object = SWCDB_THRIFT_SPEC_COLUMN_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecColumnCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cid", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->cid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "intervals", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i81;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->intervals ? this_object->intervals->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i81 = 0; i81 < (this_object->intervals ? this_object->intervals->len : 0); i81++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->intervals, i81))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_column_counter_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  swcdb_thriftSpecColumnCounter *self = SWCDB_THRIFT_SPEC_COLUMN_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_CID:
      self->cid = g_value_get_int64 (value);
      self->__isset_cid = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_INTERVALS:
      if (self->intervals != NULL)
        g_ptr_array_unref (self->intervals);
      self->intervals = g_value_dup_boxed (value);
      self->__isset_intervals = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_column_counter_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  swcdb_thriftSpecColumnCounter *self = SWCDB_THRIFT_SPEC_COLUMN_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_CID:
      g_value_set_int64 (value, self->cid);
      break;

    case PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_INTERVALS:
      g_value_set_boxed (value, self->intervals);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_column_counter_instance_init (swcdb_thriftSpecColumnCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cid = 0;
  object->__isset_cid = FALSE;
  object->intervals = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_intervals = FALSE;
}

static void 
swcdb_thrift_spec_column_counter_finalize (GObject *object)
{
  swcdb_thriftSpecColumnCounter *tobject = SWCDB_THRIFT_SPEC_COLUMN_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->intervals != NULL)
  {
    g_ptr_array_unref (tobject->intervals);
    tobject->intervals = NULL;
  }
}

static void
swcdb_thrift_spec_column_counter_class_init (swcdb_thriftSpecColumnCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_column_counter_read;
  struct_class->write = swcdb_thrift_spec_column_counter_write;

  gobject_class->finalize = swcdb_thrift_spec_column_counter_finalize;
  gobject_class->get_property = swcdb_thrift_spec_column_counter_get_property;
  gobject_class->set_property = swcdb_thrift_spec_column_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_CID,
     g_param_spec_int64 ("cid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_COLUMN_COUNTER_INTERVALS,
     g_param_spec_boxed ("intervals",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_column_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecColumnCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_column_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecColumnCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_column_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecColumnCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecColumnSerialProperties
{
  PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_0,
  PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_CID,
  PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_INTERVALS
};

/* reads a spec_column_serial object */
static gint32
swcdb_thrift_spec_column_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecColumnSerial * this_object = SWCDB_THRIFT_SPEC_COLUMN_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->cid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecIntervalSerial * _elem82 = NULL;
              if ( _elem82 != NULL)
              {
                g_object_unref (_elem82);
              }
              _elem82 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_INTERVAL_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem82), protocol, error)) < 0)
              {
                g_object_unref (_elem82);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->intervals, _elem82);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_intervals = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_column_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecColumnSerial * this_object = SWCDB_THRIFT_SPEC_COLUMN_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecColumnSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cid", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->cid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "intervals", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i83;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->intervals ? this_object->intervals->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i83 = 0; i83 < (this_object->intervals ? this_object->intervals->len : 0); i83++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->intervals, i83))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_column_serial_set_property (GObject *object,
                                              guint property_id,
                                              const GValue *value,
                                              GParamSpec *pspec)
{
  swcdb_thriftSpecColumnSerial *self = SWCDB_THRIFT_SPEC_COLUMN_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_CID:
      self->cid = g_value_get_int64 (value);
      self->__isset_cid = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_INTERVALS:
      if (self->intervals != NULL)
        g_ptr_array_unref (self->intervals);
      self->intervals = g_value_dup_boxed (value);
      self->__isset_intervals = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_column_serial_get_property (GObject *object,
                                              guint property_id,
                                              GValue *value,
                                              GParamSpec *pspec)
{
  swcdb_thriftSpecColumnSerial *self = SWCDB_THRIFT_SPEC_COLUMN_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_CID:
      g_value_set_int64 (value, self->cid);
      break;

    case PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_INTERVALS:
      g_value_set_boxed (value, self->intervals);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_column_serial_instance_init (swcdb_thriftSpecColumnSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cid = 0;
  object->__isset_cid = FALSE;
  object->intervals = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_intervals = FALSE;
}

static void 
swcdb_thrift_spec_column_serial_finalize (GObject *object)
{
  swcdb_thriftSpecColumnSerial *tobject = SWCDB_THRIFT_SPEC_COLUMN_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->intervals != NULL)
  {
    g_ptr_array_unref (tobject->intervals);
    tobject->intervals = NULL;
  }
}

static void
swcdb_thrift_spec_column_serial_class_init (swcdb_thriftSpecColumnSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_column_serial_read;
  struct_class->write = swcdb_thrift_spec_column_serial_write;

  gobject_class->finalize = swcdb_thrift_spec_column_serial_finalize;
  gobject_class->get_property = swcdb_thrift_spec_column_serial_get_property;
  gobject_class->set_property = swcdb_thrift_spec_column_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_CID,
     g_param_spec_int64 ("cid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_COLUMN_SERIAL_INTERVALS,
     g_param_spec_boxed ("intervals",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_column_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecColumnSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_column_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecColumnSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_column_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecColumnSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftSpecScanProperties
{
  PROP_SWCDB_THRIFT_SPEC_SCAN_0,
  PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_PLAIN,
  PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_COUNTER,
  PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_SERIAL,
  PROP_SWCDB_THRIFT_SPEC_SCAN_FLAGS
};

/* reads a spec_scan object */
static gint32
swcdb_thrift_spec_scan_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftSpecScan * this_object = SWCDB_THRIFT_SPEC_SCAN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecColumnPlain * _elem84 = NULL;
              if ( _elem84 != NULL)
              {
                g_object_unref (_elem84);
              }
              _elem84 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_COLUMN_PLAIN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem84), protocol, error)) < 0)
              {
                g_object_unref (_elem84);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns_plain, _elem84);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns_plain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecColumnCounter * _elem85 = NULL;
              if ( _elem85 != NULL)
              {
                g_object_unref (_elem85);
              }
              _elem85 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_COLUMN_COUNTER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem85), protocol, error)) < 0)
              {
                g_object_unref (_elem85);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns_counter, _elem85);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns_counter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSpecColumnSerial * _elem86 = NULL;
              if ( _elem86 != NULL)
              {
                g_object_unref (_elem86);
              }
              _elem86 = g_object_new (SWCDB_THRIFT_TYPE_SPEC_COLUMN_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem86), protocol, error)) < 0)
              {
                g_object_unref (_elem86);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->columns_serial, _elem86);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_columns_serial = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->flags), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_flags = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_spec_scan_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftSpecScan * this_object = SWCDB_THRIFT_SPEC_SCAN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "SpecScan", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns_plain", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i87;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns_plain ? this_object->columns_plain->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i87 = 0; i87 < (this_object->columns_plain ? this_object->columns_plain->len : 0); i87++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns_plain, i87))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns_counter", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i88;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns_counter ? this_object->columns_counter->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i88 = 0; i88 < (this_object->columns_counter ? this_object->columns_counter->len : 0); i88++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns_counter, i88))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "columns_serial", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i89;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->columns_serial ? this_object->columns_serial->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i89 = 0; i89 < (this_object->columns_serial ? this_object->columns_serial->len : 0); i89++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->columns_serial, i89))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_flags == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "flags", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->flags), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_spec_scan_set_property (GObject *object,
                                     guint property_id,
                                     const GValue *value,
                                     GParamSpec *pspec)
{
  swcdb_thriftSpecScan *self = SWCDB_THRIFT_SPEC_SCAN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_PLAIN:
      if (self->columns_plain != NULL)
        g_ptr_array_unref (self->columns_plain);
      self->columns_plain = g_value_dup_boxed (value);
      self->__isset_columns_plain = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_COUNTER:
      if (self->columns_counter != NULL)
        g_ptr_array_unref (self->columns_counter);
      self->columns_counter = g_value_dup_boxed (value);
      self->__isset_columns_counter = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_SERIAL:
      if (self->columns_serial != NULL)
        g_ptr_array_unref (self->columns_serial);
      self->columns_serial = g_value_dup_boxed (value);
      self->__isset_columns_serial = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCAN_FLAGS:
      if (self->flags != NULL)
        g_object_unref (self->flags);
      self->flags = g_value_dup_object (value);
      self->__isset_flags = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_spec_scan_get_property (GObject *object,
                                     guint property_id,
                                     GValue *value,
                                     GParamSpec *pspec)
{
  swcdb_thriftSpecScan *self = SWCDB_THRIFT_SPEC_SCAN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_PLAIN:
      g_value_set_boxed (value, self->columns_plain);
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_COUNTER:
      g_value_set_boxed (value, self->columns_counter);
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_SERIAL:
      g_value_set_boxed (value, self->columns_serial);
      break;

    case PROP_SWCDB_THRIFT_SPEC_SCAN_FLAGS:
      g_value_set_object (value, self->flags);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_spec_scan_instance_init (swcdb_thriftSpecScan * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->columns_plain = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columns_plain = FALSE;
  object->columns_counter = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columns_counter = FALSE;
  object->columns_serial = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_columns_serial = FALSE;
  object->flags = g_object_new (SWCDB_THRIFT_TYPE_SPEC_FLAGS, NULL);
  object->__isset_flags = FALSE;
}

static void 
swcdb_thrift_spec_scan_finalize (GObject *object)
{
  swcdb_thriftSpecScan *tobject = SWCDB_THRIFT_SPEC_SCAN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->columns_plain != NULL)
  {
    g_ptr_array_unref (tobject->columns_plain);
    tobject->columns_plain = NULL;
  }
  if (tobject->columns_counter != NULL)
  {
    g_ptr_array_unref (tobject->columns_counter);
    tobject->columns_counter = NULL;
  }
  if (tobject->columns_serial != NULL)
  {
    g_ptr_array_unref (tobject->columns_serial);
    tobject->columns_serial = NULL;
  }
  if (tobject->flags != NULL)
  {
    g_object_unref(tobject->flags);
    tobject->flags = NULL;
  }
}

static void
swcdb_thrift_spec_scan_class_init (swcdb_thriftSpecScanClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_spec_scan_read;
  struct_class->write = swcdb_thrift_spec_scan_write;

  gobject_class->finalize = swcdb_thrift_spec_scan_finalize;
  gobject_class->get_property = swcdb_thrift_spec_scan_get_property;
  gobject_class->set_property = swcdb_thrift_spec_scan_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_PLAIN,
     g_param_spec_boxed ("columns_plain",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_COUNTER,
     g_param_spec_boxed ("columns_counter",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_SCAN_COLUMNS_SERIAL,
     g_param_spec_boxed ("columns_serial",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SPEC_SCAN_FLAGS,
     g_param_spec_object ("flags",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_FLAGS,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_spec_scan_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftSpecScanClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_spec_scan_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftSpecScan),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_spec_scan_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftSpecScanType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftUCellPlainProperties
{
  PROP_SWCDB_THRIFT_U_CELL_PLAIN_0,
  PROP_SWCDB_THRIFT_U_CELL_PLAIN_F,
  PROP_SWCDB_THRIFT_U_CELL_PLAIN_K,
  PROP_SWCDB_THRIFT_U_CELL_PLAIN_TS,
  PROP_SWCDB_THRIFT_U_CELL_PLAIN_TS_DESC,
  PROP_SWCDB_THRIFT_U_CELL_PLAIN_V,
  PROP_SWCDB_THRIFT_U_CELL_PLAIN_ENCODER
};

/* reads a u_cell_plain object */
static gint32
swcdb_thrift_u_cell_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftUCellPlain * this_object = SWCDB_THRIFT_U_CELL_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast90;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast90, error)) < 0)
            return -1;
          xfer += ret;
          this_object->f = (swcdb_thriftFlag)ecast90;
          this_object->__isset_f = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem91 = NULL;
              if (_elem91 != NULL)
              {
                g_free(_elem91);
                _elem91 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem91 = g_byte_array_new();
              g_byte_array_append (_elem91, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem91);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->ts_desc, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts_desc = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast92;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast92, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoder = (swcdb_thriftEncodingType)ecast92;
          this_object->__isset_encoder = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_u_cell_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftUCellPlain * this_object = SWCDB_THRIFT_U_CELL_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UCellPlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "f", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->f, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i93;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i93 = 0; i93 < (this_object->k ? this_object->k->len : 0); i93++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i93)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i93)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i93)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i93)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ts_desc == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_desc", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->ts_desc, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_encoder == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encoder", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoder, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_u_cell_plain_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftUCellPlain *self = SWCDB_THRIFT_U_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_F:
      self->f = g_value_get_int (value);
      self->__isset_f = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_TS_DESC:
      self->ts_desc = g_value_get_boolean (value);
      self->__isset_ts_desc = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_ENCODER:
      self->encoder = g_value_get_int (value);
      self->__isset_encoder = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_u_cell_plain_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftUCellPlain *self = SWCDB_THRIFT_U_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_F:
      g_value_set_int (value, self->f);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_TS_DESC:
      g_value_set_boolean (value, self->ts_desc);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_V:
      g_value_set_boxed (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_PLAIN_ENCODER:
      g_value_set_int (value, self->encoder);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_u_cell_plain_instance_init (swcdb_thriftUCellPlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_f = FALSE;
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->ts_desc = 0;
  object->__isset_ts_desc = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
  object->__isset_encoder = FALSE;
}

static void 
swcdb_thrift_u_cell_plain_finalize (GObject *object)
{
  swcdb_thriftUCellPlain *tobject = SWCDB_THRIFT_U_CELL_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_u_cell_plain_class_init (swcdb_thriftUCellPlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_u_cell_plain_read;
  struct_class->write = swcdb_thrift_u_cell_plain_write;

  gobject_class->finalize = swcdb_thrift_u_cell_plain_finalize;
  gobject_class->get_property = swcdb_thrift_u_cell_plain_get_property;
  gobject_class->set_property = swcdb_thrift_u_cell_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_PLAIN_F,
     g_param_spec_int ("f",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_PLAIN_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_PLAIN_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_PLAIN_TS_DESC,
     g_param_spec_boolean ("ts_desc",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_PLAIN_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_PLAIN_ENCODER,
     g_param_spec_int ("encoder",
                       NULL,
                       NULL,
                       0,
                       255,
                       0,
                       G_PARAM_READWRITE));
}

GType
swcdb_thrift_u_cell_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftUCellPlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_u_cell_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftUCellPlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_u_cell_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftUCellPlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftUCellCounterProperties
{
  PROP_SWCDB_THRIFT_U_CELL_COUNTER_0,
  PROP_SWCDB_THRIFT_U_CELL_COUNTER_F,
  PROP_SWCDB_THRIFT_U_CELL_COUNTER_K,
  PROP_SWCDB_THRIFT_U_CELL_COUNTER_TS,
  PROP_SWCDB_THRIFT_U_CELL_COUNTER_TS_DESC,
  PROP_SWCDB_THRIFT_U_CELL_COUNTER_OP,
  PROP_SWCDB_THRIFT_U_CELL_COUNTER_V
};

/* reads a u_cell_counter object */
static gint32
swcdb_thrift_u_cell_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftUCellCounter * this_object = SWCDB_THRIFT_U_CELL_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast94;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast94, error)) < 0)
            return -1;
          xfer += ret;
          this_object->f = (swcdb_thriftFlag)ecast94;
          this_object->__isset_f = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem95 = NULL;
              if (_elem95 != NULL)
              {
                g_free(_elem95);
                _elem95 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem95 = g_byte_array_new();
              g_byte_array_append (_elem95, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem95);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->ts_desc, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts_desc = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->op, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_u_cell_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftUCellCounter * this_object = SWCDB_THRIFT_U_CELL_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UCellCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "f", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->f, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i96;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i96 = 0; i96 < (this_object->k ? this_object->k->len : 0); i96++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i96)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i96)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i96)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i96)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ts_desc == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_desc", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->ts_desc, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_BYTE, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 6, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_u_cell_counter_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftUCellCounter *self = SWCDB_THRIFT_U_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_F:
      self->f = g_value_get_int (value);
      self->__isset_f = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_TS_DESC:
      self->ts_desc = g_value_get_boolean (value);
      self->__isset_ts_desc = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_u_cell_counter_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftUCellCounter *self = SWCDB_THRIFT_U_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_F:
      g_value_set_int (value, self->f);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_TS_DESC:
      g_value_set_boolean (value, self->ts_desc);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_COUNTER_V:
      g_value_set_int64 (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_u_cell_counter_instance_init (swcdb_thriftUCellCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_f = FALSE;
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->ts_desc = 0;
  object->__isset_ts_desc = FALSE;
  object->op = 0;
  object->__isset_op = FALSE;
  object->v = G_GINT64_CONSTANT (0);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_u_cell_counter_finalize (GObject *object)
{
  swcdb_thriftUCellCounter *tobject = SWCDB_THRIFT_U_CELL_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
}

static void
swcdb_thrift_u_cell_counter_class_init (swcdb_thriftUCellCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_u_cell_counter_read;
  struct_class->write = swcdb_thrift_u_cell_counter_write;

  gobject_class->finalize = swcdb_thrift_u_cell_counter_finalize;
  gobject_class->get_property = swcdb_thrift_u_cell_counter_get_property;
  gobject_class->set_property = swcdb_thrift_u_cell_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_COUNTER_F,
     g_param_spec_int ("f",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_COUNTER_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_COUNTER_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_COUNTER_TS_DESC,
     g_param_spec_boolean ("ts_desc",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_COUNTER_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_COUNTER_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_u_cell_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftUCellCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_u_cell_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftUCellCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_u_cell_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftUCellCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCellValueSerialProperties
{
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_0,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_FIELD_ID,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_INT64,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_DOUBLE,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_BYTES,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_KEY,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_LI,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_LB
};

/* reads a cell_value_serial object */
static gint32
swcdb_thrift_cell_value_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCellValueSerial * this_object = SWCDB_THRIFT_CELL_VALUE_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v_int64, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v_int64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->v_double, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v_double = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->v_bytes != NULL)
          {
            g_free(this_object->v_bytes);
            this_object->v_bytes = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v_bytes = g_byte_array_new();
          g_byte_array_append (this_object->v_bytes, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v_bytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem97 = NULL;
              if (_elem97 != NULL)
              {
                g_free(_elem97);
                _elem97 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem97 = g_byte_array_new();
              g_byte_array_append (_elem97, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->v_key, _elem97);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              gint64* _elem98 = g_new (gint64, 1);
              if ((ret = thrift_protocol_read_i64 (protocol, &*_elem98, error)) < 0)
                return -1;
              xfer += ret;
              g_array_append_vals (this_object->v_li, _elem98, 1);
              g_free (_elem98);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v_li = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem99 = NULL;
              if (_elem99 != NULL)
              {
                g_free(_elem99);
                _elem99 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem99 = g_byte_array_new();
              g_byte_array_append (_elem99, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->v_lb, _elem99);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v_lb = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_cell_value_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCellValueSerial * this_object = SWCDB_THRIFT_CELL_VALUE_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CellValueSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field_id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->field_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_v_int64 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_int64", T_I64, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->v_int64, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_double == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_double", T_DOUBLE, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_double (protocol, this_object->v_double, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_bytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_bytes", T_STRING, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_binary (protocol, this_object->v_bytes ? ((GByteArray *) this_object->v_bytes)->data : NULL, this_object->v_bytes ? ((GByteArray *) this_object->v_bytes)->len : 0, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_key == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_key", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i100;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->v_key ? this_object->v_key->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i100 = 0; i100 < (this_object->v_key ? this_object->v_key->len : 0); i100++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_key, i100)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_key, i100)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_key, i100)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_key, i100)))->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_li == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_li", T_LIST, 6, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i101;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_I64, (gint32) (this_object->v_li ? this_object->v_li->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i101 = 0; i101 < (this_object->v_li ? this_object->v_li->len : 0); i101++)
      {
        if ((ret = thrift_protocol_write_i64 (protocol, (g_array_index (this_object->v_li, gint64, i101)), error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_lb == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_lb", T_LIST, 7, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i102;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->v_lb ? this_object->v_lb->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i102 = 0; i102 < (this_object->v_lb ? this_object->v_lb->len : 0); i102++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_lb, i102)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_lb, i102)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_lb, i102)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_lb, i102)))->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_cell_value_serial_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftCellValueSerial *self = SWCDB_THRIFT_CELL_VALUE_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_FIELD_ID:
      self->field_id = g_value_get_int (value);
      self->__isset_field_id = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_INT64:
      self->v_int64 = g_value_get_int64 (value);
      self->__isset_v_int64 = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_DOUBLE:
      self->v_double = g_value_get_double (value);
      self->__isset_v_double = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_BYTES:
      if (self->v_bytes != NULL)
        g_byte_array_unref (self->v_bytes);
      self->v_bytes = g_value_dup_boxed (value);
      self->__isset_v_bytes = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_KEY:
      if (self->v_key != NULL)
        g_ptr_array_unref (self->v_key);
      self->v_key = g_value_dup_boxed (value);
      self->__isset_v_key = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_LI:
      if (self->v_li != NULL)
        g_array_unref (self->v_li);
      self->v_li = g_value_dup_boxed (value);
      self->__isset_v_li = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_LB:
      if (self->v_lb != NULL)
        g_ptr_array_unref (self->v_lb);
      self->v_lb = g_value_dup_boxed (value);
      self->__isset_v_lb = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_cell_value_serial_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftCellValueSerial *self = SWCDB_THRIFT_CELL_VALUE_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_FIELD_ID:
      g_value_set_int (value, self->field_id);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_INT64:
      g_value_set_int64 (value, self->v_int64);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_DOUBLE:
      g_value_set_double (value, self->v_double);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_BYTES:
      g_value_set_boxed (value, self->v_bytes);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_KEY:
      g_value_set_boxed (value, self->v_key);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_LI:
      g_value_set_boxed (value, self->v_li);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_LB:
      g_value_set_boxed (value, self->v_lb);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_cell_value_serial_instance_init (swcdb_thriftCellValueSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field_id = 0;
  object->__isset_field_id = FALSE;
  object->v_int64 = 0;
  object->__isset_v_int64 = FALSE;
  object->v_double = 0;
  object->__isset_v_double = FALSE;
  object->v_bytes = NULL;
  object->__isset_v_bytes = FALSE;
  object->v_key = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_v_key = FALSE;
  object->v_li = g_array_new (0, 1, sizeof (gint64));
  object->__isset_v_li = FALSE;
  object->v_lb = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_v_lb = FALSE;
}

static void 
swcdb_thrift_cell_value_serial_finalize (GObject *object)
{
  swcdb_thriftCellValueSerial *tobject = SWCDB_THRIFT_CELL_VALUE_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v_bytes != NULL)
  {
    thrift_string_free(tobject->v_bytes);
    tobject->v_bytes = NULL;
  }
  if (tobject->v_key != NULL)
  {
    g_ptr_array_unref (tobject->v_key);
    tobject->v_key = NULL;
  }
  if (tobject->v_li != NULL)
  {
    g_array_unref (tobject->v_li);
    tobject->v_li = NULL;
  }
  if (tobject->v_lb != NULL)
  {
    g_ptr_array_unref (tobject->v_lb);
    tobject->v_lb = NULL;
  }
}

static void
swcdb_thrift_cell_value_serial_class_init (swcdb_thriftCellValueSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_cell_value_serial_read;
  struct_class->write = swcdb_thrift_cell_value_serial_write;

  gobject_class->finalize = swcdb_thrift_cell_value_serial_finalize;
  gobject_class->get_property = swcdb_thrift_cell_value_serial_get_property;
  gobject_class->set_property = swcdb_thrift_cell_value_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_FIELD_ID,
     g_param_spec_int ("field_id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_INT64,
     g_param_spec_int64 ("v_int64",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_DOUBLE,
     g_param_spec_double ("v_double",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_BYTES,
     g_param_spec_boxed ("v_bytes",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_KEY,
     g_param_spec_boxed ("v_key",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_LI,
     g_param_spec_boxed ("v_li",
                         NULL,
                         NULL,
                         G_TYPE_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_V_LB,
     g_param_spec_boxed ("v_lb",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_cell_value_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCellValueSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_cell_value_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCellValueSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_cell_value_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCellValueSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFU_INT64Properties
{
  PROP_SWCDB_THRIFT_F_U__I_N_T64_0,
  PROP_SWCDB_THRIFT_F_U__I_N_T64_CTRL,
  PROP_SWCDB_THRIFT_F_U__I_N_T64_OP,
  PROP_SWCDB_THRIFT_F_U__I_N_T64_POS,
  PROP_SWCDB_THRIFT_F_U__I_N_T64_COMP,
  PROP_SWCDB_THRIFT_F_U__I_N_T64_V
};

/* reads a f_u__i_n_t64 object */
static gint32
swcdb_thrift_f_u__i_n_t64_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFU_INT64 * this_object = SWCDB_THRIFT_F_U__I_N_T64(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->ctrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ctrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast103;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast103, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (swcdb_thriftFU_MATH_OP)ecast103;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->pos, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pos = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast104;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast104, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast104;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_u__i_n_t64_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFU_INT64 * this_object = SWCDB_THRIFT_F_U__I_N_T64(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FU_INT64", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ctrl", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->ctrl, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_pos == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pos", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->pos, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_comp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_u__i_n_t64_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftFU_INT64 *self = SWCDB_THRIFT_F_U__I_N_T64 (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__I_N_T64_CTRL:
      self->ctrl = g_value_get_int (value);
      self->__isset_ctrl = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__I_N_T64_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__I_N_T64_POS:
      self->pos = g_value_get_int (value);
      self->__isset_pos = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__I_N_T64_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__I_N_T64_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_u__i_n_t64_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftFU_INT64 *self = SWCDB_THRIFT_F_U__I_N_T64 (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__I_N_T64_CTRL:
      g_value_set_int (value, self->ctrl);
      break;

    case PROP_SWCDB_THRIFT_F_U__I_N_T64_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_SWCDB_THRIFT_F_U__I_N_T64_POS:
      g_value_set_int (value, self->pos);
      break;

    case PROP_SWCDB_THRIFT_F_U__I_N_T64_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_F_U__I_N_T64_V:
      g_value_set_int64 (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_u__i_n_t64_instance_init (swcdb_thriftFU_INT64 * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ctrl = 0;
  object->__isset_ctrl = FALSE;
  object->__isset_op = FALSE;
  object->pos = 0;
  object->__isset_pos = FALSE;
  object->__isset_comp = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_f_u__i_n_t64_finalize (GObject *object)
{
  swcdb_thriftFU_INT64 *tobject = SWCDB_THRIFT_F_U__I_N_T64 (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_f_u__i_n_t64_class_init (swcdb_thriftFU_INT64Class * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_u__i_n_t64_read;
  struct_class->write = swcdb_thrift_f_u__i_n_t64_write;

  gobject_class->finalize = swcdb_thrift_f_u__i_n_t64_finalize;
  gobject_class->get_property = swcdb_thrift_f_u__i_n_t64_get_property;
  gobject_class->set_property = swcdb_thrift_f_u__i_n_t64_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__I_N_T64_CTRL,
     g_param_spec_int ("ctrl",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__I_N_T64_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__I_N_T64_POS,
     g_param_spec_int ("pos",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__I_N_T64_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__I_N_T64_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_u__i_n_t64_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFU_INT64Class),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_u__i_n_t64_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFU_INT64),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_u__i_n_t64_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFU_INT64Type",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFU_DOUBLEProperties
{
  PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_0,
  PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_CTRL,
  PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_OP,
  PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_POS,
  PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_COMP,
  PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_V
};

/* reads a f_u__d_o_u_b_l_e object */
static gint32
swcdb_thrift_f_u__d_o_u_b_l_e_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFU_DOUBLE * this_object = SWCDB_THRIFT_F_U__D_O_U_B_L_E(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->ctrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ctrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast105;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast105, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (swcdb_thriftFU_MATH_OP)ecast105;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->pos, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pos = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast106;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast106, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast106;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_DOUBLE)
        {
          if ((ret = thrift_protocol_read_double (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_u__d_o_u_b_l_e_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFU_DOUBLE * this_object = SWCDB_THRIFT_F_U__D_O_U_B_L_E(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FU_DOUBLE", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ctrl", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->ctrl, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_pos == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pos", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->pos, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_comp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_DOUBLE, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_double (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_u__d_o_u_b_l_e_set_property (GObject *object,
                                            guint property_id,
                                            const GValue *value,
                                            GParamSpec *pspec)
{
  swcdb_thriftFU_DOUBLE *self = SWCDB_THRIFT_F_U__D_O_U_B_L_E (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_CTRL:
      self->ctrl = g_value_get_int (value);
      self->__isset_ctrl = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_POS:
      self->pos = g_value_get_int (value);
      self->__isset_pos = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_V:
      self->v = g_value_get_double (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_u__d_o_u_b_l_e_get_property (GObject *object,
                                            guint property_id,
                                            GValue *value,
                                            GParamSpec *pspec)
{
  swcdb_thriftFU_DOUBLE *self = SWCDB_THRIFT_F_U__D_O_U_B_L_E (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_CTRL:
      g_value_set_int (value, self->ctrl);
      break;

    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_POS:
      g_value_set_int (value, self->pos);
      break;

    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_V:
      g_value_set_double (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_u__d_o_u_b_l_e_instance_init (swcdb_thriftFU_DOUBLE * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ctrl = 0;
  object->__isset_ctrl = FALSE;
  object->__isset_op = FALSE;
  object->pos = 0;
  object->__isset_pos = FALSE;
  object->__isset_comp = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_f_u__d_o_u_b_l_e_finalize (GObject *object)
{
  swcdb_thriftFU_DOUBLE *tobject = SWCDB_THRIFT_F_U__D_O_U_B_L_E (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_f_u__d_o_u_b_l_e_class_init (swcdb_thriftFU_DOUBLEClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_u__d_o_u_b_l_e_read;
  struct_class->write = swcdb_thrift_f_u__d_o_u_b_l_e_write;

  gobject_class->finalize = swcdb_thrift_f_u__d_o_u_b_l_e_finalize;
  gobject_class->get_property = swcdb_thrift_f_u__d_o_u_b_l_e_get_property;
  gobject_class->set_property = swcdb_thrift_f_u__d_o_u_b_l_e_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_CTRL,
     g_param_spec_int ("ctrl",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_POS,
     g_param_spec_int ("pos",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__D_O_U_B_L_E_V,
     g_param_spec_double ("v",
                          NULL,
                          NULL,
                          -INFINITY,
                          INFINITY,
                          0,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_u__d_o_u_b_l_e_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFU_DOUBLEClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_u__d_o_u_b_l_e_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFU_DOUBLE),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_u__d_o_u_b_l_e_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFU_DOUBLEType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFU_BYTESProperties
{
  PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_0,
  PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_CTRL,
  PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_OP,
  PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_POS,
  PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_COMP,
  PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_V
};

/* reads a f_u__b_y_t_e_s object */
static gint32
swcdb_thrift_f_u__b_y_t_e_s_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFU_BYTES * this_object = SWCDB_THRIFT_F_U__B_Y_T_E_S(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->ctrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ctrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast107;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast107, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (swcdb_thriftFU_LIST_OP)ecast107;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->pos, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pos = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I32)
        {
          gint32 ecast108;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast108, error)) < 0)
            return -1;
          xfer += ret;
          this_object->comp = (swcdb_thriftComp)ecast108;
          this_object->__isset_comp = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_u__b_y_t_e_s_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFU_BYTES * this_object = SWCDB_THRIFT_F_U__B_Y_T_E_S(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FU_BYTES", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ctrl", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->ctrl, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_pos == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pos", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->pos, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_comp == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "comp", T_I32, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->comp, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 5, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_u__b_y_t_e_s_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftFU_BYTES *self = SWCDB_THRIFT_F_U__B_Y_T_E_S (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_CTRL:
      self->ctrl = g_value_get_int (value);
      self->__isset_ctrl = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_POS:
      self->pos = g_value_get_int (value);
      self->__isset_pos = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_COMP:
      self->comp = g_value_get_int (value);
      self->__isset_comp = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_u__b_y_t_e_s_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftFU_BYTES *self = SWCDB_THRIFT_F_U__B_Y_T_E_S (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_CTRL:
      g_value_set_int (value, self->ctrl);
      break;

    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_POS:
      g_value_set_int (value, self->pos);
      break;

    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_COMP:
      g_value_set_int (value, self->comp);
      break;

    case PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_u__b_y_t_e_s_instance_init (swcdb_thriftFU_BYTES * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ctrl = 0;
  object->__isset_ctrl = FALSE;
  object->__isset_op = FALSE;
  object->pos = 0;
  object->__isset_pos = FALSE;
  object->__isset_comp = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_f_u__b_y_t_e_s_finalize (GObject *object)
{
  swcdb_thriftFU_BYTES *tobject = SWCDB_THRIFT_F_U__B_Y_T_E_S (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_f_u__b_y_t_e_s_class_init (swcdb_thriftFU_BYTESClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_u__b_y_t_e_s_read;
  struct_class->write = swcdb_thrift_f_u__b_y_t_e_s_write;

  gobject_class->finalize = swcdb_thrift_f_u__b_y_t_e_s_finalize;
  gobject_class->get_property = swcdb_thrift_f_u__b_y_t_e_s_get_property;
  gobject_class->set_property = swcdb_thrift_f_u__b_y_t_e_s_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_CTRL,
     g_param_spec_int ("ctrl",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_POS,
     g_param_spec_int ("pos",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_COMP,
     g_param_spec_int ("comp",
                       NULL,
                       NULL,
                       0,
                       21,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__B_Y_T_E_S_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_u__b_y_t_e_s_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFU_BYTESClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_u__b_y_t_e_s_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFU_BYTES),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_u__b_y_t_e_s_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFU_BYTESType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFU_LIProperties
{
  PROP_SWCDB_THRIFT_F_U__L_I_0,
  PROP_SWCDB_THRIFT_F_U__L_I_CTRL,
  PROP_SWCDB_THRIFT_F_U__L_I_OP,
  PROP_SWCDB_THRIFT_F_U__L_I_POS,
  PROP_SWCDB_THRIFT_F_U__L_I_V
};

/* reads a f_u__l_i object */
static gint32
swcdb_thrift_f_u__l_i_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFU_LI * this_object = SWCDB_THRIFT_F_U__L_I(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->ctrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ctrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast109;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast109, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (swcdb_thriftFU_LIST_OP)ecast109;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->pos, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pos = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftFU_INT64 * _elem110 = NULL;
              if ( _elem110 != NULL)
              {
                g_object_unref (_elem110);
              }
              _elem110 = g_object_new (SWCDB_THRIFT_TYPE_F_U__I_N_T64, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem110), protocol, error)) < 0)
              {
                g_object_unref (_elem110);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem110);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_u__l_i_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFU_LI * this_object = SWCDB_THRIFT_F_U__L_I(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FU_LI", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ctrl", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->ctrl, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_pos == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pos", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->pos, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i111;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i111 = 0; i111 < (this_object->v ? this_object->v->len : 0); i111++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i111))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_u__l_i_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  swcdb_thriftFU_LI *self = SWCDB_THRIFT_F_U__L_I (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__L_I_CTRL:
      self->ctrl = g_value_get_int (value);
      self->__isset_ctrl = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__L_I_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__L_I_POS:
      self->pos = g_value_get_int (value);
      self->__isset_pos = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__L_I_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_u__l_i_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  swcdb_thriftFU_LI *self = SWCDB_THRIFT_F_U__L_I (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__L_I_CTRL:
      g_value_set_int (value, self->ctrl);
      break;

    case PROP_SWCDB_THRIFT_F_U__L_I_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_SWCDB_THRIFT_F_U__L_I_POS:
      g_value_set_int (value, self->pos);
      break;

    case PROP_SWCDB_THRIFT_F_U__L_I_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_u__l_i_instance_init (swcdb_thriftFU_LI * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ctrl = 0;
  object->__isset_ctrl = FALSE;
  object->__isset_op = FALSE;
  object->pos = 0;
  object->__isset_pos = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_f_u__l_i_finalize (GObject *object)
{
  swcdb_thriftFU_LI *tobject = SWCDB_THRIFT_F_U__L_I (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_f_u__l_i_class_init (swcdb_thriftFU_LIClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_u__l_i_read;
  struct_class->write = swcdb_thrift_f_u__l_i_write;

  gobject_class->finalize = swcdb_thrift_f_u__l_i_finalize;
  gobject_class->get_property = swcdb_thrift_f_u__l_i_get_property;
  gobject_class->set_property = swcdb_thrift_f_u__l_i_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__L_I_CTRL,
     g_param_spec_int ("ctrl",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__L_I_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__L_I_POS,
     g_param_spec_int ("pos",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__L_I_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_u__l_i_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFU_LIClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_u__l_i_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFU_LI),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_u__l_i_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFU_LIType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFU_LBProperties
{
  PROP_SWCDB_THRIFT_F_U__L_B_0,
  PROP_SWCDB_THRIFT_F_U__L_B_CTRL,
  PROP_SWCDB_THRIFT_F_U__L_B_OP,
  PROP_SWCDB_THRIFT_F_U__L_B_POS,
  PROP_SWCDB_THRIFT_F_U__L_B_V
};

/* reads a f_u__l_b object */
static gint32
swcdb_thrift_f_u__l_b_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFU_LB * this_object = SWCDB_THRIFT_F_U__L_B(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_BYTE)
        {
          if ((ret = thrift_protocol_read_byte (protocol, &this_object->ctrl, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ctrl = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast112;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast112, error)) < 0)
            return -1;
          xfer += ret;
          this_object->op = (swcdb_thriftFU_LIST_OP)ecast112;
          this_object->__isset_op = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->pos, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_pos = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftFU_BYTES * _elem113 = NULL;
              if ( _elem113 != NULL)
              {
                g_object_unref (_elem113);
              }
              _elem113 = g_object_new (SWCDB_THRIFT_TYPE_F_U__B_Y_T_E_S, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem113), protocol, error)) < 0)
              {
                g_object_unref (_elem113);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem113);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_u__l_b_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFU_LB * this_object = SWCDB_THRIFT_F_U__L_B(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FU_LB", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ctrl", T_BYTE, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_byte (protocol, this_object->ctrl, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "op", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->op, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_pos == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "pos", T_I32, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, this_object->pos, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i114;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i114 = 0; i114 < (this_object->v ? this_object->v->len : 0); i114++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i114))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_u__l_b_set_property (GObject *object,
                                    guint property_id,
                                    const GValue *value,
                                    GParamSpec *pspec)
{
  swcdb_thriftFU_LB *self = SWCDB_THRIFT_F_U__L_B (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__L_B_CTRL:
      self->ctrl = g_value_get_int (value);
      self->__isset_ctrl = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__L_B_OP:
      self->op = g_value_get_int (value);
      self->__isset_op = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__L_B_POS:
      self->pos = g_value_get_int (value);
      self->__isset_pos = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_U__L_B_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_u__l_b_get_property (GObject *object,
                                    guint property_id,
                                    GValue *value,
                                    GParamSpec *pspec)
{
  swcdb_thriftFU_LB *self = SWCDB_THRIFT_F_U__L_B (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_U__L_B_CTRL:
      g_value_set_int (value, self->ctrl);
      break;

    case PROP_SWCDB_THRIFT_F_U__L_B_OP:
      g_value_set_int (value, self->op);
      break;

    case PROP_SWCDB_THRIFT_F_U__L_B_POS:
      g_value_set_int (value, self->pos);
      break;

    case PROP_SWCDB_THRIFT_F_U__L_B_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_u__l_b_instance_init (swcdb_thriftFU_LB * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->ctrl = 0;
  object->__isset_ctrl = FALSE;
  object->__isset_op = FALSE;
  object->pos = 0;
  object->__isset_pos = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_f_u__l_b_finalize (GObject *object)
{
  swcdb_thriftFU_LB *tobject = SWCDB_THRIFT_F_U__L_B (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_f_u__l_b_class_init (swcdb_thriftFU_LBClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_u__l_b_read;
  struct_class->write = swcdb_thrift_f_u__l_b_write;

  gobject_class->finalize = swcdb_thrift_f_u__l_b_finalize;
  gobject_class->get_property = swcdb_thrift_f_u__l_b_get_property;
  gobject_class->set_property = swcdb_thrift_f_u__l_b_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__L_B_CTRL,
     g_param_spec_int ("ctrl",
                       NULL,
                       NULL,
                       G_MININT8,
                       G_MAXINT8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__L_B_OP,
     g_param_spec_int ("op",
                       NULL,
                       NULL,
                       0,
                       8,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__L_B_POS,
     g_param_spec_int ("pos",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_U__L_B_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_u__l_b_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFU_LBClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_u__l_b_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFU_LB),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_u__l_b_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFU_LBType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCellValueSerialOpProperties
{
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_0,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_FIELD_ID,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_INT64,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_DOUBLE,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_BYTES,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_KEY,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_LI,
  PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_LB
};

/* reads a cell_value_serial_op object */
static gint32
swcdb_thrift_cell_value_serial_op_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCellValueSerialOp * this_object = SWCDB_THRIFT_CELL_VALUE_SERIAL_OP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->field_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_field_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->v_int64), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_v_int64 = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->v_double), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_v_double = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->v_bytes), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_v_bytes = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem115 = NULL;
              if (_elem115 != NULL)
              {
                g_free(_elem115);
                _elem115 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem115 = g_byte_array_new();
              g_byte_array_append (_elem115, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->v_key, _elem115);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v_key = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->v_li), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_v_li = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 7:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->v_lb), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_v_lb = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_cell_value_serial_op_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCellValueSerialOp * this_object = SWCDB_THRIFT_CELL_VALUE_SERIAL_OP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CellValueSerialOp", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "field_id", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->field_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_v_int64 == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_int64", T_STRUCT, 2, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->v_int64), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_double == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_double", T_STRUCT, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->v_double), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_bytes == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_bytes", T_STRUCT, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->v_bytes), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_key == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_key", T_LIST, 5, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i116;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->v_key ? this_object->v_key->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i116 = 0; i116 < (this_object->v_key ? this_object->v_key->len : 0); i116++)
      {
        if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_key, i116)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_key, i116)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_key, i116)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->v_key, i116)))->len : 0, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_li == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_li", T_STRUCT, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->v_li), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_v_lb == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "v_lb", T_STRUCT, 7, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->v_lb), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_cell_value_serial_op_set_property (GObject *object,
                                                guint property_id,
                                                const GValue *value,
                                                GParamSpec *pspec)
{
  swcdb_thriftCellValueSerialOp *self = SWCDB_THRIFT_CELL_VALUE_SERIAL_OP (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_FIELD_ID:
      self->field_id = g_value_get_int (value);
      self->__isset_field_id = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_INT64:
      if (self->v_int64 != NULL)
        g_object_unref (self->v_int64);
      self->v_int64 = g_value_dup_object (value);
      self->__isset_v_int64 = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_DOUBLE:
      if (self->v_double != NULL)
        g_object_unref (self->v_double);
      self->v_double = g_value_dup_object (value);
      self->__isset_v_double = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_BYTES:
      if (self->v_bytes != NULL)
        g_object_unref (self->v_bytes);
      self->v_bytes = g_value_dup_object (value);
      self->__isset_v_bytes = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_KEY:
      if (self->v_key != NULL)
        g_ptr_array_unref (self->v_key);
      self->v_key = g_value_dup_boxed (value);
      self->__isset_v_key = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_LI:
      if (self->v_li != NULL)
        g_object_unref (self->v_li);
      self->v_li = g_value_dup_object (value);
      self->__isset_v_li = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_LB:
      if (self->v_lb != NULL)
        g_object_unref (self->v_lb);
      self->v_lb = g_value_dup_object (value);
      self->__isset_v_lb = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_cell_value_serial_op_get_property (GObject *object,
                                                guint property_id,
                                                GValue *value,
                                                GParamSpec *pspec)
{
  swcdb_thriftCellValueSerialOp *self = SWCDB_THRIFT_CELL_VALUE_SERIAL_OP (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_FIELD_ID:
      g_value_set_int (value, self->field_id);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_INT64:
      g_value_set_object (value, self->v_int64);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_DOUBLE:
      g_value_set_object (value, self->v_double);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_BYTES:
      g_value_set_object (value, self->v_bytes);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_KEY:
      g_value_set_boxed (value, self->v_key);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_LI:
      g_value_set_object (value, self->v_li);
      break;

    case PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_LB:
      g_value_set_object (value, self->v_lb);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_cell_value_serial_op_instance_init (swcdb_thriftCellValueSerialOp * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->field_id = 0;
  object->__isset_field_id = FALSE;
  object->v_int64 = g_object_new (SWCDB_THRIFT_TYPE_F_U__I_N_T64, NULL);
  object->__isset_v_int64 = FALSE;
  object->v_double = g_object_new (SWCDB_THRIFT_TYPE_F_U__D_O_U_B_L_E, NULL);
  object->__isset_v_double = FALSE;
  object->v_bytes = g_object_new (SWCDB_THRIFT_TYPE_F_U__B_Y_T_E_S, NULL);
  object->__isset_v_bytes = FALSE;
  object->v_key = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_v_key = FALSE;
  object->v_li = g_object_new (SWCDB_THRIFT_TYPE_F_U__L_I, NULL);
  object->__isset_v_li = FALSE;
  object->v_lb = g_object_new (SWCDB_THRIFT_TYPE_F_U__L_B, NULL);
  object->__isset_v_lb = FALSE;
}

static void 
swcdb_thrift_cell_value_serial_op_finalize (GObject *object)
{
  swcdb_thriftCellValueSerialOp *tobject = SWCDB_THRIFT_CELL_VALUE_SERIAL_OP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->v_int64 != NULL)
  {
    g_object_unref(tobject->v_int64);
    tobject->v_int64 = NULL;
  }
  if (tobject->v_double != NULL)
  {
    g_object_unref(tobject->v_double);
    tobject->v_double = NULL;
  }
  if (tobject->v_bytes != NULL)
  {
    g_object_unref(tobject->v_bytes);
    tobject->v_bytes = NULL;
  }
  if (tobject->v_key != NULL)
  {
    g_ptr_array_unref (tobject->v_key);
    tobject->v_key = NULL;
  }
  if (tobject->v_li != NULL)
  {
    g_object_unref(tobject->v_li);
    tobject->v_li = NULL;
  }
  if (tobject->v_lb != NULL)
  {
    g_object_unref(tobject->v_lb);
    tobject->v_lb = NULL;
  }
}

static void
swcdb_thrift_cell_value_serial_op_class_init (swcdb_thriftCellValueSerialOpClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_cell_value_serial_op_read;
  struct_class->write = swcdb_thrift_cell_value_serial_op_write;

  gobject_class->finalize = swcdb_thrift_cell_value_serial_op_finalize;
  gobject_class->get_property = swcdb_thrift_cell_value_serial_op_get_property;
  gobject_class->set_property = swcdb_thrift_cell_value_serial_op_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_FIELD_ID,
     g_param_spec_int ("field_id",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_INT64,
     g_param_spec_object ("v_int64",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_F_U__I_N_T64,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_DOUBLE,
     g_param_spec_object ("v_double",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_F_U__D_O_U_B_L_E,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_BYTES,
     g_param_spec_object ("v_bytes",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_F_U__B_Y_T_E_S,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_KEY,
     g_param_spec_boxed ("v_key",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_LI,
     g_param_spec_object ("v_li",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_F_U__L_I,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_VALUE_SERIAL_OP_V_LB,
     g_param_spec_object ("v_lb",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_F_U__L_B,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_cell_value_serial_op_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCellValueSerialOpClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_cell_value_serial_op_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCellValueSerialOp),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_cell_value_serial_op_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCellValueSerialOpType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftUCellSerialProperties
{
  PROP_SWCDB_THRIFT_U_CELL_SERIAL_0,
  PROP_SWCDB_THRIFT_U_CELL_SERIAL_F,
  PROP_SWCDB_THRIFT_U_CELL_SERIAL_K,
  PROP_SWCDB_THRIFT_U_CELL_SERIAL_TS,
  PROP_SWCDB_THRIFT_U_CELL_SERIAL_TS_DESC,
  PROP_SWCDB_THRIFT_U_CELL_SERIAL_V,
  PROP_SWCDB_THRIFT_U_CELL_SERIAL_ENCODER
};

/* reads a u_cell_serial object */
static gint32
swcdb_thrift_u_cell_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftUCellSerial * this_object = SWCDB_THRIFT_U_CELL_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast117;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast117, error)) < 0)
            return -1;
          xfer += ret;
          this_object->f = (swcdb_thriftFlag)ecast117;
          this_object->__isset_f = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem118 = NULL;
              if (_elem118 != NULL)
              {
                g_free(_elem118);
                _elem118 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem118 = g_byte_array_new();
              g_byte_array_append (_elem118, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem118);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_BOOL)
        {
          if ((ret = thrift_protocol_read_bool (protocol, &this_object->ts_desc, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts_desc = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellValueSerial * _elem119 = NULL;
              if ( _elem119 != NULL)
              {
                g_object_unref (_elem119);
              }
              _elem119 = g_object_new (SWCDB_THRIFT_TYPE_CELL_VALUE_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem119), protocol, error)) < 0)
              {
                g_object_unref (_elem119);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem119);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 6:
        if (ftype == T_I32)
        {
          gint32 ecast120;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast120, error)) < 0)
            return -1;
          xfer += ret;
          this_object->encoder = (swcdb_thriftEncodingType)ecast120;
          this_object->__isset_encoder = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_u_cell_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftUCellSerial * this_object = SWCDB_THRIFT_U_CELL_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "UCellSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "f", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->f, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i121;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i121 = 0; i121 < (this_object->k ? this_object->k->len : 0); i121++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i121)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i121)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i121)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i121)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_ts == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_ts_desc == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "ts_desc", T_BOOL, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_bool (protocol, this_object->ts_desc, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 5, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i122;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i122 = 0; i122 < (this_object->v ? this_object->v->len : 0); i122++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i122))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_encoder == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "encoder", T_I32, 6, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->encoder, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_u_cell_serial_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftUCellSerial *self = SWCDB_THRIFT_U_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_F:
      self->f = g_value_get_int (value);
      self->__isset_f = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_TS_DESC:
      self->ts_desc = g_value_get_boolean (value);
      self->__isset_ts_desc = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_ENCODER:
      self->encoder = g_value_get_int (value);
      self->__isset_encoder = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_u_cell_serial_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftUCellSerial *self = SWCDB_THRIFT_U_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_F:
      g_value_set_int (value, self->f);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_TS_DESC:
      g_value_set_boolean (value, self->ts_desc);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_V:
      g_value_set_boxed (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_U_CELL_SERIAL_ENCODER:
      g_value_set_int (value, self->encoder);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_u_cell_serial_instance_init (swcdb_thriftUCellSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_f = FALSE;
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->ts_desc = 0;
  object->__isset_ts_desc = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
  object->__isset_encoder = FALSE;
}

static void 
swcdb_thrift_u_cell_serial_finalize (GObject *object)
{
  swcdb_thriftUCellSerial *tobject = SWCDB_THRIFT_U_CELL_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_u_cell_serial_class_init (swcdb_thriftUCellSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_u_cell_serial_read;
  struct_class->write = swcdb_thrift_u_cell_serial_write;

  gobject_class->finalize = swcdb_thrift_u_cell_serial_finalize;
  gobject_class->get_property = swcdb_thrift_u_cell_serial_get_property;
  gobject_class->set_property = swcdb_thrift_u_cell_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_SERIAL_F,
     g_param_spec_int ("f",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_SERIAL_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_SERIAL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_SERIAL_TS_DESC,
     g_param_spec_boolean ("ts_desc",
                           NULL,
                           NULL,
                           FALSE,
                           G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_SERIAL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_U_CELL_SERIAL_ENCODER,
     g_param_spec_int ("encoder",
                       NULL,
                       NULL,
                       0,
                       255,
                       0,
                       G_PARAM_READWRITE));
}

GType
swcdb_thrift_u_cell_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftUCellSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_u_cell_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftUCellSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_u_cell_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftUCellSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCellPlainProperties
{
  PROP_SWCDB_THRIFT_CELL_PLAIN_0,
  PROP_SWCDB_THRIFT_CELL_PLAIN_C,
  PROP_SWCDB_THRIFT_CELL_PLAIN_K,
  PROP_SWCDB_THRIFT_CELL_PLAIN_TS,
  PROP_SWCDB_THRIFT_CELL_PLAIN_V
};

/* reads a cell_plain object */
static gint32
swcdb_thrift_cell_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCellPlain * this_object = SWCDB_THRIFT_CELL_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem123 = NULL;
              if (_elem123 != NULL)
              {
                g_free(_elem123);
                _elem123 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem123 = g_byte_array_new();
              g_byte_array_append (_elem123, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem123);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_cell_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCellPlain * this_object = SWCDB_THRIFT_CELL_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CellPlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i124;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i124 = 0; i124 < (this_object->k ? this_object->k->len : 0); i124++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i124)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i124)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i124)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i124)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_cell_plain_set_property (GObject *object,
                                      guint property_id,
                                      const GValue *value,
                                      GParamSpec *pspec)
{
  swcdb_thriftCellPlain *self = SWCDB_THRIFT_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_PLAIN_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_PLAIN_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_PLAIN_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_PLAIN_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_cell_plain_get_property (GObject *object,
                                      guint property_id,
                                      GValue *value,
                                      GParamSpec *pspec)
{
  swcdb_thriftCellPlain *self = SWCDB_THRIFT_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_PLAIN_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_CELL_PLAIN_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_CELL_PLAIN_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_CELL_PLAIN_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_cell_plain_instance_init (swcdb_thriftCellPlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_cell_plain_finalize (GObject *object)
{
  swcdb_thriftCellPlain *tobject = SWCDB_THRIFT_CELL_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_cell_plain_class_init (swcdb_thriftCellPlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_cell_plain_read;
  struct_class->write = swcdb_thrift_cell_plain_write;

  gobject_class->finalize = swcdb_thrift_cell_plain_finalize;
  gobject_class->get_property = swcdb_thrift_cell_plain_get_property;
  gobject_class->set_property = swcdb_thrift_cell_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_PLAIN_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_PLAIN_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_PLAIN_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_PLAIN_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_cell_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCellPlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_cell_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCellPlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_cell_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCellPlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCellCounterProperties
{
  PROP_SWCDB_THRIFT_CELL_COUNTER_0,
  PROP_SWCDB_THRIFT_CELL_COUNTER_C,
  PROP_SWCDB_THRIFT_CELL_COUNTER_K,
  PROP_SWCDB_THRIFT_CELL_COUNTER_TS,
  PROP_SWCDB_THRIFT_CELL_COUNTER_V,
  PROP_SWCDB_THRIFT_CELL_COUNTER_EQ
};

/* reads a cell_counter object */
static gint32
swcdb_thrift_cell_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCellCounter * this_object = SWCDB_THRIFT_CELL_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem125 = NULL;
              if (_elem125 != NULL)
              {
                g_free(_elem125);
                _elem125 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem125 = g_byte_array_new();
              g_byte_array_append (_elem125, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem125);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 5:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->eq, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_eq = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_cell_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCellCounter * this_object = SWCDB_THRIFT_CELL_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CellCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i126;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i126 = 0; i126 < (this_object->k ? this_object->k->len : 0); i126++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i126)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i126)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i126)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i126)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_eq == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "eq", T_I64, 5, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->eq, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_cell_counter_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftCellCounter *self = SWCDB_THRIFT_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_COUNTER_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_COUNTER_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_COUNTER_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_COUNTER_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_COUNTER_EQ:
      self->eq = g_value_get_int64 (value);
      self->__isset_eq = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_cell_counter_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftCellCounter *self = SWCDB_THRIFT_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_COUNTER_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_CELL_COUNTER_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_CELL_COUNTER_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_CELL_COUNTER_V:
      g_value_set_int64 (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_CELL_COUNTER_EQ:
      g_value_set_int64 (value, self->eq);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_cell_counter_instance_init (swcdb_thriftCellCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
  object->eq = 0;
  object->__isset_eq = FALSE;
}

static void 
swcdb_thrift_cell_counter_finalize (GObject *object)
{
  swcdb_thriftCellCounter *tobject = SWCDB_THRIFT_CELL_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
}

static void
swcdb_thrift_cell_counter_class_init (swcdb_thriftCellCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_cell_counter_read;
  struct_class->write = swcdb_thrift_cell_counter_write;

  gobject_class->finalize = swcdb_thrift_cell_counter_finalize;
  gobject_class->get_property = swcdb_thrift_cell_counter_get_property;
  gobject_class->set_property = swcdb_thrift_cell_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_COUNTER_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_COUNTER_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_COUNTER_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_COUNTER_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_COUNTER_EQ,
     g_param_spec_int64 ("eq",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_cell_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCellCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_cell_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCellCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_cell_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCellCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCellSerialProperties
{
  PROP_SWCDB_THRIFT_CELL_SERIAL_0,
  PROP_SWCDB_THRIFT_CELL_SERIAL_C,
  PROP_SWCDB_THRIFT_CELL_SERIAL_K,
  PROP_SWCDB_THRIFT_CELL_SERIAL_TS,
  PROP_SWCDB_THRIFT_CELL_SERIAL_V
};

/* reads a cell_serial object */
static gint32
swcdb_thrift_cell_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCellSerial * this_object = SWCDB_THRIFT_CELL_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem127 = NULL;
              if (_elem127 != NULL)
              {
                g_free(_elem127);
                _elem127 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem127 = g_byte_array_new();
              g_byte_array_append (_elem127, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem127);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellValueSerial * _elem128 = NULL;
              if ( _elem128 != NULL)
              {
                g_object_unref (_elem128);
              }
              _elem128 = g_object_new (SWCDB_THRIFT_TYPE_CELL_VALUE_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem128), protocol, error)) < 0)
              {
                g_object_unref (_elem128);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem128);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_cell_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCellSerial * this_object = SWCDB_THRIFT_CELL_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CellSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i129;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i129 = 0; i129 < (this_object->k ? this_object->k->len : 0); i129++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i129)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i129)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i129)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i129)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i130;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i130 = 0; i130 < (this_object->v ? this_object->v->len : 0); i130++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i130))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_cell_serial_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  swcdb_thriftCellSerial *self = SWCDB_THRIFT_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_SERIAL_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_SERIAL_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_SERIAL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELL_SERIAL_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_cell_serial_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  swcdb_thriftCellSerial *self = SWCDB_THRIFT_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELL_SERIAL_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_CELL_SERIAL_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_CELL_SERIAL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_CELL_SERIAL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_cell_serial_instance_init (swcdb_thriftCellSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_cell_serial_finalize (GObject *object)
{
  swcdb_thriftCellSerial *tobject = SWCDB_THRIFT_CELL_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_cell_serial_class_init (swcdb_thriftCellSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_cell_serial_read;
  struct_class->write = swcdb_thrift_cell_serial_write;

  gobject_class->finalize = swcdb_thrift_cell_serial_finalize;
  gobject_class->get_property = swcdb_thrift_cell_serial_get_property;
  gobject_class->set_property = swcdb_thrift_cell_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_SERIAL_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_SERIAL_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_SERIAL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELL_SERIAL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_cell_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCellSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_cell_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCellSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_cell_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCellSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCellsProperties
{
  PROP_SWCDB_THRIFT_CELLS_0,
  PROP_SWCDB_THRIFT_CELLS_PLAIN_CELLS,
  PROP_SWCDB_THRIFT_CELLS_COUNTER_CELLS,
  PROP_SWCDB_THRIFT_CELLS_SERIAL_CELLS
};

/* reads a cells object */
static gint32
swcdb_thrift_cells_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCells * this_object = SWCDB_THRIFT_CELLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellPlain * _elem131 = NULL;
              if ( _elem131 != NULL)
              {
                g_object_unref (_elem131);
              }
              _elem131 = g_object_new (SWCDB_THRIFT_TYPE_CELL_PLAIN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem131), protocol, error)) < 0)
              {
                g_object_unref (_elem131);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->plain_cells, _elem131);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_plain_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellCounter * _elem132 = NULL;
              if ( _elem132 != NULL)
              {
                g_object_unref (_elem132);
              }
              _elem132 = g_object_new (SWCDB_THRIFT_TYPE_CELL_COUNTER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem132), protocol, error)) < 0)
              {
                g_object_unref (_elem132);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->counter_cells, _elem132);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_counter_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellSerial * _elem133 = NULL;
              if ( _elem133 != NULL)
              {
                g_object_unref (_elem133);
              }
              _elem133 = g_object_new (SWCDB_THRIFT_TYPE_CELL_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem133), protocol, error)) < 0)
              {
                g_object_unref (_elem133);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->serial_cells, _elem133);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_serial_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_cells_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCells * this_object = SWCDB_THRIFT_CELLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Cells", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "plain_cells", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i134;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->plain_cells ? this_object->plain_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i134 = 0; i134 < (this_object->plain_cells ? this_object->plain_cells->len : 0); i134++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->plain_cells, i134))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "counter_cells", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i135;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->counter_cells ? this_object->counter_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i135 = 0; i135 < (this_object->counter_cells ? this_object->counter_cells->len : 0); i135++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->counter_cells, i135))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serial_cells", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i136;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->serial_cells ? this_object->serial_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i136 = 0; i136 < (this_object->serial_cells ? this_object->serial_cells->len : 0); i136++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->serial_cells, i136))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_cells_set_property (GObject *object,
                                 guint property_id,
                                 const GValue *value,
                                 GParamSpec *pspec)
{
  swcdb_thriftCells *self = SWCDB_THRIFT_CELLS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELLS_PLAIN_CELLS:
      if (self->plain_cells != NULL)
        g_ptr_array_unref (self->plain_cells);
      self->plain_cells = g_value_dup_boxed (value);
      self->__isset_plain_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELLS_COUNTER_CELLS:
      if (self->counter_cells != NULL)
        g_ptr_array_unref (self->counter_cells);
      self->counter_cells = g_value_dup_boxed (value);
      self->__isset_counter_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELLS_SERIAL_CELLS:
      if (self->serial_cells != NULL)
        g_ptr_array_unref (self->serial_cells);
      self->serial_cells = g_value_dup_boxed (value);
      self->__isset_serial_cells = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_cells_get_property (GObject *object,
                                 guint property_id,
                                 GValue *value,
                                 GParamSpec *pspec)
{
  swcdb_thriftCells *self = SWCDB_THRIFT_CELLS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELLS_PLAIN_CELLS:
      g_value_set_boxed (value, self->plain_cells);
      break;

    case PROP_SWCDB_THRIFT_CELLS_COUNTER_CELLS:
      g_value_set_boxed (value, self->counter_cells);
      break;

    case PROP_SWCDB_THRIFT_CELLS_SERIAL_CELLS:
      g_value_set_boxed (value, self->serial_cells);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_cells_instance_init (swcdb_thriftCells * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->plain_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_plain_cells = FALSE;
  object->counter_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_counter_cells = FALSE;
  object->serial_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_serial_cells = FALSE;
}

static void 
swcdb_thrift_cells_finalize (GObject *object)
{
  swcdb_thriftCells *tobject = SWCDB_THRIFT_CELLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->plain_cells != NULL)
  {
    g_ptr_array_unref (tobject->plain_cells);
    tobject->plain_cells = NULL;
  }
  if (tobject->counter_cells != NULL)
  {
    g_ptr_array_unref (tobject->counter_cells);
    tobject->counter_cells = NULL;
  }
  if (tobject->serial_cells != NULL)
  {
    g_ptr_array_unref (tobject->serial_cells);
    tobject->serial_cells = NULL;
  }
}

static void
swcdb_thrift_cells_class_init (swcdb_thriftCellsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_cells_read;
  struct_class->write = swcdb_thrift_cells_write;

  gobject_class->finalize = swcdb_thrift_cells_finalize;
  gobject_class->get_property = swcdb_thrift_cells_get_property;
  gobject_class->set_property = swcdb_thrift_cells_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELLS_PLAIN_CELLS,
     g_param_spec_boxed ("plain_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELLS_COUNTER_CELLS,
     g_param_spec_boxed ("counter_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELLS_SERIAL_CELLS,
     g_param_spec_boxed ("serial_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_cells_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCellsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_cells_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCells),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_cells_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCellsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCCellPlainProperties
{
  PROP_SWCDB_THRIFT_C_CELL_PLAIN_0,
  PROP_SWCDB_THRIFT_C_CELL_PLAIN_K,
  PROP_SWCDB_THRIFT_C_CELL_PLAIN_TS,
  PROP_SWCDB_THRIFT_C_CELL_PLAIN_V
};

/* reads a c_cell_plain object */
static gint32
swcdb_thrift_c_cell_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCCellPlain * this_object = SWCDB_THRIFT_C_CELL_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem137 = NULL;
              if (_elem137 != NULL)
              {
                g_free(_elem137);
                _elem137 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem137 = g_byte_array_new();
              g_byte_array_append (_elem137, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem137);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_c_cell_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCCellPlain * this_object = SWCDB_THRIFT_C_CELL_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CCellPlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i138;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i138 = 0; i138 < (this_object->k ? this_object->k->len : 0); i138++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i138)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i138)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i138)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i138)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_c_cell_plain_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftCCellPlain *self = SWCDB_THRIFT_C_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_C_CELL_PLAIN_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELL_PLAIN_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELL_PLAIN_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_c_cell_plain_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftCCellPlain *self = SWCDB_THRIFT_C_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_C_CELL_PLAIN_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_C_CELL_PLAIN_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_C_CELL_PLAIN_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_c_cell_plain_instance_init (swcdb_thriftCCellPlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_c_cell_plain_finalize (GObject *object)
{
  swcdb_thriftCCellPlain *tobject = SWCDB_THRIFT_C_CELL_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_c_cell_plain_class_init (swcdb_thriftCCellPlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_c_cell_plain_read;
  struct_class->write = swcdb_thrift_c_cell_plain_write;

  gobject_class->finalize = swcdb_thrift_c_cell_plain_finalize;
  gobject_class->get_property = swcdb_thrift_c_cell_plain_get_property;
  gobject_class->set_property = swcdb_thrift_c_cell_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_PLAIN_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_PLAIN_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_PLAIN_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_c_cell_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCCellPlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_c_cell_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCCellPlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_c_cell_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCCellPlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCCellCounterProperties
{
  PROP_SWCDB_THRIFT_C_CELL_COUNTER_0,
  PROP_SWCDB_THRIFT_C_CELL_COUNTER_K,
  PROP_SWCDB_THRIFT_C_CELL_COUNTER_TS,
  PROP_SWCDB_THRIFT_C_CELL_COUNTER_V,
  PROP_SWCDB_THRIFT_C_CELL_COUNTER_EQ
};

/* reads a c_cell_counter object */
static gint32
swcdb_thrift_c_cell_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCCellCounter * this_object = SWCDB_THRIFT_C_CELL_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem139 = NULL;
              if (_elem139 != NULL)
              {
                g_free(_elem139);
                _elem139 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem139 = g_byte_array_new();
              g_byte_array_append (_elem139, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem139);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->eq, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_eq = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_c_cell_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCCellCounter * this_object = SWCDB_THRIFT_C_CELL_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CCellCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i140;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i140 = 0; i140 < (this_object->k ? this_object->k->len : 0); i140++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i140)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i140)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i140)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i140)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_eq == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "eq", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->eq, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_c_cell_counter_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftCCellCounter *self = SWCDB_THRIFT_C_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_C_CELL_COUNTER_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELL_COUNTER_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELL_COUNTER_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELL_COUNTER_EQ:
      self->eq = g_value_get_int64 (value);
      self->__isset_eq = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_c_cell_counter_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftCCellCounter *self = SWCDB_THRIFT_C_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_C_CELL_COUNTER_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_C_CELL_COUNTER_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_C_CELL_COUNTER_V:
      g_value_set_int64 (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_C_CELL_COUNTER_EQ:
      g_value_set_int64 (value, self->eq);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_c_cell_counter_instance_init (swcdb_thriftCCellCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
  object->eq = 0;
  object->__isset_eq = FALSE;
}

static void 
swcdb_thrift_c_cell_counter_finalize (GObject *object)
{
  swcdb_thriftCCellCounter *tobject = SWCDB_THRIFT_C_CELL_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
}

static void
swcdb_thrift_c_cell_counter_class_init (swcdb_thriftCCellCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_c_cell_counter_read;
  struct_class->write = swcdb_thrift_c_cell_counter_write;

  gobject_class->finalize = swcdb_thrift_c_cell_counter_finalize;
  gobject_class->get_property = swcdb_thrift_c_cell_counter_get_property;
  gobject_class->set_property = swcdb_thrift_c_cell_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_COUNTER_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_COUNTER_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_COUNTER_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_COUNTER_EQ,
     g_param_spec_int64 ("eq",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_c_cell_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCCellCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_c_cell_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCCellCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_c_cell_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCCellCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCCellSerialProperties
{
  PROP_SWCDB_THRIFT_C_CELL_SERIAL_0,
  PROP_SWCDB_THRIFT_C_CELL_SERIAL_K,
  PROP_SWCDB_THRIFT_C_CELL_SERIAL_TS,
  PROP_SWCDB_THRIFT_C_CELL_SERIAL_V
};

/* reads a c_cell_serial object */
static gint32
swcdb_thrift_c_cell_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCCellSerial * this_object = SWCDB_THRIFT_C_CELL_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem141 = NULL;
              if (_elem141 != NULL)
              {
                g_free(_elem141);
                _elem141 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem141 = g_byte_array_new();
              g_byte_array_append (_elem141, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem141);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellValueSerial * _elem142 = NULL;
              if ( _elem142 != NULL)
              {
                g_object_unref (_elem142);
              }
              _elem142 = g_object_new (SWCDB_THRIFT_TYPE_CELL_VALUE_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem142), protocol, error)) < 0)
              {
                g_object_unref (_elem142);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem142);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_c_cell_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCCellSerial * this_object = SWCDB_THRIFT_C_CELL_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CCellSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i143;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i143 = 0; i143 < (this_object->k ? this_object->k->len : 0); i143++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i143)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i143)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i143)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i143)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i144;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i144 = 0; i144 < (this_object->v ? this_object->v->len : 0); i144++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i144))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_c_cell_serial_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftCCellSerial *self = SWCDB_THRIFT_C_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_C_CELL_SERIAL_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELL_SERIAL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELL_SERIAL_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_c_cell_serial_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftCCellSerial *self = SWCDB_THRIFT_C_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_C_CELL_SERIAL_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_C_CELL_SERIAL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_C_CELL_SERIAL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_c_cell_serial_instance_init (swcdb_thriftCCellSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_c_cell_serial_finalize (GObject *object)
{
  swcdb_thriftCCellSerial *tobject = SWCDB_THRIFT_C_CELL_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_c_cell_serial_class_init (swcdb_thriftCCellSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_c_cell_serial_read;
  struct_class->write = swcdb_thrift_c_cell_serial_write;

  gobject_class->finalize = swcdb_thrift_c_cell_serial_finalize;
  gobject_class->get_property = swcdb_thrift_c_cell_serial_get_property;
  gobject_class->set_property = swcdb_thrift_c_cell_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_SERIAL_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_SERIAL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELL_SERIAL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_c_cell_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCCellSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_c_cell_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCCellSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_c_cell_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCCellSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftcCellsProperties
{
  PROP_SWCDB_THRIFT_C_CELLS_0,
  PROP_SWCDB_THRIFT_C_CELLS_PLAIN_CELLS,
  PROP_SWCDB_THRIFT_C_CELLS_COUNTER_CELLS,
  PROP_SWCDB_THRIFT_C_CELLS_SERIAL_CELLS
};

/* reads a c_cells object */
static gint32
swcdb_thrift_c_cells_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftcCells * this_object = SWCDB_THRIFT_C_CELLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCCellPlain * _elem145 = NULL;
              if ( _elem145 != NULL)
              {
                g_object_unref (_elem145);
              }
              _elem145 = g_object_new (SWCDB_THRIFT_TYPE_C_CELL_PLAIN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem145), protocol, error)) < 0)
              {
                g_object_unref (_elem145);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->plain_cells, _elem145);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_plain_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCCellCounter * _elem146 = NULL;
              if ( _elem146 != NULL)
              {
                g_object_unref (_elem146);
              }
              _elem146 = g_object_new (SWCDB_THRIFT_TYPE_C_CELL_COUNTER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem146), protocol, error)) < 0)
              {
                g_object_unref (_elem146);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->counter_cells, _elem146);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_counter_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCCellSerial * _elem147 = NULL;
              if ( _elem147 != NULL)
              {
                g_object_unref (_elem147);
              }
              _elem147 = g_object_new (SWCDB_THRIFT_TYPE_C_CELL_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem147), protocol, error)) < 0)
              {
                g_object_unref (_elem147);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->serial_cells, _elem147);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_serial_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_c_cells_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftcCells * this_object = SWCDB_THRIFT_C_CELLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "cCells", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "plain_cells", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i148;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->plain_cells ? this_object->plain_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i148 = 0; i148 < (this_object->plain_cells ? this_object->plain_cells->len : 0); i148++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->plain_cells, i148))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "counter_cells", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i149;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->counter_cells ? this_object->counter_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i149 = 0; i149 < (this_object->counter_cells ? this_object->counter_cells->len : 0); i149++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->counter_cells, i149))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serial_cells", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i150;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->serial_cells ? this_object->serial_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i150 = 0; i150 < (this_object->serial_cells ? this_object->serial_cells->len : 0); i150++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->serial_cells, i150))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_c_cells_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  swcdb_thriftcCells *self = SWCDB_THRIFT_C_CELLS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_C_CELLS_PLAIN_CELLS:
      if (self->plain_cells != NULL)
        g_ptr_array_unref (self->plain_cells);
      self->plain_cells = g_value_dup_boxed (value);
      self->__isset_plain_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELLS_COUNTER_CELLS:
      if (self->counter_cells != NULL)
        g_ptr_array_unref (self->counter_cells);
      self->counter_cells = g_value_dup_boxed (value);
      self->__isset_counter_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_C_CELLS_SERIAL_CELLS:
      if (self->serial_cells != NULL)
        g_ptr_array_unref (self->serial_cells);
      self->serial_cells = g_value_dup_boxed (value);
      self->__isset_serial_cells = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_c_cells_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  swcdb_thriftcCells *self = SWCDB_THRIFT_C_CELLS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_C_CELLS_PLAIN_CELLS:
      g_value_set_boxed (value, self->plain_cells);
      break;

    case PROP_SWCDB_THRIFT_C_CELLS_COUNTER_CELLS:
      g_value_set_boxed (value, self->counter_cells);
      break;

    case PROP_SWCDB_THRIFT_C_CELLS_SERIAL_CELLS:
      g_value_set_boxed (value, self->serial_cells);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_c_cells_instance_init (swcdb_thriftcCells * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->plain_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_plain_cells = FALSE;
  object->counter_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_counter_cells = FALSE;
  object->serial_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_serial_cells = FALSE;
}

static void 
swcdb_thrift_c_cells_finalize (GObject *object)
{
  swcdb_thriftcCells *tobject = SWCDB_THRIFT_C_CELLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->plain_cells != NULL)
  {
    g_ptr_array_unref (tobject->plain_cells);
    tobject->plain_cells = NULL;
  }
  if (tobject->counter_cells != NULL)
  {
    g_ptr_array_unref (tobject->counter_cells);
    tobject->counter_cells = NULL;
  }
  if (tobject->serial_cells != NULL)
  {
    g_ptr_array_unref (tobject->serial_cells);
    tobject->serial_cells = NULL;
  }
}

static void
swcdb_thrift_c_cells_class_init (swcdb_thriftcCellsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_c_cells_read;
  struct_class->write = swcdb_thrift_c_cells_write;

  gobject_class->finalize = swcdb_thrift_c_cells_finalize;
  gobject_class->get_property = swcdb_thrift_c_cells_get_property;
  gobject_class->set_property = swcdb_thrift_c_cells_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELLS_PLAIN_CELLS,
     g_param_spec_boxed ("plain_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELLS_COUNTER_CELLS,
     g_param_spec_boxed ("counter_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_C_CELLS_SERIAL_CELLS,
     g_param_spec_boxed ("serial_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_c_cells_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftcCellsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_c_cells_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftcCells),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_c_cells_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftcCellsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftKCellPlainProperties
{
  PROP_SWCDB_THRIFT_K_CELL_PLAIN_0,
  PROP_SWCDB_THRIFT_K_CELL_PLAIN_C,
  PROP_SWCDB_THRIFT_K_CELL_PLAIN_TS,
  PROP_SWCDB_THRIFT_K_CELL_PLAIN_V
};

/* reads a k_cell_plain object */
static gint32
swcdb_thrift_k_cell_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftKCellPlain * this_object = SWCDB_THRIFT_K_CELL_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_k_cell_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftKCellPlain * this_object = SWCDB_THRIFT_K_CELL_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KCellPlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_k_cell_plain_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftKCellPlain *self = SWCDB_THRIFT_K_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_K_CELL_PLAIN_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELL_PLAIN_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELL_PLAIN_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_k_cell_plain_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftKCellPlain *self = SWCDB_THRIFT_K_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_K_CELL_PLAIN_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_K_CELL_PLAIN_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_K_CELL_PLAIN_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_k_cell_plain_instance_init (swcdb_thriftKCellPlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_k_cell_plain_finalize (GObject *object)
{
  swcdb_thriftKCellPlain *tobject = SWCDB_THRIFT_K_CELL_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_k_cell_plain_class_init (swcdb_thriftKCellPlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_k_cell_plain_read;
  struct_class->write = swcdb_thrift_k_cell_plain_write;

  gobject_class->finalize = swcdb_thrift_k_cell_plain_finalize;
  gobject_class->get_property = swcdb_thrift_k_cell_plain_get_property;
  gobject_class->set_property = swcdb_thrift_k_cell_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_PLAIN_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_PLAIN_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_PLAIN_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_k_cell_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftKCellPlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_k_cell_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftKCellPlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_k_cell_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftKCellPlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftKCellCounterProperties
{
  PROP_SWCDB_THRIFT_K_CELL_COUNTER_0,
  PROP_SWCDB_THRIFT_K_CELL_COUNTER_C,
  PROP_SWCDB_THRIFT_K_CELL_COUNTER_TS,
  PROP_SWCDB_THRIFT_K_CELL_COUNTER_V,
  PROP_SWCDB_THRIFT_K_CELL_COUNTER_EQ
};

/* reads a k_cell_counter object */
static gint32
swcdb_thrift_k_cell_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftKCellCounter * this_object = SWCDB_THRIFT_K_CELL_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->eq, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_eq = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_k_cell_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftKCellCounter * this_object = SWCDB_THRIFT_K_CELL_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KCellCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_eq == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "eq", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->eq, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_k_cell_counter_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftKCellCounter *self = SWCDB_THRIFT_K_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_K_CELL_COUNTER_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELL_COUNTER_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELL_COUNTER_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELL_COUNTER_EQ:
      self->eq = g_value_get_int64 (value);
      self->__isset_eq = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_k_cell_counter_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftKCellCounter *self = SWCDB_THRIFT_K_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_K_CELL_COUNTER_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_K_CELL_COUNTER_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_K_CELL_COUNTER_V:
      g_value_set_int64 (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_K_CELL_COUNTER_EQ:
      g_value_set_int64 (value, self->eq);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_k_cell_counter_instance_init (swcdb_thriftKCellCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
  object->eq = 0;
  object->__isset_eq = FALSE;
}

static void 
swcdb_thrift_k_cell_counter_finalize (GObject *object)
{
  swcdb_thriftKCellCounter *tobject = SWCDB_THRIFT_K_CELL_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
}

static void
swcdb_thrift_k_cell_counter_class_init (swcdb_thriftKCellCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_k_cell_counter_read;
  struct_class->write = swcdb_thrift_k_cell_counter_write;

  gobject_class->finalize = swcdb_thrift_k_cell_counter_finalize;
  gobject_class->get_property = swcdb_thrift_k_cell_counter_get_property;
  gobject_class->set_property = swcdb_thrift_k_cell_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_COUNTER_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_COUNTER_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_COUNTER_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_COUNTER_EQ,
     g_param_spec_int64 ("eq",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_k_cell_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftKCellCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_k_cell_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftKCellCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_k_cell_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftKCellCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftKCellSerialProperties
{
  PROP_SWCDB_THRIFT_K_CELL_SERIAL_0,
  PROP_SWCDB_THRIFT_K_CELL_SERIAL_C,
  PROP_SWCDB_THRIFT_K_CELL_SERIAL_TS,
  PROP_SWCDB_THRIFT_K_CELL_SERIAL_V
};

/* reads a k_cell_serial object */
static gint32
swcdb_thrift_k_cell_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftKCellSerial * this_object = SWCDB_THRIFT_K_CELL_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellValueSerial * _elem151 = NULL;
              if ( _elem151 != NULL)
              {
                g_object_unref (_elem151);
              }
              _elem151 = g_object_new (SWCDB_THRIFT_TYPE_CELL_VALUE_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem151), protocol, error)) < 0)
              {
                g_object_unref (_elem151);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem151);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_k_cell_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftKCellSerial * this_object = SWCDB_THRIFT_K_CELL_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "KCellSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i152;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i152 = 0; i152 < (this_object->v ? this_object->v->len : 0); i152++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i152))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_k_cell_serial_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftKCellSerial *self = SWCDB_THRIFT_K_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_K_CELL_SERIAL_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELL_SERIAL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELL_SERIAL_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_k_cell_serial_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftKCellSerial *self = SWCDB_THRIFT_K_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_K_CELL_SERIAL_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_K_CELL_SERIAL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_K_CELL_SERIAL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_k_cell_serial_instance_init (swcdb_thriftKCellSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_k_cell_serial_finalize (GObject *object)
{
  swcdb_thriftKCellSerial *tobject = SWCDB_THRIFT_K_CELL_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_k_cell_serial_class_init (swcdb_thriftKCellSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_k_cell_serial_read;
  struct_class->write = swcdb_thrift_k_cell_serial_write;

  gobject_class->finalize = swcdb_thrift_k_cell_serial_finalize;
  gobject_class->get_property = swcdb_thrift_k_cell_serial_get_property;
  gobject_class->set_property = swcdb_thrift_k_cell_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_SERIAL_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_SERIAL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELL_SERIAL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_k_cell_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftKCellSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_k_cell_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftKCellSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_k_cell_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftKCellSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftkCellsProperties
{
  PROP_SWCDB_THRIFT_K_CELLS_0,
  PROP_SWCDB_THRIFT_K_CELLS_K,
  PROP_SWCDB_THRIFT_K_CELLS_PLAIN_CELLS,
  PROP_SWCDB_THRIFT_K_CELLS_COUNTER_CELLS,
  PROP_SWCDB_THRIFT_K_CELLS_SERIAL_CELLS
};

/* reads a k_cells object */
static gint32
swcdb_thrift_k_cells_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftkCells * this_object = SWCDB_THRIFT_K_CELLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              GByteArray * _elem153 = NULL;
              if (_elem153 != NULL)
              {
                g_free(_elem153);
                _elem153 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              _elem153 = g_byte_array_new();
              g_byte_array_append (_elem153, (guint8 *) data, (guint) len);
              g_free (data);
              g_ptr_array_add (this_object->k, _elem153);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_k = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftKCellPlain * _elem154 = NULL;
              if ( _elem154 != NULL)
              {
                g_object_unref (_elem154);
              }
              _elem154 = g_object_new (SWCDB_THRIFT_TYPE_K_CELL_PLAIN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem154), protocol, error)) < 0)
              {
                g_object_unref (_elem154);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->plain_cells, _elem154);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_plain_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftKCellCounter * _elem155 = NULL;
              if ( _elem155 != NULL)
              {
                g_object_unref (_elem155);
              }
              _elem155 = g_object_new (SWCDB_THRIFT_TYPE_K_CELL_COUNTER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem155), protocol, error)) < 0)
              {
                g_object_unref (_elem155);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->counter_cells, _elem155);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_counter_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftKCellSerial * _elem156 = NULL;
              if ( _elem156 != NULL)
              {
                g_object_unref (_elem156);
              }
              _elem156 = g_object_new (SWCDB_THRIFT_TYPE_K_CELL_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem156), protocol, error)) < 0)
              {
                g_object_unref (_elem156);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->serial_cells, _elem156);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_serial_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_k_cells_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftkCells * this_object = SWCDB_THRIFT_K_CELLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "kCells", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "k", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i157;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRING, (gint32) (this_object->k ? this_object->k->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i157 = 0; i157 < (this_object->k ? this_object->k->len : 0); i157++)
    {
      if ((ret = thrift_protocol_write_binary (protocol, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i157)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i157)))->data : NULL, ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i157)) ? ((GByteArray *) ((gchar*)g_ptr_array_index ((GPtrArray *) this_object->k, i157)))->len : 0, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "plain_cells", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i158;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->plain_cells ? this_object->plain_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i158 = 0; i158 < (this_object->plain_cells ? this_object->plain_cells->len : 0); i158++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->plain_cells, i158))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "counter_cells", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i159;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->counter_cells ? this_object->counter_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i159 = 0; i159 < (this_object->counter_cells ? this_object->counter_cells->len : 0); i159++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->counter_cells, i159))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serial_cells", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i160;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->serial_cells ? this_object->serial_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i160 = 0; i160 < (this_object->serial_cells ? this_object->serial_cells->len : 0); i160++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->serial_cells, i160))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_k_cells_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  swcdb_thriftkCells *self = SWCDB_THRIFT_K_CELLS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_K_CELLS_K:
      if (self->k != NULL)
        g_ptr_array_unref (self->k);
      self->k = g_value_dup_boxed (value);
      self->__isset_k = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELLS_PLAIN_CELLS:
      if (self->plain_cells != NULL)
        g_ptr_array_unref (self->plain_cells);
      self->plain_cells = g_value_dup_boxed (value);
      self->__isset_plain_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELLS_COUNTER_CELLS:
      if (self->counter_cells != NULL)
        g_ptr_array_unref (self->counter_cells);
      self->counter_cells = g_value_dup_boxed (value);
      self->__isset_counter_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_K_CELLS_SERIAL_CELLS:
      if (self->serial_cells != NULL)
        g_ptr_array_unref (self->serial_cells);
      self->serial_cells = g_value_dup_boxed (value);
      self->__isset_serial_cells = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_k_cells_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  swcdb_thriftkCells *self = SWCDB_THRIFT_K_CELLS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_K_CELLS_K:
      g_value_set_boxed (value, self->k);
      break;

    case PROP_SWCDB_THRIFT_K_CELLS_PLAIN_CELLS:
      g_value_set_boxed (value, self->plain_cells);
      break;

    case PROP_SWCDB_THRIFT_K_CELLS_COUNTER_CELLS:
      g_value_set_boxed (value, self->counter_cells);
      break;

    case PROP_SWCDB_THRIFT_K_CELLS_SERIAL_CELLS:
      g_value_set_boxed (value, self->serial_cells);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_k_cells_instance_init (swcdb_thriftkCells * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->k = g_ptr_array_new_with_free_func (thrift_string_free);
  object->__isset_k = FALSE;
  object->plain_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_plain_cells = FALSE;
  object->counter_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_counter_cells = FALSE;
  object->serial_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_serial_cells = FALSE;
}

static void 
swcdb_thrift_k_cells_finalize (GObject *object)
{
  swcdb_thriftkCells *tobject = SWCDB_THRIFT_K_CELLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->k != NULL)
  {
    g_ptr_array_unref (tobject->k);
    tobject->k = NULL;
  }
  if (tobject->plain_cells != NULL)
  {
    g_ptr_array_unref (tobject->plain_cells);
    tobject->plain_cells = NULL;
  }
  if (tobject->counter_cells != NULL)
  {
    g_ptr_array_unref (tobject->counter_cells);
    tobject->counter_cells = NULL;
  }
  if (tobject->serial_cells != NULL)
  {
    g_ptr_array_unref (tobject->serial_cells);
    tobject->serial_cells = NULL;
  }
}

static void
swcdb_thrift_k_cells_class_init (swcdb_thriftkCellsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_k_cells_read;
  struct_class->write = swcdb_thrift_k_cells_write;

  gobject_class->finalize = swcdb_thrift_k_cells_finalize;
  gobject_class->get_property = swcdb_thrift_k_cells_get_property;
  gobject_class->set_property = swcdb_thrift_k_cells_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELLS_K,
     g_param_spec_boxed ("k",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELLS_PLAIN_CELLS,
     g_param_spec_boxed ("plain_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELLS_COUNTER_CELLS,
     g_param_spec_boxed ("counter_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_K_CELLS_SERIAL_CELLS,
     g_param_spec_boxed ("serial_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_k_cells_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftkCellsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_k_cells_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftkCells),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_k_cells_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftkCellsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFCellPlainProperties
{
  PROP_SWCDB_THRIFT_F_CELL_PLAIN_0,
  PROP_SWCDB_THRIFT_F_CELL_PLAIN_C,
  PROP_SWCDB_THRIFT_F_CELL_PLAIN_TS,
  PROP_SWCDB_THRIFT_F_CELL_PLAIN_V
};

/* reads a f_cell_plain object */
static gint32
swcdb_thrift_f_cell_plain_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFCellPlain * this_object = SWCDB_THRIFT_F_CELL_PLAIN(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_STRING)
        {
          if (this_object->v != NULL)
          {
            g_free(this_object->v);
            this_object->v = NULL;
          }

          if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
            return -1;
          xfer += ret;
          this_object->v = g_byte_array_new();
          g_byte_array_append (this_object->v, (guint8 *) data, (guint) len);
          g_free (data);
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_cell_plain_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFCellPlain * this_object = SWCDB_THRIFT_F_CELL_PLAIN(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FCellPlain", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_STRING, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_binary (protocol, this_object->v ? ((GByteArray *) this_object->v)->data : NULL, this_object->v ? ((GByteArray *) this_object->v)->len : 0, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_cell_plain_set_property (GObject *object,
                                        guint property_id,
                                        const GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftFCellPlain *self = SWCDB_THRIFT_F_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_CELL_PLAIN_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELL_PLAIN_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELL_PLAIN_V:
      if (self->v != NULL)
        g_byte_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_cell_plain_get_property (GObject *object,
                                        guint property_id,
                                        GValue *value,
                                        GParamSpec *pspec)
{
  swcdb_thriftFCellPlain *self = SWCDB_THRIFT_F_CELL_PLAIN (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_CELL_PLAIN_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_F_CELL_PLAIN_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_F_CELL_PLAIN_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_cell_plain_instance_init (swcdb_thriftFCellPlain * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = NULL;
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_f_cell_plain_finalize (GObject *object)
{
  swcdb_thriftFCellPlain *tobject = SWCDB_THRIFT_F_CELL_PLAIN (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->v != NULL)
  {
    thrift_string_free(tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_f_cell_plain_class_init (swcdb_thriftFCellPlainClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_cell_plain_read;
  struct_class->write = swcdb_thrift_f_cell_plain_write;

  gobject_class->finalize = swcdb_thrift_f_cell_plain_finalize;
  gobject_class->get_property = swcdb_thrift_f_cell_plain_get_property;
  gobject_class->set_property = swcdb_thrift_f_cell_plain_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_PLAIN_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_PLAIN_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_PLAIN_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_BYTE_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_cell_plain_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFCellPlainClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_cell_plain_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFCellPlain),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_cell_plain_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFCellPlainType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFCellCounterProperties
{
  PROP_SWCDB_THRIFT_F_CELL_COUNTER_0,
  PROP_SWCDB_THRIFT_F_CELL_COUNTER_C,
  PROP_SWCDB_THRIFT_F_CELL_COUNTER_TS,
  PROP_SWCDB_THRIFT_F_CELL_COUNTER_V,
  PROP_SWCDB_THRIFT_F_CELL_COUNTER_EQ
};

/* reads a f_cell_counter object */
static gint32
swcdb_thrift_f_cell_counter_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFCellCounter * this_object = SWCDB_THRIFT_F_CELL_COUNTER(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->v, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->eq, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_eq = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_cell_counter_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFCellCounter * this_object = SWCDB_THRIFT_F_CELL_COUNTER(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FCellCounter", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_I64, 3, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->v, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_eq == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "eq", T_I64, 4, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->eq, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_cell_counter_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftFCellCounter *self = SWCDB_THRIFT_F_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_CELL_COUNTER_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELL_COUNTER_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELL_COUNTER_V:
      self->v = g_value_get_int64 (value);
      self->__isset_v = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELL_COUNTER_EQ:
      self->eq = g_value_get_int64 (value);
      self->__isset_eq = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_cell_counter_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftFCellCounter *self = SWCDB_THRIFT_F_CELL_COUNTER (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_CELL_COUNTER_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_F_CELL_COUNTER_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_F_CELL_COUNTER_V:
      g_value_set_int64 (value, self->v);
      break;

    case PROP_SWCDB_THRIFT_F_CELL_COUNTER_EQ:
      g_value_set_int64 (value, self->eq);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_cell_counter_instance_init (swcdb_thriftFCellCounter * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = 0;
  object->__isset_v = FALSE;
  object->eq = 0;
  object->__isset_eq = FALSE;
}

static void 
swcdb_thrift_f_cell_counter_finalize (GObject *object)
{
  swcdb_thriftFCellCounter *tobject = SWCDB_THRIFT_F_CELL_COUNTER (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
}

static void
swcdb_thrift_f_cell_counter_class_init (swcdb_thriftFCellCounterClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_cell_counter_read;
  struct_class->write = swcdb_thrift_f_cell_counter_write;

  gobject_class->finalize = swcdb_thrift_f_cell_counter_finalize;
  gobject_class->get_property = swcdb_thrift_f_cell_counter_get_property;
  gobject_class->set_property = swcdb_thrift_f_cell_counter_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_COUNTER_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_COUNTER_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_COUNTER_V,
     g_param_spec_int64 ("v",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_COUNTER_EQ,
     g_param_spec_int64 ("eq",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_cell_counter_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFCellCounterClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_cell_counter_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFCellCounter),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_cell_counter_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFCellCounterType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFCellSerialProperties
{
  PROP_SWCDB_THRIFT_F_CELL_SERIAL_0,
  PROP_SWCDB_THRIFT_F_CELL_SERIAL_C,
  PROP_SWCDB_THRIFT_F_CELL_SERIAL_TS,
  PROP_SWCDB_THRIFT_F_CELL_SERIAL_V
};

/* reads a f_cell_serial object */
static gint32
swcdb_thrift_f_cell_serial_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFCellSerial * this_object = SWCDB_THRIFT_F_CELL_SERIAL(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->c != NULL)
          {
            g_free(this_object->c);
            this_object->c = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->c, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_c = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->ts, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_ts = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellValueSerial * _elem161 = NULL;
              if ( _elem161 != NULL)
              {
                g_object_unref (_elem161);
              }
              _elem161 = g_object_new (SWCDB_THRIFT_TYPE_CELL_VALUE_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem161), protocol, error)) < 0)
              {
                g_object_unref (_elem161);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->v, _elem161);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_v = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_cell_serial_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFCellSerial * this_object = SWCDB_THRIFT_F_CELL_SERIAL(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FCellSerial", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "c", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->c, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ts", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->ts, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "v", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i162;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->v ? this_object->v->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i162 = 0; i162 < (this_object->v ? this_object->v->len : 0); i162++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->v, i162))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_cell_serial_set_property (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftFCellSerial *self = SWCDB_THRIFT_F_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_CELL_SERIAL_C:
      if (self->c != NULL)
        g_free (self->c);
      self->c = g_value_dup_string (value);
      self->__isset_c = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELL_SERIAL_TS:
      self->ts = g_value_get_int64 (value);
      self->__isset_ts = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELL_SERIAL_V:
      if (self->v != NULL)
        g_ptr_array_unref (self->v);
      self->v = g_value_dup_boxed (value);
      self->__isset_v = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_cell_serial_get_property (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec)
{
  swcdb_thriftFCellSerial *self = SWCDB_THRIFT_F_CELL_SERIAL (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_CELL_SERIAL_C:
      g_value_set_string (value, self->c);
      break;

    case PROP_SWCDB_THRIFT_F_CELL_SERIAL_TS:
      g_value_set_int64 (value, self->ts);
      break;

    case PROP_SWCDB_THRIFT_F_CELL_SERIAL_V:
      g_value_set_boxed (value, self->v);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_cell_serial_instance_init (swcdb_thriftFCellSerial * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->c = NULL;
  object->__isset_c = FALSE;
  object->ts = 0;
  object->__isset_ts = FALSE;
  object->v = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_v = FALSE;
}

static void 
swcdb_thrift_f_cell_serial_finalize (GObject *object)
{
  swcdb_thriftFCellSerial *tobject = SWCDB_THRIFT_F_CELL_SERIAL (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->c != NULL)
  {
    g_free(tobject->c);
    tobject->c = NULL;
  }
  if (tobject->v != NULL)
  {
    g_ptr_array_unref (tobject->v);
    tobject->v = NULL;
  }
}

static void
swcdb_thrift_f_cell_serial_class_init (swcdb_thriftFCellSerialClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_cell_serial_read;
  struct_class->write = swcdb_thrift_f_cell_serial_write;

  gobject_class->finalize = swcdb_thrift_f_cell_serial_finalize;
  gobject_class->get_property = swcdb_thrift_f_cell_serial_get_property;
  gobject_class->set_property = swcdb_thrift_f_cell_serial_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_SERIAL_C,
     g_param_spec_string ("c",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_SERIAL_TS,
     g_param_spec_int64 ("ts",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELL_SERIAL_V,
     g_param_spec_boxed ("v",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_cell_serial_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFCellSerialClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_cell_serial_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFCellSerial),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_cell_serial_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFCellSerialType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftFCellsProperties
{
  PROP_SWCDB_THRIFT_F_CELLS_0,
  PROP_SWCDB_THRIFT_F_CELLS_F,
  PROP_SWCDB_THRIFT_F_CELLS_PLAIN_CELLS,
  PROP_SWCDB_THRIFT_F_CELLS_COUNTER_CELLS,
  PROP_SWCDB_THRIFT_F_CELLS_SERIAL_CELLS
};

/* reads a f_cells object */
static gint32
swcdb_thrift_f_cells_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftFCells * this_object = SWCDB_THRIFT_F_CELLS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              GByteArray * key163 = NULL;
              swcdb_thriftFCells * val164 = NULL;
              if (key163 != NULL)
              {
                g_free(key163);
                key163 = NULL;
              }

              if ((ret = thrift_protocol_read_binary (protocol, &data, &len, error)) < 0)
                return -1;
              xfer += ret;
              key163 = g_byte_array_new();
              g_byte_array_append (key163, (guint8 *) data, (guint) len);
              g_free (data);
              if ( val164 != NULL)
              {
                g_object_unref (val164);
              }
              val164 = g_object_new (SWCDB_THRIFT_TYPE_F_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val164), protocol, error)) < 0)
              {
                g_object_unref (val164);
                return -1;
              }
              xfer += ret;
              if (this_object->f && key163)
                g_hash_table_insert ((GHashTable *)this_object->f, (gpointer) key163, (gpointer) val164);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_f = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftFCellPlain * _elem165 = NULL;
              if ( _elem165 != NULL)
              {
                g_object_unref (_elem165);
              }
              _elem165 = g_object_new (SWCDB_THRIFT_TYPE_F_CELL_PLAIN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem165), protocol, error)) < 0)
              {
                g_object_unref (_elem165);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->plain_cells, _elem165);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_plain_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftFCellCounter * _elem166 = NULL;
              if ( _elem166 != NULL)
              {
                g_object_unref (_elem166);
              }
              _elem166 = g_object_new (SWCDB_THRIFT_TYPE_F_CELL_COUNTER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem166), protocol, error)) < 0)
              {
                g_object_unref (_elem166);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->counter_cells, _elem166);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_counter_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftFCellSerial * _elem167 = NULL;
              if ( _elem167 != NULL)
              {
                g_object_unref (_elem167);
              }
              _elem167 = g_object_new (SWCDB_THRIFT_TYPE_F_CELL_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem167), protocol, error)) < 0)
              {
                g_object_unref (_elem167);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->serial_cells, _elem167);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_serial_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_f_cells_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftFCells * this_object = SWCDB_THRIFT_F_CELLS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "FCells", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "f", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    GByteArray * key168 = NULL;
    swcdb_thriftFCells * val169 = NULL;
    GList *key_list = NULL, *iter = NULL;
    GByteArray ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->f ? (gint32) g_hash_table_size ((GHashTable *) this_object->f) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->f)
      g_hash_table_foreach ((GHashTable *) this_object->f, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (GByteArray *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (GByteArray *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key168 = keys[i];
      val169 = (swcdb_thriftFCells *) g_hash_table_lookup (((GHashTable *) this_object->f), (gpointer) key168);

      if ((ret = thrift_protocol_write_binary (protocol,  key168 ? ((GByteArray *)  key168)->data : NULL,  key168 ? ((GByteArray *)  key168)->len : 0, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val169), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "plain_cells", T_LIST, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i170;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->plain_cells ? this_object->plain_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i170 = 0; i170 < (this_object->plain_cells ? this_object->plain_cells->len : 0); i170++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->plain_cells, i170))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "counter_cells", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i171;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->counter_cells ? this_object->counter_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i171 = 0; i171 < (this_object->counter_cells ? this_object->counter_cells->len : 0); i171++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->counter_cells, i171))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serial_cells", T_LIST, 4, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i172;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->serial_cells ? this_object->serial_cells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i172 = 0; i172 < (this_object->serial_cells ? this_object->serial_cells->len : 0); i172++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->serial_cells, i172))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_f_cells_set_property (GObject *object,
                                   guint property_id,
                                   const GValue *value,
                                   GParamSpec *pspec)
{
  swcdb_thriftFCells *self = SWCDB_THRIFT_F_CELLS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_CELLS_F:
      if (self->f != NULL)
        g_hash_table_unref (self->f);
      self->f = g_value_dup_boxed (value);
      self->__isset_f = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELLS_PLAIN_CELLS:
      if (self->plain_cells != NULL)
        g_ptr_array_unref (self->plain_cells);
      self->plain_cells = g_value_dup_boxed (value);
      self->__isset_plain_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELLS_COUNTER_CELLS:
      if (self->counter_cells != NULL)
        g_ptr_array_unref (self->counter_cells);
      self->counter_cells = g_value_dup_boxed (value);
      self->__isset_counter_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_F_CELLS_SERIAL_CELLS:
      if (self->serial_cells != NULL)
        g_ptr_array_unref (self->serial_cells);
      self->serial_cells = g_value_dup_boxed (value);
      self->__isset_serial_cells = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_f_cells_get_property (GObject *object,
                                   guint property_id,
                                   GValue *value,
                                   GParamSpec *pspec)
{
  swcdb_thriftFCells *self = SWCDB_THRIFT_F_CELLS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_F_CELLS_F:
      g_value_set_boxed (value, self->f);
      break;

    case PROP_SWCDB_THRIFT_F_CELLS_PLAIN_CELLS:
      g_value_set_boxed (value, self->plain_cells);
      break;

    case PROP_SWCDB_THRIFT_F_CELLS_COUNTER_CELLS:
      g_value_set_boxed (value, self->counter_cells);
      break;

    case PROP_SWCDB_THRIFT_F_CELLS_SERIAL_CELLS:
      g_value_set_boxed (value, self->serial_cells);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_f_cells_instance_init (swcdb_thriftFCells * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->f = g_hash_table_new_full (g_str_hash, g_str_equal, thrift_string_free, g_object_unref);
  object->__isset_f = FALSE;
  object->plain_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_plain_cells = FALSE;
  object->counter_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_counter_cells = FALSE;
  object->serial_cells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_serial_cells = FALSE;
}

static void 
swcdb_thrift_f_cells_finalize (GObject *object)
{
  swcdb_thriftFCells *tobject = SWCDB_THRIFT_F_CELLS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->f != NULL)
  {
    g_hash_table_destroy (tobject->f);
    tobject->f = NULL;
  }
  if (tobject->plain_cells != NULL)
  {
    g_ptr_array_unref (tobject->plain_cells);
    tobject->plain_cells = NULL;
  }
  if (tobject->counter_cells != NULL)
  {
    g_ptr_array_unref (tobject->counter_cells);
    tobject->counter_cells = NULL;
  }
  if (tobject->serial_cells != NULL)
  {
    g_ptr_array_unref (tobject->serial_cells);
    tobject->serial_cells = NULL;
  }
}

static void
swcdb_thrift_f_cells_class_init (swcdb_thriftFCellsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_f_cells_read;
  struct_class->write = swcdb_thrift_f_cells_write;

  gobject_class->finalize = swcdb_thrift_f_cells_finalize;
  gobject_class->get_property = swcdb_thrift_f_cells_get_property;
  gobject_class->set_property = swcdb_thrift_f_cells_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELLS_F,
     g_param_spec_boxed ("f",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELLS_PLAIN_CELLS,
     g_param_spec_boxed ("plain_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELLS_COUNTER_CELLS,
     g_param_spec_boxed ("counter_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_F_CELLS_SERIAL_CELLS,
     g_param_spec_boxed ("serial_cells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_f_cells_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftFCellsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_f_cells_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftFCells),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_f_cells_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftFCellsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCellsGroupProperties
{
  PROP_SWCDB_THRIFT_CELLS_GROUP_0,
  PROP_SWCDB_THRIFT_CELLS_GROUP_CELLS,
  PROP_SWCDB_THRIFT_CELLS_GROUP_CCELLS,
  PROP_SWCDB_THRIFT_CELLS_GROUP_KCELLS,
  PROP_SWCDB_THRIFT_CELLS_GROUP_FCELLS
};

/* reads a cells_group object */
static gint32
swcdb_thrift_cells_group_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCellsGroup * this_object = SWCDB_THRIFT_CELLS_GROUP(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cells), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key173 = NULL;
              swcdb_thriftcCells * val174 = NULL;
              if (key173 != NULL)
              {
                g_free(key173);
                key173 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key173, error)) < 0)
                return -1;
              xfer += ret;
              if ( val174 != NULL)
              {
                g_object_unref (val174);
              }
              val174 = g_object_new (SWCDB_THRIFT_TYPE_C_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val174), protocol, error)) < 0)
              {
                g_object_unref (val174);
                return -1;
              }
              xfer += ret;
              if (this_object->ccells && key173)
                g_hash_table_insert ((GHashTable *)this_object->ccells, (gpointer) key173, (gpointer) val174);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_ccells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftkCells * _elem175 = NULL;
              if ( _elem175 != NULL)
              {
                g_object_unref (_elem175);
              }
              _elem175 = g_object_new (SWCDB_THRIFT_TYPE_K_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem175), protocol, error)) < 0)
              {
                g_object_unref (_elem175);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->kcells, _elem175);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_kcells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->fcells), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_fcells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_cells_group_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCellsGroup * this_object = SWCDB_THRIFT_CELLS_GROUP(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CellsGroup", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cells), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "ccells", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    gchar * key176 = NULL;
    swcdb_thriftcCells * val177 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gchar ** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->ccells ? (gint32) g_hash_table_size ((GHashTable *) this_object->ccells) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->ccells)
      g_hash_table_foreach ((GHashTable *) this_object->ccells, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gchar *, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gchar *) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key176 = keys[i];
      val177 = (swcdb_thriftcCells *) g_hash_table_lookup (((GHashTable *) this_object->ccells), (gpointer) key176);

      if ((ret = thrift_protocol_write_string (protocol,  key176, error)) < 0)
        return -1;
      xfer += ret;

      if ((ret = thrift_struct_write (THRIFT_STRUCT ( val177), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "kcells", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i178;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->kcells ? this_object->kcells->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i178 = 0; i178 < (this_object->kcells ? this_object->kcells->len : 0); i178++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->kcells, i178))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "fcells", T_STRUCT, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->fcells), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_cells_group_set_property (GObject *object,
                                       guint property_id,
                                       const GValue *value,
                                       GParamSpec *pspec)
{
  swcdb_thriftCellsGroup *self = SWCDB_THRIFT_CELLS_GROUP (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELLS_GROUP_CELLS:
      if (self->cells != NULL)
        g_object_unref (self->cells);
      self->cells = g_value_dup_object (value);
      self->__isset_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELLS_GROUP_CCELLS:
      if (self->ccells != NULL)
        g_hash_table_unref (self->ccells);
      self->ccells = g_value_dup_boxed (value);
      self->__isset_ccells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELLS_GROUP_KCELLS:
      if (self->kcells != NULL)
        g_ptr_array_unref (self->kcells);
      self->kcells = g_value_dup_boxed (value);
      self->__isset_kcells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_CELLS_GROUP_FCELLS:
      if (self->fcells != NULL)
        g_object_unref (self->fcells);
      self->fcells = g_value_dup_object (value);
      self->__isset_fcells = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_cells_group_get_property (GObject *object,
                                       guint property_id,
                                       GValue *value,
                                       GParamSpec *pspec)
{
  swcdb_thriftCellsGroup *self = SWCDB_THRIFT_CELLS_GROUP (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_CELLS_GROUP_CELLS:
      g_value_set_object (value, self->cells);
      break;

    case PROP_SWCDB_THRIFT_CELLS_GROUP_CCELLS:
      g_value_set_boxed (value, self->ccells);
      break;

    case PROP_SWCDB_THRIFT_CELLS_GROUP_KCELLS:
      g_value_set_boxed (value, self->kcells);
      break;

    case PROP_SWCDB_THRIFT_CELLS_GROUP_FCELLS:
      g_value_set_object (value, self->fcells);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_cells_group_instance_init (swcdb_thriftCellsGroup * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cells = g_object_new (SWCDB_THRIFT_TYPE_CELLS, NULL);
  object->__isset_cells = FALSE;
  object->ccells = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
  object->__isset_ccells = FALSE;
  object->kcells = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_kcells = FALSE;
  object->fcells = g_object_new (SWCDB_THRIFT_TYPE_F_CELLS, NULL);
  object->__isset_fcells = FALSE;
}

static void 
swcdb_thrift_cells_group_finalize (GObject *object)
{
  swcdb_thriftCellsGroup *tobject = SWCDB_THRIFT_CELLS_GROUP (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cells != NULL)
  {
    g_object_unref(tobject->cells);
    tobject->cells = NULL;
  }
  if (tobject->ccells != NULL)
  {
    g_hash_table_destroy (tobject->ccells);
    tobject->ccells = NULL;
  }
  if (tobject->kcells != NULL)
  {
    g_ptr_array_unref (tobject->kcells);
    tobject->kcells = NULL;
  }
  if (tobject->fcells != NULL)
  {
    g_object_unref(tobject->fcells);
    tobject->fcells = NULL;
  }
}

static void
swcdb_thrift_cells_group_class_init (swcdb_thriftCellsGroupClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_cells_group_read;
  struct_class->write = swcdb_thrift_cells_group_write;

  gobject_class->finalize = swcdb_thrift_cells_group_finalize;
  gobject_class->get_property = swcdb_thrift_cells_group_get_property;
  gobject_class->set_property = swcdb_thrift_cells_group_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELLS_GROUP_CELLS,
     g_param_spec_object ("cells",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_CELLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELLS_GROUP_CCELLS,
     g_param_spec_boxed ("ccells",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELLS_GROUP_KCELLS,
     g_param_spec_boxed ("kcells",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_CELLS_GROUP_FCELLS,
     g_param_spec_object ("fcells",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_F_CELLS,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_cells_group_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCellsGroupClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_cells_group_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCellsGroup),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_cells_group_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCellsGroupType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftCompactResultProperties
{
  PROP_SWCDB_THRIFT_COMPACT_RESULT_0,
  PROP_SWCDB_THRIFT_COMPACT_RESULT_CID,
  PROP_SWCDB_THRIFT_COMPACT_RESULT_ERR
};

/* reads a compact_result object */
static gint32
swcdb_thrift_compact_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftCompactResult * this_object = SWCDB_THRIFT_COMPACT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->cid, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_cid = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->err, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_err = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_compact_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftCompactResult * this_object = SWCDB_THRIFT_COMPACT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "CompactResult", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cid", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->cid, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "err", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->err, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_compact_result_set_property (GObject *object,
                                          guint property_id,
                                          const GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftCompactResult *self = SWCDB_THRIFT_COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_COMPACT_RESULT_CID:
      self->cid = g_value_get_int64 (value);
      self->__isset_cid = TRUE;
      break;

    case PROP_SWCDB_THRIFT_COMPACT_RESULT_ERR:
      self->err = g_value_get_int (value);
      self->__isset_err = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_compact_result_get_property (GObject *object,
                                          guint property_id,
                                          GValue *value,
                                          GParamSpec *pspec)
{
  swcdb_thriftCompactResult *self = SWCDB_THRIFT_COMPACT_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_COMPACT_RESULT_CID:
      g_value_set_int64 (value, self->cid);
      break;

    case PROP_SWCDB_THRIFT_COMPACT_RESULT_ERR:
      g_value_set_int (value, self->err);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_compact_result_instance_init (swcdb_thriftCompactResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cid = 0;
  object->__isset_cid = FALSE;
  object->err = 0;
  object->__isset_err = FALSE;
}

static void 
swcdb_thrift_compact_result_finalize (GObject *object)
{
  swcdb_thriftCompactResult *tobject = SWCDB_THRIFT_COMPACT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_compact_result_class_init (swcdb_thriftCompactResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_compact_result_read;
  struct_class->write = swcdb_thrift_compact_result_write;

  gobject_class->finalize = swcdb_thrift_compact_result_finalize;
  gobject_class->get_property = swcdb_thrift_compact_result_get_property;
  gobject_class->set_property = swcdb_thrift_compact_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_COMPACT_RESULT_CID,
     g_param_spec_int64 ("cid",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_COMPACT_RESULT_ERR,
     g_param_spec_int ("err",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
swcdb_thrift_compact_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftCompactResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_compact_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftCompactResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_compact_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftCompactResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftResultProperties
{
  PROP_SWCDB_THRIFT_RESULT_0,
  PROP_SWCDB_THRIFT_RESULT_SCHEMAS,
  PROP_SWCDB_THRIFT_RESULT_CELLS,
  PROP_SWCDB_THRIFT_RESULT_COMPACT
};

/* reads a result object */
static gint32
swcdb_thrift_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftResult * this_object = SWCDB_THRIFT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSchema * _elem179 = NULL;
              if ( _elem179 != NULL)
              {
                g_object_unref (_elem179);
              }
              _elem179 = g_object_new (SWCDB_THRIFT_TYPE_SCHEMA, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem179), protocol, error)) < 0)
              {
                g_object_unref (_elem179);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->schemas, _elem179);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_schemas = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->cells), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCompactResult * _elem180 = NULL;
              if ( _elem180 != NULL)
              {
                g_object_unref (_elem180);
              }
              _elem180 = g_object_new (SWCDB_THRIFT_TYPE_COMPACT_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem180), protocol, error)) < 0)
              {
                g_object_unref (_elem180);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->compact, _elem180);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_compact = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftResult * this_object = SWCDB_THRIFT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "Result", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schemas", T_LIST, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i181;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->schemas ? this_object->schemas->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i181 = 0; i181 < (this_object->schemas ? this_object->schemas->len : 0); i181++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->schemas, i181))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->cells), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "compact", T_LIST, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    guint i182;

    if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->compact ? this_object->compact->len : 0), error)) < 0)
      return -1;
    xfer += ret;
    for (i182 = 0; i182 < (this_object->compact ? this_object->compact->len : 0); i182++)
    {
      if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->compact, i182))), protocol, error)) < 0)
        return -1;
      xfer += ret;

    }
    if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_result_set_property (GObject *object,
                                  guint property_id,
                                  const GValue *value,
                                  GParamSpec *pspec)
{
  swcdb_thriftResult *self = SWCDB_THRIFT_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_RESULT_SCHEMAS:
      if (self->schemas != NULL)
        g_ptr_array_unref (self->schemas);
      self->schemas = g_value_dup_boxed (value);
      self->__isset_schemas = TRUE;
      break;

    case PROP_SWCDB_THRIFT_RESULT_CELLS:
      if (self->cells != NULL)
        g_object_unref (self->cells);
      self->cells = g_value_dup_object (value);
      self->__isset_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_RESULT_COMPACT:
      if (self->compact != NULL)
        g_ptr_array_unref (self->compact);
      self->compact = g_value_dup_boxed (value);
      self->__isset_compact = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_result_get_property (GObject *object,
                                  guint property_id,
                                  GValue *value,
                                  GParamSpec *pspec)
{
  swcdb_thriftResult *self = SWCDB_THRIFT_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_RESULT_SCHEMAS:
      g_value_set_boxed (value, self->schemas);
      break;

    case PROP_SWCDB_THRIFT_RESULT_CELLS:
      g_value_set_object (value, self->cells);
      break;

    case PROP_SWCDB_THRIFT_RESULT_COMPACT:
      g_value_set_boxed (value, self->compact);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_result_instance_init (swcdb_thriftResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->schemas = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_schemas = FALSE;
  object->cells = g_object_new (SWCDB_THRIFT_TYPE_CELLS, NULL);
  object->__isset_cells = FALSE;
  object->compact = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_compact = FALSE;
}

static void 
swcdb_thrift_result_finalize (GObject *object)
{
  swcdb_thriftResult *tobject = SWCDB_THRIFT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schemas != NULL)
  {
    g_ptr_array_unref (tobject->schemas);
    tobject->schemas = NULL;
  }
  if (tobject->cells != NULL)
  {
    g_object_unref(tobject->cells);
    tobject->cells = NULL;
  }
  if (tobject->compact != NULL)
  {
    g_ptr_array_unref (tobject->compact);
    tobject->compact = NULL;
  }
}

static void
swcdb_thrift_result_class_init (swcdb_thriftResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_result_read;
  struct_class->write = swcdb_thrift_result_write;

  gobject_class->finalize = swcdb_thrift_result_finalize;
  gobject_class->get_property = swcdb_thrift_result_get_property;
  gobject_class->set_property = swcdb_thrift_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_RESULT_SCHEMAS,
     g_param_spec_boxed ("schemas",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_RESULT_CELLS,
     g_param_spec_object ("cells",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_CELLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_RESULT_COMPACT,
     g_param_spec_boxed ("compact",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftResultType",
                                   &type_info, 0);
  }

  return type;
}

/* constants */

enum _swcdb_thriftServiceSqlMngColumnArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS_SQL
};

/* reads a service_sql_mng_column_args object */
static gint32
swcdb_thrift_service_sql_mng_column_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlMngColumnArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_mng_column_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlMngColumnArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlMngColumnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_mng_column_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceSqlMngColumnArgs *self = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_mng_column_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceSqlMngColumnArgs *self = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_mng_column_args_instance_init (swcdb_thriftServiceSqlMngColumnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_mng_column_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlMngColumnArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_mng_column_args_class_init (swcdb_thriftServiceSqlMngColumnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_mng_column_args_read;
  struct_class->write = swcdb_thrift_service_sql_mng_column_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_mng_column_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_mng_column_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_mng_column_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_mng_column_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlMngColumnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_mng_column_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlMngColumnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_mng_column_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlMngColumnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlMngColumnResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT_E
};

/* reads a service_sql_mng_column_result object */
static gint32
swcdb_thrift_service_sql_mng_column_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlMngColumnResult * this_object = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_mng_column_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlMngColumnResult * this_object = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlMngColumnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_mng_column_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceSqlMngColumnResult *self = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_mng_column_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceSqlMngColumnResult *self = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_mng_column_result_instance_init (swcdb_thriftServiceSqlMngColumnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_mng_column_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlMngColumnResult *tobject = SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_mng_column_result_class_init (swcdb_thriftServiceSqlMngColumnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_mng_column_result_read;
  struct_class->write = swcdb_thrift_service_sql_mng_column_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_mng_column_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_mng_column_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_mng_column_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_MNG_COLUMN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_mng_column_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlMngColumnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_mng_column_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlMngColumnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_mng_column_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlMngColumnResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlListColumnsArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS_SQL
};

/* reads a service_sql_list_columns_args object */
static gint32
swcdb_thrift_service_sql_list_columns_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlListColumnsArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_list_columns_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlListColumnsArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlListColumnsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_list_columns_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceSqlListColumnsArgs *self = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_list_columns_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceSqlListColumnsArgs *self = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_list_columns_args_instance_init (swcdb_thriftServiceSqlListColumnsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_list_columns_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlListColumnsArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_list_columns_args_class_init (swcdb_thriftServiceSqlListColumnsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_list_columns_args_read;
  struct_class->write = swcdb_thrift_service_sql_list_columns_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_list_columns_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_list_columns_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_list_columns_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_list_columns_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlListColumnsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_list_columns_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlListColumnsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_list_columns_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlListColumnsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlListColumnsResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_E
};

/* reads a service_sql_list_columns_result object */
static gint32
swcdb_thrift_service_sql_list_columns_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlListColumnsResult * this_object = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSchema * _elem183 = NULL;
              if ( _elem183 != NULL)
              {
                g_object_unref (_elem183);
              }
              _elem183 = g_object_new (SWCDB_THRIFT_TYPE_SCHEMA, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem183), protocol, error)) < 0)
              {
                g_object_unref (_elem183);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem183);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_list_columns_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlListColumnsResult * this_object = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlListColumnsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i184;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i184 = 0; i184 < (this_object->success ? this_object->success->len : 0); i184++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i184))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_list_columns_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  swcdb_thriftServiceSqlListColumnsResult *self = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_list_columns_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  swcdb_thriftServiceSqlListColumnsResult *self = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_list_columns_result_instance_init (swcdb_thriftServiceSqlListColumnsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_list_columns_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlListColumnsResult *tobject = SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_list_columns_result_class_init (swcdb_thriftServiceSqlListColumnsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_list_columns_result_read;
  struct_class->write = swcdb_thrift_service_sql_list_columns_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_list_columns_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_list_columns_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_list_columns_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_LIST_COLUMNS_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_list_columns_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlListColumnsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_list_columns_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlListColumnsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_list_columns_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlListColumnsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlCompactColumnsArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS_SQL
};

/* reads a service_sql_compact_columns_args object */
static gint32
swcdb_thrift_service_sql_compact_columns_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlCompactColumnsArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_compact_columns_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlCompactColumnsArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlCompactColumnsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_compact_columns_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  swcdb_thriftServiceSqlCompactColumnsArgs *self = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_compact_columns_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  swcdb_thriftServiceSqlCompactColumnsArgs *self = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_compact_columns_args_instance_init (swcdb_thriftServiceSqlCompactColumnsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_compact_columns_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlCompactColumnsArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_compact_columns_args_class_init (swcdb_thriftServiceSqlCompactColumnsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_compact_columns_args_read;
  struct_class->write = swcdb_thrift_service_sql_compact_columns_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_compact_columns_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_compact_columns_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_compact_columns_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_compact_columns_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlCompactColumnsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_compact_columns_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlCompactColumnsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_compact_columns_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlCompactColumnsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlCompactColumnsResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_E
};

/* reads a service_sql_compact_columns_result object */
static gint32
swcdb_thrift_service_sql_compact_columns_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlCompactColumnsResult * this_object = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCompactResult * _elem185 = NULL;
              if ( _elem185 != NULL)
              {
                g_object_unref (_elem185);
              }
              _elem185 = g_object_new (SWCDB_THRIFT_TYPE_COMPACT_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem185), protocol, error)) < 0)
              {
                g_object_unref (_elem185);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem185);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_compact_columns_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlCompactColumnsResult * this_object = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlCompactColumnsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i186;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i186 = 0; i186 < (this_object->success ? this_object->success->len : 0); i186++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i186))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_compact_columns_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  swcdb_thriftServiceSqlCompactColumnsResult *self = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_compact_columns_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  swcdb_thriftServiceSqlCompactColumnsResult *self = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_compact_columns_result_instance_init (swcdb_thriftServiceSqlCompactColumnsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_compact_columns_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlCompactColumnsResult *tobject = SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_compact_columns_result_class_init (swcdb_thriftServiceSqlCompactColumnsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_compact_columns_result_read;
  struct_class->write = swcdb_thrift_service_sql_compact_columns_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_compact_columns_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_compact_columns_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_compact_columns_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_COMPACT_COLUMNS_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_compact_columns_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlCompactColumnsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_compact_columns_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlCompactColumnsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_compact_columns_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlCompactColumnsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectPlainArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS_SQL
};

/* reads a service_sql_select_plain_args object */
static gint32
swcdb_thrift_service_sql_select_plain_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectPlainArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_plain_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectPlainArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectPlainArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_plain_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectPlainArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_plain_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectPlainArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_plain_args_instance_init (swcdb_thriftServiceSqlSelectPlainArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_select_plain_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectPlainArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_plain_args_class_init (swcdb_thriftServiceSqlSelectPlainArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_plain_args_read;
  struct_class->write = swcdb_thrift_service_sql_select_plain_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_plain_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_plain_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_plain_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_plain_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectPlainArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_plain_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectPlainArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_plain_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectPlainArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectPlainResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_E
};

/* reads a service_sql_select_plain_result object */
static gint32
swcdb_thrift_service_sql_select_plain_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectPlainResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellPlain * _elem187 = NULL;
              if ( _elem187 != NULL)
              {
                g_object_unref (_elem187);
              }
              _elem187 = g_object_new (SWCDB_THRIFT_TYPE_CELL_PLAIN, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem187), protocol, error)) < 0)
              {
                g_object_unref (_elem187);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem187);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_plain_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectPlainResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectPlainResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i188;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i188 = 0; i188 < (this_object->success ? this_object->success->len : 0); i188++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i188))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_plain_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectPlainResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_plain_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectPlainResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_plain_result_instance_init (swcdb_thriftServiceSqlSelectPlainResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_select_plain_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectPlainResult *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_plain_result_class_init (swcdb_thriftServiceSqlSelectPlainResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_plain_result_read;
  struct_class->write = swcdb_thrift_service_sql_select_plain_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_plain_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_plain_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_plain_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_PLAIN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_plain_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectPlainResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_plain_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectPlainResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_plain_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectPlainResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectCounterArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS_SQL
};

/* reads a service_sql_select_counter_args object */
static gint32
swcdb_thrift_service_sql_select_counter_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectCounterArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_counter_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectCounterArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectCounterArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_counter_args_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectCounterArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_counter_args_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectCounterArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_counter_args_instance_init (swcdb_thriftServiceSqlSelectCounterArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_select_counter_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectCounterArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_counter_args_class_init (swcdb_thriftServiceSqlSelectCounterArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_counter_args_read;
  struct_class->write = swcdb_thrift_service_sql_select_counter_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_counter_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_counter_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_counter_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_counter_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectCounterArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_counter_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectCounterArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_counter_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectCounterArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectCounterResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_E
};

/* reads a service_sql_select_counter_result object */
static gint32
swcdb_thrift_service_sql_select_counter_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectCounterResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellCounter * _elem189 = NULL;
              if ( _elem189 != NULL)
              {
                g_object_unref (_elem189);
              }
              _elem189 = g_object_new (SWCDB_THRIFT_TYPE_CELL_COUNTER, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem189), protocol, error)) < 0)
              {
                g_object_unref (_elem189);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem189);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_counter_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectCounterResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectCounterResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i190;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i190 = 0; i190 < (this_object->success ? this_object->success->len : 0); i190++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i190))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_counter_result_set_property (GObject *object,
                                                             guint property_id,
                                                             const GValue *value,
                                                             GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectCounterResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_counter_result_get_property (GObject *object,
                                                             guint property_id,
                                                             GValue *value,
                                                             GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectCounterResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_counter_result_instance_init (swcdb_thriftServiceSqlSelectCounterResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_select_counter_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectCounterResult *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_counter_result_class_init (swcdb_thriftServiceSqlSelectCounterResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_counter_result_read;
  struct_class->write = swcdb_thrift_service_sql_select_counter_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_counter_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_counter_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_counter_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_COUNTER_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_counter_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectCounterResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_counter_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectCounterResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_counter_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectCounterResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectSerialArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS_SQL
};

/* reads a service_sql_select_serial_args object */
static gint32
swcdb_thrift_service_sql_select_serial_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectSerialArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_serial_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectSerialArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectSerialArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_serial_args_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectSerialArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_serial_args_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectSerialArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_serial_args_instance_init (swcdb_thriftServiceSqlSelectSerialArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_select_serial_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectSerialArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_serial_args_class_init (swcdb_thriftServiceSqlSelectSerialArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_serial_args_read;
  struct_class->write = swcdb_thrift_service_sql_select_serial_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_serial_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_serial_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_serial_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_serial_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectSerialArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_serial_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectSerialArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_serial_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectSerialArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectSerialResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_E
};

/* reads a service_sql_select_serial_result object */
static gint32
swcdb_thrift_service_sql_select_serial_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectSerialResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCellSerial * _elem191 = NULL;
              if ( _elem191 != NULL)
              {
                g_object_unref (_elem191);
              }
              _elem191 = g_object_new (SWCDB_THRIFT_TYPE_CELL_SERIAL, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem191), protocol, error)) < 0)
              {
                g_object_unref (_elem191);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem191);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_serial_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectSerialResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectSerialResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i192;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i192 = 0; i192 < (this_object->success ? this_object->success->len : 0); i192++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i192))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_serial_result_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectSerialResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_serial_result_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectSerialResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_serial_result_instance_init (swcdb_thriftServiceSqlSelectSerialResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_select_serial_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectSerialResult *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_serial_result_class_init (swcdb_thriftServiceSqlSelectSerialResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_serial_result_read;
  struct_class->write = swcdb_thrift_service_sql_select_serial_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_serial_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_serial_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_serial_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_SERIAL_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_serial_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectSerialResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_serial_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectSerialResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_serial_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectSerialResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS_SQL
};

/* reads a service_sql_select_args object */
static gint32
swcdb_thrift_service_sql_select_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_args_instance_init (swcdb_thriftServiceSqlSelectArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_select_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_args_class_init (swcdb_thriftServiceSqlSelectArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_args_read;
  struct_class->write = swcdb_thrift_service_sql_select_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_E
};

/* reads a service_sql_select_result object */
static gint32
swcdb_thrift_service_sql_select_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_result_instance_init (swcdb_thriftServiceSqlSelectResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (SWCDB_THRIFT_TYPE_CELLS, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_select_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectResult *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_result_class_init (swcdb_thriftServiceSqlSelectResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_result_read;
  struct_class->write = swcdb_thrift_service_sql_select_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_CELLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectRsltOnColumnArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_SQL
};

/* reads a service_sql_select_rslt_on_column_args object */
static gint32
swcdb_thrift_service_sql_select_rslt_on_column_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectRsltOnColumnArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_rslt_on_column_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectRsltOnColumnArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnColumnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_rslt_on_column_args_set_property (GObject *object,
                                                                  guint property_id,
                                                                  const GValue *value,
                                                                  GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnColumnArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_column_args_get_property (GObject *object,
                                                                  guint property_id,
                                                                  GValue *value,
                                                                  GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnColumnArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_rslt_on_column_args_instance_init (swcdb_thriftServiceSqlSelectRsltOnColumnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_select_rslt_on_column_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectRsltOnColumnArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_column_args_class_init (swcdb_thriftServiceSqlSelectRsltOnColumnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_rslt_on_column_args_read;
  struct_class->write = swcdb_thrift_service_sql_select_rslt_on_column_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_rslt_on_column_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_rslt_on_column_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_rslt_on_column_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_rslt_on_column_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectRsltOnColumnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_rslt_on_column_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectRsltOnColumnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_rslt_on_column_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectRsltOnColumnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectRsltOnColumnResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_E
};

/* reads a service_sql_select_rslt_on_column_result object */
static gint32
swcdb_thrift_service_sql_select_rslt_on_column_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectRsltOnColumnResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key193 = NULL;
              swcdb_thriftcCells * val194 = NULL;
              if (key193 != NULL)
              {
                g_free(key193);
                key193 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key193, error)) < 0)
                return -1;
              xfer += ret;
              if ( val194 != NULL)
              {
                g_object_unref (val194);
              }
              val194 = g_object_new (SWCDB_THRIFT_TYPE_C_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val194), protocol, error)) < 0)
              {
                g_object_unref (val194);
                return -1;
              }
              xfer += ret;
              if (this_object->success && key193)
                g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key193, (gpointer) val194);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_rslt_on_column_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectRsltOnColumnResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnColumnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key195 = NULL;
      swcdb_thriftcCells * val196 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->success ? (gint32) g_hash_table_size ((GHashTable *) this_object->success) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->success)
        g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key195 = keys[i];
        val196 = (swcdb_thriftcCells *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key195);

        if ((ret = thrift_protocol_write_string (protocol,  key195, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_struct_write (THRIFT_STRUCT ( val196), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_rslt_on_column_result_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnColumnResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_column_result_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnColumnResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_rslt_on_column_result_instance_init (swcdb_thriftServiceSqlSelectRsltOnColumnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_select_rslt_on_column_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectRsltOnColumnResult *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_column_result_class_init (swcdb_thriftServiceSqlSelectRsltOnColumnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_rslt_on_column_result_read;
  struct_class->write = swcdb_thrift_service_sql_select_rslt_on_column_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_rslt_on_column_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_rslt_on_column_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_rslt_on_column_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_COLUMN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_rslt_on_column_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectRsltOnColumnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_rslt_on_column_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectRsltOnColumnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_rslt_on_column_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectRsltOnColumnResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectRsltOnKeyArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_SQL
};

/* reads a service_sql_select_rslt_on_key_args object */
static gint32
swcdb_thrift_service_sql_select_rslt_on_key_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectRsltOnKeyArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_rslt_on_key_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectRsltOnKeyArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnKeyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_rslt_on_key_args_set_property (GObject *object,
                                                               guint property_id,
                                                               const GValue *value,
                                                               GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnKeyArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_key_args_get_property (GObject *object,
                                                               guint property_id,
                                                               GValue *value,
                                                               GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnKeyArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_rslt_on_key_args_instance_init (swcdb_thriftServiceSqlSelectRsltOnKeyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_select_rslt_on_key_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectRsltOnKeyArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_key_args_class_init (swcdb_thriftServiceSqlSelectRsltOnKeyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_rslt_on_key_args_read;
  struct_class->write = swcdb_thrift_service_sql_select_rslt_on_key_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_rslt_on_key_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_rslt_on_key_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_rslt_on_key_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_rslt_on_key_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectRsltOnKeyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_rslt_on_key_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectRsltOnKeyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_rslt_on_key_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectRsltOnKeyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectRsltOnKeyResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_E
};

/* reads a service_sql_select_rslt_on_key_result object */
static gint32
swcdb_thrift_service_sql_select_rslt_on_key_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectRsltOnKeyResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftkCells * _elem197 = NULL;
              if ( _elem197 != NULL)
              {
                g_object_unref (_elem197);
              }
              _elem197 = g_object_new (SWCDB_THRIFT_TYPE_K_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem197), protocol, error)) < 0)
              {
                g_object_unref (_elem197);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem197);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_rslt_on_key_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectRsltOnKeyResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnKeyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i198;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i198 = 0; i198 < (this_object->success ? this_object->success->len : 0); i198++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i198))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_rslt_on_key_result_set_property (GObject *object,
                                                                 guint property_id,
                                                                 const GValue *value,
                                                                 GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnKeyResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_key_result_get_property (GObject *object,
                                                                 guint property_id,
                                                                 GValue *value,
                                                                 GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnKeyResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_rslt_on_key_result_instance_init (swcdb_thriftServiceSqlSelectRsltOnKeyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_select_rslt_on_key_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectRsltOnKeyResult *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_key_result_class_init (swcdb_thriftServiceSqlSelectRsltOnKeyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_rslt_on_key_result_read;
  struct_class->write = swcdb_thrift_service_sql_select_rslt_on_key_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_rslt_on_key_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_rslt_on_key_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_rslt_on_key_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_KEY_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_rslt_on_key_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectRsltOnKeyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_rslt_on_key_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectRsltOnKeyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_rslt_on_key_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectRsltOnKeyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectRsltOnFractionArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_SQL
};

/* reads a service_sql_select_rslt_on_fraction_args object */
static gint32
swcdb_thrift_service_sql_select_rslt_on_fraction_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectRsltOnFractionArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_rslt_on_fraction_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectRsltOnFractionArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnFractionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_rslt_on_fraction_args_set_property (GObject *object,
                                                                    guint property_id,
                                                                    const GValue *value,
                                                                    GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnFractionArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_fraction_args_get_property (GObject *object,
                                                                    guint property_id,
                                                                    GValue *value,
                                                                    GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnFractionArgs *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_rslt_on_fraction_args_instance_init (swcdb_thriftServiceSqlSelectRsltOnFractionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_sql_select_rslt_on_fraction_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectRsltOnFractionArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_fraction_args_class_init (swcdb_thriftServiceSqlSelectRsltOnFractionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_rslt_on_fraction_args_read;
  struct_class->write = swcdb_thrift_service_sql_select_rslt_on_fraction_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_rslt_on_fraction_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_rslt_on_fraction_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_rslt_on_fraction_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_rslt_on_fraction_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectRsltOnFractionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_rslt_on_fraction_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectRsltOnFractionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_rslt_on_fraction_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectRsltOnFractionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlSelectRsltOnFractionResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_E
};

/* reads a service_sql_select_rslt_on_fraction_result object */
static gint32
swcdb_thrift_service_sql_select_rslt_on_fraction_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlSelectRsltOnFractionResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_select_rslt_on_fraction_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlSelectRsltOnFractionResult * this_object = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlSelectRsltOnFractionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_select_rslt_on_fraction_result_set_property (GObject *object,
                                                                      guint property_id,
                                                                      const GValue *value,
                                                                      GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnFractionResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_fraction_result_get_property (GObject *object,
                                                                      guint property_id,
                                                                      GValue *value,
                                                                      GParamSpec *pspec)
{
  swcdb_thriftServiceSqlSelectRsltOnFractionResult *self = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_select_rslt_on_fraction_result_instance_init (swcdb_thriftServiceSqlSelectRsltOnFractionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (SWCDB_THRIFT_TYPE_F_CELLS, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_select_rslt_on_fraction_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlSelectRsltOnFractionResult *tobject = SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_select_rslt_on_fraction_result_class_init (swcdb_thriftServiceSqlSelectRsltOnFractionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_select_rslt_on_fraction_result_read;
  struct_class->write = swcdb_thrift_service_sql_select_rslt_on_fraction_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_select_rslt_on_fraction_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_select_rslt_on_fraction_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_select_rslt_on_fraction_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_F_CELLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_SELECT_RSLT_ON_FRACTION_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_select_rslt_on_fraction_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlSelectRsltOnFractionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_select_rslt_on_fraction_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlSelectRsltOnFractionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_select_rslt_on_fraction_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlSelectRsltOnFractionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlQueryArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_SQL,
  PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_RSLT
};

/* reads a service_sql_query_args object */
static gint32
swcdb_thrift_service_sql_query_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlQueryArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast199;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast199, error)) < 0)
            return -1;
          xfer += ret;
          this_object->rslt = (swcdb_thriftCellsResult)ecast199;
          this_object->__isset_rslt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_query_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlQueryArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlQueryArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rslt", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->rslt, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_query_args_set_property (GObject *object,
                                                  guint property_id,
                                                  const GValue *value,
                                                  GParamSpec *pspec)
{
  swcdb_thriftServiceSqlQueryArgs *self = SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_RSLT:
      self->rslt = g_value_get_int (value);
      self->__isset_rslt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_query_args_get_property (GObject *object,
                                                  guint property_id,
                                                  GValue *value,
                                                  GParamSpec *pspec)
{
  swcdb_thriftServiceSqlQueryArgs *self = SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_RSLT:
      g_value_set_int (value, self->rslt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_query_args_instance_init (swcdb_thriftServiceSqlQueryArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
  object->__isset_rslt = FALSE;
}

static void 
swcdb_thrift_service_sql_query_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlQueryArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_query_args_class_init (swcdb_thriftServiceSqlQueryArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_query_args_read;
  struct_class->write = swcdb_thrift_service_sql_query_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_query_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_query_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_query_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_ARGS_RSLT,
     g_param_spec_int ("rslt",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_query_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlQueryArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_query_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlQueryArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_query_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlQueryArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlQueryResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_E
};

/* reads a service_sql_query_result object */
static gint32
swcdb_thrift_service_sql_query_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlQueryResult * this_object = SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_query_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlQueryResult * this_object = SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlQueryResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_query_result_set_property (GObject *object,
                                                    guint property_id,
                                                    const GValue *value,
                                                    GParamSpec *pspec)
{
  swcdb_thriftServiceSqlQueryResult *self = SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_query_result_get_property (GObject *object,
                                                    guint property_id,
                                                    GValue *value,
                                                    GParamSpec *pspec)
{
  swcdb_thriftServiceSqlQueryResult *self = SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_query_result_instance_init (swcdb_thriftServiceSqlQueryResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (SWCDB_THRIFT_TYPE_CELLS_GROUP, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_query_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlQueryResult *tobject = SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_query_result_class_init (swcdb_thriftServiceSqlQueryResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_query_result_read;
  struct_class->write = swcdb_thrift_service_sql_query_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_query_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_query_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_query_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_CELLS_GROUP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_QUERY_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_query_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlQueryResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_query_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlQueryResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_query_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlQueryResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlUpdateArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_SQL,
  PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_UPDATER_ID
};

/* reads a service_sql_update_args object */
static gint32
swcdb_thrift_service_sql_update_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlUpdateArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updater_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updater_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_update_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlUpdateArgs * this_object = SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlUpdateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updater_id", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->updater_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_update_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftServiceSqlUpdateArgs *self = SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_UPDATER_ID:
      self->updater_id = g_value_get_int64 (value);
      self->__isset_updater_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_update_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftServiceSqlUpdateArgs *self = SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_UPDATER_ID:
      g_value_set_int64 (value, self->updater_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_update_args_instance_init (swcdb_thriftServiceSqlUpdateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
  object->updater_id = G_GINT64_CONSTANT (0);
  object->__isset_updater_id = FALSE;
}

static void 
swcdb_thrift_service_sql_update_args_finalize (GObject *object)
{
  swcdb_thriftServiceSqlUpdateArgs *tobject = SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_sql_update_args_class_init (swcdb_thriftServiceSqlUpdateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_update_args_read;
  struct_class->write = swcdb_thrift_service_sql_update_args_write;

  gobject_class->finalize = swcdb_thrift_service_sql_update_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_update_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_update_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_ARGS_UPDATER_ID,
     g_param_spec_int64 ("updater_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_update_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlUpdateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_update_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlUpdateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_update_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlUpdateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceSqlUpdateResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT_E
};

/* reads a service_sql_update_result object */
static gint32
swcdb_thrift_service_sql_update_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceSqlUpdateResult * this_object = SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_sql_update_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceSqlUpdateResult * this_object = SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceSqlUpdateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_sql_update_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceSqlUpdateResult *self = SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_sql_update_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceSqlUpdateResult *self = SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_sql_update_result_instance_init (swcdb_thriftServiceSqlUpdateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_sql_update_result_finalize (GObject *object)
{
  swcdb_thriftServiceSqlUpdateResult *tobject = SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_sql_update_result_class_init (swcdb_thriftServiceSqlUpdateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_sql_update_result_read;
  struct_class->write = swcdb_thrift_service_sql_update_result_write;

  gobject_class->finalize = swcdb_thrift_service_sql_update_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_sql_update_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_sql_update_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SQL_UPDATE_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_sql_update_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceSqlUpdateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_sql_update_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceSqlUpdateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_sql_update_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceSqlUpdateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceExecSqlArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS_SQL
};

/* reads a service_exec_sql_args object */
static gint32
swcdb_thrift_service_exec_sql_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceExecSqlArgs * this_object = SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRING)
        {
          if (this_object->sql != NULL)
          {
            g_free(this_object->sql);
            this_object->sql = NULL;
          }

          if ((ret = thrift_protocol_read_string (protocol, &this_object->sql, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_sql = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_exec_sql_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceExecSqlArgs * this_object = SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceExecSqlArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "sql", T_STRING, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_string (protocol, this_object->sql, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_exec_sql_args_set_property (GObject *object,
                                                 guint property_id,
                                                 const GValue *value,
                                                 GParamSpec *pspec)
{
  swcdb_thriftServiceExecSqlArgs *self = SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS_SQL:
      if (self->sql != NULL)
        g_free (self->sql);
      self->sql = g_value_dup_string (value);
      self->__isset_sql = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_exec_sql_args_get_property (GObject *object,
                                                 guint property_id,
                                                 GValue *value,
                                                 GParamSpec *pspec)
{
  swcdb_thriftServiceExecSqlArgs *self = SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS_SQL:
      g_value_set_string (value, self->sql);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_exec_sql_args_instance_init (swcdb_thriftServiceExecSqlArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->sql = NULL;
  object->__isset_sql = FALSE;
}

static void 
swcdb_thrift_service_exec_sql_args_finalize (GObject *object)
{
  swcdb_thriftServiceExecSqlArgs *tobject = SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->sql != NULL)
  {
    g_free(tobject->sql);
    tobject->sql = NULL;
  }
}

static void
swcdb_thrift_service_exec_sql_args_class_init (swcdb_thriftServiceExecSqlArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_exec_sql_args_read;
  struct_class->write = swcdb_thrift_service_exec_sql_args_write;

  gobject_class->finalize = swcdb_thrift_service_exec_sql_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_exec_sql_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_exec_sql_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_ARGS_SQL,
     g_param_spec_string ("sql",
                          NULL,
                          NULL,
                          NULL,
                          G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_exec_sql_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceExecSqlArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_exec_sql_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceExecSqlArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_exec_sql_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceExecSqlArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceExecSqlResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_E
};

/* reads a service_exec_sql_result object */
static gint32
swcdb_thrift_service_exec_sql_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceExecSqlResult * this_object = SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_exec_sql_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceExecSqlResult * this_object = SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceExecSqlResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_exec_sql_result_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftServiceExecSqlResult *self = SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_exec_sql_result_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftServiceExecSqlResult *self = SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_exec_sql_result_instance_init (swcdb_thriftServiceExecSqlResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (SWCDB_THRIFT_TYPE_RESULT, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_exec_sql_result_finalize (GObject *object)
{
  swcdb_thriftServiceExecSqlResult *tobject = SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_exec_sql_result_class_init (swcdb_thriftServiceExecSqlResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_exec_sql_result_read;
  struct_class->write = swcdb_thrift_service_exec_sql_result_write;

  gobject_class->finalize = swcdb_thrift_service_exec_sql_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_exec_sql_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_exec_sql_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_RESULT,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_EXEC_SQL_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_exec_sql_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceExecSqlResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_exec_sql_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceExecSqlResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_exec_sql_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceExecSqlResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdaterCreateArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS_BUFFER_SIZE
};

/* reads a service_updater_create_args object */
static gint32
swcdb_thrift_service_updater_create_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdaterCreateArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          if ((ret = thrift_protocol_read_i32 (protocol, &this_object->buffer_size, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_buffer_size = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_updater_create_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdaterCreateArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdaterCreateArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "buffer_size", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, this_object->buffer_size, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_updater_create_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceUpdaterCreateArgs *self = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS_BUFFER_SIZE:
      self->buffer_size = g_value_get_int (value);
      self->__isset_buffer_size = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_updater_create_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceUpdaterCreateArgs *self = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS_BUFFER_SIZE:
      g_value_set_int (value, self->buffer_size);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_updater_create_args_instance_init (swcdb_thriftServiceUpdaterCreateArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->buffer_size = 0;
  object->__isset_buffer_size = FALSE;
}

static void 
swcdb_thrift_service_updater_create_args_finalize (GObject *object)
{
  swcdb_thriftServiceUpdaterCreateArgs *tobject = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_service_updater_create_args_class_init (swcdb_thriftServiceUpdaterCreateArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_updater_create_args_read;
  struct_class->write = swcdb_thrift_service_updater_create_args_write;

  gobject_class->finalize = swcdb_thrift_service_updater_create_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_updater_create_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_updater_create_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_ARGS_BUFFER_SIZE,
     g_param_spec_int ("buffer_size",
                       NULL,
                       NULL,
                       G_MININT32,
                       G_MAXINT32,
                       0,
                       G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_updater_create_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdaterCreateArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_updater_create_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdaterCreateArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_updater_create_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdaterCreateArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdaterCreateResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_E
};

/* reads a service_updater_create_result object */
static gint32
swcdb_thrift_service_updater_create_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdaterCreateResult * this_object = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->success, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_updater_create_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdaterCreateResult * this_object = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdaterCreateResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_I64, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_protocol_write_i64 (protocol, this_object->success, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_updater_create_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceUpdaterCreateResult *self = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_SUCCESS:
      self->success = g_value_get_int64 (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_updater_create_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceUpdaterCreateResult *self = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_SUCCESS:
      g_value_set_int64 (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_updater_create_result_instance_init (swcdb_thriftServiceUpdaterCreateResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = 0;
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_updater_create_result_finalize (GObject *object)
{
  swcdb_thriftServiceUpdaterCreateResult *tobject = SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_updater_create_result_class_init (swcdb_thriftServiceUpdaterCreateResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_updater_create_result_read;
  struct_class->write = swcdb_thrift_service_updater_create_result_write;

  gobject_class->finalize = swcdb_thrift_service_updater_create_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_updater_create_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_updater_create_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_SUCCESS,
     g_param_spec_int64 ("success",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATER_CREATE_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_updater_create_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdaterCreateResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_updater_create_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdaterCreateResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_updater_create_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdaterCreateResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdaterCloseArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS_ID
};

/* reads a service_updater_close_args object */
static gint32
swcdb_thrift_service_updater_close_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdaterCloseArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_updater_close_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdaterCloseArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdaterCloseArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "id", T_I64, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_updater_close_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  swcdb_thriftServiceUpdaterCloseArgs *self = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS_ID:
      self->id = g_value_get_int64 (value);
      self->__isset_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_updater_close_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  swcdb_thriftServiceUpdaterCloseArgs *self = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS_ID:
      g_value_set_int64 (value, self->id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_updater_close_args_instance_init (swcdb_thriftServiceUpdaterCloseArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->id = 0;
  object->__isset_id = FALSE;
}

static void 
swcdb_thrift_service_updater_close_args_finalize (GObject *object)
{
  swcdb_thriftServiceUpdaterCloseArgs *tobject = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
}

static void
swcdb_thrift_service_updater_close_args_class_init (swcdb_thriftServiceUpdaterCloseArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_updater_close_args_read;
  struct_class->write = swcdb_thrift_service_updater_close_args_write;

  gobject_class->finalize = swcdb_thrift_service_updater_close_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_updater_close_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_updater_close_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_ARGS_ID,
     g_param_spec_int64 ("id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_updater_close_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdaterCloseArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_updater_close_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdaterCloseArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_updater_close_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdaterCloseArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdaterCloseResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT_E
};

/* reads a service_updater_close_result object */
static gint32
swcdb_thrift_service_updater_close_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdaterCloseResult * this_object = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_updater_close_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdaterCloseResult * this_object = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdaterCloseResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_updater_close_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftServiceUpdaterCloseResult *self = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_updater_close_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftServiceUpdaterCloseResult *self = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_updater_close_result_instance_init (swcdb_thriftServiceUpdaterCloseResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_updater_close_result_finalize (GObject *object)
{
  swcdb_thriftServiceUpdaterCloseResult *tobject = SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_updater_close_result_class_init (swcdb_thriftServiceUpdaterCloseResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_updater_close_result_read;
  struct_class->write = swcdb_thrift_service_updater_close_result_write;

  gobject_class->finalize = swcdb_thrift_service_updater_close_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_updater_close_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_updater_close_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATER_CLOSE_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_updater_close_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdaterCloseResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_updater_close_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdaterCloseResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_updater_close_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdaterCloseResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdatePlainArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_CELLS,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_UPDATER_ID
};

/* reads a service_update_plain_args object */
static gint32
swcdb_thrift_service_update_plain_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdatePlainArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key200 = g_new (gint64, 1);
              swcdb_thriftUCellsPlain * val201 = g_ptr_array_new_with_free_func (g_object_unref);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key200, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  swcdb_thriftUCellPlain * _elem202 = NULL;
                  if ( _elem202 != NULL)
                  {
                    g_object_unref (_elem202);
                  }
                  _elem202 = g_object_new (SWCDB_THRIFT_TYPE_U_CELL_PLAIN, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem202), protocol, error)) < 0)
                  {
                    g_object_unref (_elem202);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val201, _elem202);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->cells && key200)
                g_hash_table_insert ((GHashTable *)this_object->cells, (gpointer) key200, (gpointer) val201);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updater_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updater_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_update_plain_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdatePlainArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdatePlainArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint64* key203 = NULL;
    swcdb_thriftUCellsPlain * val204 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_LIST, this_object->cells ? (gint32) g_hash_table_size ((GHashTable *) this_object->cells) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->cells)
      g_hash_table_foreach ((GHashTable *) this_object->cells, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key203 = keys[i];
      val204 = (swcdb_thriftUCellsPlain *) g_hash_table_lookup (((GHashTable *) this_object->cells), (gpointer) key203);

      if ((ret = thrift_protocol_write_i64 (protocol, * key203, error)) < 0)
        return -1;
      xfer += ret;

      {
        guint i205;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val204 ?  val204->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i205 = 0; i205 < ( val204 ?  val204->len : 0); i205++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val204, i205))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updater_id", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->updater_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_update_plain_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceUpdatePlainArgs *self = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_CELLS:
      if (self->cells != NULL)
        g_hash_table_unref (self->cells);
      self->cells = g_value_dup_boxed (value);
      self->__isset_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_UPDATER_ID:
      self->updater_id = g_value_get_int64 (value);
      self->__isset_updater_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_update_plain_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceUpdatePlainArgs *self = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_CELLS:
      g_value_set_boxed (value, self->cells);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_UPDATER_ID:
      g_value_set_int64 (value, self->updater_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_update_plain_args_instance_init (swcdb_thriftServiceUpdatePlainArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cells = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_cells = FALSE;
  object->updater_id = G_GINT64_CONSTANT (0);
  object->__isset_updater_id = FALSE;
}

static void 
swcdb_thrift_service_update_plain_args_finalize (GObject *object)
{
  swcdb_thriftServiceUpdatePlainArgs *tobject = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cells != NULL)
  {
    g_hash_table_destroy (tobject->cells);
    tobject->cells = NULL;
  }
}

static void
swcdb_thrift_service_update_plain_args_class_init (swcdb_thriftServiceUpdatePlainArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_update_plain_args_read;
  struct_class->write = swcdb_thrift_service_update_plain_args_write;

  gobject_class->finalize = swcdb_thrift_service_update_plain_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_update_plain_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_update_plain_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_CELLS,
     g_param_spec_boxed ("cells",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_ARGS_UPDATER_ID,
     g_param_spec_int64 ("updater_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_update_plain_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdatePlainArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_update_plain_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdatePlainArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_update_plain_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdatePlainArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdatePlainResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT_E
};

/* reads a service_update_plain_result object */
static gint32
swcdb_thrift_service_update_plain_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdatePlainResult * this_object = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_update_plain_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdatePlainResult * this_object = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdatePlainResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_update_plain_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceUpdatePlainResult *self = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_update_plain_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceUpdatePlainResult *self = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_update_plain_result_instance_init (swcdb_thriftServiceUpdatePlainResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_update_plain_result_finalize (GObject *object)
{
  swcdb_thriftServiceUpdatePlainResult *tobject = SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_update_plain_result_class_init (swcdb_thriftServiceUpdatePlainResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_update_plain_result_read;
  struct_class->write = swcdb_thrift_service_update_plain_result_write;

  gobject_class->finalize = swcdb_thrift_service_update_plain_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_update_plain_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_update_plain_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_PLAIN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_update_plain_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdatePlainResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_update_plain_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdatePlainResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_update_plain_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdatePlainResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdateCounterArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_CELLS,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_UPDATER_ID
};

/* reads a service_update_counter_args object */
static gint32
swcdb_thrift_service_update_counter_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdateCounterArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key206 = g_new (gint64, 1);
              swcdb_thriftUCellsCounter * val207 = g_ptr_array_new_with_free_func (g_object_unref);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key206, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  swcdb_thriftUCellCounter * _elem208 = NULL;
                  if ( _elem208 != NULL)
                  {
                    g_object_unref (_elem208);
                  }
                  _elem208 = g_object_new (SWCDB_THRIFT_TYPE_U_CELL_COUNTER, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem208), protocol, error)) < 0)
                  {
                    g_object_unref (_elem208);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val207, _elem208);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->cells && key206)
                g_hash_table_insert ((GHashTable *)this_object->cells, (gpointer) key206, (gpointer) val207);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updater_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updater_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_update_counter_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdateCounterArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdateCounterArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint64* key209 = NULL;
    swcdb_thriftUCellsCounter * val210 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_LIST, this_object->cells ? (gint32) g_hash_table_size ((GHashTable *) this_object->cells) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->cells)
      g_hash_table_foreach ((GHashTable *) this_object->cells, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key209 = keys[i];
      val210 = (swcdb_thriftUCellsCounter *) g_hash_table_lookup (((GHashTable *) this_object->cells), (gpointer) key209);

      if ((ret = thrift_protocol_write_i64 (protocol, * key209, error)) < 0)
        return -1;
      xfer += ret;

      {
        guint i211;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val210 ?  val210->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i211 = 0; i211 < ( val210 ?  val210->len : 0); i211++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val210, i211))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updater_id", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->updater_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_update_counter_args_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateCounterArgs *self = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_CELLS:
      if (self->cells != NULL)
        g_hash_table_unref (self->cells);
      self->cells = g_value_dup_boxed (value);
      self->__isset_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_UPDATER_ID:
      self->updater_id = g_value_get_int64 (value);
      self->__isset_updater_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_update_counter_args_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateCounterArgs *self = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_CELLS:
      g_value_set_boxed (value, self->cells);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_UPDATER_ID:
      g_value_set_int64 (value, self->updater_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_update_counter_args_instance_init (swcdb_thriftServiceUpdateCounterArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cells = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_cells = FALSE;
  object->updater_id = G_GINT64_CONSTANT (0);
  object->__isset_updater_id = FALSE;
}

static void 
swcdb_thrift_service_update_counter_args_finalize (GObject *object)
{
  swcdb_thriftServiceUpdateCounterArgs *tobject = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cells != NULL)
  {
    g_hash_table_destroy (tobject->cells);
    tobject->cells = NULL;
  }
}

static void
swcdb_thrift_service_update_counter_args_class_init (swcdb_thriftServiceUpdateCounterArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_update_counter_args_read;
  struct_class->write = swcdb_thrift_service_update_counter_args_write;

  gobject_class->finalize = swcdb_thrift_service_update_counter_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_update_counter_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_update_counter_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_CELLS,
     g_param_spec_boxed ("cells",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_ARGS_UPDATER_ID,
     g_param_spec_int64 ("updater_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_update_counter_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdateCounterArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_update_counter_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdateCounterArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_update_counter_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdateCounterArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdateCounterResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT_E
};

/* reads a service_update_counter_result object */
static gint32
swcdb_thrift_service_update_counter_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdateCounterResult * this_object = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_update_counter_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdateCounterResult * this_object = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdateCounterResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_update_counter_result_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateCounterResult *self = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_update_counter_result_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateCounterResult *self = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_update_counter_result_instance_init (swcdb_thriftServiceUpdateCounterResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_update_counter_result_finalize (GObject *object)
{
  swcdb_thriftServiceUpdateCounterResult *tobject = SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_update_counter_result_class_init (swcdb_thriftServiceUpdateCounterResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_update_counter_result_read;
  struct_class->write = swcdb_thrift_service_update_counter_result_write;

  gobject_class->finalize = swcdb_thrift_service_update_counter_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_update_counter_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_update_counter_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_COUNTER_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_update_counter_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdateCounterResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_update_counter_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdateCounterResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_update_counter_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdateCounterResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdateSerialArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_CELLS,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_UPDATER_ID
};

/* reads a service_update_serial_args object */
static gint32
swcdb_thrift_service_update_serial_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdateSerialArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key212 = g_new (gint64, 1);
              swcdb_thriftUCellsSerial * val213 = g_ptr_array_new_with_free_func (g_object_unref);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key212, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  swcdb_thriftUCellSerial * _elem214 = NULL;
                  if ( _elem214 != NULL)
                  {
                    g_object_unref (_elem214);
                  }
                  _elem214 = g_object_new (SWCDB_THRIFT_TYPE_U_CELL_SERIAL, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem214), protocol, error)) < 0)
                  {
                    g_object_unref (_elem214);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val213, _elem214);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->cells && key212)
                g_hash_table_insert ((GHashTable *)this_object->cells, (gpointer) key212, (gpointer) val213);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_cells = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updater_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updater_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_update_serial_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdateSerialArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdateSerialArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "cells", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint64* key215 = NULL;
    swcdb_thriftUCellsSerial * val216 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_LIST, this_object->cells ? (gint32) g_hash_table_size ((GHashTable *) this_object->cells) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->cells)
      g_hash_table_foreach ((GHashTable *) this_object->cells, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key215 = keys[i];
      val216 = (swcdb_thriftUCellsSerial *) g_hash_table_lookup (((GHashTable *) this_object->cells), (gpointer) key215);

      if ((ret = thrift_protocol_write_i64 (protocol, * key215, error)) < 0)
        return -1;
      xfer += ret;

      {
        guint i217;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val216 ?  val216->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i217 = 0; i217 < ( val216 ?  val216->len : 0); i217++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val216, i217))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updater_id", T_I64, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->updater_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_update_serial_args_set_property (GObject *object,
                                                      guint property_id,
                                                      const GValue *value,
                                                      GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateSerialArgs *self = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_CELLS:
      if (self->cells != NULL)
        g_hash_table_unref (self->cells);
      self->cells = g_value_dup_boxed (value);
      self->__isset_cells = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_UPDATER_ID:
      self->updater_id = g_value_get_int64 (value);
      self->__isset_updater_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_update_serial_args_get_property (GObject *object,
                                                      guint property_id,
                                                      GValue *value,
                                                      GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateSerialArgs *self = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_CELLS:
      g_value_set_boxed (value, self->cells);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_UPDATER_ID:
      g_value_set_int64 (value, self->updater_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_update_serial_args_instance_init (swcdb_thriftServiceUpdateSerialArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->cells = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_cells = FALSE;
  object->updater_id = G_GINT64_CONSTANT (0);
  object->__isset_updater_id = FALSE;
}

static void 
swcdb_thrift_service_update_serial_args_finalize (GObject *object)
{
  swcdb_thriftServiceUpdateSerialArgs *tobject = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->cells != NULL)
  {
    g_hash_table_destroy (tobject->cells);
    tobject->cells = NULL;
  }
}

static void
swcdb_thrift_service_update_serial_args_class_init (swcdb_thriftServiceUpdateSerialArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_update_serial_args_read;
  struct_class->write = swcdb_thrift_service_update_serial_args_write;

  gobject_class->finalize = swcdb_thrift_service_update_serial_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_update_serial_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_update_serial_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_CELLS,
     g_param_spec_boxed ("cells",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_ARGS_UPDATER_ID,
     g_param_spec_int64 ("updater_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_update_serial_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdateSerialArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_update_serial_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdateSerialArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_update_serial_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdateSerialArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdateSerialResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT_E
};

/* reads a service_update_serial_result object */
static gint32
swcdb_thrift_service_update_serial_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdateSerialResult * this_object = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_update_serial_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdateSerialResult * this_object = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdateSerialResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_update_serial_result_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateSerialResult *self = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_update_serial_result_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateSerialResult *self = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_update_serial_result_instance_init (swcdb_thriftServiceUpdateSerialResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_update_serial_result_finalize (GObject *object)
{
  swcdb_thriftServiceUpdateSerialResult *tobject = SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_update_serial_result_class_init (swcdb_thriftServiceUpdateSerialResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_update_serial_result_read;
  struct_class->write = swcdb_thrift_service_update_serial_result_write;

  gobject_class->finalize = swcdb_thrift_service_update_serial_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_update_serial_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_update_serial_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_SERIAL_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_update_serial_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdateSerialResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_update_serial_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdateSerialResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_update_serial_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdateSerialResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdateByTypesArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_PLAIN,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_COUNTER,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_SERIAL,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_UPDATER_ID
};

/* reads a service_update_by_types_args object */
static gint32
swcdb_thrift_service_update_by_types_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdateByTypesArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key218 = g_new (gint64, 1);
              swcdb_thriftUCellsPlain * val219 = g_ptr_array_new_with_free_func (g_object_unref);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key218, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  swcdb_thriftUCellPlain * _elem220 = NULL;
                  if ( _elem220 != NULL)
                  {
                    g_object_unref (_elem220);
                  }
                  _elem220 = g_object_new (SWCDB_THRIFT_TYPE_U_CELL_PLAIN, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem220), protocol, error)) < 0)
                  {
                    g_object_unref (_elem220);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val219, _elem220);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->plain && key218)
                g_hash_table_insert ((GHashTable *)this_object->plain, (gpointer) key218, (gpointer) val219);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_plain = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key221 = g_new (gint64, 1);
              swcdb_thriftUCellsCounter * val222 = g_ptr_array_new_with_free_func (g_object_unref);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key221, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  swcdb_thriftUCellCounter * _elem223 = NULL;
                  if ( _elem223 != NULL)
                  {
                    g_object_unref (_elem223);
                  }
                  _elem223 = g_object_new (SWCDB_THRIFT_TYPE_U_CELL_COUNTER, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem223), protocol, error)) < 0)
                  {
                    g_object_unref (_elem223);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val222, _elem223);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->counter && key221)
                g_hash_table_insert ((GHashTable *)this_object->counter, (gpointer) key221, (gpointer) val222);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_counter = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 3:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gint64* key224 = g_new (gint64, 1);
              swcdb_thriftUCellsSerial * val225 = g_ptr_array_new_with_free_func (g_object_unref);
              if ((ret = thrift_protocol_read_i64 (protocol, &*key224, error)) < 0)
                return -1;
              xfer += ret;
              {
                guint32 size;
                guint32 i;
                ThriftType element_type;

                if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
                  return -1;
                xfer += ret;

                /* iterate through list elements */
                for (i = 0; i < size; i++)
                {
                  swcdb_thriftUCellSerial * _elem226 = NULL;
                  if ( _elem226 != NULL)
                  {
                    g_object_unref (_elem226);
                  }
                  _elem226 = g_object_new (SWCDB_THRIFT_TYPE_U_CELL_SERIAL, NULL);
                  if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem226), protocol, error)) < 0)
                  {
                    g_object_unref (_elem226);
                    return -1;
                  }
                  xfer += ret;
                  g_ptr_array_add (val225, _elem226);
                }
                if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
                  return -1;
                xfer += ret;
              }
              if (this_object->serial && key224)
                g_hash_table_insert ((GHashTable *)this_object->serial, (gpointer) key224, (gpointer) val225);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_serial = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 4:
        if (ftype == T_I64)
        {
          if ((ret = thrift_protocol_read_i64 (protocol, &this_object->updater_id, error)) < 0)
            return -1;
          xfer += ret;
          this_object->__isset_updater_id = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_update_by_types_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdateByTypesArgs * this_object = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdateByTypesArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "plain", T_MAP, 1, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint64* key227 = NULL;
    swcdb_thriftUCellsPlain * val228 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_LIST, this_object->plain ? (gint32) g_hash_table_size ((GHashTable *) this_object->plain) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->plain)
      g_hash_table_foreach ((GHashTable *) this_object->plain, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key227 = keys[i];
      val228 = (swcdb_thriftUCellsPlain *) g_hash_table_lookup (((GHashTable *) this_object->plain), (gpointer) key227);

      if ((ret = thrift_protocol_write_i64 (protocol, * key227, error)) < 0)
        return -1;
      xfer += ret;

      {
        guint i229;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val228 ?  val228->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i229 = 0; i229 < ( val228 ?  val228->len : 0); i229++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val228, i229))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "counter", T_MAP, 2, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint64* key230 = NULL;
    swcdb_thriftUCellsCounter * val231 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_LIST, this_object->counter ? (gint32) g_hash_table_size ((GHashTable *) this_object->counter) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->counter)
      g_hash_table_foreach ((GHashTable *) this_object->counter, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key230 = keys[i];
      val231 = (swcdb_thriftUCellsCounter *) g_hash_table_lookup (((GHashTable *) this_object->counter), (gpointer) key230);

      if ((ret = thrift_protocol_write_i64 (protocol, * key230, error)) < 0)
        return -1;
      xfer += ret;

      {
        guint i232;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val231 ?  val231->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i232 = 0; i232 < ( val231 ?  val231->len : 0); i232++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val231, i232))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "serial", T_MAP, 3, error)) < 0)
    return -1;
  xfer += ret;
  {
    gint64* key233 = NULL;
    swcdb_thriftUCellsSerial * val234 = NULL;
    GList *key_list = NULL, *iter = NULL;
    gint64** keys;
    int i = 0, key_count;

    if ((ret = thrift_protocol_write_map_begin (protocol, T_I64, T_LIST, this_object->serial ? (gint32) g_hash_table_size ((GHashTable *) this_object->serial) : 0, error)) < 0)
      return -1;
    xfer += ret;
    if (this_object->serial)
      g_hash_table_foreach ((GHashTable *) this_object->serial, thrift_hash_table_get_keys, &key_list);
    key_count = g_list_length (key_list);
    keys = g_newa (gint64*, key_count);
    for (iter = g_list_first (key_list); iter; iter = iter->next)
      keys[i++] = (gint64*) iter->data;
    g_list_free (key_list);

    for (i = 0; i < key_count; ++i)
    {
      key233 = keys[i];
      val234 = (swcdb_thriftUCellsSerial *) g_hash_table_lookup (((GHashTable *) this_object->serial), (gpointer) key233);

      if ((ret = thrift_protocol_write_i64 (protocol, * key233, error)) < 0)
        return -1;
      xfer += ret;

      {
        guint i235;

        if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) ( val234 ?  val234->len : 0), error)) < 0)
          return -1;
        xfer += ret;
        for (i235 = 0; i235 < ( val234 ?  val234->len : 0); i235++)
        {
          if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *)  val234, i235))), protocol, error)) < 0)
            return -1;
          xfer += ret;

        }
        if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
          return -1;
        xfer += ret;
      }
    }
    if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "updater_id", T_I64, 4, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i64 (protocol, this_object->updater_id, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_update_by_types_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateByTypesArgs *self = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_PLAIN:
      if (self->plain != NULL)
        g_hash_table_unref (self->plain);
      self->plain = g_value_dup_boxed (value);
      self->__isset_plain = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_COUNTER:
      if (self->counter != NULL)
        g_hash_table_unref (self->counter);
      self->counter = g_value_dup_boxed (value);
      self->__isset_counter = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_SERIAL:
      if (self->serial != NULL)
        g_hash_table_unref (self->serial);
      self->serial = g_value_dup_boxed (value);
      self->__isset_serial = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_UPDATER_ID:
      self->updater_id = g_value_get_int64 (value);
      self->__isset_updater_id = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_update_by_types_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateByTypesArgs *self = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_PLAIN:
      g_value_set_boxed (value, self->plain);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_COUNTER:
      g_value_set_boxed (value, self->counter);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_SERIAL:
      g_value_set_boxed (value, self->serial);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_UPDATER_ID:
      g_value_set_int64 (value, self->updater_id);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_update_by_types_args_instance_init (swcdb_thriftServiceUpdateByTypesArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->plain = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_plain = FALSE;
  object->counter = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_counter = FALSE;
  object->serial = g_hash_table_new_full (g_int64_hash, g_int64_equal, g_free, (GDestroyNotify) g_ptr_array_unref);
  object->__isset_serial = FALSE;
  object->updater_id = G_GINT64_CONSTANT (0);
  object->__isset_updater_id = FALSE;
}

static void 
swcdb_thrift_service_update_by_types_args_finalize (GObject *object)
{
  swcdb_thriftServiceUpdateByTypesArgs *tobject = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->plain != NULL)
  {
    g_hash_table_destroy (tobject->plain);
    tobject->plain = NULL;
  }
  if (tobject->counter != NULL)
  {
    g_hash_table_destroy (tobject->counter);
    tobject->counter = NULL;
  }
  if (tobject->serial != NULL)
  {
    g_hash_table_destroy (tobject->serial);
    tobject->serial = NULL;
  }
}

static void
swcdb_thrift_service_update_by_types_args_class_init (swcdb_thriftServiceUpdateByTypesArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_update_by_types_args_read;
  struct_class->write = swcdb_thrift_service_update_by_types_args_write;

  gobject_class->finalize = swcdb_thrift_service_update_by_types_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_update_by_types_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_update_by_types_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_PLAIN,
     g_param_spec_boxed ("plain",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_COUNTER,
     g_param_spec_boxed ("counter",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_SERIAL,
     g_param_spec_boxed ("serial",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_ARGS_UPDATER_ID,
     g_param_spec_int64 ("updater_id",
                         NULL,
                         NULL,
                         G_MININT64,
                         G_MAXINT64,
                         0,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_update_by_types_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdateByTypesArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_update_by_types_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdateByTypesArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_update_by_types_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdateByTypesArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceUpdateByTypesResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT_E
};

/* reads a service_update_by_types_result object */
static gint32
swcdb_thrift_service_update_by_types_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceUpdateByTypesResult * this_object = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_update_by_types_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceUpdateByTypesResult * this_object = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceUpdateByTypesResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_update_by_types_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateByTypesResult *self = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_update_by_types_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  swcdb_thriftServiceUpdateByTypesResult *self = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_update_by_types_result_instance_init (swcdb_thriftServiceUpdateByTypesResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_update_by_types_result_finalize (GObject *object)
{
  swcdb_thriftServiceUpdateByTypesResult *tobject = SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_update_by_types_result_class_init (swcdb_thriftServiceUpdateByTypesResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_update_by_types_result_read;
  struct_class->write = swcdb_thrift_service_update_by_types_result_write;

  gobject_class->finalize = swcdb_thrift_service_update_by_types_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_update_by_types_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_update_by_types_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_UPDATE_BY_TYPES_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_update_by_types_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceUpdateByTypesResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_update_by_types_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceUpdateByTypesResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_update_by_types_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceUpdateByTypesResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceMngColumnArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_FUNC,
  PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_SCHEMA
};

/* reads a service_mng_column_args object */
static gint32
swcdb_thrift_service_mng_column_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceMngColumnArgs * this_object = SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_I32)
        {
          gint32 ecast236;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast236, error)) < 0)
            return -1;
          xfer += ret;
          this_object->func = (swcdb_thriftSchemaFunc)ecast236;
          this_object->__isset_func = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_schema = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_mng_column_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceMngColumnArgs * this_object = SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceMngColumnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "func", T_I32, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->func, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "schema", T_STRUCT, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->schema), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_mng_column_args_set_property (GObject *object,
                                                   guint property_id,
                                                   const GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftServiceMngColumnArgs *self = SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_FUNC:
      self->func = g_value_get_int (value);
      self->__isset_func = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_SCHEMA:
      if (self->schema != NULL)
        g_object_unref (self->schema);
      self->schema = g_value_dup_object (value);
      self->__isset_schema = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_mng_column_args_get_property (GObject *object,
                                                   guint property_id,
                                                   GValue *value,
                                                   GParamSpec *pspec)
{
  swcdb_thriftServiceMngColumnArgs *self = SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_FUNC:
      g_value_set_int (value, self->func);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_SCHEMA:
      g_value_set_object (value, self->schema);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_mng_column_args_instance_init (swcdb_thriftServiceMngColumnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->__isset_func = FALSE;
  object->schema = g_object_new (SWCDB_THRIFT_TYPE_SCHEMA, NULL);
  object->__isset_schema = FALSE;
}

static void 
swcdb_thrift_service_mng_column_args_finalize (GObject *object)
{
  swcdb_thriftServiceMngColumnArgs *tobject = SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->schema != NULL)
  {
    g_object_unref(tobject->schema);
    tobject->schema = NULL;
  }
}

static void
swcdb_thrift_service_mng_column_args_class_init (swcdb_thriftServiceMngColumnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_mng_column_args_read;
  struct_class->write = swcdb_thrift_service_mng_column_args_write;

  gobject_class->finalize = swcdb_thrift_service_mng_column_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_mng_column_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_mng_column_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_FUNC,
     g_param_spec_int ("func",
                       NULL,
                       NULL,
                       3,
                       7,
                       3,
                       G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_ARGS_SCHEMA,
     g_param_spec_object ("schema",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SCHEMA,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_mng_column_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceMngColumnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_mng_column_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceMngColumnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_mng_column_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceMngColumnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceMngColumnResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT_E
};

/* reads a service_mng_column_result object */
static gint32
swcdb_thrift_service_mng_column_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceMngColumnResult * this_object = SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_mng_column_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceMngColumnResult * this_object = SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceMngColumnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_mng_column_result_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceMngColumnResult *self = SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_mng_column_result_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceMngColumnResult *self = SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_mng_column_result_instance_init (swcdb_thriftServiceMngColumnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_mng_column_result_finalize (GObject *object)
{
  swcdb_thriftServiceMngColumnResult *tobject = SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_mng_column_result_class_init (swcdb_thriftServiceMngColumnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_mng_column_result_read;
  struct_class->write = swcdb_thrift_service_mng_column_result_write;

  gobject_class->finalize = swcdb_thrift_service_mng_column_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_mng_column_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_mng_column_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_MNG_COLUMN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_mng_column_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceMngColumnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_mng_column_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceMngColumnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_mng_column_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceMngColumnResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceListColumnsArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS_SPEC
};

/* reads a service_list_columns_args object */
static gint32
swcdb_thrift_service_list_columns_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceListColumnsArgs * this_object = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_list_columns_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceListColumnsArgs * this_object = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceListColumnsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_list_columns_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceListColumnsArgs *self = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_list_columns_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceListColumnsArgs *self = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_list_columns_args_instance_init (swcdb_thriftServiceListColumnsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->spec = g_object_new (SWCDB_THRIFT_TYPE_SPEC_SCHEMAS, NULL);
  object->__isset_spec = FALSE;
}

static void 
swcdb_thrift_service_list_columns_args_finalize (GObject *object)
{
  swcdb_thriftServiceListColumnsArgs *tobject = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
swcdb_thrift_service_list_columns_args_class_init (swcdb_thriftServiceListColumnsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_list_columns_args_read;
  struct_class->write = swcdb_thrift_service_list_columns_args_write;

  gobject_class->finalize = swcdb_thrift_service_list_columns_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_list_columns_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_list_columns_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_SCHEMAS,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_list_columns_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceListColumnsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_list_columns_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceListColumnsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_list_columns_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceListColumnsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceListColumnsResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_E
};

/* reads a service_list_columns_result object */
static gint32
swcdb_thrift_service_list_columns_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceListColumnsResult * this_object = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftSchema * _elem237 = NULL;
              if ( _elem237 != NULL)
              {
                g_object_unref (_elem237);
              }
              _elem237 = g_object_new (SWCDB_THRIFT_TYPE_SCHEMA, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem237), protocol, error)) < 0)
              {
                g_object_unref (_elem237);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem237);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_list_columns_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceListColumnsResult * this_object = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceListColumnsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i238;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i238 = 0; i238 < (this_object->success ? this_object->success->len : 0); i238++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i238))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_list_columns_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceListColumnsResult *self = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_list_columns_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceListColumnsResult *self = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_list_columns_result_instance_init (swcdb_thriftServiceListColumnsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_list_columns_result_finalize (GObject *object)
{
  swcdb_thriftServiceListColumnsResult *tobject = SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_list_columns_result_class_init (swcdb_thriftServiceListColumnsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_list_columns_result_read;
  struct_class->write = swcdb_thrift_service_list_columns_result_write;

  gobject_class->finalize = swcdb_thrift_service_list_columns_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_list_columns_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_list_columns_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_LIST_COLUMNS_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_list_columns_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceListColumnsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_list_columns_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceListColumnsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_list_columns_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceListColumnsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceCompactColumnsArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS_SPEC
};

/* reads a service_compact_columns_args object */
static gint32
swcdb_thrift_service_compact_columns_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceCompactColumnsArgs * this_object = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_compact_columns_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceCompactColumnsArgs * this_object = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceCompactColumnsArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_compact_columns_args_set_property (GObject *object,
                                                        guint property_id,
                                                        const GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftServiceCompactColumnsArgs *self = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_compact_columns_args_get_property (GObject *object,
                                                        guint property_id,
                                                        GValue *value,
                                                        GParamSpec *pspec)
{
  swcdb_thriftServiceCompactColumnsArgs *self = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_compact_columns_args_instance_init (swcdb_thriftServiceCompactColumnsArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->spec = g_object_new (SWCDB_THRIFT_TYPE_SPEC_SCHEMAS, NULL);
  object->__isset_spec = FALSE;
}

static void 
swcdb_thrift_service_compact_columns_args_finalize (GObject *object)
{
  swcdb_thriftServiceCompactColumnsArgs *tobject = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
swcdb_thrift_service_compact_columns_args_class_init (swcdb_thriftServiceCompactColumnsArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_compact_columns_args_read;
  struct_class->write = swcdb_thrift_service_compact_columns_args_write;

  gobject_class->finalize = swcdb_thrift_service_compact_columns_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_compact_columns_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_compact_columns_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_SCHEMAS,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_compact_columns_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceCompactColumnsArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_compact_columns_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceCompactColumnsArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_compact_columns_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceCompactColumnsArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceCompactColumnsResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_E
};

/* reads a service_compact_columns_result object */
static gint32
swcdb_thrift_service_compact_columns_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceCompactColumnsResult * this_object = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftCompactResult * _elem239 = NULL;
              if ( _elem239 != NULL)
              {
                g_object_unref (_elem239);
              }
              _elem239 = g_object_new (SWCDB_THRIFT_TYPE_COMPACT_RESULT, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem239), protocol, error)) < 0)
              {
                g_object_unref (_elem239);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem239);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_compact_columns_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceCompactColumnsResult * this_object = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceCompactColumnsResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i240;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i240 = 0; i240 < (this_object->success ? this_object->success->len : 0); i240++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i240))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_compact_columns_result_set_property (GObject *object,
                                                          guint property_id,
                                                          const GValue *value,
                                                          GParamSpec *pspec)
{
  swcdb_thriftServiceCompactColumnsResult *self = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_compact_columns_result_get_property (GObject *object,
                                                          guint property_id,
                                                          GValue *value,
                                                          GParamSpec *pspec)
{
  swcdb_thriftServiceCompactColumnsResult *self = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_compact_columns_result_instance_init (swcdb_thriftServiceCompactColumnsResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_compact_columns_result_finalize (GObject *object)
{
  swcdb_thriftServiceCompactColumnsResult *tobject = SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_compact_columns_result_class_init (swcdb_thriftServiceCompactColumnsResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_compact_columns_result_read;
  struct_class->write = swcdb_thrift_service_compact_columns_result_write;

  gobject_class->finalize = swcdb_thrift_service_compact_columns_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_compact_columns_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_compact_columns_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_COMPACT_COLUMNS_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_compact_columns_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceCompactColumnsResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_compact_columns_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceCompactColumnsResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_compact_columns_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceCompactColumnsResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_ARGS_SPEC
};

/* reads a service_scan_args object */
static gint32
swcdb_thrift_service_scan_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_args_set_property (GObject *object,
                                             guint property_id,
                                             const GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftServiceScanArgs *self = SWCDB_THRIFT_SERVICE_SCAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_args_get_property (GObject *object,
                                             guint property_id,
                                             GValue *value,
                                             GParamSpec *pspec)
{
  swcdb_thriftServiceScanArgs *self = SWCDB_THRIFT_SERVICE_SCAN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_args_instance_init (swcdb_thriftServiceScanArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->spec = g_object_new (SWCDB_THRIFT_TYPE_SPEC_SCAN, NULL);
  object->__isset_spec = FALSE;
}

static void 
swcdb_thrift_service_scan_args_finalize (GObject *object)
{
  swcdb_thriftServiceScanArgs *tobject = SWCDB_THRIFT_SERVICE_SCAN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
swcdb_thrift_service_scan_args_class_init (swcdb_thriftServiceScanArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_args_read;
  struct_class->write = swcdb_thrift_service_scan_args_write;

  gobject_class->finalize = swcdb_thrift_service_scan_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_SCAN,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_E
};

/* reads a service_scan_result object */
static gint32
swcdb_thrift_service_scan_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_result_set_property (GObject *object,
                                               guint property_id,
                                               const GValue *value,
                                               GParamSpec *pspec)
{
  swcdb_thriftServiceScanResult *self = SWCDB_THRIFT_SERVICE_SCAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_result_get_property (GObject *object,
                                               guint property_id,
                                               GValue *value,
                                               GParamSpec *pspec)
{
  swcdb_thriftServiceScanResult *self = SWCDB_THRIFT_SERVICE_SCAN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_result_instance_init (swcdb_thriftServiceScanResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (SWCDB_THRIFT_TYPE_CELLS, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_scan_result_finalize (GObject *object)
{
  swcdb_thriftServiceScanResult *tobject = SWCDB_THRIFT_SERVICE_SCAN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_scan_result_class_init (swcdb_thriftServiceScanResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_result_read;
  struct_class->write = swcdb_thrift_service_scan_result_write;

  gobject_class->finalize = swcdb_thrift_service_scan_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_CELLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanRsltOnColumnArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS_SPEC
};

/* reads a service_scan_rslt_on_column_args object */
static gint32
swcdb_thrift_service_scan_rslt_on_column_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanRsltOnColumnArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_rslt_on_column_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanRsltOnColumnArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanRsltOnColumnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_rslt_on_column_args_set_property (GObject *object,
                                                            guint property_id,
                                                            const GValue *value,
                                                            GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnColumnArgs *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_column_args_get_property (GObject *object,
                                                            guint property_id,
                                                            GValue *value,
                                                            GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnColumnArgs *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_rslt_on_column_args_instance_init (swcdb_thriftServiceScanRsltOnColumnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->spec = g_object_new (SWCDB_THRIFT_TYPE_SPEC_SCAN, NULL);
  object->__isset_spec = FALSE;
}

static void 
swcdb_thrift_service_scan_rslt_on_column_args_finalize (GObject *object)
{
  swcdb_thriftServiceScanRsltOnColumnArgs *tobject = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_column_args_class_init (swcdb_thriftServiceScanRsltOnColumnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_rslt_on_column_args_read;
  struct_class->write = swcdb_thrift_service_scan_rslt_on_column_args_write;

  gobject_class->finalize = swcdb_thrift_service_scan_rslt_on_column_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_rslt_on_column_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_rslt_on_column_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_SCAN,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_rslt_on_column_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanRsltOnColumnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_rslt_on_column_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanRsltOnColumnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_rslt_on_column_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanRsltOnColumnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanRsltOnColumnResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_E
};

/* reads a service_scan_rslt_on_column_result object */
static gint32
swcdb_thrift_service_scan_rslt_on_column_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanRsltOnColumnResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_MAP)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType key_type;
            ThriftType value_type;

            /* read the map begin marker */
            if ((ret = thrift_protocol_read_map_begin (protocol, &key_type, &value_type, &size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through each of the map's fields */
            for (i = 0; i < size; i++)
            {
              gchar * key241 = NULL;
              swcdb_thriftcCells * val242 = NULL;
              if (key241 != NULL)
              {
                g_free(key241);
                key241 = NULL;
              }

              if ((ret = thrift_protocol_read_string (protocol, &key241, error)) < 0)
                return -1;
              xfer += ret;
              if ( val242 != NULL)
              {
                g_object_unref (val242);
              }
              val242 = g_object_new (SWCDB_THRIFT_TYPE_C_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (val242), protocol, error)) < 0)
              {
                g_object_unref (val242);
                return -1;
              }
              xfer += ret;
              if (this_object->success && key241)
                g_hash_table_insert ((GHashTable *)this_object->success, (gpointer) key241, (gpointer) val242);
            }

            /* read the map end marker */
            if ((ret = thrift_protocol_read_map_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_rslt_on_column_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanRsltOnColumnResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanRsltOnColumnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_MAP, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      gchar * key243 = NULL;
      swcdb_thriftcCells * val244 = NULL;
      GList *key_list = NULL, *iter = NULL;
      gchar ** keys;
      int i = 0, key_count;

      if ((ret = thrift_protocol_write_map_begin (protocol, T_STRING, T_STRUCT, this_object->success ? (gint32) g_hash_table_size ((GHashTable *) this_object->success) : 0, error)) < 0)
        return -1;
      xfer += ret;
      if (this_object->success)
        g_hash_table_foreach ((GHashTable *) this_object->success, thrift_hash_table_get_keys, &key_list);
      key_count = g_list_length (key_list);
      keys = g_newa (gchar *, key_count);
      for (iter = g_list_first (key_list); iter; iter = iter->next)
        keys[i++] = (gchar *) iter->data;
      g_list_free (key_list);

      for (i = 0; i < key_count; ++i)
      {
        key243 = keys[i];
        val244 = (swcdb_thriftcCells *) g_hash_table_lookup (((GHashTable *) this_object->success), (gpointer) key243);

        if ((ret = thrift_protocol_write_string (protocol,  key243, error)) < 0)
          return -1;
        xfer += ret;

        if ((ret = thrift_struct_write (THRIFT_STRUCT ( val244), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_map_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_rslt_on_column_result_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnColumnResult *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_SUCCESS:
      if (self->success != NULL)
        g_hash_table_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_column_result_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnColumnResult *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_rslt_on_column_result_instance_init (swcdb_thriftServiceScanRsltOnColumnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_scan_rslt_on_column_result_finalize (GObject *object)
{
  swcdb_thriftServiceScanRsltOnColumnResult *tobject = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_hash_table_destroy (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_column_result_class_init (swcdb_thriftServiceScanRsltOnColumnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_rslt_on_column_result_read;
  struct_class->write = swcdb_thrift_service_scan_rslt_on_column_result_write;

  gobject_class->finalize = swcdb_thrift_service_scan_rslt_on_column_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_rslt_on_column_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_rslt_on_column_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_HASH_TABLE,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_COLUMN_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_rslt_on_column_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanRsltOnColumnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_rslt_on_column_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanRsltOnColumnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_rslt_on_column_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanRsltOnColumnResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanRsltOnKeyArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS_SPEC
};

/* reads a service_scan_rslt_on_key_args object */
static gint32
swcdb_thrift_service_scan_rslt_on_key_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanRsltOnKeyArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_rslt_on_key_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanRsltOnKeyArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanRsltOnKeyArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_rslt_on_key_args_set_property (GObject *object,
                                                         guint property_id,
                                                         const GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnKeyArgs *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_key_args_get_property (GObject *object,
                                                         guint property_id,
                                                         GValue *value,
                                                         GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnKeyArgs *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_rslt_on_key_args_instance_init (swcdb_thriftServiceScanRsltOnKeyArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->spec = g_object_new (SWCDB_THRIFT_TYPE_SPEC_SCAN, NULL);
  object->__isset_spec = FALSE;
}

static void 
swcdb_thrift_service_scan_rslt_on_key_args_finalize (GObject *object)
{
  swcdb_thriftServiceScanRsltOnKeyArgs *tobject = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_key_args_class_init (swcdb_thriftServiceScanRsltOnKeyArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_rslt_on_key_args_read;
  struct_class->write = swcdb_thrift_service_scan_rslt_on_key_args_write;

  gobject_class->finalize = swcdb_thrift_service_scan_rslt_on_key_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_rslt_on_key_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_rslt_on_key_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_SCAN,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_rslt_on_key_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanRsltOnKeyArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_rslt_on_key_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanRsltOnKeyArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_rslt_on_key_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanRsltOnKeyArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanRsltOnKeyResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_E
};

/* reads a service_scan_rslt_on_key_result object */
static gint32
swcdb_thrift_service_scan_rslt_on_key_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanRsltOnKeyResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_LIST)
        {
          {
            guint32 size;
            guint32 i;
            ThriftType element_type;

            if ((ret = thrift_protocol_read_list_begin (protocol, &element_type,&size, error)) < 0)
              return -1;
            xfer += ret;

            /* iterate through list elements */
            for (i = 0; i < size; i++)
            {
              swcdb_thriftkCells * _elem245 = NULL;
              if ( _elem245 != NULL)
              {
                g_object_unref (_elem245);
              }
              _elem245 = g_object_new (SWCDB_THRIFT_TYPE_K_CELLS, NULL);
              if ((ret = thrift_struct_read (THRIFT_STRUCT (_elem245), protocol, error)) < 0)
              {
                g_object_unref (_elem245);
                return -1;
              }
              xfer += ret;
              g_ptr_array_add (this_object->success, _elem245);
            }
            if ((ret = thrift_protocol_read_list_end (protocol, error)) < 0)
              return -1;
            xfer += ret;
          }
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_rslt_on_key_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanRsltOnKeyResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanRsltOnKeyResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_LIST, 0, error)) < 0)
      return -1;
    xfer += ret;
    {
      guint i246;

      if ((ret = thrift_protocol_write_list_begin (protocol, T_STRUCT, (gint32) (this_object->success ? this_object->success->len : 0), error)) < 0)
        return -1;
      xfer += ret;
      for (i246 = 0; i246 < (this_object->success ? this_object->success->len : 0); i246++)
      {
        if ((ret = thrift_struct_write (THRIFT_STRUCT ((g_ptr_array_index ((GPtrArray *) this_object->success, i246))), protocol, error)) < 0)
          return -1;
        xfer += ret;

      }
      if ((ret = thrift_protocol_write_list_end (protocol, error)) < 0)
        return -1;
      xfer += ret;
    }
    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_rslt_on_key_result_set_property (GObject *object,
                                                           guint property_id,
                                                           const GValue *value,
                                                           GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnKeyResult *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_SUCCESS:
      if (self->success != NULL)
        g_ptr_array_unref (self->success);
      self->success = g_value_dup_boxed (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_key_result_get_property (GObject *object,
                                                           guint property_id,
                                                           GValue *value,
                                                           GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnKeyResult *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_SUCCESS:
      g_value_set_boxed (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_rslt_on_key_result_instance_init (swcdb_thriftServiceScanRsltOnKeyResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_ptr_array_new_with_free_func (g_object_unref);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_scan_rslt_on_key_result_finalize (GObject *object)
{
  swcdb_thriftServiceScanRsltOnKeyResult *tobject = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_ptr_array_unref (tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_key_result_class_init (swcdb_thriftServiceScanRsltOnKeyResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_rslt_on_key_result_read;
  struct_class->write = swcdb_thrift_service_scan_rslt_on_key_result_write;

  gobject_class->finalize = swcdb_thrift_service_scan_rslt_on_key_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_rslt_on_key_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_rslt_on_key_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_SUCCESS,
     g_param_spec_boxed ("success",
                         NULL,
                         NULL,
                         G_TYPE_PTR_ARRAY,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_KEY_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_rslt_on_key_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanRsltOnKeyResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_rslt_on_key_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanRsltOnKeyResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_rslt_on_key_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanRsltOnKeyResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanRsltOnFractionArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS_SPEC
};

/* reads a service_scan_rslt_on_fraction_args object */
static gint32
swcdb_thrift_service_scan_rslt_on_fraction_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanRsltOnFractionArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_rslt_on_fraction_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanRsltOnFractionArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanRsltOnFractionArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_rslt_on_fraction_args_set_property (GObject *object,
                                                              guint property_id,
                                                              const GValue *value,
                                                              GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnFractionArgs *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_fraction_args_get_property (GObject *object,
                                                              guint property_id,
                                                              GValue *value,
                                                              GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnFractionArgs *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_rslt_on_fraction_args_instance_init (swcdb_thriftServiceScanRsltOnFractionArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->spec = g_object_new (SWCDB_THRIFT_TYPE_SPEC_SCAN, NULL);
  object->__isset_spec = FALSE;
}

static void 
swcdb_thrift_service_scan_rslt_on_fraction_args_finalize (GObject *object)
{
  swcdb_thriftServiceScanRsltOnFractionArgs *tobject = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_fraction_args_class_init (swcdb_thriftServiceScanRsltOnFractionArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_rslt_on_fraction_args_read;
  struct_class->write = swcdb_thrift_service_scan_rslt_on_fraction_args_write;

  gobject_class->finalize = swcdb_thrift_service_scan_rslt_on_fraction_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_rslt_on_fraction_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_rslt_on_fraction_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_SCAN,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_rslt_on_fraction_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanRsltOnFractionArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_rslt_on_fraction_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanRsltOnFractionArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_rslt_on_fraction_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanRsltOnFractionArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanRsltOnFractionResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_E
};

/* reads a service_scan_rslt_on_fraction_result object */
static gint32
swcdb_thrift_service_scan_rslt_on_fraction_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanRsltOnFractionResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_rslt_on_fraction_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanRsltOnFractionResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanRsltOnFractionResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_rslt_on_fraction_result_set_property (GObject *object,
                                                                guint property_id,
                                                                const GValue *value,
                                                                GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnFractionResult *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_fraction_result_get_property (GObject *object,
                                                                guint property_id,
                                                                GValue *value,
                                                                GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnFractionResult *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_rslt_on_fraction_result_instance_init (swcdb_thriftServiceScanRsltOnFractionResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (SWCDB_THRIFT_TYPE_F_CELLS, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_scan_rslt_on_fraction_result_finalize (GObject *object)
{
  swcdb_thriftServiceScanRsltOnFractionResult *tobject = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_fraction_result_class_init (swcdb_thriftServiceScanRsltOnFractionResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_rslt_on_fraction_result_read;
  struct_class->write = swcdb_thrift_service_scan_rslt_on_fraction_result_write;

  gobject_class->finalize = swcdb_thrift_service_scan_rslt_on_fraction_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_rslt_on_fraction_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_rslt_on_fraction_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_F_CELLS,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_FRACTION_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_rslt_on_fraction_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanRsltOnFractionResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_rslt_on_fraction_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanRsltOnFractionResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_rslt_on_fraction_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanRsltOnFractionResultType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanRsltOnArgsProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_SPEC,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_RSLT
};

/* reads a service_scan_rslt_on_args object */
static gint32
swcdb_thrift_service_scan_rslt_on_args_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanRsltOnArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 1:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_spec = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 2:
        if (ftype == T_I32)
        {
          gint32 ecast247;
          if ((ret = thrift_protocol_read_i32 (protocol, &ecast247, error)) < 0)
            return -1;
          xfer += ret;
          this_object->rslt = (swcdb_thriftCellsResult)ecast247;
          this_object->__isset_rslt = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_rslt_on_args_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanRsltOnArgs * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanRsltOnArgs", error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "spec", T_STRUCT, 1, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->spec), protocol, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_begin (protocol, "rslt", T_I32, 2, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_i32 (protocol, (gint32) this_object->rslt, error)) < 0)
    return -1;
  xfer += ret;

  if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_rslt_on_args_set_property (GObject *object,
                                                     guint property_id,
                                                     const GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnArgs *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_SPEC:
      if (self->spec != NULL)
        g_object_unref (self->spec);
      self->spec = g_value_dup_object (value);
      self->__isset_spec = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_RSLT:
      self->rslt = g_value_get_int (value);
      self->__isset_rslt = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_args_get_property (GObject *object,
                                                     guint property_id,
                                                     GValue *value,
                                                     GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnArgs *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_SPEC:
      g_value_set_object (value, self->spec);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_RSLT:
      g_value_set_int (value, self->rslt);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_rslt_on_args_instance_init (swcdb_thriftServiceScanRsltOnArgs * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->spec = g_object_new (SWCDB_THRIFT_TYPE_SPEC_SCAN, NULL);
  object->__isset_spec = FALSE;
  object->__isset_rslt = FALSE;
}

static void 
swcdb_thrift_service_scan_rslt_on_args_finalize (GObject *object)
{
  swcdb_thriftServiceScanRsltOnArgs *tobject = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->spec != NULL)
  {
    g_object_unref(tobject->spec);
    tobject->spec = NULL;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_args_class_init (swcdb_thriftServiceScanRsltOnArgsClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_rslt_on_args_read;
  struct_class->write = swcdb_thrift_service_scan_rslt_on_args_write;

  gobject_class->finalize = swcdb_thrift_service_scan_rslt_on_args_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_rslt_on_args_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_rslt_on_args_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_SPEC,
     g_param_spec_object ("spec",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_SPEC_SCAN,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_ARGS_RSLT,
     g_param_spec_int ("rslt",
                       NULL,
                       NULL,
                       0,
                       3,
                       0,
                       G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_rslt_on_args_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanRsltOnArgsClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_rslt_on_args_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanRsltOnArgs),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_rslt_on_args_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanRsltOnArgsType",
                                   &type_info, 0);
  }

  return type;
}

enum _swcdb_thriftServiceScanRsltOnResultProperties
{
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_0,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_SUCCESS,
  PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_E
};

/* reads a service_scan_rslt_on_result object */
static gint32
swcdb_thrift_service_scan_rslt_on_result_read (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;
  gchar *name = NULL;
  ThriftType ftype;
  gint16 fid;
  guint32 len = 0;
  gpointer data = NULL;
  swcdb_thriftServiceScanRsltOnResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT(object);

  /* satisfy -Wall in case these aren't used */
  THRIFT_UNUSED_VAR (len);
  THRIFT_UNUSED_VAR (data);
  THRIFT_UNUSED_VAR (this_object);

  /* read the struct begin marker */
  if ((ret = thrift_protocol_read_struct_begin (protocol, &name, error)) < 0)
  {
    if (name) g_free (name);
    return -1;
  }
  xfer += ret;
  if (name) g_free (name);
  name = NULL;

  /* read the struct fields */
  while (1)
  {
    /* read the beginning of a field */
    if ((ret = thrift_protocol_read_field_begin (protocol, &name, &ftype, &fid, error)) < 0)
    {
      if (name) g_free (name);
      return -1;
    }
    xfer += ret;
    if (name) g_free (name);
    name = NULL;

    /* break if we get a STOP field */
    if (ftype == T_STOP)
    {
      break;
    }

    switch (fid)
    {
      case 0:
        if (ftype == T_STRUCT)
        {
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
          {
            return -1;
          }
          xfer += ret;
          this_object->__isset_success = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      case 1:
        if (ftype == T_STRUCT)
        {
          /* This struct is an exception */
          if ( this_object->e != NULL)
          {
            g_object_unref (this_object->e);
          }
          this_object->e = g_object_new (SWCDB_THRIFT_TYPE_EXCEPTION, NULL);
          if ((ret = thrift_struct_read (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
          {
            g_object_unref (this_object->e);
            this_object->e = NULL;
            return -1;
          }
          xfer += ret;
          this_object->__isset_e = TRUE;
        } else {
          if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
            return -1;
          xfer += ret;
        }
        break;
      default:
        if ((ret = thrift_protocol_skip (protocol, ftype, error)) < 0)
          return -1;
        xfer += ret;
        break;
    }
    if ((ret = thrift_protocol_read_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }

  if ((ret = thrift_protocol_read_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static gint32
swcdb_thrift_service_scan_rslt_on_result_write (ThriftStruct *object, ThriftProtocol *protocol, GError **error)
{
  gint32 ret;
  gint32 xfer = 0;

  swcdb_thriftServiceScanRsltOnResult * this_object = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT(object);
  THRIFT_UNUSED_VAR (this_object);
  if ((ret = thrift_protocol_write_struct_begin (protocol, "ServiceScanRsltOnResult", error)) < 0)
    return -1;
  xfer += ret;
  if (this_object->__isset_success == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "success", T_STRUCT, 0, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->success), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if (this_object->__isset_e == TRUE) {
    if ((ret = thrift_protocol_write_field_begin (protocol, "e", T_STRUCT, 1, error)) < 0)
      return -1;
    xfer += ret;
    if ((ret = thrift_struct_write (THRIFT_STRUCT (this_object->e), protocol, error)) < 0)
      return -1;
    xfer += ret;

    if ((ret = thrift_protocol_write_field_end (protocol, error)) < 0)
      return -1;
    xfer += ret;
  }
  if ((ret = thrift_protocol_write_field_stop (protocol, error)) < 0)
    return -1;
  xfer += ret;
  if ((ret = thrift_protocol_write_struct_end (protocol, error)) < 0)
    return -1;
  xfer += ret;

  return xfer;
}

static void
swcdb_thrift_service_scan_rslt_on_result_set_property (GObject *object,
                                                       guint property_id,
                                                       const GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnResult *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_SUCCESS:
      if (self->success != NULL)
        g_object_unref (self->success);
      self->success = g_value_dup_object (value);
      self->__isset_success = TRUE;
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_E:
      if (self->e != NULL)
        g_object_unref (self->e);
      self->e = g_value_dup_object (value);
      self->__isset_e = TRUE;
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_result_get_property (GObject *object,
                                                       guint property_id,
                                                       GValue *value,
                                                       GParamSpec *pspec)
{
  swcdb_thriftServiceScanRsltOnResult *self = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT (object);

  switch (property_id)
  {
    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_SUCCESS:
      g_value_set_object (value, self->success);
      break;

    case PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_E:
      g_value_set_object (value, self->e);
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
      break;
  }
}

static void 
swcdb_thrift_service_scan_rslt_on_result_instance_init (swcdb_thriftServiceScanRsltOnResult * object)
{
  /* satisfy -Wall */
  THRIFT_UNUSED_VAR (object);
  object->success = g_object_new (SWCDB_THRIFT_TYPE_CELLS_GROUP, NULL);
  object->__isset_success = FALSE;
  object->e = NULL;
  object->__isset_e = FALSE;
}

static void 
swcdb_thrift_service_scan_rslt_on_result_finalize (GObject *object)
{
  swcdb_thriftServiceScanRsltOnResult *tobject = SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT (object);

  /* satisfy -Wall in case we don't use tobject */
  THRIFT_UNUSED_VAR (tobject);
  if (tobject->success != NULL)
  {
    g_object_unref(tobject->success);
    tobject->success = NULL;
  }
  if (tobject->e != NULL)
  {
    g_object_unref(tobject->e);
    tobject->e = NULL;
  }
}

static void
swcdb_thrift_service_scan_rslt_on_result_class_init (swcdb_thriftServiceScanRsltOnResultClass * cls)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (cls);
  ThriftStructClass *struct_class = THRIFT_STRUCT_CLASS (cls);

  struct_class->read = swcdb_thrift_service_scan_rslt_on_result_read;
  struct_class->write = swcdb_thrift_service_scan_rslt_on_result_write;

  gobject_class->finalize = swcdb_thrift_service_scan_rslt_on_result_finalize;
  gobject_class->get_property = swcdb_thrift_service_scan_rslt_on_result_get_property;
  gobject_class->set_property = swcdb_thrift_service_scan_rslt_on_result_set_property;

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_SUCCESS,
     g_param_spec_object ("success",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_CELLS_GROUP,
                         G_PARAM_READWRITE));

  g_object_class_install_property
    (gobject_class,
     PROP_SWCDB_THRIFT_SERVICE_SCAN_RSLT_ON_RESULT_E,
     g_param_spec_object ("e",
                         NULL,
                         NULL,
                         SWCDB_THRIFT_TYPE_EXCEPTION,
                         G_PARAM_READWRITE));
}

GType
swcdb_thrift_service_scan_rslt_on_result_get_type (void)
{
  static GType type = 0;

  if (type == 0) 
  {
    static const GTypeInfo type_info = 
    {
      sizeof (swcdb_thriftServiceScanRsltOnResultClass),
      NULL, /* base_init */
      NULL, /* base_finalize */
      (GClassInitFunc) swcdb_thrift_service_scan_rslt_on_result_class_init,
      NULL, /* class_finalize */
      NULL, /* class_data */
      sizeof (swcdb_thriftServiceScanRsltOnResult),
      0, /* n_preallocs */
      (GInstanceInitFunc) swcdb_thrift_service_scan_rslt_on_result_instance_init,
      NULL, /* value_table */
    };

    type = g_type_register_static (THRIFT_TYPE_STRUCT, 
                                   "swcdb_thriftServiceScanRsltOnResultType",
                                   &type_info, 0);
  }

  return type;
}

